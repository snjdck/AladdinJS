'use strict';

const net = require('net');
const listenPacket = require('../listenPacket');
const readDataAsync = require('../readDataAsync');
const {waitWhen} = require('../../utils/events');

const END = '\r\n';

class Packet
{
	static cut(buffer, offset){
		for(let text=END;;){
			const index = buffer.indexOf(text, offset);
			if(index < 0)return;
			if(buffer[offset+3] != 0x2D || text != END){
				return buffer.slice(offset, index + text.length);
			}
			const code = buffer.toString('utf8', offset, offset + 3);
			text = `${code} End${END}`;
		}
	}

	static decode(packet){
		const text = packet.slice(0, -2).toString();
		return [Number(text.slice(0, 3)), text.slice(4)];
	}
}

const parseFileList = function(){
	function mapFn(v){
		const [v0, v1, v2, v3] = v.split(/\s+/);
		const item = {name: v3};
		if(v2 == '<DIR>'){
			item.isDir = true;
		}else{
			item.size = Number(v2);
		}
		return item;
	}
	return v => v.toString().match(/.+/g).map(mapFn);
}();

const parsePasvIP = function(){
	const reduceFn = (a, b) => a << 8 | b;
	return function(value){
		const info = value.match(/(?<=\()[^)]+/)[0].split(',');
		const port = info.splice(4).reduce(reduceFn);
		const host = info.join('.');
		return [port, host];
	}
}();

const FtpProto = {
	async send(data, waitCode){
		this.write(data + END);
		const [code, text] = await waitWhen(this, 'packet', 60000, packet => {
			const [code, text] = packet;
			return (code == waitCode || code == 550) && packet;
		});
		if(code == 550)throw text;
		return text;
	},
	USER(value){
		return this.send(`USER ${value}`, 220);
	},
	PASS(value){
		return this.send(`PASS ${value}`, 230);
	},
	TYPE(value){
		return this.send(`TYPE ${value}`, 200);
	},
	async pwd(){
		const text = await this.send(`PWD`, 257);
		const index = text.lastIndexOf('"');
		return text.slice(1, index);
	},
	cwd(path){
		return this.send(`CWD ${path}`, 250);
	},
	async PASV(){
		const [port, host] = parsePasvIP(await this.send(`PASV`, 227));
		return new Promise(resolve => net.connect(port, host, function(){resolve(this)}));
	},
	async pasvDo(command, data){
		const socket = await this.PASV();
		this.send(command, 226);
		return new Promise(resolve => {
			if(data){
				socket.end(data, 'utf8', resolve);
			}else{
				readDataAsync(socket, resolve);
			}
		});
	},
	list(path){
		const command = path ? `LIST ${path}` : 'LIST';
		return this.pasvDo(command).then(parseFileList);
	},
	retrieve(path){
		return this.pasvDo(`RETR ${path}`);
	},
	store(path, data){
		return this.pasvDo(`STOR ${path}`, data);
	},
	append(path, data){
		return this.pasvDo(`APPE ${path}`, data);
	},
	async rename(from, to){
		await this.send(`RNFR ${from}`, 350);
		await this.send(`RNTO ${to}`, 250);
	},
	delete(path){
		return this.send(`DELE ${path}`, 250);
	},
	mkdir(path, recursive=false){
		return this.send(`MKD ${path}`, 257);
	},
	rmdir(path, recursive=false){
		return this.send(`RMD ${path}`, 250);
	},
}

net.connect(21, '192.168.1.133', async function(){
	listenPacket(this, Packet, packet => this.emit('packet', packet));
	Object.assign(this, FtpProto);
	console.log(await this.USER('anonymous'));
	console.log(await this.PASS('anonymous@'));
	await this.pwd();
	console.log(await this.list('/'));
	await this.pwd();
	let data = await this.retrieve('RecognizeImageColor.png');
	console.log(data.length)
	await this.pwd();
	await this.store('/test.txt', 'hello world!~');
	await this.pwd();
	console.log(await this.list('/'));
	console.log((await this.retrieve('/test.txt')).toString());
	await this.append('/test.txt', '\r\nappend data');
	console.log((await this.retrieve('/test.txt')).toString());
	await this.cwd('dir');
	console.log(await this.pwd());
	console.log(await this.list());
	await this.cwd('..');
	await this.pwd();
	//await this.delete('/dir');
	try{
		await this.rename('/test.txt', '/newname.txt');
	}catch(error){
		console.log('rename faild')
	}
	try{
		await this.mkdir('new dir')
	}catch(error){
		console.log('new dir faild')
	}
	await this.rmdir('new dir')
	console.log(await this.list());
	console.log(await this.pwd());
})
