
const ByteArray = require('utils/ByteArray');

const TERMINATOR	= 0x00;
const DOUBLE		= 0x01;
const STRING		= 0x02;
const DOCUMENT		= 0x03;
const ARRAY			= 0x04;
const BINARY		= 0x05;
const UNDEFINED		= 0x06;
const OBJECT_ID		= 0x07;
const BOOLEAN		= 0x08;
const DATE			= 0x09;
const NULL			= 0x0A;
const REG_EXP		= 0x0B;
const INT32			= 0x10;
const TIMESTAMP		= 0x11;
const INT64			= 0x12;

function flatten(array, result=[]){
	for(let value of array){
		if(Array.isArray(value)){
			flatten(value, result);
		}else if(value !== undefined){
			result.push(value);
		}
	}
	return result;
}

function calcTotalSize(array){
	let result = 0;
	for(let value of array){
		if(Array.isArray(value)){
			result += calcTotalSize(value);
		}else if(value !== undefined){
			result += value.length;
		}
	}
	return result;
}

const encode = function(){
	writeDoc(value){
		let payload = Object.entries(value).map(([k, v]) => writeData(k, v));
		let head = Buffer.alloc(4);
		head.writeInt32LE(calcTotalSize(payload) + 5, 0);
		return [head, payload, Buffer.alloc(1)];
	}
	writeData(key, value){
		let type = calcType(value);
		let buffer;
		switch(type){
			case DOUBLE:
				buffer = Buffer.alloc(8);
				buffer.writeDoubleLE(value, 0);
				break;
			case STRING:
				buffer = Buffer.alloc(Buffer.byteLength(value) + 5);
				buffer.writeInt32LE(buffer.length - 4, 0);
				buffer.write(value, 4);
				break;
			case DOCUMENT:
			case ARRAY:
				buffer = writeDoc(value);
				break;
			case BINARY:
				buffer = Buffer.alloc(5);
				buffer.writeInt32LE(value.length, 0);
				buffer = [buffer, value];
				break;
			case BOOLEAN:
				buffer = Buffer.alloc(1, value);
				break;
			case UNDEFINED:
			case NULL:
				break;
			case INT32:
				buffer = Buffer.alloc(4);
				buffer.writeInt32LE(value, 0);
				break;
			default:
				return undefined;
		}
		return [Buffer.alloc(1, type), Buffer.from(key), Buffer.alloc(1), buffer];
	}
	calcType(value){
		switch(typeof value){
			case 'string': return STRING;
			case 'boolean':return BOOLEAN;
			case 'undefined':return UNDEFINED;
			case 'number':
				return Number.isInteger(value) ? INT32 : DOUBLE;
			case 'object':
				break;
			default:
				return;
		}
		if(value === null)return NULL;
		if(Buffer.isBuffer(value))return BINARY;
		return DOCUMENT;
	}
	return value => Buffer.concat(flatten(writeDoc(value)));
}();

const decode = function(){
	readDoc(buffer, output={}){
		buffer.position += 4;
		for(;;){
			let type = buffer.readUInt8();
			if(type === TERMINATOR)
				break;
			output[buffer.readCString()] = readData(buffer, type);
		}
		return output;
	}
	readData(buffer, type){
		switch(type){
			case DOUBLE:	return buffer.readDouble();
			case STRING:	return readString(buffer);
			case DOCUMENT:	return readDoc(buffer);
			case ARRAY:		return readDoc(buffer, []);
			case BINARY:	return readBinary(buffer);
			case UNDEFINED:	return undefined;
			case OBJECT_ID:	return readObjectID(buffer);
			case BOOLEAN:	return buffer.readBoolean();
			case DATE:		return new Date(buffer.readInt64LE());
			case NULL:		return null;
			case REG_EXP:	return new RegExp(buffer.readCString(), buffer.readCString());
			case INT32:		return buffer.readInt32LE();
			case INT64:		return buffer.readInt64LE();
		}
		throw new Error();
	}
	readString(buffer){
		let value = buffer.readUTFBytes(buffer.readInt32LE()-1);
		++buffer.position;
		return value;
	}
	readBinary(buffer){
		let size = buffer.readInt32LE();
		let subType = buffer.readUInt8();
		if(2 == subType){
			size = buffer.readInt32LE();
		}
		return buffer.readBytes(size);
	}
	readObjectID(buffer){
		let objectID = [];
		for(let i=0; i<12; ++i)
			objectID.push(buffer.readUInt8().toString(16).padStart(2, '0'));
		return objectID.join('');
	}
	return buffer => readDoc(new ByteArray(buffer));
}();

module.exports = {
	encode,
	decode
};
