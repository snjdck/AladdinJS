
function encode(data){
	const isBuffer = Buffer.isBuffer(data);
	let opCode, payloadLen;
	if(isBuffer){
		opCode = 2;
		payloadLen = data.length;
	}else{
		opCode = 1;
		payloadLen = Buffer.byteLength(data);
	}
	const packetLen = calcPacketLen(payloadLen);
	const packet = Buffer.alloc(packetLen);
	packet.writeUInt8(0x80 | opCode, 0);
	writePayloadLen(packet, payloadLen);
	if(isBuffer){
		data.copy(packet, packetLen - payloadLen);
	}else{
		packet.write(data, packetLen - payloadLen);
	}
	return packet;
}

function calcPacketLen(payloadLen, hasMask=false){
	let headLen = (payloadLen < 126) ? 2 : (payloadLen < 0x10000) ? 4 : 10;
	let packetLen = headLen + payloadLen;
	return hasMask ? packetLen + 4 : packetLen;
}

function writePayloadLen(packet, payloadLen){
	if(payloadLen < 126){
		packet.writeUInt8(payloadLen, 1);
	}else if(payloadLen < 0x10000){
		packet.writeUInt8(126, 1);
		packet.writeUInt16BE(payloadLen, 2);
	}else{
		packet.writeUInt8(127, 1);
		packet.writeUInt32BE(0, 2);
		packet.writeUInt32BE(payloadLen, 6);
	}
}

export default encode;