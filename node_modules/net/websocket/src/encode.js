
function encode(data, useMask){
	const isBuffer = Buffer.isBuffer(data);
	const payloadLen = isBuffer ? data.length : Buffer.byteLength(data);
	const headLen = calcHeadLen(payloadLen, useMask);
	const packet = Buffer.allocUnsafe(headLen + payloadLen);
	writePayloadLen(packet, payloadLen, useMask);
	if(isBuffer){
		packet.writeUInt8(0x82, 0);
		data.copy(packet, headLen);
	}else{
		packet.writeUInt8(0x81, 0);
		packet.write(data, headLen);
	}
	if(useMask){
		let maskOffset = headLen - 4;
		packet.writeUInt32BE(0x100000000 * Math.random(), maskOffset);
		for(let i=0; i<payloadLen; ++i){
			packet[headLen + i] ^= packet[maskOffset + i % 4];
		}
	}
	return packet;
}

function calcHeadLen(payloadLen, useMask){
	let headLen = (payloadLen < 126) ? 2 : (payloadLen < 0x10000) ? 4 : 10;
	return useMask ? headLen + 4 : headLen;
}

function writePayloadLen(packet, payloadLen, useMask){
	let flag = useMask ? 0x80 : 0;
	if(payloadLen < 126){
		packet.writeUInt8(payloadLen | flag, 1);
	}else if(payloadLen < 0x10000){
		packet.writeUInt8(126 | flag, 1);
		packet.writeUInt16BE(payloadLen, 2);
	}else{
		packet.writeUInt8(127 | flag, 1);
		packet.writeUInt32BE(0, 2);
		packet.writeUInt32BE(payloadLen, 6);
	}
}

module.exports = encode;