
class Packet
{
	static cut(buffer, offset){
		const count = buffer.length - offset;
		if(count < 2)return;
		const byte2 = buffer.readUInt8(offset+1);
		const hasMask	= byte2 >> 7 == 1;
		let payloadLen	= byte2 & 0x7F;
		const headLen = calcHeadLen(hasMask, payloadLen);
		if(count < headLen)return;
		payloadLen = readPayloadLen(buffer, payloadLen, offset);
		const packetLen = headLen + payloadLen;
		if(count < packetLen)return;
		return buffer.slice(offset, offset+packetLen);
	}

	static decode(buffer){
		const byte1 = buffer.readUInt8(0);
		const byte2 = buffer.readUInt8(1);

		const finFlag	= byte1 >> 7 == 1;
		const opCode	= byte1 & 0x0F;
		const hasMask	= byte2 >> 7 == 1;
		let payloadLen	= byte2 & 0x7F;

		const headLen = calcHeadLen(hasMask, payloadLen);
		payloadLen = readPayloadLen(buffer, payloadLen, 0);
		if(hasMask)decodePayload(buffer, headLen, payloadLen);
		if(opCode === 1)return buffer.toString('utf8', headLen);
		if(opCode === 2)return buffer.slice(headLen);
		if(opCode === 8)return buffer.readUInt16BE(headLen);
	}
}

function calcHeadLen(hasMask, payloadLen){
	let headLen = (payloadLen < 126) ? 2 : (payloadLen > 126) ? 10 : 4;
	return hasMask ? headLen + 4 : headLen;
}

function readPayloadLen(packet, payloadLen, offset){
	if(payloadLen <  126)	return payloadLen;
	if(payloadLen == 126)	return packet.readUInt16BE(offset+2);
	return packet.readUInt32BE(offset+6);
}

function decodePayload(packet, offset, payloadLen){
	let maskOffset = offset - 4;
	for(let i=0; i<payloadLen; ++i){
		packet[offset + i] ^= packet[maskOffset + i % 4];
	}
}

module.exports = Packet;