'use strict';

const {URL} = require('url');
const {getCookie, setCookie} = require('./cookie');
const readDataAsync = require('./readDataAsync');
const compose = require('utils/function/compose');

const castType = Reflect.get.bind(null, Object.create(null, {
	text: {value: v => v.toString()},
	json: {value: v => JSON.parse(v.toString())},
	form: {value: v => new URLSearchParams(value.toString())},
}));

const castContentType = contentType => {
	if(contentType.startsWith('text/'))
		return 'text';
	switch(contentType){
		case 'application/json':
			return 'json';
		case 'application/x-www-form-urlencoded':
			return 'form';
		case 'application/xml':
		case 'application/rss+xml':
			return 'text';
	}
}

function load(url, {method, body, headers, query, autoRead, onProgress, onInit}={}){
	return new Promise(function(resolve, reject){
		const info = new URL(url);
		for(let k in query)info.searchParams.append(k, query[k]);
		require(info.protocol.slice(0, -1)).request({
			method, headers,
			path: info.pathname + info.search,
			host: info.hostname,
			port: info.port
		}, response => {
			const {headers} = response;
			const contentLength = Number(headers['content-length']);
			const contentType = headers['content-type'];
			if(onInit)onInit.call(headers, contentLength, contentType);
			const isOK = response.statusCode == 200 || response.statusCode == 206;
			const fn = isOK ? resolve : reject;
			if(autoRead === false){
				return fn(response);
			}
			if(onProgress){
				response.on('data', (total => data => onProgress.call(response, total += data.length, contentLength))(0));
			}
			readDataAsync(response, value => {
				response.body = value;
				fn(response);
			});
		}).on('error', reject).end(body);
	});
}

const BodyPluginFactory = (key, contentType, castFn) => next => (url, args) => {
	const value = args && args[key];
	if(value){
		if(!args)args={};
		if(!args.headers)args.headers={};
		args.method = 'POST';
		args.headers['Content-Type'] = contentType;
		args.body = castFn(value);
	}
	return next(url, args);
}

const FormBodyPlugin = function(key, contentType){
	const BOUNDARY = '----WebKitFormBoundaryJogJuHTlZmoELETx';
	const castFn = ((FORM_BEGIN, FORM_END, FORM_RETURN) => function*(form){
		for(let k in form){
			let v = form[k];
			yield FORM_BEGIN;
			if(Buffer.isBuffer(v)){
				yield Buffer.from(`Content-Disposition: form-data; name="${k}"; filename="blob"\nContent-Type: image/jpeg\n\n`);
				yield v;
				yield FORM_RETURN;
			}else{
				yield Buffer.from(`Content-Disposition: form-data; name="${k}"\n\n${v}\n`);
			}
		}
		yield FORM_END;
	})(Buffer.from(`--${BOUNDARY}\n`), Buffer.from(`--${BOUNDARY}--`), Buffer.from('\n'));
	return BodyPluginFactory(key, `${contentType}; boundary=${BOUNDARY}`, v => Buffer.concat(Array.from(castFn(v))));
}

const castResponseTypePlugin = next => (url, args) => {
	return next(url, args).then(response => {
		if(args && args.method == 'HEAD')return response.headers;
		if(args && args.autoRead === false)return response;
		const castFn = castType(args && args.responseType);
		if(castFn)return castFn(response.body);
		const contentType = response.headers['content-type'];
		if(contentType){
			const index = contentType.indexOf(';');
			const responseType = castContentType(index > 0 ? contentType.slice(0, index) : contentType);
			if(responseType)return castType(responseType)(response.body);
		}
		return response.body;
	});
}

const CookiePlugin = next => (url, args) => {
	if(args && args.useCookieFlag === false){
		return next(url, args);
	}
	const site = new URL(url);
	const value = getCookie(site);
	if(value){
		if(!args)args={};
		if(!args.headers)args.headers={};
		args.headers['Cookie'] = value;
	}
	return next(url, args).then(response => {
		setCookie(site, response.headers['set-cookie']);
		return response;
	});
}

const redirectPlugin = next => function self(url, args){
	const promise = next(url, args);
	if(args && args.redirect === false)return promise;
	return promise.catch(response => {
		switch(response.statusCode){
			case 301:case 302:
				let {location} = response.headers;
				if(location.indexOf('://') < 0){
					location = url + location;
				}
				return self(location, args);
		}
		return Promise.reject(response);
	});
}

module.exports = compose(
	castResponseTypePlugin,
	BodyPluginFactory('json', 'application/json', v => JSON.stringify(v)),
	BodyPluginFactory('search', 'application/x-www-form-urlencoded', v => new URLSearchParams(v).toString()),
	FormBodyPlugin('form', 'multipart/form-data'),
	CookiePlugin,
	redirectPlugin,
)(load);
