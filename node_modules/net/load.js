'use strict';

const {URL} = require('url');
const {sendCookie, recvCookie} = require('./cookie');
const readDataAsync = require('./readDataAsync');
const compose = require('utils/function/compose');

const castType = Reflect.get.bind(null, Object.create(null, {
	text: {value: v => v.toString()},
	json: {value: v => JSON.parse(v.toString())},
}));
/*
const castBody = function(){
	const BOUNDARY = '----WebKitFormBoundaryJogJuHTlZmoELETx';
	const newFormBody = function(FORM_BEGIN, FORM_END, FORM_RETURN){
		return function*(form){
			for(let k in form){
				let v = form[k];
				yield FORM_BEGIN;
				if(Buffer.isBuffer(v)){
					yield Buffer.from(`Content-Disposition: form-data; name="${k}"; filename="blob"\nContent-Type: image/jpeg\n\n`);
					yield v;
					yield FORM_RETURN;
				}else{
					yield Buffer.from(`Content-Disposition: form-data; name="${k}"\n\n${v}\n`);
				}
			}
			yield FORM_END;
		}
	}(Buffer.from(`--${BOUNDARY}\n`), Buffer.from(`--${BOUNDARY}--`), Buffer.from('\n'));
	return function(headers, body){
		const contentType = headers['Content-Type'];
		if(contentType == 'application/json')return JSON.stringify(body);
		if(contentType == 'application/x-www-form-urlencoded')return new URLSearchParams(body).toString();
		if(contentType == 'multipart/form-data'){
			headers['Content-Type'] = `multipart/form-data; boundary=${BOUNDARY}`;
			return Buffer.concat(Array.from(newFormBody(body)));
		}
		return body;
	}
}()
*/
function load(url, {method, body, headers, query}={}){
	return new Promise(function(resolve, reject){
		const info = new URL(url);
		for(let k in query)info.searchParams.append(k, query[k]);
		const http = require(info.protocol.slice(0, -1));
		const request = http.request({method, headers,
			path: info.pathname + info.search,
			host: info.hostname,
			port: info.port
		}, response => {
			if(response.statusCode == 200){
				recvCookie(response, info);
				resolve(response);
			}else{
				reject(response);
			}
		});
		sendCookie(request, info);
		request.on('error', reject);
		request.end(body);
	});
}

const BodyPluginFactory = (key, contentType, castFn) => next => (url, args) => {
	const value = args && args[key];
	if(value){
		if(!args)args={};
		if(!args.headers)args.headers={};
		args.method = 'POST';
		args.headers['Content-Type'] = contentType;
		args.body = castFn(value);
	}
	return next(url, args);
}

const FormBodyPlugin = function(){
	const BOUNDARY = '----WebKitFormBoundaryJogJuHTlZmoELETx';
	const castFn = ((FORM_BEGIN, FORM_END, FORM_RETURN) => function*(form){
		for(let k in form){
			let v = form[k];
			yield FORM_BEGIN;
			if(Buffer.isBuffer(v)){
				yield Buffer.from(`Content-Disposition: form-data; name="${k}"; filename="blob"\nContent-Type: image/jpeg\n\n`);
				yield v;
				yield FORM_RETURN;
			}else{
				yield Buffer.from(`Content-Disposition: form-data; name="${k}"\n\n${v}\n`);
			}
		}
		yield FORM_END;
	})(Buffer.from(`--${BOUNDARY}\n`), Buffer.from(`--${BOUNDARY}--`), Buffer.from('\n'));
	return BodyPluginFactory('form', `multipart/form-data; boundary=${BOUNDARY}`, v => Buffer.concat(Array.from(castFn(v))));
}()

const castResponseTypePlugin = next => (url, args) => {
	return next(url, args).then(response => new Promise(resolve => readDataAsync(response, value => {
		let contentType = response.headers['content-type'];
		const responseType = args && args.responseType;
		console.log('castResponseType', contentType, responseType);
		if(responseType){
			if(responseType == 'text'){
				value = value.toString();
			}else if(responseType == 'json'){
				value = JSON.parse(value.toString());
			}
		}else if(contentType){
			if(contentType.startsWith('text/')){
				value = value.toString();
			}else{
				const index = contentType.indexOf(';');
				if(index > 0){
					contentType = contentType.slice(0, index);
				}
				if(contentType == 'application/json'){
					value = JSON.parse(value.toString());
				}else if(contentType == 'application/x-www-form-urlencoded'){
					value = new URLSearchParams(value.toString());
				}else if(contentType == 'application/xml'){
					value = value.toString();
				}
			}
		}
		resolve(value);
	})));
}

const redirectPlugin = next => (url, args) => {
	const promise = next(url, args);
	if(args && args.redirect === false)return promise;
	return promise.then(null, response => {
		switch(response.statusCode){
			case 301:case 302:
				return next(response.headers.location, args);
		}
		return Promise.reject(response);
	});
}

module.exports = compose(
	BodyPluginFactory('json', 'application/json', v => JSON.stringify(v)),
	BodyPluginFactory('search', 'application/x-www-form-urlencoded', v => new URLSearchParams(v).toString()),
	FormBodyPlugin,
	castResponseTypePlugin,
	redirectPlugin,
)(load);
