
const vuint = require('./vuint');

const wrapToArray = value => Array.isArray(value) ? value : [value];

function gen_string(value){
	const size = Buffer.byteLength(value);
	const result = Buffer.allocUnsafe(2 + size);
	result.writeUInt16BE(size, 0);
	result.write(value, 2);
	return result;
}

function gen_uint16(value){
	const result = Buffer.allocUnsafe(2);
	result.writeUInt16BE(value, 0);
	return result;
}

const TypeMsgID = {
	decode(buffer){this.msgID = buffer.readUInt16BE(0)},
	encode({msgID}){return gen_uint16(msgID)}
};

const TypeEmpty = {
	decode(buffer){},
	encode(packet){return Buffer.alloc(0)}
};

const typeList = [null, {
	encode({clientID, flag=2, timeout=60}){
		return Buffer.concat([
			gen_string('MQTT'),
			Buffer.from([4, flag]),//version, flag
			gen_uint16(timeout),//keep alive
			gen_string(clientID)
		]);
	}
}, {
	decode(buffer){
		this.sp = buffer[0];
		this.code = buffer[1];
	},
	encode({code, sp}){
		return Buffer.from([sp, code]);
	}
}, {
	decode(buffer){
		const topicLen = buffer.readUInt16BE(0);
		this.topic = buffer.toString('utf8', 2,  2 + topicLen);
		if(this.qos > 0){
			this.msgID = buffer.readUInt16BE(2 + topicLen);
			this.message = buffer.slice(4 + topicLen);
		}else{
			this.message = buffer.slice(2 + topicLen);
		}
	},
	encode({msgID, topic, message}){
		return Buffer.concat([
			gen_string(topic),
			msgID > 0 ? gen_uint16(msgID) : Buffer.alloc(0),
			message ? Buffer.isBuffer(message) ? message : Buffer.from(message) : Buffer.alloc(0)
		]);
	}
}, TypeMsgID, TypeMsgID, TypeMsgID, TypeMsgID, {
	decode(buffer){
		this.msgID = buffer.readUInt16BE(0);
		const topic = this.topic = [];
		let offset = 2;
		while(offset < buffer.length){
			const size = buffer.readUInt16BE(offset);
			offset += 2 + size;
			topic.push({
				name: buffer.toString('utf8', offset-size, offset),
				qos: buffer[offset]
			});
			offset += 1;
		}
	},
	encode({msgID, topic}){
		return Buffer.concat([gen_uint16(msgID), gen_string(topic), Buffer.from([2])]);
	}
}, {
	decode(buffer){
		this.msgID = buffer.readUInt16BE(0);
		this.code = buffer.slice(2);
	},
	encode({msgID, code}){
		return Buffer.concat([gen_uint16(msgID), Buffer.from(wrapToArray(code))]);
	}
}, {
	decode(buffer){
		this.msgID = buffer.readUInt16BE(0);
		const topic = this.topic = [];
		let offset = 2;
		while(offset < buffer.length){
			const size = buffer.readUInt16BE(offset);
			offset += 2 + size;
			topic.push(buffer.toString('utf8', offset-size, offset));
		}
	},
	encode({msgID, topic}){
		return Buffer.concat([gen_uint16(msgID), ...wrapToArray(topic).map(gen_string)]);
	}
}, TypeMsgID, TypeEmpty, TypeEmpty, TypeEmpty];

class Packet
{
	static cut(buffer, offset){
		const info = vuint.decode(buffer, offset+1);
		if(!info)return;
		const packetSize = 1 + info.count + info.value;
		if(buffer.length - offset < packetSize)return;
		return buffer.slice(offset, offset+packetSize);
	}

	static decode(buffer){
		const byte = buffer[0];
		const type = byte >> 4;
		const packet = {type};
		packet.dup = byte >> 3 & 0x1;
		packet.qos = byte >> 1 & 0x3;
		packet.retain = byte & 1;
		typeList[type].decode.call(packet, buffer.slice(1 + vuint.decode(buffer, 1).count));
		return packet;
	}

	static encode(packet){
		const {type, qos, retain} = packet;
		const head = type << 4 | qos << 1 | retain;
		const data = typeList[type].encode(packet);
		return Buffer.concat([Buffer.from([head, ...vuint.encode(data.length)]), data]);
	}
}

module.exports = Packet;
