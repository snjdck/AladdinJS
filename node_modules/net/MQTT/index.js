'use strict';

const {URL} = require('url');
const EventEmitter = require('events');
const net = require('net');
const retry = require('../../utils/function/retry');
const {waitWhen} = require('../../utils/events');
const {RangePool} = require('../../utils/counter');
const listenPacket = require('../listenPacket');
const vuint = require('./vuint');

const CONNECT = 1;
const CONNACK = 2;
const PUBLISH = 3;
const PUBACK = 4;
const PUBREC = 5;
const PUBREL = 6;
const PUBCOMP = 7;
const SUBSCRIBE = 8;
const SUBACK = 9;
const UNSUBSCRIBE = 10;
const UNSUBACK = 11;
const PINGREQ = 12;
const PINGRESP = 13;
const DISCONNECT = 14;

class Packet
{
	static cut(buffer, offset){
		const info = vuint.decode(buffer, offset+1);
		if(!info)return;
		const packetSize = 1 + info.count + info.value;
		if(buffer.length - offset < packetSize)return;
		return buffer.slice(offset, offset+packetSize);
	}

	static decode(buffer){
		let offset = 1 + vuint.decode(buffer, 1).count;
		const byte1 = buffer.readUInt8(0);
		const type = byte1 >> 4;
		const flag = byte1 & 0xF;
		const data = Object.create(null);
		data.type = type;
		data.dup = flag >> 3;
		data.qos = flag >> 1 & 0x3;
		data.retain = flag & 1;
		if(type == CONNACK){
			data.code = buffer[offset+1];
		}else if(type == PUBLISH){
			const topicLen = buffer.readUInt16BE(offset);
			offset += 2;
			data.topic = buffer.toString('utf8', offset,  offset + topicLen);
			offset += topicLen;
			if(data.qos > 0){
				data.msgID = buffer.readUInt16BE(offset);
				offset += 2;
			}
			data.message = buffer.slice(offset);
		}else if(type == PUBACK || type == PUBREC || type == PUBREL || type == PUBCOMP || type == UNSUBACK){
			data.msgID = buffer.readUInt16BE(offset);
		}else if(type == SUBACK){
			data.msgID = buffer.readUInt16BE(offset);
			data.code = buffer.readUInt8(offset+2);
		}
		return data;
	}

	static encode(packet){
		const {type, qos, retain, msgID} = packet;
		const head = type << 4 | qos << 1 | retain;
		if(type == PUBLISH){
			const topic = gen_string(packet.topic);
			let {message} = packet;
			if(!Buffer.isBuffer(message)){
				message = Buffer.from(message);
			}
			const size = topic.length + (qos > 0 ? 2 : 0) + message.length;
			return Buffer.concat([
				Buffer.from([head, ...vuint.encode(size)]),
				topic,
				qos > 0 ? gen_uint16(msgID) : Buffer.alloc(0),
				message
			]);
		}
		if(type == PUBACK || type == PUBREC || type == PUBREL || type == PUBCOMP){
			return Buffer.from([head, 2, msgID >> 8, msgID]);
		}
		if(type == SUBSCRIBE){
			const topic = gen_string(packet.topic);
			const size = 3 + topic.length;
			return Buffer.concat([
				Buffer.from([head, ...vuint.encode(size)]),
				gen_uint16(msgID),
				topic,
				Buffer.from([0])
			]);
		}
		if(type == UNSUBSCRIBE){
			const topic = gen_string(packet.topic);
			const size = 2 + topic.length;
			return Buffer.concat([
				Buffer.from([head, ...vuint.encode(size)]),
				gen_uint16(msgID),
				topic,
			]);
		}
		if(type == CONNECT){
			const {clientID} = packet;
			const size = 12 + clientID.length;
			return Buffer.concat([
				Buffer.from([head, ...vuint.encode(size)]),
				gen_string('MQTT'),
				Buffer.from([4]),//version
				Buffer.from([2]),//flags
				gen_uint16(60),//keep alive
				gen_string(clientID)
			]);
		}
	}
}

function markDupFlag(buffer, dup){
	if(buffer[0] >> 4 == PUBLISH){
		buffer[0] |= dup << 3;
	}
	return buffer;
};

class Client extends EventEmitter
{
	constructor(socket){
		super();
		this.socket = socket;
		this.rangePool = RangePool(0x10000, 1);
	}

	async send(packet){
		const {qos} = packet;
		if(!qos)return this.socket.write(Packet.encode(packet));
		const msgID = packet.msgID = this.rangePool();
		await this.makeSureSend(Packet.encode(packet), packet.type + qos, msgID);
		if(qos > 1)await this.makeSureSend(Packet.encode({type:PUBREL, qos:1, msgID}), PUBCOMP, msgID);
		this.rangePool(msgID);
	}

	connect(clientID){
		this.send({type:CONNECT, clientID});
		//return waitWhen(this, 'packet', 10000, checker);
	}

	subscribe(topic){
		return this.send({type:SUBSCRIBE, qos:1, topic});
	}

	unsubscribe(topic){
		return this.send({type:UNSUBSCRIBE, qos:1, topic});
	}

	publish(topic, message, qos=0, retain=0){
		return this.send({type:PUBLISH, topic, message, qos, retain});
	}

	makeSureSend(data, type, msgID){
		const checker = packet => packet.type == type && packet.msgID == msgID;
		let dup = 0;
		return retry(() => {
			this.socket.write(markDupFlag(data, dup));
			dup = 1;
			return waitWhen(this, 'packet', 10000, checker);
		}, Infinity);
	}
}

function connect(url){
	const clientID = 'mqttjs_' + Math.random().toString(16).slice(2, 8);
	const {hostname, port} = new URL(url);
	const socket = net.connect(port || 1883, hostname);
	const status = new Map();
	listenPacket(socket, Packet, packet => {
		const {type, msgID} = packet;
		if(type == CONNACK){
			client.emit('connect');
		}else if(type == SUBACK || type == UNSUBACK || type == PUBACK || type == PUBREC || type == PUBCOMP){
			client.emit('packet', packet);
		}else if(type == PUBREL){
			status.delete(msgID);
			client.send({type:PUBCOMP, msgID});
		}else if(type == PUBLISH){
			const {topic, message, qos} = packet;
			if(qos == 0){
				client.emit('message', topic, message);
			}else if(qos == 1){
				client.emit('message', topic, message);
				client.send({type:PUBACK, msgID});
			}else if(qos == 2){
				if(!status.get(msgID)){
					client.emit('message', topic, message);
					status.set(msgID, true);
				}
				client.send({type:PUBREC, msgID});
			}
		}
	});
	const client = new Client(socket);
	client.connect(clientID);
	return client;
}

function gen_string(value){
	const size = Buffer.byteLength(value);
	const result = Buffer.alloc(2 + size);
	result.writeUInt16BE(size, 0);
	result.write(value, 2);
	return result;
}

function gen_uint16(value){
	const buffer = Buffer.allocUnsafe(2);
	buffer.writeUInt16BE(value, 0);
	return buffer;
}

connect('mqtt://test.mosquitto.org').on('connect', function () {
	this.subscribe('presence?')
	setInterval(() => {
		 this.publish('presence?', 'Hello mqtt', 1).then(() => console.log('pub ok'));
		}, 1000);
	setTimeout(() =>{
		this.unsubscribe('presence?')
	}, 5000)
}).on('message', function (topic, message) {
	// message is Buffer
	console.log(topic, message.toString())
	//client.end()
})
/*
setInterval(() => {
	console.log('tick')
}, 5000)
*/