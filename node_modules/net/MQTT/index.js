'use strict';

const {URL} = require('url');
const EventEmitter = require('events');
const net = require('net');

const listenPacket = require('../listenPacket');

class Packet
{
	static cut(buffer, offset){
		const count = buffer.length - offset;
		let payloadLen = 0;
		for(let i=0; i<4; ++i){
			const headLen = 2 + i;
			if(count < headLen)return;
			const byte = buffer.readUInt8(offset+1+i);
			payloadLen |= (byte & 0x7F) << 7 * i;
			if(byte <= 0x7F){
				return buffer.slice(offset, offset+headLen+payloadLen);
			}
		}
		return buffer.slice(offset, offset+5+payloadLen);
	}

	static decode(buffer){
		const byte1 = buffer.readUInt8(0);
		let offset = 0;
		let payloadLen = 0;
		for(let i=0; i<4; ++i){
			const byte = buffer.readUInt8(++offset);
			payloadLen |= (byte & 0x7F) << 7 * i;
			if(byte <= 0x7F)break;
		}
		++offset;
		const type = byte1 >> 4;
		const flag = byte1 & 0xF;
		const data = Object.create(null);
		data.type = type;
		data.flag = flag;
		if(type == 2){//connect ack
			data.code = buffer[offset+1];
		}else if(type == 3){//publish
			const qos = flag >> 1 & 0x3;
			data.topic = buffer.toString('utf8', offset + 2,  offset + 2 + buffer.readUInt16BE(offset));
			offset += 2 + buffer.readUInt16BE(offset);
			if(qos > 0){
				offset += 2;
			}
			data.message = buffer.slice(offset);
		}else if(type == 4){//publish ack
			data.msgID = buffer.readUInt16BE(offset);
		}else if(type == 9){//subscribe ack
			data.msgID = buffer.readUInt16BE(offset);
			data.code = buffer.readUInt8(offset+2);
		}else if(type == 11){//unsubscribe ack
			data.msgID = buffer.readUInt16BE(offset);
		}
		return data;
	}
}

class Client extends EventEmitter
{
	constructor(socket){
		super();
		this.socket = socket;
		socket.on('packet', packet => {
			if(packet.type == 3){//publish
				const {topic, message} = packet;
				this.emit('message', topic, message);
			}
		});
	}

	subscribe(topic){
		const msgID = 123;
		makeSureSend(this.socket, packet_subscribe(topic, msgID), 9, msgID);
	}

	unsubscribe(topic){
		const msgID = 124;
		makeSureSend(this.socket, packet_unsubscribe(topic, msgID), 11, msgID);
	}

	publish(topic, message, qos=0, retain=false){
		const msgID = 125;
		const packet = packet_publish(topic, message, msgID, qos);
		if(qos == 0){//most once
			this.socket.write(packet);
		}else if(qos == 1){//least once
			makeSureSend(this.socket, dup => {
				packet[0] |= dup << 3;
				return packet;
			}, 4, msgID);
		}else if(qos == 2){//exact once
			
		}
	}
}

function makeSureSend(socket, data, type, msgID){
	const sendFn = (dup=true) => socket.write(Buffer.isBuffer(data) ? data : data(dup));
	const timer = setInterval(sendFn, 10000);
	const onPacket = packet => {
		if(packet.type != type)return;
		if(packet.msgID != msgID)return;
		socket.off('packet', onPacket);
		clearInterval(timer);
		console.log('recv ack', type);
	};
	socket.on('packet', onPacket);
	sendFn(false);
}

function connect(url){
	const clientID = 'mqttjs_' + Math.random().toString(16).slice(2, 8);
	const {hostname, port} = new URL(url);
	const socket = net.connect(port || 1883, hostname, function(){
		listenPacket(this, Packet);
		this.write(packet_connect(clientID));
		this.once('packet', packet => {
			if(packet.type == 2){
				client.emit('connect');
			}
		})
	});
	const client = new Client(socket);
	return client;
}

function gen_vuint(value){
	const result = [];
	while(value > 0x7F){
		result.push(0x80 | value & 0x7F);
		value >> 7;
	}
	result.push(value & 0x7F);
	return Buffer.from(result);
}

function gen_string(value){
	const size = Buffer.byteLength(value);
	const result = Buffer.alloc(2 + size);
	result.writeUInt16BE(size, 0);
	result.write(value, 2);
	return result;
}

function gen_uint16(value){
	const buffer = Buffer.allocUnsafe(2);
	buffer.writeUInt16BE(value, 0);
	return buffer;
}


function packet_connect(clientID){
	const size = 12 + clientID.length;
	return Buffer.concat([
		Buffer.from([1<<4]),//connect
		gen_vuint(size),//size after this block
		gen_string('MQTT'),
		Buffer.from([4]),//version
		Buffer.from([2]),//flags
		gen_uint16(60),//keep alive
		gen_string(clientID)
	]);
}

function packet_subscribe(topic, msgID){
	topic = gen_string(topic);
	const size = 3 + topic.length;
	return Buffer.concat([
		Buffer.from([8<<4 | 2]),//subscribe
		gen_vuint(size),//size after this block
		gen_uint16(msgID),
		topic,
		Buffer.from([0])
	]);
}

function packet_unsubscribe(topic, msgID){
	topic = gen_string(topic);
	const size = 2 + topic.length;
	return Buffer.concat([
		Buffer.from([10<<4 | 2]),//subscribe
		gen_vuint(size),//size after this block
		gen_uint16(msgID),
		topic,
	]);
}

function packet_publish(topic, message, msgID, qos=0, retain=0){
	topic = gen_string(topic);
	if(!Buffer.isBuffer(message)){
		message = Buffer.from(message);
	}
	const size = topic.length + (qos > 0 ? 2 : 0) + message.length;
	return Buffer.concat([
		Buffer.from([3 << 4 | qos << 1 | retain]),//publish
		gen_vuint(size),//size after this block
		topic,
		qos > 0 ? gen_uint16(msgID) : Buffer.alloc(0),
		message
	]);
}


connect('mqtt://test.mosquitto.org').on('connect', function () {
  this.subscribe('presence?')
 
  setInterval(() => {
  	 this.publish('presence?', 'Hello mqtt', 1);
  	}, 1000);
  setTimeout(() =>{
  	this.unsubscribe('presence?')
  }, 5000)
}).on('message', function (topic, message) {
  // message is Buffer
  console.log(topic, message.toString())
  //client.end()
})
/*
setInterval(() => {
	console.log('tick')
}, 5000)
*/