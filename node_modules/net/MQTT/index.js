'use strict';

const EventEmitter = require('events');
const retry = require('../../utils/function/retry');
const {waitWhen} = require('../../utils/events');
const {RangePool} = require('../../utils/counter');
const listenPacket = require('../listenPacket');
const Packet = require('./Packet');

const CONNECT = 1;
const CONNACK = 2;
const PUBLISH = 3;
const PUBACK = 4;
const PUBREC = 5;
const PUBREL = 6;
const PUBCOMP = 7;
const SUBSCRIBE = 8;
const SUBACK = 9;
const UNSUBSCRIBE = 10;
const UNSUBACK = 11;
const PINGREQ = 12;
const PINGRESP = 13;
const DISCONNECT = 14;

function markDupFlag(buffer, dup){
	if(buffer[0] >> 4 == PUBLISH){
		buffer[0] |= dup << 3;
	}
	return buffer;
};

class Client extends EventEmitter
{
	constructor(socket){
		super();
		this.socket = socket;
		this.rangePool = RangePool(0x10000, 1);
	}

	write(buffer){
		return new Promise(resolve => this.socket.write(buffer, resolve));
	}

	async send(packet){
		const {qos} = packet;
		if(!qos)return this.write(Packet.encode(packet));
		const msgID = packet.msgID = this.rangePool();
		const {code} = await this.makeSureSend(Packet.encode(packet), packet.type + qos, msgID);
		if(qos > 1)await this.makeSureSend(Packet.encode({type:PUBREL, qos:1, msgID}), PUBCOMP, msgID);
		this.rangePool(msgID);
		return code;
	}

	makeSureSend(data, type, msgID){
		const checker = packet => packet.type == type && packet.msgID == msgID && packet;
		let dup = 0;
		return retry(() => {
			this.socket.write(markDupFlag(data, dup));
			dup = 1;
			return waitWhen(this, 'packet', 10000, checker);
		}, Infinity);
	}

	async connect(clientID, timeout=10000){
		this.send({type:CONNECT, clientID});
		const {code, sp} = await waitWhen(this, 'packet', timeout, packet => packet.type == CONNACK && packet);
		if(code > 0)return Promise.reject(code);
	}

	subscribe(topic){
		return this.send({type:SUBSCRIBE, qos:1, topic});
	}

	unsubscribe(topic){
		return this.send({type:UNSUBSCRIBE, qos:1, topic});
	}

	publish(topic, message, qos=0, retain=0){
		return this.send({type:PUBLISH, topic, message, qos, retain});
	}

	ping(timeout=10000){
		this.send({type:PINGREQ});
		return waitWhen(this, 'packet', timeout, packet => packet.type == PINGRESP);
	}

	disconnect(){
		return this.send({type:DISCONNECT});
	}
}

function createClient(socket){
	const client = new Client(socket);
	const status = new Map();
	listenPacket(socket, Packet, packet => {
		client.emit('packet', packet);
		const {type, msgID} = packet;
		if(type == PUBREL){
			status.delete(msgID);
			client.send({type:PUBCOMP, msgID});
			return;
		}
		if(type != PUBLISH)return;
		const {qos, topic, message} = packet;
		if(qos > 2)return;
		if(qos > 0)client.send({type:PUBLISH+qos, msgID});
		if(qos < 2)return client.emit('message', topic, message);
		if(status.get(msgID))return;
		status.set(msgID, true);
		client.emit('message', topic, message);
	});
	return client;
}

exports.createClient = createClient;
