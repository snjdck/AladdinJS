'use strict';

const {URL} = require('url');
const EventEmitter = require('events');
const net = require('net');
const ObjectCache = require('utils/ObjectCache');
const retry = require('../../utils/function/retry');
const {waitWhen} = require('../../utils/events');
const listenPacket = require('../listenPacket');

const CONNECT = 1;
const CONNACK = 2;
const PUBLISH = 3;
const PUBACK = 4;
const PUBREC = 5;
const PUBREL = 6;
const PUBCOMP = 7;
const SUBSCRIBE = 8;
const SUBACK = 9;
const UNSUBSCRIBE = 10;
const UNSUBACK = 11;
const PINGREQ = 12;
const PINGRESP = 13;
const DISCONNECT = 14;

class Packet
{
	static cut(buffer, offset){
		const count = buffer.length - offset;
		let headLen = 1;
		let payloadLen = 0;
		for(let i=0; i<4; ++i){
			if(count < ++headLen)return;
			const byte = buffer.readUInt8(offset+1+i);
			payloadLen |= (byte & 0x7F) << 7 * i;
			if(byte <= 0x7F)break;
		}
		return buffer.slice(offset, offset+headLen+payloadLen);
	}

	static decode(buffer){
		const byte1 = buffer.readUInt8(0);
		let offset = 1;
		let payloadLen = 0;
		for(let i=0; i<4; ++i){
			const byte = buffer.readUInt8(offset++);
			payloadLen |= (byte & 0x7F) << 7 * i;
			if(byte <= 0x7F)break;
		}
		const type = byte1 >> 4;
		const flag = byte1 & 0xF;
		const data = Object.create(null);
		data.type = type;
		data.flag = flag;
		data.dup = flag >> 3;
		data.qos = flag >> 1 & 0x3;
		data.retain = flag & 1;
		if(type == CONNACK){
			data.code = buffer[offset+1];
		}else if(type == PUBLISH){
			const topicLen = buffer.readUInt16BE(offset);
			offset += 2;
			data.topic = buffer.toString('utf8', offset,  offset + topicLen);
			offset += topicLen;
			if(data.qos > 0){
				data.msgID = buffer.readUInt16BE(offset);
				offset += 2;
			}
			data.message = buffer.slice(offset);
		}else if(type == PUBACK){
			data.msgID = buffer.readUInt16BE(offset);
		}else if(type == PUBREC){
			data.msgID = buffer.readUInt16BE(offset);
		}else if(type == PUBREL){
			data.msgID = buffer.readUInt16BE(offset);
		}else if(type == PUBCOMP){
			data.msgID = buffer.readUInt16BE(offset);
		}else if(type == SUBACK){
			data.msgID = buffer.readUInt16BE(offset);
			data.code = buffer.readUInt8(offset+2);
		}else if(type == UNSUBACK){
			data.msgID = buffer.readUInt16BE(offset);
		}
		return data;
	}

	static encode(packet, msgIDMgr){
		if(packet.qos > 0 && !packet.msgID){
			packet.msgID = msgIDMgr.getOut();
		}
		const {type, qos, retain, msgID} = packet;
		const head = type << 4 | qos << 1 | retain;
		if(type == PUBLISH){
			const topic = gen_string(packet.topic);
			let {message} = packet;
			if(!Buffer.isBuffer(message)){
				message = Buffer.from(message);
			}
			const size = topic.length + (qos > 0 ? 2 : 0) + message.length;
			return Buffer.concat([
				Buffer.from([head]),
				gen_vuint(size),//size after this block
				topic,
				qos > 0 ? gen_uint16(msgID) : Buffer.alloc(0),
				message
			]);
		}
		if(type == PUBACK || type == PUBREC || type == PUBREL || type == PUBCOMP){
			return Buffer.concat([
				Buffer.from([head]),
				gen_vuint(2),//size after this block
				gen_uint16(msgID)
			]);
		}
		if(type == SUBSCRIBE){
			const topic = gen_string(packet.topic);
			const size = 3 + topic.length;
			return Buffer.concat([
				Buffer.from([head]),
				gen_vuint(size),//size after this block
				gen_uint16(msgID),
				topic,
				Buffer.from([0])
			]);
		}
		if(type == UNSUBSCRIBE){
			const topic = gen_string(packet.topic);
			const size = 2 + topic.length;
			return Buffer.concat([
				Buffer.from([head]),
				gen_vuint(size),//size after this block
				gen_uint16(msgID),
				topic,
			]);
		}
		if(type == CONNECT){
			const {clientID} = packet;
			const size = 12 + clientID.length;
			return Buffer.concat([
				Buffer.from([head]),
				gen_vuint(size),//size after this block
				gen_string('MQTT'),
				Buffer.from([4]),//version
				Buffer.from([2]),//flags
				gen_uint16(60),//keep alive
				gen_string(clientID)
			]);
		}
	}
}

function createMsgIDManager(){
	return new ObjectCache((offset => () => {
		if(offset > 0xFFFF)throw new Error('msgID use out!');
		return offset++;
	})(1));
}

function markDupFlag(buffer, dup){
	if(buffer[0] >> 4 == PUBLISH){
		buffer[0] |= dup << 3;
	}
	return buffer;
};

class Client extends EventEmitter
{
	constructor(socket){
		super();
		this.socket = socket;
		socket.on('packet', (dict => packet => {
			if(packet.type == PUBLISH){
				const {topic, message} = packet;
				if(packet.qos == 0){
					this.emit('message', topic, message);
				}else if(packet.qos == 1){
					this.emit('message', topic, message);
					this.send({type: PUBACK, msgID: packet.msgID});
				}else if(packet.qos == 2){
					if(!dict.get(packet.msgID)){
						this.emit('message', topic, message);
						dict.set(packet.msgID, true);
					}
					this.send({type: PUBREC, msgID: packet.msgID});
				}
			}else if(packet.type == PUBREL){
				dict.set(packet.msgID, false);
				this.send({type: PUBCOMP, msgID: packet.msgID});
			}else if(packet.type == CONNACK){
				this.emit('connect');
			}
		})(new Map()));
		this.msgIDMgr = createMsgIDManager();
	}

	async send(packet){
		const buffer = Packet.encode(packet, this.msgIDMgr);
		if(packet.qos === 1){
			await this.makeSureSend(buffer, packet.waitMsgType, packet.msgID);
			this.msgIDMgr.putIn(packet.msgID);
		}else if(packet.qos === 2){
			await this.makeSureSend(buffer, PUBREC, packet.msgID);
			await this.send({type: PUBREL, qos: 1, waitMsgType: PUBCOMP, msgID: packet.msgID});
		}else{
			this.socket.write(buffer);
		}
	}

	connect(clientID){
		this.send({type: CONNECT, clientID});
	}

	subscribe(topic){
		this.send({type: SUBSCRIBE, qos: 1, waitMsgType: SUBACK, topic});
	}

	unsubscribe(topic){
		this.send({type: UNSUBSCRIBE, qos: 1, waitMsgType: UNSUBACK, topic});
	}

	publish(topic, message, qos, retain){
		this.send({type: PUBLISH, waitMsgType: PUBACK, topic, message, qos, retain});
	}

	makeSureSend(data, type, msgID){
		let dup = false;
		return retry(() => {
			this.socket.write(markDupFlag(data, dup));
			dup = true;
			return waitWhen(this.socket, 'packet', 10000, packet => packet.type == type && packet.msgID == msgID);
		}, Infinity);
	}
}

function connect(url){
	const clientID = 'mqttjs_' + Math.random().toString(16).slice(2, 8);
	const {hostname, port} = new URL(url);
	const socket = net.connect(port || 1883, hostname, function(){
		listenPacket(this, Packet, packet => this.emit('packet', packet));
	});
	const client = new Client(socket);
	client.connect(clientID);
	return client;
}

function gen_vuint(value){
	const result = [];
	while(value > 0x7F){
		result.push(0x80 | value & 0x7F);
		value >> 7;
	}
	result.push(value & 0x7F);
	return Buffer.from(result);
}

function gen_string(value){
	const size = Buffer.byteLength(value);
	const result = Buffer.alloc(2 + size);
	result.writeUInt16BE(size, 0);
	result.write(value, 2);
	return result;
}

function gen_uint16(value){
	const buffer = Buffer.allocUnsafe(2);
	buffer.writeUInt16BE(value, 0);
	return buffer;
}

connect('mqtt://test.mosquitto.org').on('connect', function () {
	this.subscribe('presence?')
	setInterval(() => {
		 this.publish('presence?', 'Hello mqtt', 1);
		}, 1000);
	setTimeout(() =>{
		this.unsubscribe('presence?')
	}, 5000)
}).on('message', function (topic, message) {
	// message is Buffer
	console.log(topic, message.toString())
	//client.end()
})
/*
setInterval(() => {
	console.log('tick')
}, 5000)
*/