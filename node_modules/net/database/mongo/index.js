const net = require('net');
const bson = require('net/codec/bson');
const delayCall = require('utils/function/delayCall');
const listenPacket = require('net/listenPacket');
const {doAsyncWait} = require('net/doAsyncWait');

function connect(host='127.0.0.1', port=27017){
	return new Promise(resolve => {
		net.connect(port, host, function(){
			listenPacket(this, Packet);
			resolve(this);
		});
	});
}

class Packet
{
	static cut(buffer, offset=0){
		let count = buffer.length - offset;
		if(count < 4)return;
		let packetLen = buffer.readInt32LE(offset);
		if(count < packetLen)return;
		return buffer.slice(offset, offset+packetLen);
	}

	static decode(buffer){
		let responseID = buffer.readInt32LE(8);
		let data = bson.decode(buffer.slice(21));
		return {responseID, data};
	}
}

const db_query = (nextReqId => function(query){
	const requestID = nextReqId();
	const packet = Buffer.concat([
		Buffer.allocUnsafe(21).fill(0),
		bson.encode(query)
	]);
	packet.writeInt32LE(packet.length, 0);
	packet.writeInt32LE(requestID, 4);
	packet.writeInt32LE(2013, 12);
	this.write(packet);
	return doAsyncWait(this, 'packet', 10,
		({responseID}) => responseID === requestID,
		({data}) => data
	);
})((reqId => () => reqId = (reqId + 1) % 0x80000000)(0));

class Find extends Promise
{
	static get [Symbol.species](){return Promise;}
	constructor(executor, target){
		super(delayCall(executor));
		this._target = target;
	}
	sort(data){
		this._target.sort = data;
		return this;
	}
	skip(count){
		this._target.skip = count;
		return this;
	}
	limit(count){
		this._target.limit = count;
		return this;
	}
}

function do_delete(queryList, limit){
	if(queryList.length <= 0)return Promise.resolve();
	let {socket, $db, name} = this;
	let deletes = queryList.map(q => ({q, limit}));
	let command = {delete:name, $db, deletes};
	return db_query.call(socket, command);
}

class Collection
{
	constructor(socket, db, name){
		this.socket = socket;
		this.$db = db;
		this.name = name;
	}

	delete_one(...queryList){
		return do_delete.call(this, queryList, 1);
	}

	delete_all(...queryList){
		return do_delete.call(this, queryList, 0);
	}

	update(q, u){
		let {socket, $db, name} = this;
		let updates = [{q, u}];
		let command = {update:name, $db, updates};
		return db_query.call(socket, command);
	}

	insert(...documents){
		if(documents.length <= 0)return Promise.resolve();
		let {socket, $db, name} = this;
		let command = {insert:name, $db, documents};
		return db_query.call(socket, command);
	}

	find(filter, projection){
		let {socket, $db, name} = this;
		let command = {find:name, $db, filter, projection};
		return new Find(resolve => db_query.call(socket, command).then(resolve), command);
	}

	getMore(cursorID){
		let {socket, $db, name} = this;
		let command = {collection:name, $db, getMore:cursorID};
		return db_query.call(socket, command);
	}

	findAndRemove(query, sort){
		let {socket, $db, name} = this;
		let command = {findAndModify:name, $db, query, sort, remove:true};
		return db_query.call(socket, command);
	}

	findAndUpdate(query, update, sort){
		let {socket, $db, name} = this;
		let command = {findAndModify:name, $db, query, sort, update};
		return db_query.call(socket, command);
	}
}

void async function(){
	let socket = await connect();
	let collection = new Collection(socket, 'test', 'users');
	console.log(JSON.stringify(await collection.find({})))
	console.log(JSON.stringify(await collection.insert({name:1}, {name:2})))
	console.log(JSON.stringify(await collection.find({})))
	
	//console.log(JSON.stringify(await collection.update({name:1}, {name:'alex'})))
	//return;
	//console.log(JSON.stringify(await collection.delete_one({name:1})))
	//console.log(JSON.stringify(await collection.find({})))
	//console.log(JSON.stringify(await collection.delete_all({name:2})))
	//console.log(JSON.stringify(await collection.find({}, {name:1,_id:0}).limit(2).skip(2)))
	//console.log(JSON.stringify(await collection.findAndRemove({name:2})))
}();

