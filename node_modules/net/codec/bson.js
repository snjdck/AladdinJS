
const ByteArray = require('utils/ByteArray');
const flatten = require('utils/array/flatten');

const TERMINATOR	= 0x00;
const DOUBLE		= 0x01;
const STRING		= 0x02;
const DOCUMENT		= 0x03;
const ARRAY			= 0x04;
const BINARY		= 0x05;
const UNDEFINED		= 0x06;
const OBJECT_ID		= 0x07;
const BOOLEAN		= 0x08;
const DATE			= 0x09;
const NULL			= 0x0A;
const REG_EXP		= 0x0B;
const INT32			= 0x10;
const TIMESTAMP		= 0x11;
const INT64			= 0x12;

const encode = function(){
	const byte = v => Buffer.allocUnsafe(1).fill(v);
	function castInt32(value){
		let buffer = Buffer.allocUnsafe(4);
		buffer.writeInt32LE(value, 0);
		return buffer;
	}
	function writeDoc(value){
		let payload = flatten(Object.entries(value).map(([k, v]) => writeData(k, v)));
		let size = payload.reduce((sum, v) => sum + v.length, 0);
		return [castInt32(size+5), ...payload, byte()];
	}
	function writeData(key, value){
		let type = calcType(value);
		let buffer;
		switch(type){
			case DOUBLE:
				buffer = Buffer.allocUnsafe(8);
				buffer.writeDoubleLE(value, 0);
				break;
			case STRING:
				buffer = Buffer.from(value);
				buffer = [castInt32(buffer.length+1), buffer, byte()];
				break;
			case DOCUMENT:
				if(typeof value.toBSON === 'function'){
					return writeData(key, value.toBSON());
				}
				//fallthrough
			case ARRAY:
				buffer = writeDoc(value);
				break;
			case BINARY:
				buffer = [castInt32(value.length), byte(), value];
				break;
			case BOOLEAN:
				buffer = byte(value);
				break;
			case UNDEFINED:
			case NULL:
				break;
			case INT32:
				buffer = castInt32(value);
				break;
			case OBJECT_ID:
				buffer = value.toBSON();
				break;
			default:
				return;
		}
		return [byte(type), Buffer.from(key), byte(), buffer];
	}
	function calcType(value){
		switch(typeof value){
			case 'string': return STRING;
			case 'boolean':return BOOLEAN;
			case 'undefined':return UNDEFINED;
			case 'number':
				return Number.isInteger(value) ? INT32 : DOUBLE;
			case 'object':
				break;
			default:
				return;
		}
		if(value === null)return NULL;
		if(value instanceof ObjectID)return OBJECT_ID;
		if(Buffer.isBuffer(value))return BINARY;
		return Array.isArray(value) ? ARRAY : DOCUMENT;
	}
	return value => Buffer.concat(writeDoc(value));
}();

const decode = function(){
	function readDoc(buffer, output={}){
		buffer.position += 4;
		for(;;){
			let type = buffer.readUInt8();
			if(type === TERMINATOR)
				break;
			output[buffer.readCString()] = readData(buffer, type);
		}
		return output;
	}
	function readData(buffer, type){
		switch(type){
			case DOUBLE:	return buffer.readDouble();
			case STRING:	return readString(buffer);
			case DOCUMENT:	return readDoc(buffer);
			case ARRAY:		return readDoc(buffer, []);
			case BINARY:	return readBinary(buffer);
			case UNDEFINED:	return undefined;
			case OBJECT_ID:	return new ObjectID(buffer.readBytes(12));
			case BOOLEAN:	return buffer.readBoolean();
			case DATE:		return new Date(buffer.readInt64LE());
			case NULL:		return null;
			case REG_EXP:	return new RegExp(buffer.readCString(), buffer.readCString());
			case INT32:		return buffer.readInt32LE();
			case INT64:		return buffer.readInt64LE();
		}
		throw new Error();
	}
	function readString(buffer){
		let value = buffer.readUTFBytes(buffer.readInt32LE()-1);
		++buffer.position;
		return value;
	}
	function readBinary(buffer){
		let size = buffer.readInt32LE();
		let subType = buffer.readUInt8();
		if(2 == subType)
			size = buffer.readInt32LE();
		return buffer.readBytes(size);
	}
	return buffer => readDoc(new ByteArray(buffer));
}();

class ObjectID
{
	constructor(value){
		this.value = value;
	}
	toBSON(){
		return this.value;
	}
}

module.exports = {
	encode,
	decode
};