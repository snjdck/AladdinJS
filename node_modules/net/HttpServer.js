'use strict';

const {URL} = require('url');
const compose = require('utils/function/compose');

function HttpServer(info, middlewareList, upgradeDict={}){
	const {host, port, protocol, options} = Object.assign({protocol:'http',host:'0.0.0.0',port:80}, info);
	const handler = compose(...middlewareList)(respond404);
	const calcURL = request => new URL(request.url, protocol + '://' + request.headers.host);
	require(protocol).createServer(options, (request, response) => {
		handler(request, response, calcURL(request));
	}).on('upgrade', (request, socket) => {
		const upgradeFn = upgradeDict[request.headers.upgrade];
		if(!upgradeFn)return socket.end();
		upgradeFn(request, socket, calcURL(request));
	}).listen(port, host);
}

function respond404(request, response){
	response.statusCode = 404;
	response.end();
}

function EventSource(handlerMap){
	const headers = {
		'Access-Control-Allow-Origin': '*',
		'Content-Type': 'text/event-stream',
		'Cache-Control': 'no-cache',
		'Connection': 'keep-alive',
	}
	return next => (request, response, url) => {
		const {pathname:path, searchParams:params} = url;
		const handler = handlerMap[path];
		if(request.method != 'GET' || !handler)
			return next(request, response, url);
		response.writeHead(200, headers);
		const onClose = handler(response, params);
		if(onClose)request.on('close', onClose);
	}
}

function StaticFile(directory, prefix){
	const fs = require('fs');
	const {extname} = require('path');
	const mime = require('./file_server/mime');
	const findContentType = extName => (extName in mime) ? mime[extName] : 'unknow';
	const redirect = path => path.endsWith('/') ? path + 'index.html' : path;
	return next => (request, response, url) => {
		let {pathname:path} = url;
		if(prefix){
			if(!path.startsWith(prefix + '/'))
				return next(request, response, url);
			path = path.slice(prefix.length);
		}
		const filePath = directory + redirect(path);
		console.log(request.url, filePath);
		if(request.method != 'GET' || !fs.existsSync(filePath))
			return next(request, response, url);
		fs.readFile(filePath, function(error, data){
			if(error != null)
				return next(request, response, url);
			response.setHeader('Content-Type', findContentType(extname(filePath).slice(1)));
			response.setHeader('Content-Length', data.length);
			response.end(data);
		});
	}
}

function Redirect(fn, code=302){
	return next => (request, response, url) => {
		const location = fn(request, url);
		if(!location)return next(request, response, url);
		response.writeHead(code, {
			'Location': location
		});
		response.end();
	}
}

function Router(method, handlerMap){
	return next => (request, response, url) => {
		const handler = (!method || request.method == method) && handlerMap[url.pathname];
		(handler || next)(request, response, url);
	}
}

function readData(target, callback){
	let result = [];
	target.on('data', chunk => result.push(chunk));
	target.on('end', () => callback(Buffer.concat(result)));
}

exports.HttpServer = HttpServer;
exports.EventSource = EventSource;
exports.StaticFile = StaticFile;
exports.Redirect = Redirect;
exports.Router = Router;

exports.readData = readData;
