'use strict';

const {URL} = require('url');
const compose = require('utils/function/compose');
const readDataAsync = require('./readDataAsync');

function HttpServer(info, middlewareList, upgradeDict={}){
	const {host, port, protocol, options} = Object.assign({protocol:'http',host:'0.0.0.0',port:80}, info);
	const handler = compose(...middlewareList)(respond404);
	const calcURL = request => new URL(request.url, protocol + '://' + request.headers.host);
	require(protocol).createServer(options, (request, response) => {
		handler(request, response, calcURL(request));
	}).on('upgrade', (request, socket) => {
		const upgradeFn = upgradeDict[request.headers.upgrade];
		if(!upgradeFn)return socket.end();
		upgradeFn(request, socket, calcURL(request));
	}).listen(port, host);
}

function respond404(request, response){
	response.statusCode = 404;
	response.end();
}

function EventSource(handlerMap){
	const headers = {
		'Access-Control-Allow-Origin': '*',
		'Content-Type': 'text/event-stream',
		'Cache-Control': 'no-cache',
		'Connection': 'keep-alive',
	}
	return next => (request, response, url) => {
		const {pathname:path, searchParams:params} = url;
		const handler = handlerMap[path];
		if(request.method != 'GET' || !handler)
			return next(request, response, url);
		response.writeHead(200, headers);
		const onClose = handler(response, params);
		if(onClose)request.on('close', onClose);
	}
}

function StaticFile(directory, prefix){
	const fs = require('fs');
	const {extname} = require('path');
	const mime = require('./file_server/mime');
	const findContentType = extName => (extName in mime) ? mime[extName] : 'unknow';
	const redirect = path => path.endsWith('/') ? path + 'index.html' : path;
	return next => (request, response, url) => {
		let {pathname:path} = url;
		if(prefix){
			if(!path.startsWith(prefix + '/'))
				return next(request, response, url);
			path = path.slice(prefix.length);
		}
		const filePath = directory + redirect(decodeURIComponent(path));
		console.log(request.url, filePath);
		if(request.method != 'GET' || !fs.existsSync(filePath))
			return next(request, response, url);
		response.setHeader('Content-Type', findContentType(extname(filePath).slice(1)));
		const {range} = request.headers;
		const totalLength = fs.lstatSync(filePath).size;
		if(range){
			let [start, end] = range.split('=')[1].split('-').map(Number);
			if(!end){
				end = totalLength - 1;
			}
			response.setHeader('Content-Length', end - start + 1);
			response.setHeader('Content-Range', `bytes ${start}-${end}/${totalLength}`);
			response.writeHead(206, 'Partial Content');
			fs.createReadStream(filePath, {start, end}).pipe(response);
		}else{
			response.setHeader('Content-Length', totalLength);
			fs.createReadStream(filePath).pipe(response);
		}
	}
}

function Redirect(fn, code=302){
	return next => (request, response, url) => {
		const location = fn(request, url);
		if(!location)return next(request, response, url);
		response.writeHead(code, {
			'Location': location
		});
		response.end();
	}
}

function Router(method, handlerMap){
	return next => (request, response, url) => {
		const handler = (!method || request.method == method) && handlerMap[url.pathname];
		(handler || next)(request, response, url);
	}
}

const bodyParser = function(){
	const BodyParser = fn => next => (request, response, url) => readDataAsync(request, body => {
		request.body = fn(body);
		next(request, response, url);
	})
	return {
		raw: BodyParser(v => v),
		text: BodyParser(v => v.toString()),
		json: BodyParser(v => JSON.parse(v.toString())),
		urlencoded: BodyParser(v => new URLSearchParams(v.toString())),
	}
}()

exports.HttpServer = HttpServer;
exports.EventSource = EventSource;
exports.StaticFile = StaticFile;
exports.Redirect = Redirect;
exports.Router = Router;

exports.bodyParser = bodyParser;
