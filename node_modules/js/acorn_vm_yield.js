'use strict';

//const containsYield = require('./acorn_yield');
const containsYield = node => node.type == 'AwaitExpression';

function throwError(node){
	console.error(node);
	throw new Error(node);
}

function ReturnStatement(value){
	this.value = value;
}

function BreakStatement(label){
	this.label = label;
}

function ContinueStatement(label){
	this.label = label;
}

function YieldExpression(value){
	this.value = value;
}

function newNodeReturnStatement(argument){
	return {
		type: 'ReturnStatement',
		argument
	}
}

function newNodeVariableDeclaration(kind, declarations){
	return {
		type: 'VariableDeclaration',
		kind,
		declarations
	}
}

function newNodeVariableDeclarator(name, init){
	return {
		type: 'VariableDeclarator',
		id: newNodeIdentifier(name),
		init
	}
}

function newNodeIdentifier(name){
	return {
		type: 'Identifier',
		name
	}
}

function newNodeBlockStatement(body){
	return {
		type: 'BlockStatement',
		body
	}
}

function newNodeAssignmentExpression(name, right){
	return {
		type: 'AssignmentExpression',
		operator: '=',
		left: newNodeIdentifier(name),
		right
	}
}

function newNodeMemberExpression(object, name){
	return {
		type: 'MemberExpression',
		object,
		property: {
			type: 'Identifier',
			name
		},
		computed: false
	}
}

function newNodeExpressionStatement(expression){
	return {
		type: 'ExpressionStatement',
		expression
	}
}

function newNodeBinaryExpression(operator, left, right){
	return {
		type: 'BinaryExpression',
		operator, left, right
	}
}

function newNodeCallExpression(callee, args){
	return {
		type: 'CallExpression',
		callee,
		arguments: args
	}
}

function newNodeFunctionExpression(params, body){
	return {
		type: 'FunctionExpression',
		params: params.map(newNodeIdentifier),
		body: Array.isArray(body) ? newNodeBlockStatement(body) : body
	}
}


function collectArgs(node, ctx){
	let args = [];
	for(let arg of node.arguments){
		let value = this(arg, ctx);
		if(arg.type == 'SpreadElement'){
			args.push(...value);
		}else{
			args.push(value);
		}
	}
	return args;
}

function getProperty(node, ctx){
	return node.computed ? this(node.property, ctx) : node.property.name;
}

function print(node){
	const fn = (k, v) => ['start', 'end'].indexOf(k) >= 0 ? undefined : v;
	console.log(JSON.stringify(node, fn, 2));
}

const handler = new Proxy({
	Program(node, ctx){
		node.body.forEach(v => this(v, ctx));
	},
	Identifier(node, ctx){},
	FunctionDeclaration(node, ctx){
		if(node.async){
			node.async = false;
			node.body = newNodeBlockStatement([
				newNodeReturnStatement(
					newNodeCallExpression(
					newNodeMemberExpression(
						newNodeCallExpression(newNodeMemberExpression(newNodeIdentifier('Promise'), 'resolve'), []),
						'then'
					), [newNodeFunctionExpression([], node.body)])
				)
			])
		}
		this(node.body, ctx);
	},
	ArrowFunctionExpression(node, ctx){
		ctx.pushFn(node);
		this(node.body, ctx);
	},
	FunctionExpression(node, ctx){
		ctx.pushFn(node);
		this(node.body, ctx);
	},
	AwaitExpression(node, ctx){
		let {blockStatementBody, expressionStatement} = ctx;
		const name = ctx.getName();
		const index = blockStatementBody.indexOf(expressionStatement);
		let rest = blockStatementBody.splice(index);
		blockStatementBody.push(newNodeReturnStatement(newNodeCallExpression(newNodeMemberExpression(newNodeCallExpression(
				newNodeMemberExpression(newNodeIdentifier('Promise'), 'resolve'), [node.argument]
			), 'then'), [
			newNodeFunctionExpression([name], rest)
		])));
		ctx.blockStatementBody = rest;
		ctx.expressionStatement = rest[0];

		Object.assign(node, newNodeIdentifier(name));
		this(node.argument, ctx);
	},
	YieldExpression(node, ctx){
		console.log(node.delegate)
		//throw new YieldExpression(this(node.argument, ctx));
	},
	BlockStatement(node, ctx){
		ctx.blockStatementBody = node.body;
		node.body.slice().forEach(v => this(v, ctx));
	},
	ExpressionStatement(node, ctx){
		ctx.expressionStatement = node;
		this(node.expression, ctx);
	},
	CallExpression(node, ctx){
		this(node.callee, ctx);
		collectArgs.call(this, node, ctx);
	},
	SpreadElement(node, ctx){
		this(node.argument, ctx);
	},
	MemberExpression(node, ctx){
		this(node.object, ctx);
		getProperty.call(this, node, ctx);
	},
	EmptyStatement(node, ctx){},
	UnaryExpression(node, ctx){
		this(node.argument, ctx);
	},
	BinaryExpression(node, ctx){
		const hasYieldL = containsYield(node.left);
		const hasYieldR = containsYield(node.right);
		this(node.left, ctx);
		this(node.right, ctx);
		if(hasYieldL){
			node.left = newNodeIdentifier(ctx.insertExpression(node.left));
			node.right = newNodeIdentifier(ctx.insertExpression(node.right));
		}else if(hasYieldR){
			node.right = newNodeIdentifier(ctx.insertExpression(node.right));
		}
	},
	AssignmentExpression(node, ctx){
		const left = this(node.left, ctx);
		const right = this(node.right, ctx);
	},
	LogicalExpression(node, ctx){
		this(node.left, ctx);
		this(node.right, ctx);
	},
	Literal(node, ctx){},
	VariableDeclaration(node, ctx){
		node.declarations.forEach(v => this(v, ctx));
	},
	VariableDeclarator(node, ctx){
		if(node.init){
			this(node.init, ctx);
		}
	},
	ReturnStatement(node, ctx){
		this(node.argument, ctx);
	},
	ConditionalExpression(node, ctx){
		this(node.test, ctx);
		this(node.consequent, ctx);
		this(node.alternate, ctx);
	},
	IfStatement(node, ctx){
		this(node.test, ctx);
		this(node.consequent, ctx);
		if(node.alternate){
			this(node.alternate, ctx);
		}
	},
	WhileStatement(node, ctx){
		this(node.test, ctx);
		this(node.body, ctx);
	},
	DoWhileStatement(node, ctx){
		this(node.test, ctx);
		this(node.body, ctx);
	},
	ForStatement(node, ctx){
		this(node.init, ctx);
		this(node.test, ctx);
		this(node.update, ctx);
		this(node.body, ctx);
	},
	ForInStatement(node, ctx){
		this(node.right, ctx);
		this(node.body, ctx);
	},
	ForOfStatement(node, ctx){
		this(node.right, ctx);
		this(node.body, ctx);
	},
	BreakStatement(node, ctx){},
	ContinueStatement(node, ctx){},
	LabeledStatement(node, ctx){
		this(node.body, ctx);
	},
	UpdateExpression(node, ctx){
		this(node.argument, ctx);
	},
	ArrayExpression(node, ctx){
		node.elements.map(v => this(v, ctx));
	},
	ObjectExpression(node, ctx){
		node.properties.forEach(v => this(v.value, ctx));
	},
	NewExpression(node, ctx){
		this(node.callee, ctx);
		collectArgs.call(this, node, ctx);
	},
	DebuggerStatement(node, ctx){},
	ThisExpression(node, ctx){},
	SequenceExpression(node, ctx){
		node.expressions.reduce((r, v) => this(v, ctx));
	},
	SwitchStatement(node, ctx){
		this(node.discriminant, ctx);
		for(let item of node.cases){
			if(item.test){
				this(item.test, ctx)
			}
			item.consequent.forEach(v => this(v, ctx));
		}
	},
	ThrowStatement(node, ctx){
		this(node.argument, ctx);
	},
	TryStatement(node, ctx){
		this(node.block, ctx);
		if(node.handler){
			this(node.handler, ctx);
		}
		if(node.finalizer){
			this(node.finalizer, ctx);
		}
	},
	CatchClause(node, ctx){
		this(node.body, ctx);
	},
	TemplateLiteral(node, ctx){
		node.expressions.map(v => this(v, ctx));
	},
	TemplateElement(node, ctx){},
	TaggedTemplateExpression(node, ctx){
		this(node.tag, ctx);
		node.quasi.expressions.map(v => this(v, ctx))
	}
}, {
	get(target, key, self){
		if(typeof key == 'symbol')return;
		switch(key){
			case 'inspect':
			case 'constructor':
				return;
		}
		if(key in target)return target[key];
		return node => console.log(key, JSON.stringify(node));
	}
});

class Context {
	constructor(){
		this.fnStack = [];
		this.nodeStack = [];
		this.id = 0;
	}
	getFn(){
		const stack = this.fnStack;
		return stack[stack.length-1];
	}
	pushFn(info){
		this.fnStack.push(info);
	}
	popFn(){
		this.fnStack.pop();
	}
	insertExpression(expression){
		if(expression.type == 'Identifier'){
			return expression.name;
		}
		const {blockStatementBody, expressionStatement} = this;
		const name = this.getName();
		blockStatementBody.splice(
			blockStatementBody.indexOf(expressionStatement),
			0,
			newNodeVariableDeclaration('const', [newNodeVariableDeclarator(name, expression)])
		);
		return name;
	}
	getName(){
		return '$await_' + this.id++;
	}
	isInAsyncFn(){
		return this.getFn().async;
	}
}

function walk(node, ctx){
	ctx.nodeStack.push(node);
	handler[node.type].call(walk, node, ctx, handler);
	ctx.nodeStack.pop();
	return node;
}

module.exports = node => walk(node, new Context());
