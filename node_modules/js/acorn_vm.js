'use strict';

const acorn = require('./acorn.js');
const jsx = require('./acorn-jsx');

function throwError(node){
	console.error(node);
	throw new Error(node);
}

function ReturnStatement(value){
	this.value = value;
}

function BreakStatement(label){
	this.label = label;
}

function ContinueStatement(label){
	this.label = label;
}

function YieldExpression(value){
	this.value = value;
}

function collectArgs(node, ctx){
	let args = [];
	for(let arg of node.arguments){
		let value = this(arg, ctx);
		if(arg.type == 'SpreadElement'){
			args.push(...value);
		}else{
			args.push(value);
		}
	}
	return args;
}

function initArgs(node, scope, args){
	for(let i=0, n=node.params.length; i<n; ++i){
		let param = node.params[i];
		if(param.type == 'RestElement'){
			scope[param.argument.name] = args.slice(i);
			break;
		}else{
			scope[param.name] = args[i];
		}
	}
	//scope['arguments'] = arguments;
}

function getProperty(node, ctx){
	return node.computed ? this(node.property, ctx) : node.property.name;
}

const handler = new Proxy({
	Program(node, ctx){
		ctx.pushScope(global);
		node.body.forEach(v => this(v, ctx));
		ctx.popScope();
	},
	Identifier(node, ctx){
		const scope = ctx.getScope();
		return scope[node.name];
	},
	FunctionDeclaration(node, ctx, handler){
		const defineScope = ctx.getScope();
		defineScope[node.id.name] = handler.FunctionExpression.call(this, node, ctx);
	},
	ArrowFunctionExpression(node, ctx, handler){
		return handler.FunctionExpression.call(this, node, ctx);
	},
	FunctionExpression(node, ctx){
		if(node.async){
			node.async = false;
			const factory = self(node, ctx);
			return function(...args){
				const generator = factory.apply(this, args);
				return new Promise((resolve, reject) => {
					void function exec(result){
						for(;;){
							const {done, value} = generator.next(result);
							if(done)return resolve(value);
							if(value instanceof Promise)return value.then(exec);
							result = value;
						}
					}();
				});
			}
		}
		const self = this;
		const defineScope = ctx.getScope();
		return function(...args){
			initArgs(node, ctx.pushScope(defineScope), args);
			if(node.expression){//arrow function
				try{
					return self(node.body, ctx);
				}finally{
					ctx.popScope();
				}
			}
			const prevThis = ctx.$this;
			ctx.$this = this;
			try{
				self(node.body, ctx);
			}catch(error){
				if(error instanceof ReturnStatement){
					return error.value;
				}
				throw error;
			}finally{
				ctx.$this = prevThis;
				ctx.popScope();
			}
		}
	},
	AwaitExpression(node, ctx){
		throw new YieldExpression(this(node.argument, ctx));
	},
	YieldExpression(node, ctx){
		console.log(node.delegate)
		throw new YieldExpression(this(node.argument, ctx));
	},
	BlockStatement(node, ctx){
		node.body.forEach(v => this(v, ctx));
	},
	ExpressionStatement(node, ctx){
		this(node.expression, ctx);
	},
	CallExpression(node, ctx){
		if(node.callee.type == 'MemberExpression'){
			const object = this(node.callee.object, ctx);
			const property = getProperty.call(this, node.callee, ctx);
			const args = collectArgs.call(this, node, ctx);
			return object[property](...args);
		}else{
			const callee = this(node.callee, ctx);
			const args = collectArgs.call(this, node, ctx);
			return callee(...args);
		}
		throwError(node);
	},
	SpreadElement(node, ctx){
		return this(node.argument, ctx);
	},
	MemberExpression(node, ctx){
		return this(node.object, ctx)[getProperty.call(this, node, ctx)];
	},
	EmptyStatement(node, ctx){
	},
	UnaryExpression(node, ctx){
		if(node.operator == 'delete' && node.argument.type == 'MemberExpression'){
			return delete this(node.argument.object, ctx)[getProperty.call(this, node.argument, ctx)];
		}
		const argument = this(node.argument, ctx);
		switch(node.operator){
			case '+': return +argument;
			case '-': return -argument;
			case '~': return ~argument;
			case '!': return !argument;
			case 'typeof': return typeof argument;
			case 'void': return void argument;
		}
		throwError(node);
	},
	BinaryExpression(node, ctx){
		const left = this(node.left, ctx);
		const right = this(node.right, ctx);
		switch(node.operator){
			case '+': return left + right;
			case '-': return left - right;
			case '*': return left * right;
			case '/': return left / right;
			case '%': return left % right;
			case '&': return left & right;
			case '|': return left | right;
			case '^': return left ^ right;
			case '<<': return left << right;
			case '>>': return left >> right;
			case '>>>': return left >>> right;
			case '==': return left == right;
			case '!=': return left != right;
			case '===': return left === right;
			case '!==': return left !== right;
			case '<': return left < right;
			case '>': return left > right;
			case '<=': return left <= right;
			case '>=': return left >= right;
			case 'in': return left in right;
			case 'instanceof': return left instanceof right;
		}
		console.error(node);
	},
	AssignmentExpression(node, ctx){
		let value = this(node.right, ctx);
		if(node.left.type == 'Identifier'){
			if(node.operator != '='){
				let left = this(node.left, ctx);
				switch(node.operator){
					case '+=': value += left; break;
					case '-=': value -= left; break;
					case '*=': value *= left; break;
					case '/=': value /= left; break;
					case '%=': value %= left; break;
					case '&=': value &= left; break;
					case '|=': value |= left; break;
					case '^=': value ^= left; break;
					case '<<=': value <<= left; break;
					case '>>=': value >>= left; break;
					case '>>>=': value >>>= left; break;
					default: throwError(node);
				}
			}
			ctx.setVar(node.left.name, value);
			return value;
		}else if(node.left.type == 'MemberExpression'){
			let object = this(node.left.object, ctx);
			let property = getProperty.call(this, node.left, ctx);
			switch(node.operator){
				case '=':	return object[property] = value;
				case '+=':	return object[property] += value;
				case '-=':	return object[property] -= value;
				case '*=':	return object[property] *= value;
				case '/=':	return object[property] /= value;
				case '%=':	return object[property] %= value;
				case '&=':	return object[property] &= value;
				case '|=': 	return object[property] |= value;
				case '^=':	return object[property] ^= value;
				case '<<=':	return object[property] <<= value;
				case '>>=':	return object[property] >>= value;
				case '>>>=':return object[property] >>>= value;
				default: throwError(node);
			}
		}
		throwError(node);
	},
	LogicalExpression(node, ctx){
		let left = this(node.left, ctx);
		switch(node.operator){
			case '&&': return left && this(node.right, ctx);
			case '||': return left || this(node.right, ctx);
		}
	},
	Literal(node, ctx){
		return node.value;
	},
	VariableDeclaration(node, ctx){
		node.declarations.forEach(v => this(v, ctx));
	},
	VariableDeclarator(node, ctx){
		const scope = ctx.getScope();
		scope[node.id.name] = node.init == null ? undefined : this(node.init, ctx);
	},
	ReturnStatement(node, ctx){
		throw new ReturnStatement(this(node.argument, ctx));
	},
	ConditionalExpression(node, ctx){
		return this(node.test, ctx) ? this(node.consequent, ctx) : this(node.alternate, ctx);
	},
	IfStatement(node, ctx){
		if(this(node.test, ctx)){
			this(node.consequent, ctx);
		}else if(node.alternate){
			this(node.alternate, ctx);
		}
	},
	WhileStatement(node, ctx){
		var label = ctx.label;
		while(this(node.test, ctx)){
			try{
				this(node.body, ctx);
			}catch(error){
				if(error instanceof BreakStatement){
					if(error.label == null || error.label == label){
						break;
					}
				}
				if(error instanceof ContinueStatement){
					if(error.label == null || error.label == label){
						continue;
					}
				}
				throw error;
			}
		}
	},
	DoWhileStatement(node, ctx){
		var label = ctx.label;
		do{
			try{
				this(node.body, ctx);
			}catch(error){
				if(error instanceof BreakStatement){
					if(error.label == null || error.label == label){
						break;
					}
				}
				if(error instanceof ContinueStatement){
					if(error.label == null || error.label == label){
						continue;
					}
				}
				throw error;
			}
		}while(this(node.test, ctx));
	},
	ForStatement(node, ctx){
		var label = ctx.label;
		for(this(node.init, ctx); this(node.test, ctx); this(node.update, ctx)){
			try{
				this(node.body, ctx);
			}catch(error){
				if(error instanceof BreakStatement){
					if(error.label == null || error.label == label){
						break;
					}
				}
				if(error instanceof ContinueStatement){
					if(error.label == null || error.label == label){
						continue;
					}
				}
				throw error;
			}
		}
	},
	ForInStatement(node, ctx){
		const scope = ctx.pushScope();
		try{
			for(let key in this(node.right, ctx)){
				node.left.declarations.forEach(v => scope[v.id.name] = key);
				try{
					this(node.body, ctx);
				}catch(error){
					if(error instanceof BreakStatement){
						if(error.label == null || error.label == label){
							break;
						}
					}
					if(error instanceof ContinueStatement){
						if(error.label == null || error.label == label){
							continue;
						}
					}
					throw error;
				}
			}
		}finally{
			ctx.popScope();
		}
	},
	ForOfStatement(node, ctx){
		const scope = ctx.pushScope();
		try{
			for(let key of this(node.right, ctx)){
				node.left.declarations.forEach(v => scope[v.id.name] = key);
				try{
					this(node.body, ctx);
				}catch(error){
					if(error instanceof BreakStatement){
						if(error.label == null || error.label == label){
							break;
						}
					}
					if(error instanceof ContinueStatement){
						if(error.label == null || error.label == label){
							continue;
						}
					}
					throw error;
				}
			}
		}finally{
			ctx.popScope();
		}
	},
	BreakStatement(node, ctx){
		throw new BreakStatement(node.label);
	},
	ContinueStatement(node, ctx){
		throw new ContinueStatement(node.label);
	},
	LabeledStatement(node, ctx){
		ctx.label = node.label.name;
		this(node.body, ctx);
	},
	UpdateExpression(node, ctx){
		var argument = node.argument;
		var oldValue, newValue;
		if(argument.type == 'Identifier'){
			oldValue = ctx.getScope()[argument.name];
			if(node.operator == '++'){
				newValue = oldValue + 1;
			}else if(node.operator == '--'){
				newValue = oldValue - 1;
			}else{
				throwError(node);
			}
			ctx.setVar(argument.name, newValue);
		}else if(argument.type == 'MemberExpression'){
			let object = this(argument.object, ctx);
			let property = getProperty.call(this, argument, ctx);
			oldValue = object[property];
			if(node.operator == '++'){
				newValue = oldValue + 1;
			}else if(node.operator == '--'){
				newValue = oldValue - 1;
			}else{
				throwError(node);
			}
			object[property] = newValue;
		}else{
			throwError(node);
		}
		return node.prefix ? newValue : oldValue;
	},
	ArrayExpression(node, ctx){
		return node.elements.map(v => this(v, ctx));
	},
	ObjectExpression(node, ctx){
		var self = this;
		var result = {};
		node.properties.forEach(function(propNode){
			let key;
			switch(propNode.key.type){
				case 'Identifier':
					key = propNode.key.name;
					break;
				case 'Literal':
					key = propNode.key.value;
					break;
				default: throw new Error(propNode);
			}
			const value = self(propNode.value, ctx);
			switch(propNode.kind){
				case 'init':
					result[key] = value;
					break;
				case 'get':
					Object.defineProperty(result, key, {get:value});
					break;
				case 'set':
					Object.defineProperty(result, key, {set:value});
					break;
				default: throw new Error(propNode);
			}
		})
		return result;
	},
	NewExpression(node, ctx){
		const klazz = this(node.callee, ctx);
		return new klazz(...collectArgs.call(this, node, ctx));
	},
	DebuggerStatement(node, ctx){
		debugger;
	},
	ThisExpression(node, ctx){
		return ctx.$this;
	},
	SequenceExpression(node, ctx){
		return node.expressions.reduce((r, v) => this(v, ctx));
	},
	SwitchStatement(node, ctx){
		let discriminant = this(node.discriminant, ctx);
		let matched = false;
		for(let item of node.cases){
			if(!matched){
				if(item.test && this(item.test, ctx) != discriminant){
					continue;
				}
				matched = true;
			}
			try{
				item.consequent.forEach(v => this(v, ctx));
			}catch(error){
				if(error instanceof BreakStatement){
					break;
				}
				throw error;
			}
		}
	},
	ThrowStatement(node, ctx){
		throw this(node.argument, ctx);
	},
	TryStatement(node, ctx){
		try{
			this(node.block, ctx);
		}catch(error){
			if(!node.handler)throw error;
			let scope = ctx.pushScope();
			scope[node.handler.param.name] = error;
			try{
				this(node.handler, ctx);
			}finally{
				ctx.popScope();
			}
		}finally{
			if(node.finalizer){
				this(node.finalizer, ctx);
			}
		}
	},
	CatchClause(node, ctx){
		this(node.body, ctx);
	},
	TemplateLiteral(node, ctx){
		return this(node.quasis[0], ctx) + node.expressions.map((v, i) => this(v, ctx) + this(node.quasis[i+1], ctx)).join('');
	},
	TemplateElement(node, ctx){
		return node.value.raw;
	},
	TaggedTemplateExpression(node, ctx){
		let mapFn = v => this(v, ctx);
		return this(node.tag, ctx).call(null, node.quasi.quasis.map(mapFn), ...node.quasi.expressions.map(mapFn));
	}
}, {
	get(target, key, self){
		if(typeof key == 'symbol')return;
		switch(key){
			case 'inspect':
			case 'constructor':
				return;
		}
		if(key in target)return target[key];
		return node => console.log(key, JSON.stringify(node));
	}
});

class Context {
	constructor(){
		this.scopeStack = [];
		this.fnStack = [];
	}
	get label(){
		let result = this._label;
		this._label = undefined;
		return result;
	}
	set label(value){
		this._label = value;
	}
	getScope(){
		const stack = this.scopeStack;
		return stack[stack.length-1];
	}
	pushScope(prevScope){
		const scope = Object.create(prevScope || this.getScope());
		this.scopeStack.push(scope);
		return scope;
	}
	popScope(){
		this.scopeStack.pop();
	}
	getFn(){
		const stack = this.fnStack;
		return stack[stack.length-1];
	}
	pushFn(info){
		this.fnStack.push(info);
	}
	popFn(){
		this.fnStack.pop();
	}
	setVar(name, value){
		let scope = this.getScope();
		while(scope){
			if(scope.hasOwnProperty(name)){
				scope[name] = value;
				break;
			}else{
				scope = Object.getPrototypeOf(scope);
			}
		}
	}
}

const walk = (node, ctx) => handler[node.type].call(walk, node, ctx, handler);

exports.exec = code => walk(acorn.Parser.extend(jsx()).parse(code), new Context());
