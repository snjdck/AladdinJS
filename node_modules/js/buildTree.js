'use strict';

const compose = require('utils/function/compose');
const NodeType = require('./NodeType');

function calcute(op, a, b){
	op.firstChild = a;
	if(b){
		if(a.nextSibling){
			throw new Error("a.nextSibling is not null!");
		}
		a.nextSibling = b;
	}
	return op;
}

function readValueList(nodeList, endNodeType, readHandler){
	if(nodeList.expect(endNodeType)){
		return null;
	}
	var firstNode = readHandler(nodeList);
	var currentNode = firstNode;
	while(!nodeList.expect(endNodeType)){
		nodeList.accept(NodeType.COMMA);
		currentNode.nextSibling = readHandler(nodeList);
		currentNode = currentNode.nextSibling;
	}
	return firstNode;
}

function readKeyValue(nodeList){
	var key = nodeList.accept(NodeType.STRING);
	nodeList.accept(NodeType.COLON);
	return calcute(new Node(NodeType.KEY_VALUE), key, this(nodeList));
}

const matchUnitary = opList => nextNode => function self(nodeList){
	if(nodeList.matchAny(opList)){
		return calcute(nodeList.next(), self.call(this, nodeList));
	}
	return nextNode.call(this, nodeList);
}

const matchLeft = opList => nextNode => function(nodeList){
	var a = nextNode.call(this, nodeList);
	while(nodeList.matchAny(opList)){
		a = calcute(nodeList.next(), a, nextNode.call(this, nodeList));
	}
	return a;
}

const matchRight = opList => nextNode => function self(nodeList){
	var a = nextNode.call(this, nodeList);
	if(nodeList.matchAny(opList)){
		return calcute(nodeList.next(), a, self.call(this, nodeList));
	}
	return a;
}

const matchNone = opList => nextNode => function(nodeList){
	if(nodeList.matchAny(opList)){
		return nodeList.next();
	}
	return nextNode.call(this, nodeList);
}

const matchQuote = opList => nextNode => function(nodeList){
	if(nodeList.matchAny(opList)){
		nodeList.next();
		let result = this.call(this, nodeList);
		nodeList.next();
		return result;
	}
	return nextNode.call(this, nodeList);
}

function createSuperFunc(...ruleList){
	const fn = compose(...ruleList.reverse())();
	return fn.bind(fn);
}

module.exports = createSuperFunc(
	matchNone([NodeType.NUM, NodeType.VAR_ID]),
	matchQuote([NodeType.PARENTHESES_LEFT]),
	matchUnitary([NodeType.OP_SUB, NodeType.OP_ADD, NodeType.OP_BIT_NOT, NodeType.OP_LOGIC_NOT]),
	matchRight([NodeType.OP_POW]),
	matchLeft([NodeType.OP_MUL, NodeType.OP_DIV, NodeType.OP_REMAIN]),
	matchLeft([NodeType.OP_SUB, NodeType.OP_ADD]),
	matchLeft([NodeType.OP_BIT_R_SHIFT, NodeType.OP_BIT_L_SHIFT]),
	matchLeft([NodeType.OP_GREATER, NodeType.OP_GREATER_EQUAL, NodeType.OP_LESS, NodeType.OP_LESS_EQUAL]),
	matchLeft([NodeType.OP_EQUAL, NodeType.OP_NOT_EQUAL]),
	matchLeft([NodeType.OP_BIT_AND]),
	matchLeft([NodeType.OP_BIT_XOR]),
	matchLeft([NodeType.OP_BIT_OR]),
	matchLeft([NodeType.OP_LOGIC_AND]),
	matchLeft([NodeType.OP_LOGIC_OR]),
	matchRight([NodeType.OP_CONDITION]),
	matchRight([NodeType.OP_ASSIGN]),
);
