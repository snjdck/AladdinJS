
const NodeType = require('./NodeType');

function calcute(op, a, b){
	op.firstChild = a;
	if(b){
		if(a.nextSibling){
			throw new Error("a.nextSibling is not null!");
		}
		a.nextSibling = b;
	}
	return op;
}

function readValueList(nodeList, endNodeType, readHandler){
	if(nodeList.expect(endNodeType)){
		return null;
	}
	var firstNode = readHandler(nodeList);
	var currentNode = firstNode;
	while(!nodeList.expect(endNodeType)){
		nodeList.accept(NodeType.COMMA);
		currentNode.nextSibling = readHandler(nodeList);
		currentNode = currentNode.nextSibling;
	}
	return firstNode;
}

function readKeyValue(nodeList){
	var key = nodeList.accept(NodeType.STRING);
	nodeList.accept(NodeType.COLON);
	return calcute(new Node(NodeType.KEY_VALUE), key, this(nodeList));
}

function matchUnitary(nodeList, nextNode, opList){
	if(nodeList.matchAny(opList)){
		return calcute(nodeList.next(), matchUnitary(nodeList, nextNode, opList));
	}
	return nextNode(nodeList);
}

function matchLeft(nodeList, nextNode, opList){
	var a = nextNode(nodeList);
	while(nodeList.matchAny(opList)){
		a = calcute(nodeList.next(), a, nextNode(nodeList));
	}
	return a;
}

function matchRight(nodeList, nextNode, opList){
	var a = nextNode(nodeList);
	if(nodeList.matchAny(opList)){
		return calcute(nodeList.next(), a, matchRight(nodeList, nextNode, opList));
	}
	return a;
}

function matchNone(nodeList, nextNode, opList){
	if(nodeList.matchAny(opList)){
		return nodeList.next();
	}
	return nextNode(nodeList);
}

function matchQuote(nodeList, nextNode, opList){
	if(nodeList.matchAny(opList)){
		nodeList.next();
		let result = this(nodeList);
		nodeList.next();
		return result;
	}
	return nextNode(nodeList);
}

function createSuperFunc(...ruleList){
	let self = v => func(v);
	let func = ruleList.reduce((fn, [matchFn, opList]) => nodeList => matchFn.call(self, nodeList, fn, opList), null);
	return func;
}

module.exports = createSuperFunc(
	[matchNone, [NodeType.NUM, NodeType.VAR_ID]],
	[matchQuote, [NodeType.PARENTHESES_LEFT]],
	[matchRight, [NodeType.OP_POW]],
	[matchUnitary, [NodeType.OP_SUB, NodeType.OP_ADD]],
	[matchLeft, [NodeType.OP_MUL, NodeType.OP_DIV]],
	[matchLeft, [NodeType.OP_SUB, NodeType.OP_ADD]],
	[matchLeft, [NodeType.OP_GREATER, NodeType.OP_GREATER_EQUAL, NodeType.OP_LESS, NodeType.OP_LESS_EQUAL]],
	[matchLeft, [NodeType.OP_EQUAL, NodeType.OP_NOT_EQUAL]],
	[matchRight, [NodeType.OP_ASSIGN]],
);
