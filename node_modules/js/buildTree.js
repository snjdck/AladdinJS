
const NodeType = require('./NodeType');

function calcute(op, a, b){
	op.firstChild = a;
	if(b){
		if(a.nextSibling){
			throw new Error("a.nextSibling is not null!");
		}
		a.nextSibling = b;
	}
	return op;
}

function readValueList(nodeList, endNodeType, readHandler){
	if(nodeList.expect(endNodeType)){
		return null;
	}
	var firstNode = readHandler(nodeList);
	var currentNode = firstNode;
	while(!nodeList.expect(endNodeType)){
		nodeList.accept(NodeType.COMMA);
		currentNode.nextSibling = readHandler(nodeList);
		currentNode = currentNode.nextSibling;
	}
	return firstNode;
}

function readKeyValue(nodeList){
	var key = nodeList.accept(NodeType.STRING);
	nodeList.accept(NodeType.COLON);
	return calcute(new Node(NodeType.KEY_VALUE), key, expression(nodeList));
}

function matchUnitary(nodeList, nextNode, opList){
	if(nodeList.matchAny(opList)){
		return calcute(nodeList.next(), matchUnitary(nodeList, nextNode, opList));
	}
	return nextNode(nodeList);
}

function matchLeft(nodeList, nextNode, opList){
	var a = nextNode(nodeList);
	while(nodeList.matchAny(opList)){
		a = calcute(nodeList.next(), a, nextNode(nodeList));
	}
	return a;
}

function matchRight(nodeList, nextNode, opList){
	var a = nextNode(nodeList);
	if(nodeList.matchAny(opList)){
		return calcute(nodeList.next(), a, matchRight(nodeList, nextNode, opList));
	}
	return a;
}

function val(nodeList){
	switch(nodeList.first().type){
		case NodeType.REG_ID:
		case NodeType.NUM:
			return nodeList.next();
		case NodeType.VAR_ID:
			var result = nodeList.next();
			nodeList.accept(NodeType.COLON);
			result.firstChild = readValueList(nodeList, NodeType.EOF, expression);
			return result;
		case NodeType.PARENTHESES_LEFT:
			nodeList.accept(NodeType.PARENTHESES_LEFT);
			var val = expression();
			nodeList.accept(NodeType.PARENTHESES_RIGHT);
			return val;
		default:
			throw new Error("error input!");
	}
}

const createSuperFunc = (fn, ruleList) => ruleList.reduce((fn, [matchFn, opList]) => nodeList => matchFn(nodeList, fn, opList), fn);

module.exports = function(nodeList){
	const expression = createSuperFunc(val, [
		[matchRight, [NodeType.OP_POW]],
		[matchUnitary, [NodeType.OP_SUB, NodeType.OP_ADD]],
		[matchLeft, [NodeType.OP_MUL, NodeType.OP_DIV]],
		[matchLeft, [NodeType.OP_SUB, NodeType.OP_ADD]],
		[matchLeft, [NodeType.OP_GREATER, NodeType.OP_GREATER_EQUAL, NodeType.OP_LESS, NodeType.OP_LESS_EQUAL]],
		[matchLeft, [NodeType.OP_EQUAL, NodeType.OP_NOT_EQUAL]],
		[matchRight, [NodeType.OP_ASSIGN]],
	]);
	return expression(nodeList);
}
