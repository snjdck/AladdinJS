'use strict';

const acorn = require('./acorn.js');
const jsx = require('./acorn-jsx');

function replaceBreakContinue(codeList, totalCodeLength){
	for(let i=0, n=codeList.length; i<n; ++i){
		switch(codeList[i][0]){
			case "break":
				codeList[i] = ['jump', totalCodeLength - i];
				break;
			case "continue":
				codeList[i] = ['jump', n - i];
				break;
		}
	}
}

function genForCode(initCode, conditionCode, iterCode, loopCode, finalCode){
	const result = [...initCode];
	const loopCount = loopCode.length + iterCode.length;
	const totalCount = loopCount + conditionCode.length;
	if(false){
		replaceBreakContinue(loopCode, loopCount + 1);
		result.push(...conditionCode);
		result.push(['jumpIf', loopCount + 2]);
		result.push(...loopCode);
		result.push(...iterCode);
		result.push(['jump', -(totalCount + 1)]);
	}else{
		replaceBreakContinue(loopCode, totalCount + 1);
		result.push(['jump', loopCount + 1]);
		result.push(...loopCode);
		result.push(...iterCode);
		result.push(...conditionCode);
		result.push(['jumpIf', -totalCount]);
	}
	if(finalCode)result.push(...finalCode);
	return result;
}

function genForInOfCode(node, key){
	return genForCode([
		...this(node.right),
		['get', 'Object'],
		['push', key],
		...invokeCall('__asm__getKey', 2, 1),
		['invoke', 1, 1],
	], [
		...invokeCall('__asm__duplicate', 1, 2),
		['push', 'length'],
		...invokeCall('__asm__getKey', 2, 1),
		['push', 0],
		...invokeCall('>', 2, 1),
	], [], [
		...invokeCall('__asm__duplicate', 1, 2),
		['push', 'shift'],
		...invokeCall('__asm__getKey', 2, 1),
		['invoke', 0, 1],
		['set', node.left.declarations[0].id.name],
		...this(node.body),
	], [
		pop(),
	]);
}

//need solve call order problem, a.b(c,d,e) calc order should be [a,b,c,d,e],but now is [c,d,e,a,b]!
const invokeCall = (name, argCount, retCount) => [['get', name], ['invoke', argCount, retCount]];
const pop = () => ['jumpIf', 1];

function collectArgs(node, ctx){
	let args = [];
	for(let arg of node.arguments){
		let value = this(arg, ctx);
		if(arg.type == 'SpreadElement'){//bug fix need
			args.push(...value);
		}else{
			args.push(...value);
		}
	}
	return args;
}

function initArgs(node, scope, args){
	for(let i=0, n=node.params.length; i<n; ++i){
		let param = node.params[i];
		if(param.type == 'RestElement'){
			scope[param.argument.name] = args.slice(i);
			break;
		}else{
			scope[param.name] = args[i];
		}
	}
	//scope['arguments'] = arguments;
}

const createAsyncFn = factory => function(...args){
	const generator = factory.apply(this, args);
	return generator
	return new Promise((resolve, reject) => {
		void function exec(result){
			for(;;){
				const {done, value} = generator.next(result);
				if(done)return resolve(value);
				if(value instanceof Promise)return value.then(exec);
				result = value;
			}
		}();
	});
}

function createFunctionExpression(node, ctx, async, generator){
	const result = this(node.body, ctx);
	return [
		['function', result.length + 2, node.params],
		...result,
		['return', node.expression ? 1 : 0]
	];
}

function getProperty(node, ctx){
	if(node.computed){
		return this(node.property, ctx);
	}
	return [['push', node.property.name]];
}

const handler = {
	Program(node, ctx){
		return concat(node.body);
	},
	Identifier(node, ctx){
		return [['get', node.name]];
	},
	FunctionDeclaration(node, ctx, handler){
		const result = handler.FunctionExpression.call(this, node, ctx);
		return [
			...result,
			['set', node.id.name]
		];
	},
	ArrowFunctionExpression(node, ctx, handler){
		return handler.FunctionExpression.call(this, node, ctx);
	},
	FunctionExpression(node, ctx){
		/*if(node.async && !node.generator){
			return createAsyncFn(createFunctionExpression.call(this, node, ctx, false, true));
		}*/
		return createFunctionExpression.call(this, node, ctx);
	},
	AwaitExpression(node, ctx){
		//throw new YieldExpression(this(node.argument, ctx));
	},
	YieldExpression(node, ctx){
		return [
			...this(node.argument, ctx),
			['yield', 1]
		];
	},
	BlockStatement(node, ctx){
		return concat(node.body);
	},
	ExpressionStatement(node, ctx){
		return this(node.expression, ctx);
	},
	CallExpression(node, ctx){
		if(node.callee.type == 'MemberExpression'){
			return [
				...this(node.callee.object, ctx),
				...getProperty.call(this, node.callee, ctx),
				['get', '__asm__getKey'],
				['invoke', 2, 1],
				...collectArgs.call(this, node, ctx),
				['invoke', 0, 0],//need fix bug
			];
		}else{
			return [
				...this(node.callee, ctx),
				...collectArgs.call(this, node, ctx),
				['invoke', 0, 0],//need fix bug
			];
		}
		throwError(node);
	},
	SpreadElement(node, ctx){
		return genForCode([
			...this(node.argument),
			['get', 'Object'],
			['push', 'values'],
			...invokeCall('__asm__getKey', 2, 1),
			['invoke', 1, 1],
		], [
			...invokeCall('__asm__duplicate', 1, 2),
			['push', 'length'],
			...invokeCall('__asm__getKey', 2, 1),
			['push', 0],
			...invokeCall('>', 2, 1),
		], [], [
			...invokeCall('__asm__duplicate', 1, 2),
			['push', 'shift'],
			...invokeCall('__asm__getKey', 2, 1),
			['invoke', 0, 1],
			...invokeCall('__asm__swap', 2, 2),
		], [
			pop(),
		]);
	},
	MemberExpression(node, ctx){
		return [
			...this(node.object, ctx),
			...getProperty.call(this, node, ctx),
			...invokeCall('__asm__getKey', 2, 1),
		];
	},
	EmptyStatement(node, ctx){
		return [];
	},
	UnaryExpression(node, ctx){
		if(node.operator == 'delete' && node.argument.type == 'MemberExpression'){
			return [
				...this(node.argument.object, ctx),
				...getProperty.call(this, node.argument, ctx),
				...invokeCall(node.operator, 2, 1),
			];
		}
		return [
			...this(node.argument, ctx),
			...invokeCall(node.operator, 1, 1),
		];
	},
	BinaryExpression(node, ctx){
		return [
			...this(node.left, ctx),
			...this(node.right, ctx),
			...invokeCall(node.operator, 2, 1),
		];
	},
	AssignmentExpression(node, ctx){
		let value = this(node.right, ctx);
		return [
			...value,
			['set', node.left.name]
		];
		if(node.left.type == 'Identifier'){
			if(node.operator != '='){
				let left = this(node.left, ctx);
				switch(node.operator){
					case '+=': value += left; break;
					case '-=': value -= left; break;
					case '*=': value *= left; break;
					case '/=': value /= left; break;
					case '%=': value %= left; break;
					case '&=': value &= left; break;
					case '|=': value |= left; break;
					case '^=': value ^= left; break;
					case '<<=': value <<= left; break;
					case '>>=': value >>= left; break;
					case '>>>=': value >>>= left; break;
					default: throwError(node);
				}
			}
			ctx.setVar(node.left.name, value);
			return value;
		}else if(node.left.type == 'MemberExpression'){
			let object = this(node.left.object, ctx);
			let property = getProperty.call(this, node.left, ctx);
			switch(node.operator){
				case '=':	return object[property] = value;
				case '+=':	return object[property] += value;
				case '-=':	return object[property] -= value;
				case '*=':	return object[property] *= value;
				case '/=':	return object[property] /= value;
				case '%=':	return object[property] %= value;
				case '&=':	return object[property] &= value;
				case '|=': 	return object[property] |= value;
				case '^=':	return object[property] ^= value;
				case '<<=':	return object[property] <<= value;
				case '>>=':	return object[property] >>= value;
				case '>>>=':return object[property] >>>= value;
				default: throwError(node);
			}
		}
		throwError(node);
	},
	LogicalExpression(node, ctx){
		const caseRight = this(node.right, ctx);
		if(node.operator == '&&'){
			return [
				...this(node.left, ctx),
				...invokeCall('__asm__duplicate', 1, 2),
				['jumpIf', 2], ['jump', caseRight.length + 2],//jump if false
				pop(),
				...caseRight
			];
		}
		if(node.operator == '||'){
			return [
				...this(node.left, ctx),
				...invokeCall('__asm__duplicate', 1, 2),
				['jumpIf', caseRight.length + 2],
				pop(),
				...caseRight
			];
		}
	},
	Literal(node, ctx){
		return [['push', node.value]];
	},
	VariableDeclaration(node, ctx){
		return concat(node.declarations);
	},
	VariableDeclarator(node, ctx){
		const result = [];
		if(node.init){
			result.push(...this(node.init, ctx));
		}else{
			result.push(['push', undefined]);
		}
		result.push(['set', node.id.name]);
		return result;
	},
	ReturnStatement(node, ctx){
		return [
			...this(node.argument, ctx),
			['return', 1]
		];
	},
	ConditionalExpression(node, ctx, handler){
		return handler.IfStatement.call(this, node, ctx);
	},
	IfStatement(node, ctx){
		const caseTrue = this(node.consequent, ctx);
		const caseFalse = node.alternate ? this(node.alternate, ctx) : [];
		return [
			...this(node.test, ctx),
			['jumpIf', caseFalse.length + 2],
			...caseFalse
			['jump', caseTrue.length + 1],
			...caseTrue,
		];
	},
	WhileStatement(node, ctx){
		const loopCode = this(node.body, ctx);
		const conditionCode = this(node.test, ctx);
		const loopCount = loopCode.length;
		const totalCount = loopCount + conditionCode.length;
		replaceBreakContinue(loopCode, totalCount + 1);
		return [
			['jump', loopCount + 1],
			...loopCode,
			...conditionCode,
			['jumpIf', -totalCount],
		];
	},
	DoWhileStatement(node, ctx){
		const loopCode = this(node.body, ctx);
		const conditionCode = this(node.test, ctx);
		const totalCount = loopCode.length + conditionCode.length;
		replaceBreakContinue(loopCode, totalCount + 1);
		return [
			...loopCode,
			...conditionCode,
			['jumpIf', -totalCount],
		];
	},
	ForStatement(node){
		return genForCode(
			this(node.init),
			this(node.test),
			node.update ? this(node.update) : [],
			this(node.body)
		);
	},
	ForInStatement(node, ctx){
		return genForInOfCode(node, 'keys');
	},
	ForOfStatement(node, ctx){
		return genForInOfCode(node, 'values');
	},
	BreakStatement(node, ctx){
		return [['break']];
	},
	ContinueStatement(node, ctx){
		return [['continue']];
	},
	LabeledStatement(node, ctx){
		return this(node.body, ctx);
	},
	UpdateExpression(node, ctx){
		const argument = node.argument;
		if(argument.type == 'Identifier'){
			if(node.prefix){
				return [
					...this(argument, ctx),
					...invokeCall(node.operator, 1, 1),
					...invokeCall('__asm__duplicate', 1, 2),
					['set', argument.name],
				];
			}else{
				return [
					...this(argument, ctx),
					...invokeCall('__asm__duplicate', 1, 2),
					...invokeCall(node.operator, 1, 1),
					['set', argument.name],
				];
			}
		}
		if(argument.type == 'MemberExpression'){
			if(node.prefix){
				return [
					...this(argument.object, ctx),
					...getProperty.call(this, argument, ctx),
					...this(argument, ctx),
					...invokeCall(node.operator, 1, 1),
					...invokeCall('__asm__setKey', 3, 1),
				];
			}
		}
		console.error(node);
	},
	ArrayExpression(node, ctx){
		const result = invokeCall('__asm__newArray', 0, 1);
		node.elements.forEach((v, i) => {
			result.push(['push', i], ...this(v, ctx), ...invokeCall('__asm__setKey', 3, 1));
		});
		return result;
	},
	ObjectExpression(node, ctx){
		const result = invokeCall('__asm__newObject', 0, 1);
		for(const propNode of node.properties){
			let key;
			switch(propNode.key.type){
				case 'Identifier':
					key = propNode.key.name;
					break;
				case 'Literal':
					key = propNode.key.value;
					break;
				default: throw new Error(propNode);
			}
			const value = this(propNode.value, ctx);
			switch(propNode.kind){
				case 'init':
					result.push(['push', key], ...value, ...invokeCall('__asm__setKey', 3, 1));
					break;
				default: throw new Error(propNode);
			}
		}
		return result;
	},
	NewExpression(node, ctx){
		const klazz = this(node.callee, ctx);
		return new klazz(...collectArgs.call(this, node, ctx));
	},
	DebuggerStatement(node, ctx){
		return [];
	},
	ThisExpression(node, ctx){
		return [['get', 'this']];
	},
	SequenceExpression(node, ctx){
		const expressions = node.expressions.slice();
		const element = expressions.pop();
		return [
			...concat(expressions),
			...invokeCall('__asm__pop', expressions.length, 0),
			...this(element, ctx),
		];
	},
	SwitchStatement(node, ctx){
		const offsetList = [];
		const testList = [];
		const codeList = [];
		for(const {consequent} of node.cases){
			offsetList.push(codeList.length);
			codeList.push(...concat(consequent));
		}
		for(const {test} of node.cases.reverse()){
			const position = testList.length + offsetList.pop() + 2;
			if(!test){
				testList.unshift(['jump', position]);
				continue;
			}
			testList.unshift(
				...invokeCall('__asm__duplicate', 1, 2),
				...this(test, ctx),
				...invokeCall('__asm__isEqual', 2, 1),
				['jumpIf', position],
			);
		}
		for(let i=0, n=codeList.length; i<n; ++i){
			if(codeList[i][0] != 'break')continue;
			codeList[i] = ['jump', n - i];
		}
		return [
			...this(node.discriminant, ctx),
			...testList,
			['jump', codeList.length + 1],
			...codeList,
			pop(),
		];
	},
	ThrowStatement(node, ctx){
		return [];
	},
	TryStatement(node, ctx){
		return this(node.block, ctx);
	},
	CatchClause(node, ctx){
		return this(node.body, ctx);
	},
	TemplateLiteral(node, ctx){
		const {expressions} = node;
		const result = this(node.quasis[0], ctx);
		for(let i=0, n=expressions.length; i<n; ++i){
			result.push(
				...this(expressions[i], ctx),
				...invokeCall('+', 2, 1),
				...this(node.quasis[i+1], ctx),
				...invokeCall('+', 2, 1),
			);
		}
		return result;
	},
	TemplateElement(node, ctx){
		return [['push', node.value.raw]];
	},
	TaggedTemplateExpression(node, ctx){
		return [[]];
	}
};

const concat = (fn => list => list.map(walk).reduce(fn))((a, b) => a.concat(b));
const walk = node => handler[node.type].call(walk, node, null, handler);
const exec = code => walk(acorn.Parser.extend(jsx()).parse(code));
//yieldFlag', 'yieldOneTickFlag', 'suspendFlag
let ttt = exec(`
function test(yieldFlag, yieldOneTickFlag, suspendFlag){
return $ => {
let fn = {}
return {*["0!R#c$3[eLos8B%+Mo*Z"](){
	for(let i=10;i>0;--i){
		yield yieldFlag
		yield $.weeemake_buzzer({NOTE:262,BEAT:500})
		for(let end=performance.now()+1000*(1);performance.now()<end;)yield yieldOneTickFlag;
	}
}}
}}
	`)

//console.log(ttt.map(JSON.stringify).join('\n'))

console.log(exec(`
	/*
switch(100){
	case 5:
		print(5)
		break
	default:
		print(6)
}

for(let i=10;i>0;--i){
	print('hello')
}
*/
print(\`abc\${52}dd\`, [1,2,3])
`).map(JSON.stringify).join('\n'))
