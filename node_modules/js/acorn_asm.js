'use strict';

const acorn = require('./acorn.js');
const jsx = require('./acorn-jsx');

function replaceBreakContinue(codeList, totalCodeLength){
	for(let i=0, n=codeList.length; i<n; ++i){
		switch(codeList[i][0]){
			case "break":
				codeList[i] = ['jump', totalCodeLength - i];
				break;
			case "continue":
				codeList[i] = ['jump', n - i];
				break;
		}
	}
}

function genForCode(initCode, conditionCode, iterCode, loopCode, finalCode){
	const result = [...initCode];
	const loopCount = loopCode.length + iterCode.length;
	const totalCount = loopCount + conditionCode.length;
	if(false){
		replaceBreakContinue(loopCode, loopCount + 1);
		result.push(...conditionCode);
		result.push(['jumpIf', loopCount + 2]);
		result.push(...loopCode);
		result.push(...iterCode);
		result.push(['jump', -(totalCount + 1)]);
	}else{
		replaceBreakContinue(loopCode, totalCount + 1);
		result.push(['jump', loopCount + 1]);
		result.push(...loopCode);
		result.push(...iterCode);
		result.push(...conditionCode);
		result.push(['jumpIf', -totalCount]);
	}
	if(finalCode)result.push(...finalCode);
	return result;
}

function genIterCode(key, target, body){
	return genForCode([
		['get', 'Object'],
		['push', key],
		...target,
		['call', 1],
	], [
		['duplicate'],
		['get', '__asm__getKey'],
		['swap'],
		['push', 'length'],
		['invoke', 2],
		['push', 0],
		['>'],
	], [], [
		['duplicate'],
		['push', 'shift'],
		['call', 0],
		...body,
	], [
		['pop'],
	]);
}

function genForInOfCode(node, key){
	return genIterCode(key, walk(node.right), [
		['set', node.left.declarations[0].id.name],
		...walk(node.body),
	]);
}

//need solve call order problem, a.b(c,d,e) calc order should be [a,b,c,d,e],but now is [c,d,e,a,b]!

function initArgs(node, scope, args){
	for(let i=0, n=node.params.length; i<n; ++i){
		let param = node.params[i];
		if(param.type == 'RestElement'){
			scope[param.argument.name] = args.slice(i);
			break;
		}else{
			scope[param.name] = args[i];
		}
	}
	//scope['arguments'] = arguments;
}

const createAsyncFn = factory => function(...args){
	const generator = factory.apply(this, args);
	return generator
	return new Promise((resolve, reject) => {
		void function exec(result){
			for(;;){
				const {done, value} = generator.next(result);
				if(done)return resolve(value);
				if(value instanceof Promise)return value.then(exec);
				result = value;
			}
		}();
	});
}

function createFunctionExpression(node, async, generator){
	const result = walk(node.body);
	return [
		['function', result.length + 2, node.params.map(v => v.name), []],
		...result,
		['return', node.expression ? 1 : 0]
	];
}

const getProperty = node => node.computed ? walk(node.property) : [['push', node.property.name]];

const handler = {
	Program(node, ctx){
		console.log(JSON.stringify(node.body));
		return concat(node.body);
	},
	Identifier(node, ctx){
		return [['get', node.name]];
	},
	FunctionDeclaration(node, ctx, handler){
		return [
			...createFunctionExpression(node),
			['set', node.id.name]
		];
	},
	ArrowFunctionExpression(node, ctx, handler){
		return createFunctionExpression(node);
	},
	FunctionExpression(node, ctx){
		/*if(node.async && !node.generator){
			return createAsyncFn(createFunctionExpression.call(this, node, ctx, false, true));
		}*/
		return createFunctionExpression(node);
	},
	AwaitExpression(node, ctx){
		//throw new YieldExpression(this(node.argument, ctx));
	},
	YieldExpression(node, ctx){
		return [
			...this(node.argument, ctx),
			['yield', 1]
		];
	},
	BlockStatement(node, ctx){
		return concat(node.body);
	},
	ExpressionStatement(node, ctx){
		return [
			...this(node.expression),
			['pop'],
		];
	},
	CallExpression(node, ctx){
		if(node.callee.type == 'MemberExpression'){
			return [
				...this(node.callee.object, ctx),
				...getProperty.call(this, node.callee, ctx),
				...concat(node.arguments),
				['call', node.arguments.length],
			];
		}else{
			return [
				...this(node.callee, ctx),
				...concat(node.arguments),
				['invoke', node.arguments.length],
			];
		}
		throwError(node);
	},
	SpreadElement(node, ctx){
		return genIterCode('values', this(node.argument), [['swap']]);
	},
	MemberExpression(node, ctx){
		return [
			['get', '__asm__getKey'],
			...this(node.object, ctx),
			...getProperty.call(this, node, ctx),
			['invoke', 2],
		];
	},
	EmptyStatement(node, ctx){
		return [];
	},
	UnaryExpression(node, ctx){
		if(node.operator == 'delete' && node.argument.type == 'MemberExpression'){
			return [
				...this(node.argument.object, ctx),
				...getProperty.call(this, node.argument, ctx),
				[node.operator],
			];
		}
		let operator = node.operator;
		switch(operator){
			case '+': case '-': case 'delete':
				operator += '1';
		}
		return [
			...this(node.argument, ctx),
			[operator],
		];
	},
	BinaryExpression(node, ctx){
		return [
			...this(node.left, ctx),
			...this(node.right, ctx),
			[node.operator],
		];
	},
	AssignmentExpression(node, ctx){
		if(node.left.type == 'MemberExpression'){
			return [
				...this(node.left.object),
				...getProperty.call(this, node.left),
				...this(node.right),
				[node.operator],
			];
		}
		if(node.left.type == 'Identifier'){
			if(node.operator == '='){
				return [
					...this(node.right),
					['duplicate'],
					['set', node.left.name],
				];
			}else{
				return [
					...this(node.left),
					...this(node.right),
					[node.operator.slice(0, -1)],
					['duplicate'],
					['set', node.left.name],
				];
			}
		}
	},
	LogicalExpression(node, ctx){
		const caseRight = this(node.right, ctx);
		if(node.operator == '&&'){
			return [
				...this(node.left, ctx),
				['duplicate'],
				['jumpIf', 2], ['jump', caseRight.length + 2],//jump if false
				['pop'],
				...caseRight
			];
		}
		if(node.operator == '||'){
			return [
				...this(node.left, ctx),
				['duplicate'],
				['jumpIf', caseRight.length + 2],
				['pop'],
				...caseRight
			];
		}
	},
	Literal(node, ctx){
		return [['push', node.value]];
	},
	VariableDeclaration(node, ctx){
		return concat(node.declarations);
	},
	VariableDeclarator(node, ctx){
		const result = [];
		if(node.init){
			result.push(...this(node.init, ctx));
		}else{
			result.push(['push']);
		}
		result.push(['set', node.id.name]);
		return result;
	},
	ReturnStatement(node, ctx){
		return [
			...this(node.argument, ctx),
			['return', 1]
		];
	},
	ConditionalExpression(node, ctx, handler){
		return handler.IfStatement.call(this, node, ctx);
	},
	IfStatement(node, ctx){
		const caseTrue = this(node.consequent, ctx);
		const caseFalse = node.alternate ? this(node.alternate, ctx) : [];
		return [
			...this(node.test, ctx),
			['jumpIf', caseFalse.length + 2],
			...caseFalse,
			['jump', caseTrue.length + 1],
			...caseTrue,
		];
	},
	WhileStatement(node, ctx){
		const loopCode = this(node.body, ctx);
		const conditionCode = this(node.test, ctx);
		const loopCount = loopCode.length;
		const totalCount = loopCount + conditionCode.length;
		replaceBreakContinue(loopCode, totalCount + 1);
		return [
			['jump', loopCount + 1],
			...loopCode,
			...conditionCode,
			['jumpIf', -totalCount],
		];
	},
	DoWhileStatement(node, ctx){
		const loopCode = this(node.body, ctx);
		const conditionCode = this(node.test, ctx);
		const totalCount = loopCode.length + conditionCode.length;
		replaceBreakContinue(loopCode, totalCount + 1);
		return [
			...loopCode,
			...conditionCode,
			['jumpIf', -totalCount],
		];
	},
	ForStatement(node){
		return genForCode(
			node.init ? this(node.init) : [],
			node.test ? this(node.test) : [['push', true]],
			node.update ? [...this(node.update), ['pop']] : [],
			this(node.body)
		);
	},
	ForInStatement(node, ctx){
		return genForInOfCode(node, 'keys');
	},
	ForOfStatement(node, ctx){
		return genForInOfCode(node, 'values');
	},
	BreakStatement(node, ctx){
		return [['break']];
	},
	ContinueStatement(node, ctx){
		return [['continue']];
	},
	LabeledStatement(node, ctx){
		return this(node.body, ctx);
	},
	UpdateExpression(node, ctx){
		const argument = node.argument;
		if(argument.type == 'Identifier'){
			if(node.prefix){
				return [
					...this(argument, ctx),
					[node.operator],
					['duplicate'],
					['set', argument.name],
				];
			}else{
				return [
					...this(argument, ctx),
					['duplicate'],
					[node.operator],
					['set', argument.name],
				];
			}
		}
		if(argument.type == 'MemberExpression'){
			const result = [
				...this(argument.object, ctx),
				...getProperty.call(this, argument, ctx),
				['push', 1],
				[node.operator.slice(-1) + '='],
			];
			if(!node.prefix){
				result.push([node.operator == '++' ? '--' : '++']);
			}
			return result;
		}
		console.error(node);
	},
	ArrayExpression(node, ctx){
		return [
			['get', '__asm__newArray'],
			...concat(node.elements),
			['invoke', node.elements.length],
		];
	},
	ObjectExpression(node, ctx){
		const result = [
			['get', '__asm__newObject'],
			['invoke', 0],
		];
		for(const propNode of node.properties){
			let key;
			switch(propNode.key.type){
				case 'Identifier':
					key = propNode.key.name;
					break;
				case 'Literal':
					key = propNode.key.value;
					break;
				default: throw new Error(propNode);
			}
			const value = this(propNode.value, ctx);
			switch(propNode.kind){
				case 'init':
					result.push(
						['get', '__asm__setKey'],
						['swap'],
						['push', key], ...value,
						['invoke', 3]
					);
					break;
				default: throw new Error(propNode);
			}
		}
		return result;
	},
	NewExpression(node, ctx){
		const klazz = this(node.callee, ctx);
		return new klazz(...collectArgs.call(this, node, ctx));
	},
	DebuggerStatement(node, ctx){
		return [];
	},
	ThisExpression(node, ctx){
		return [['get', 'this']];
	},
	SequenceExpression(node, ctx){
		const expressions = node.expressions;
		const result = this(expressions[0]);
		for(let i=1, n=expressions.length; i<n; ++i){
			result.push(['pop'], ...this(expressions[i]));
		}
		return result;
	},
	SwitchStatement(node, ctx){
		const offsetList = [];
		const testList = [];
		const codeList = [];
		for(const {consequent} of node.cases){
			offsetList.push(codeList.length);
			codeList.push(...concat(consequent));
		}
		for(const {test} of node.cases.reverse()){
			const position = testList.length + offsetList.pop() + 2;
			if(!test){
				testList.unshift(['jump', position]);
				continue;
			}
			testList.unshift(
				['duplicate'],
				...this(test, ctx),
				['==='],
				['jumpIf', position],
			);
		}
		for(let i=0, n=codeList.length; i<n; ++i){
			if(codeList[i][0] != 'break')continue;
			codeList[i] = ['jump', n - i];
		}
		return [
			...this(node.discriminant, ctx),
			...testList,
			['jump', codeList.length + 1],
			...codeList,
			['pop'],
		];
	},
	ThrowStatement(node, ctx){
		return [];
	},
	TryStatement(node, ctx){
		return this(node.block, ctx);
	},
	CatchClause(node, ctx){
		return this(node.body, ctx);
	},
	TemplateLiteral(node, ctx){
		const {expressions} = node;
		const result = this(node.quasis[0], ctx);
		for(let i=0, n=expressions.length; i<n; ++i){
			result.push(
				...this(expressions[i], ctx),
				['+'],
				...this(node.quasis[i+1], ctx),
				['+'],
			);
		}
		return result;
	},
	TemplateElement(node, ctx){
		return [['push', node.value.raw]];
	},
	TaggedTemplateExpression(node, ctx){
		return [[]];
	}
};

const concat = (fn => list => list.map(walk).reduce(fn, []))((a, b) => a.concat(b));
const walk = node => handler[node.type].call(walk, node, null, handler);
const exec = code => walk(acorn.Parser.extend(jsx()).parse(code));
//yieldFlag', 'yieldOneTickFlag', 'suspendFlag
module.exports = exec;
