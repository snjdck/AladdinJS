'use strict';

const acorn = require('./acorn.js');
const jsx = require('./acorn-jsx');

function replaceBreakContinue(codeList, totalCodeLength){
	for(let i=0, n=codeList.length; i<n; ++i){
		switch(codeList[i][0]){
			case "break":
				codeList[i] = ['jump', totalCodeLength - i];
				break;
			case "continue":
				codeList[i] = ['jump', n - i];
				break;
		}
	}
}

//need solve call order problem, a.b(c,d,e) calc order should be [a,b,c,d,e],but now is [c,d,e,a,b]!
const invokeCall = (name, argCount, retCount) => [['get', name], ['invoke', argCount, retCount]];
const pop = () => ['jumpIf', 1];
const concat = v => v.reduce((a, b) => a.concat(b));

function collectArgs(node, ctx){
	let args = [];
	for(let arg of node.arguments){
		let value = this(arg, ctx);
		if(arg.type == 'SpreadElement'){//bug fix need
			args.push(...value);
		}else{
			args.push(...value);
		}
	}
	return args;
}

function initArgs(node, scope, args){
	for(let i=0, n=node.params.length; i<n; ++i){
		let param = node.params[i];
		if(param.type == 'RestElement'){
			scope[param.argument.name] = args.slice(i);
			break;
		}else{
			scope[param.name] = args[i];
		}
	}
	//scope['arguments'] = arguments;
}

const createAsyncFn = factory => function(...args){
	const generator = factory.apply(this, args);
	return generator
	return new Promise((resolve, reject) => {
		void function exec(result){
			for(;;){
				const {done, value} = generator.next(result);
				if(done)return resolve(value);
				if(value instanceof Promise)return value.then(exec);
				result = value;
			}
		}();
	});
}

function createFunctionExpression(node, ctx, async, generator){
	const result = this(node.body, ctx);
	return [
		['function', result.length + 2, node.params],
		...result,
		['return', node.expression ? 1 : 0]
	];
}

function getProperty(node, ctx){
	if(node.computed){
		return this(node.property, ctx);
	}
	return [['push', node.property.name]];
}

const handler = {
	Program(node, ctx){
		return concat(node.body.map(v => this(v, ctx)));
	},
	Identifier(node, ctx){
		return [['get', node.name]];
	},
	FunctionDeclaration(node, ctx, handler){
		const result = handler.FunctionExpression.call(this, node, ctx);
		return [
			...result,
			['set', node.id.name]
		];
	},
	ArrowFunctionExpression(node, ctx, handler){
		return handler.FunctionExpression.call(this, node, ctx);
	},
	FunctionExpression(node, ctx){
		/*if(node.async && !node.generator){
			return createAsyncFn(createFunctionExpression.call(this, node, ctx, false, true));
		}*/
		return createFunctionExpression.call(this, node, ctx);
	},
	AwaitExpression(node, ctx){
		//throw new YieldExpression(this(node.argument, ctx));
	},
	YieldExpression(node, ctx){
		return [
			...this(node.argument, ctx),
			['yield', 1]
		];
	},
	BlockStatement(node, ctx){
		return concat(node.body.map(v => this(v, ctx)));
	},
	ExpressionStatement(node, ctx){
		console.log('enter expression');
		return this(node.expression, ctx);
	},
	CallExpression(node, ctx){
		if(node.callee.type == 'MemberExpression'){
			return [
				...this(node.callee.object, ctx),
				...getProperty.call(this, node.callee, ctx),
				['get', '__asm__getKey'],
				['invoke', 2, 1],
				...collectArgs.call(this, node, ctx),
				['invoke', 0, 0],//need fix bug
			];
		}else{
			return [
				...this(node.callee, ctx),
				...collectArgs.call(this, node, ctx),
				['invoke', 0, 0],//need fix bug
			];
		}
		throwError(node);
	},
	SpreadElement(node, ctx){
		return this(node.argument, ctx);
	},
	MemberExpression(node, ctx){
		return [
			...this(node.object, ctx),
			...getProperty.call(this, node, ctx),
			...invokeCall('__asm__getKey', 2, 1),
		];
	},
	EmptyStatement(node, ctx){
		return [];
	},
	UnaryExpression(node, ctx){
		if(node.operator == 'delete' && node.argument.type == 'MemberExpression'){
			return [
				...this(node.argument.object, ctx),
				...getProperty.call(this, node.argument, ctx),
				...invokeCall(node.operator, 2, 1),
			];
		}
		return [
			...this(node.argument, ctx),
			...invokeCall(node.operator, 1, 1),
		];
	},
	BinaryExpression(node, ctx){
		return [
			...this(node.left, ctx),
			...this(node.right, ctx),
			...invokeCall(node.operator, 2, 1),
		];
	},
	AssignmentExpression(node, ctx){
		let value = this(node.right, ctx);
		return [
			...value,
			['set', node.left.name]
		];
		if(node.left.type == 'Identifier'){
			if(node.operator != '='){
				let left = this(node.left, ctx);
				switch(node.operator){
					case '+=': value += left; break;
					case '-=': value -= left; break;
					case '*=': value *= left; break;
					case '/=': value /= left; break;
					case '%=': value %= left; break;
					case '&=': value &= left; break;
					case '|=': value |= left; break;
					case '^=': value ^= left; break;
					case '<<=': value <<= left; break;
					case '>>=': value >>= left; break;
					case '>>>=': value >>>= left; break;
					default: throwError(node);
				}
			}
			ctx.setVar(node.left.name, value);
			return value;
		}else if(node.left.type == 'MemberExpression'){
			let object = this(node.left.object, ctx);
			let property = getProperty.call(this, node.left, ctx);
			switch(node.operator){
				case '=':	return object[property] = value;
				case '+=':	return object[property] += value;
				case '-=':	return object[property] -= value;
				case '*=':	return object[property] *= value;
				case '/=':	return object[property] /= value;
				case '%=':	return object[property] %= value;
				case '&=':	return object[property] &= value;
				case '|=': 	return object[property] |= value;
				case '^=':	return object[property] ^= value;
				case '<<=':	return object[property] <<= value;
				case '>>=':	return object[property] >>= value;
				case '>>>=':return object[property] >>>= value;
				default: throwError(node);
			}
		}
		throwError(node);
	},
	LogicalExpression(node, ctx){
		const caseRight = this(node.right, ctx);
		if(node.operator == '&&'){
			return [
				...this(node.left, ctx),
				...invokeCall('__asm__duplicate', 1, 2),
				['jumpIf', 2], ['jump', caseRight.length + 2],//jump if false
				pop(),
				...caseRight
			];
		}
		if(node.operator == '||'){
			return [
				...this(node.left, ctx),
				...invokeCall('__asm__duplicate', 1, 2),
				['jumpIf', caseRight.length + 2],
				pop(),
				...caseRight
			];
		}
	},
	Literal(node, ctx){
		return [['push', node.value]];
	},
	VariableDeclaration(node, ctx){
		return concat(node.declarations.map(v => this(v, ctx)));
	},
	VariableDeclarator(node, ctx){
		const result = [];
		if(node.init){
			result.push(...this(node.init, ctx));
		}else{
			result.push(['push', undefined]);
		}
		result.push(['set', node.id.name]);
		return result;
	},
	ReturnStatement(node, ctx){
		return [
			...this(node.argument, ctx),
			['return', 1]
		];
	},
	ConditionalExpression(node, ctx, handler){
		return handler.IfStatement.call(this, node, ctx);
	},
	IfStatement(node, ctx){
		const caseTrue = this(node.consequent, ctx);
		const caseFalse = node.alternate ? this(node.alternate, ctx) : [];
		return [
			...this(node.test, ctx),
			['jumpIf', caseFalse.length + 2],
			...caseFalse
			['jump', caseTrue.length + 1],
			...caseTrue,
		];
	},
	WhileStatement(node, ctx){
		const loopCode = this(node.body, ctx);
		const conditionCode = this(node.test, ctx);
		const loopCount = loopCode.length;
		const totalCount = loopCount + conditionCode.length;
		replaceBreakContinue(loopCode, totalCount + 1);
		return [
			['jump', loopCount + 1],
			...loopCode,
			...conditionCode,
			['jumpIf', -totalCount],
		];
	},
	DoWhileStatement(node, ctx){
		const loopCode = this(node.body, ctx);
		const conditionCode = this(node.test, ctx);
		const totalCount = loopCode.length + conditionCode.length;
		replaceBreakContinue(loopCode, totalCount + 1);
		return [
			...loopCode,
			...conditionCode,
			['jumpIf', -totalCount],
		];
	},
	ForStatement(node, ctx){
		const loopCode = this(node.body, ctx);
		const iterCode = node.update ? this(node.update, ctx) : [];
		const conditionCode = this(node.test, ctx);
		const result = this(node.init, ctx);
	
		const loopCount = loopCode.length + iterCode.length;
		const totalCount = loopCount + conditionCode.length;
		if(false){
			replaceBreakContinue(loopCode, loopCount + 1);
			result.push(...conditionCode);
			result.push(['jumpIf', loopCount + 2]);
			result.push(...loopCode);
			result.push(...iterCode);
			result.push(['jump', -(totalCount + 1)]);
		}else{
			replaceBreakContinue(loopCode, totalCount + 1);
			result.push(['jump', loopCount + 1]);
			result.push(...loopCode);
			result.push(...iterCode);
			result.push(...conditionCode);
			result.push(['jumpIf', -totalCount]);
		}
		return result;
	},
	ForInStatement(node, ctx){
		return [
			...this(node.right, ctx),
			['get', 'Object'],
			['push', 'keys'],
			...invokeCall('__asm__getKey', 2, 1),
			['invoke', 1, 1],
		];
		//node.left.declarations.map(v => scope[v.id.name] = key);

		const loopCode = [
			...invokeCall('__asm__duplicate', 1, 2),
			['push', 'shift'],
			...invokeCall('__asm__getKey', 2, 1),
			['invoke', 1, 1],
			['set', node.left.declarations[0].id.name],
			...this(node.body, ctx),
		];
		const iterCode = [];
		const conditionCode = [
			...invokeCall('__asm__duplicate', 1, 2),
			['push', 'length'],
			...invokeCall('__asm__getKey', 2, 1),
			['push', 0],
			...invokeCall('>', 2, 1),
		];
		const result = [];
	
		const loopCount = loopCode.length + iterCode.length;
		const totalCount = loopCount + conditionCode.length;
		replaceBreakContinue(loopCode, totalCount + 1);
		result.push(['jump', loopCount + 1]);
		result.push(...loopCode);
		result.push(...iterCode);
		result.push(...conditionCode);
		result.push(['jumpIf', -totalCount]);
		return result;
	},
	ForOfStatement(node, ctx){
		const scope = ctx.pushScope();
		try{
			for(let key of this(node.right, ctx)){
				node.left.declarations.forEach(v => scope[v.id.name] = key);
				try{
					this(node.body, ctx);
				}catch(error){
					if(error instanceof BreakStatement){
						if(error.label == null || error.label == label){
							break;
						}
					}
					if(error instanceof ContinueStatement){
						if(error.label == null || error.label == label){
							continue;
						}
					}
					throw error;
				}
			}
		}finally{
			ctx.popScope();
		}
	},
	BreakStatement(node, ctx){
		return [['break']];
	},
	ContinueStatement(node, ctx){
		return [['continue']];
	},
	LabeledStatement(node, ctx){
		console.log(node.label.name);
		return this(node.body, ctx);
	},
	UpdateExpression(node, ctx){
		const argument = node.argument;
		if(argument.type == 'Identifier'){
			if(node.prefix){
				return [
					...this(argument, ctx),
					...invokeCall(node.operator, 1, 1),
					...invokeCall('__asm__duplicate', 1, 2),
					['set', argument.name],
				];
			}else{
				return [
					...this(argument, ctx),
					...invokeCall('__asm__duplicate', 1, 2),
					...invokeCall(node.operator, 1, 1),
					['set', argument.name],
				];
			}
		}
		if(argument.type == 'MemberExpression'){
			if(node.prefix){
				return [
					...this(argument.object, ctx),
					...getProperty.call(this, argument, ctx),
					...this(argument, ctx),
					...invokeCall(node.operator, 1, 1),
					...invokeCall('__asm__setKey', 3, 1),
				];
			}
		}
		console.error(node);
	},
	ArrayExpression(node, ctx){
		const result = invokeCall('__asm__newArray', 0, 1);
		node.elements.forEach((v, i) => {
			result.push(['push', i], ...this(v, ctx), ...invokeCall('__asm__setKey', 3, 1));
		});
		return result;
	},
	ObjectExpression(node, ctx){
		const result = invokeCall('__asm__newObject', 0, 1);
		for(const propNode of node.properties){
			let key;
			switch(propNode.key.type){
				case 'Identifier':
					key = propNode.key.name;
					break;
				case 'Literal':
					key = propNode.key.value;
					break;
				default: throw new Error(propNode);
			}
			const value = this(propNode.value, ctx);
			switch(propNode.kind){
				case 'init':
					result.push(['push', key], ...value, ...invokeCall('__asm__setKey', 3, 1));
					break;
				default: throw new Error(propNode);
			}
		}
		return result;
	},
	NewExpression(node, ctx){
		const klazz = this(node.callee, ctx);
		return new klazz(...collectArgs.call(this, node, ctx));
	},
	DebuggerStatement(node, ctx){
		return [];
	},
	ThisExpression(node, ctx){
		return [['get', 'this']];
	},
	SequenceExpression(node, ctx){
		const expressions = node.expressions.slice();
		const element = expressions.pop();
		return [
			...concat(expressions.map(v => this(v, ctx))),
			...invokeCall('__asm__pop', expressions.length, 0),
			...this(element, ctx),
		];
	},
	SwitchStatement(node, ctx){
		const offsetList = [];
		const testList = [];
		const codeList = [];
		for(const {consequent} of node.cases){
			offsetList.push(codeList.length);
			codeList.push(...concat(consequent.map(v => this(v, ctx))));
		}
		for(const {test} of node.cases.reverse()){
			const position = testList.length + offsetList.pop() + 2;
			if(!test){
				testList.unshift(['jump', position]);
				continue;
			}
			testList.unshift(
				...invokeCall('__asm__duplicate', 1, 2),
				...this(test, ctx),
				...invokeCall('__asm__isEqual', 2, 1),
				['jumpIf', position],
			);
		}
		for(let i=0, n=codeList.length; i<n; ++i){
			if(codeList[i][0] != 'break')continue;
			codeList[i] = ['jump', n - i];
		}
		return [
			...this(node.discriminant, ctx),
			...testList,
			['jump', codeList.length + 1],
			...codeList,
			pop(),
		];
	},
	ThrowStatement(node, ctx){
		return [];
	},
	TryStatement(node, ctx){
		try{
			this(node.block, ctx);
		}catch(error){
			if(!node.handler)throw error;
			let scope = ctx.pushScope();
			scope[node.handler.param.name] = error;
			try{
				this(node.handler, ctx);
			}finally{
				ctx.popScope();
			}
		}finally{
			if(node.finalizer){
				this(node.finalizer, ctx);
			}
		}
	},
	CatchClause(node, ctx){
		this(node.body, ctx);
	},
	TemplateLiteral(node, ctx){
		return this(node.quasis[0], ctx) + node.expressions.map((v, i) => this(v, ctx) + this(node.quasis[i+1], ctx)).join('');
	},
	TemplateElement(node, ctx){
		return node.value.raw;
	},
	TaggedTemplateExpression(node, ctx){
		let mapFn = v => this(v, ctx);
		return this(node.tag, ctx).call(null, node.quasi.quasis.map(mapFn), ...node.quasi.expressions.map(mapFn));
	}
};

const walk = node => handler[node.type].call(walk, node, null, handler);
const exec = code => walk(acorn.Parser.extend(jsx()).parse(code));
//yieldFlag', 'yieldOneTickFlag', 'suspendFlag
let ttt = exec(`
function test(yieldFlag, yieldOneTickFlag, suspendFlag){
return $ => {
let fn = {}
return {*["0!R#c$3[eLos8B%+Mo*Z"](){
	for(let i=10;i>0;--i){
		yield yieldFlag
		yield $.weeemake_buzzer({NOTE:262,BEAT:500})
		for(let end=performance.now()+1000*(1);performance.now()<end;)yield yieldOneTickFlag;
	}
}}
}}
	`)

//console.log(ttt.map(JSON.stringify).join('\n'))

console.log(exec(`
switch(100){
	case 5:
		print(5)
		break
	default:
		print(6)
}

`).map(JSON.stringify).join('\n'))
