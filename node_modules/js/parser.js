
const NodeType = require('./NodeType');
const testRule = require('./RuleList');
const Node = require('./Node');
const NodeList = require('./NodeList');
const buildTree = require('./buildTree');

function lexer(input){
	const outputNodeList = new NodeList();
	const spaceRegExp = /^\s+/;
	while(input.length > 0){
		const spaceTest = spaceRegExp.exec(input);
		if(spaceTest){
			input = input.slice(spaceTest[0].length);
			continue;
		}
		let result = testRule(input);
		if(!result){
			console.log('not matched');
			break;
		}
		outputNodeList.add(new Node(...result));
		input = input.slice(result[1].length);
	}
	outputNodeList.add(new Node(NodeType.EOF));
	return outputNodeList;
}

function readValueList(nodeList, endNodeType, readHandler){
	if(nodeList.expect(endNodeType)){
		return null;
	}
	var firstNode = readHandler(nodeList);
	var currentNode = firstNode;
	while(!nodeList.expect(endNodeType)){
		nodeList.accept(NodeType.COMMA);
		currentNode.nextSibling = readHandler(nodeList);
		currentNode = currentNode.nextSibling;
	}
	return firstNode;
}

function readKeyValue(nodeList){
	var key = nodeList.accept(NodeType.STRING);
	nodeList.accept(NodeType.COLON);
	return calcute(new Node(NodeType.KEY_VALUE), key, this(nodeList));
}

function readStatement(nodeList){
	if(nodeList.expect(NodeType.BRACES_LEFT)){
		nodeList.accept(NodeType.BRACES_LEFT);
		let result = readStatementList(nodeList);
		nodeList.accept(NodeType.BRACES_RIGHT);
		return result;
	}else if(nodeList.matchAny([NodeType.KEYWORD_IF, NodeType.KEYWORD_WHILE])){
		let op = nodeList.next();
		nodeList.accept(NodeType.PARENTHESES_LEFT);
		let condition = buildTree(nodeList);
		nodeList.accept(NodeType.PARENTHESES_RIGHT);
		let code = readStatement(nodeList);
		op.firstChild = condition;
		condition.nextSibling = code;
		return op;
	}else if(nodeList.matchAny([NodeType.VAR_ID])){
		let a = nodeList.next();
		while(nodeList.matchAny([NodeType.OP_DOT, NodeType.PARENTHESES_LEFT])){
			let method = nodeList.next();
			if(method.type == NodeType.OP_DOT){
				method.firstChild = a;
				a.nextSibling = nodeList.next();
				a = method;
			}else if(a.type == NodeType.OP_DOT){
				a.type = NodeType.CALL_METHOD;
				a.firstChild.nextSibling.nextSibling = readValueList(nodeList, NodeType.PARENTHESES_RIGHT, buildTree);
				nodeList.accept(NodeType.PARENTHESES_RIGHT);
			}else{
				method.type = NodeType.CALL_FUNCTION;
				method.firstChild = a;
				a.nextSibling = readValueList(nodeList, NodeType.PARENTHESES_RIGHT, buildTree);
				nodeList.accept(NodeType.PARENTHESES_RIGHT);
				a = method;
			}
		}
		return a;
	}else if(nodeList.matchAny([NodeType.SEMICOLON])){
		nodeList.next();
		return readStatement(nodeList);
	}
}

function readStatementList(nodeList){
	if(nodeList.empty())return;
	let op = readStatement(nodeList);
	op.nextSibling = readStatement(nodeList);
	return op;
}

console.log(buildTree(lexer("1 = 2 = 3 = 4")).calcute())
console.log(buildTree(lexer("1 + 2 + 3 + ---+++4")).calcute())
let nodeList = lexer("if(5 > 0)console.log(100, 200, 300);while(0){console.log(2);}");
let tree = readStatementList(nodeList);
while(tree){
	console.log(tree.calcute());
	tree = tree.nextSibling;
}
