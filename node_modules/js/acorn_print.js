'use strict';

function collectArgs(node, ctx){
	return node.arguments.map(v => this(v, ctx));
}

function getProperty(node, ctx){
	return node.computed ? '[' + this(node.property, ctx) + ']' : '.' + node.property.name;
}

function addTab(code){
	return code.replace(/^/gm, ' '.repeat(4));
}

const handler = {
	Program(node, ctx){
		return node.body.map(v => this(v, ctx)).join('\n');
	},
	BlockStatement(node, ctx, handler){
		return handler.Program.call(this, node, ctx, handler);
	},
	Identifier(node, ctx){
		return node.name;
	},
	FunctionDeclaration(node, ctx, handler){
		return handler.FunctionExpression.call(this, node, ctx, handler);
	},
	ArrowFunctionExpression(node, ctx){
		throw new Error(node);
		this(node.body, ctx);
	},
	FunctionExpression(node, ctx){
		const body = this(node.body, ctx);
		return `${node.async ? 'async ': ''}function${node.id ? ' ' + node.id.name : ''}(${node.params.map(v => this(v, ctx))}){\n${addTab(body)}\n}`;
	},
	AwaitExpression(node, ctx){
		return `await ` + this(node.argument, ctx);
	},
	YieldExpression(node, ctx){
		console.log(node.delegate)
		return `yield ` + this(node.argument, ctx);
	},
	ExpressionStatement(node, ctx){
		return this(node.expression, ctx) + ';';
	},
	CallExpression(node, ctx){
		return this(node.callee, ctx) + '(' + collectArgs.call(this, node, ctx) + ')';
	},
	SpreadElement(node, ctx){
		return '...' + this(node.argument, ctx);
	},
	RestElement(node, ctx){
		return '...' + this(node.argument, ctx);
	},
	MemberExpression(node, ctx){
		return this(node.object, ctx) + getProperty.call(this, node, ctx);
	},
	EmptyStatement(node, ctx){
		return '';
	},
	UnaryExpression(node, ctx){
		return node.operator + ' ' + this(node.argument, ctx);
	},
	BinaryExpression(node, ctx){
		return this(node.left, ctx) + ' ' + node.operator + ' ' + this(node.right, ctx);
	},
	AssignmentExpression(node, ctx, handler){
		return handler.BinaryExpression.call(this, node, ctx, handler);
	},
	LogicalExpression(node, ctx, handler){
		return handler.BinaryExpression.call(this, node, ctx, handler);
	},
	Literal(node, ctx){
		return node.raw;
	},
	VariableDeclaration(node, ctx){
		return node.kind + ' ' + node.declarations.map(v => this(v, ctx));
	},
	VariableDeclarator(node, ctx){
		if(node.init){
			return this(node.id, ctx) + ' = ' + this(node.init, ctx);
		}
		return this(node.id, ctx);
	},
	ReturnStatement(node, ctx){
		if(node.argument){
			return 'return ' + this(node.argument, ctx);
		}
		return 'return';
	},
	ConditionalExpression(node, ctx){
		return this(node.test, ctx) + ' ? ' + this(node.consequent, ctx) + ' : ' + this(node.alternate, ctx);
	},
	IfStatement(node, ctx){
		let result = `if(${this(node.test, ctx)}){\n` + addTab(this(node.consequent, ctx)) + `\n}`;
		if(node.alternate){
			return result + `else{\n` + addTab(this(node.alternate, ctx)) + '\n}';
		}
		return result;
	},
	WhileStatement(node, ctx){
		return `while(${this(node.test, ctx)}){\n${addTab(this(node.body, ctx))}\n}`;
	},
	DoWhileStatement(node, ctx){
		return `do{\n${addTab(this(node.body, ctx))}\n}while(${this(node.test, ctx)});`
	},
	ForStatement(node, ctx){
		return `for(${this(node.init, ctx)}${this(node.test, ctx)};${this(node.update, ctx)}){\n${addTab(this(node.body, ctx))}\n}`;
	},
	ForInStatement(node, ctx){
		return `for(${this(node.left, ctx)} in ${this(node.right, ctx)}){\n${addTab(this(node.body, ctx))}\n}`;
	},
	ForOfStatement(node, ctx){
		return `for(${this(node.left, ctx)} of ${this(node.right, ctx)}){\n${addTab(this(node.body, ctx))}\n}`;
	},
	BreakStatement(node, ctx){
		return node.label ? 'break ' + node.label : 'break';
	},
	ContinueStatement(node, ctx){
		return node.label ? 'continue ' + node.label : 'continue';
	},
	LabeledStatement(node, ctx){
		return this(node.label, ctx) + ':\n' + this(node.body, ctx);
	},
	UpdateExpression(node, ctx){
		let result = this(node.argument, ctx);
		if(node.prefix){
			return node.operator + result;
		}
		return result + node.operator;
	},
	ArrayExpression(node, ctx){
		return '[' + node.elements.map(v => this(v, ctx)) + ']';
	},
	ObjectExpression(node, ctx){
		return '{' + node.properties.map(v => (v.key.type =='Identifier' ? this(v.key) : `[${this(v.key)}]`) + ':' + this(v.value, ctx)) + '}';
	},
	NewExpression(node, ctx, handler){
		return 'new ' + handler.CallExpression.call(this, node, ctx, handler);
	},
	DebuggerStatement(node, ctx){
		return 'debugger';
	},
	ThisExpression(node, ctx){
		return 'this';
	},
	SequenceExpression(node, ctx){
		return '(' + node.expressions.map(v => this(v, ctx)) + ')';
	},
	SwitchStatement(node, ctx){
		const body = addTab(node.cases.map(v => this(v, ctx)).join('\n'));
		return `switch(${this(node.discriminant, ctx)}){\n${body}\n}`;
	},
	SwitchCase(node, ctx){
		const body = addTab(node.consequent.map(v => this(v, ctx)).join('\n'));
		if(node.test){
			return `case ${this(node.test, ctx)}:\n${body}`;
		}
		return `default:\n${body}`;
	},
	ThrowStatement(node, ctx){
		return 'throw ' + this(node.argument, ctx);
	},
	TryStatement(node, ctx){
		let result = `try{\n${addTab(this(node.block, ctx))}\n}`;
		if(node.handler){
			result += this(node.handler, ctx);
		}
		if(node.finalizer){
			result += `finally{\n${addTab(this(node.finalizer, ctx))}\n}`;
		}
		return result;
	},
	CatchClause(node, ctx){
		return `catch(${this(node.param, ctx)}){\n${addTab(this(node.body, ctx))}\n}`;
	},
	TemplateLiteral(node, ctx){
		return '`' + this(node.quasis[0], ctx) + node.expressions.map((v, i) => '${' + this(v, ctx) + '}' + this(node.quasis[i+1], ctx)).join('') + '`';
	},
	TemplateElement(node, ctx){
		return node.value.raw;
	},
	TaggedTemplateExpression(node, ctx){
		return this(node.tag, ctx) + this(node.quasi, ctx);
	}
};

function walk(node, ctx){
	return handler[node.type].call(walk, node, ctx, handler);
}

module.exports = walk;
