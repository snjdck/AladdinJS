'use strict';

const fixBrackets = function(){
	const wrap = (v, l='(', r=')') => l + v + r;
	const Precedence_Order = {
		'()':19,
		'=>':18,
		'+1':16, '-1':16, 'await':16, '!':16, '~':16, 'typeof':16, 'void':16, 'delete':16,
		'**':15,
		'*':14, '/':14, '%':14,
		'+':13, '-':13,
		'<<':12, '>>':12, '>>>':12,
		'<':11, '<=':11, '>':11, '>=':11, 'in':11, 'instanceof':11,
		'==':10, '===':10, '!=':10, '!==':10,
		'&':9,
		'^':8,
		'|':7,
		'&&':6,
		'||':5,
		'?:':4,
		'=':3,'+=':3,'-=':3,'*=':3,'/=':3,'%=':3,'<<=':3,'>>=':3,'>>>=':3,'&=':3,'|=':3,'^=':3,
		'yield':2,
	};
	const Right_Associativity = [2, 3, 4, 15, 16];
	const needBrackets = require('./needBrackets')(op => Precedence_Order[op] || 0, op => Right_Associativity.includes(op));
	return function(name, getInnerOP){
		const oldFn = handler[name];
		handler[name] = function(node, outerOP, isRightOperand){
			const value = oldFn.call(this, node);
			return needBrackets(getInnerOP(node), outerOP, isRightOperand) ? wrap(value) : value;
		}
	}
}();

function UnaryOperator(node){
	switch(node.operator){
		case '+': case '-': return node.operator + '1';
	}
	return node.operator;
}

const collectArgs = node => node.arguments.map(walk);
const getProperty = node => node.computed ? '[' + walk(node.property) + ']' : '.' + node.property.name;

const addTab = ((...args) => code => code.replace(...args))(/^/gm, ' '.repeat(4));

function FunctionExpression(node, method){
	const body = walk(node.body);
	return `${node.async ? 'async ': ''}${method || 'function'}${node.generator ? '*' : ' '}${node.id ? node.id.name : ''}(${node.params.map(walk)}){\n${addTab(body)}\n}`;
}

const handler = {
	ImportDeclaration(node){
		if(node.specifiers.length <= 0){
			return `import ${walk(node.source)}`;
		}
		let specifiers;
		let a = node.specifiers.filter(v => v.type != 'ImportSpecifier').map(walk);
		let b = node.specifiers.filter(v => v.type == 'ImportSpecifier').map(walk);
		if(a.length > 0 && b.length > 0){
			specifiers = a.join(', ') + ', {' + b.join(', ') + '}';
		}else if(a.length > 0){
			specifiers = a.join(', ');
		}else if(b.length > 0){
			specifiers = '{' + b.join(', ') + '}';
		}
		return `import ${specifiers} from ${walk(node.source)}`;
	},
	ImportDefaultSpecifier(node){
		return walk(node.local);
	},
	ImportNamespaceSpecifier(node){
		return '* as ' + walk(node.local);
	},
	ImportSpecifier(node){
		let name = walk(node.imported);
		let alias = walk(node.local);
		return name == alias ? name : `${name} as ${alias}`;
	},
	ExportNamedDeclaration(node){
		let result = 'export ';
		if(node.declaration){
			result += walk(node.declaration);
		}
		if(node.specifiers.length > 0){
			result += '{' + node.specifiers.map(walk).join(', ') + '}';
		}
		if(node.source){
			result += ' from ' + walk(node.source);
		}
		return result;
	},
	ExportDefaultDeclaration(node){
		return 'export default ' + walk(node.declaration);
	},
	ExportSpecifier(node){
		let name = walk(node.local);
		let alias = walk(node.exported);
		return name == alias ? name : `${name} as ${alias}`;
	},
	ExportAllDeclaration(node){
		return 'export * from ' + walk(node.source);
	},
	ClassDeclaration(node){
		return `class ${walk(node.id)}${node.superClass ? ' extends ' + walk(node.superClass) : ''} {\n${walk(node.body)}\n}`;
	},
	ClassBody(node){
		return addTab(handler.Program(node));
	},
	MethodDefinition(node){
		let prefix = node.static ? 'static ' : '';
		let key = walk(node.key);
		if(node.computed){
			key = '[' + key + ']';
		}
		if(node.value.type == 'FunctionExpression'){
			return prefix + FunctionExpression(node.value, key);
		}
		return prefix + walk(node.key) + ':' + walk(node.value);
	},
	Program(node){
		return node.body.map(walk).join('\n');
	},
	BlockStatement(node){
		return handler.Program(node);
	},
	Identifier(node){
		return node.name;
	},
	FunctionDeclaration(node){
		return FunctionExpression(node);
	},
	ArrowFunctionExpression(node){
		const body = walk(node.body);
		let params;
		if(node.params.length == 1 && node.params[0].type == 'Identifier'){
			params = walk(node.params[0]);
		}else{
			params = `(${node.params.map(walk)})`;
		}
		const result = params + ` => `;
		if(node.expression){
			return result + body;
		}
		return result + `{\n${addTab(body)}\n}`;
	},
	FunctionExpression(node){
		return FunctionExpression(node);
	},
	AwaitExpression(node){
		return `await ` + walk(node.argument, 'await', true);
	},
	YieldExpression(node){
		return `yield` + (node.delegate ? '*' : ' ') + walk(node.argument, 'yield', true);
	},
	ExpressionStatement(node){
		return walk(node.expression) + ';';
	},
	CallExpression(node){
		return walk(node.callee, '()') + '(' + collectArgs(node) + ')';
	},
	SpreadElement(node){
		return '...' + walk(node.argument);
	},
	RestElement(node){
		return '...' + walk(node.argument);
	},
	MemberExpression(node){
		return walk(node.object) + getProperty(node);
	},
	EmptyStatement(node){
		return '';
	},
	UnaryExpression(node){
		return node.operator + ' ' + walk(node.argument, UnaryOperator(node), true);
	},
	BinaryExpression(node){
		return walk(node.left, node.operator) + ' ' + node.operator + ' ' + walk(node.right, node.operator, true);
	},
	AssignmentExpression(...args){
		return this.BinaryExpression(...args);
	},
	LogicalExpression(...args){
		return this.BinaryExpression(...args);
	},
	Literal(node){
		return node.raw;
	},
	VariableDeclaration(node){
		return node.kind + ' ' + node.declarations.map(walk);
	},
	VariableDeclarator(node){
		if(node.init){
			return walk(node.id) + ' = ' + walk(node.init);
		}
		return walk(node.id);
	},
	ArrayPattern(node){
		return handler.ArrayExpression(node);
	},
	ObjectPattern(node){
		return handler.ObjectExpression(node);
	},
	AssignmentPattern(node){
		return walk(node.left) + ' = ' + walk(node.right);
	},
	ReturnStatement(node){
		if(node.argument){
			return 'return ' + walk(node.argument);
		}
		return 'return';
	},
	ConditionalExpression(node){
		const operator = '?:';
		return walk(node.test, operator) + ' ? ' + walk(node.consequent, operator) + ' : ' + walk(node.alternate, operator, true);
	},
	IfStatement(node){
		let result = `if(${walk(node.test)}){\n` + addTab(walk(node.consequent)) + `\n}`;
		if(!node.alternate)return result;
		const {alternate} = node;
		if(alternate.type == 'IfStatement'){
			return result + `else ${walk(alternate)}`;
		}
		return result + `else{\n` + addTab(walk(alternate)) + '\n}';
	},
	WhileStatement(node){
		return `while(${walk(node.test)}){\n${addTab(walk(node.body))}\n}`;
	},
	DoWhileStatement(node){
		return `do{\n${addTab(walk(node.body))}\n}while(${walk(node.test)});`;
	},
	ForStatement(node){
		return `for(${walk(node.init)};${walk(node.test)};${walk(node.update)}){\n${addTab(walk(node.body))}\n}`;
	},
	ForInStatement(node){
		return `for(${walk(node.left)} in ${walk(node.right)}){\n${addTab(walk(node.body))}\n}`;
	},
	ForOfStatement(node){
		return `for(${walk(node.left)} of ${walk(node.right)}){\n${addTab(walk(node.body))}\n}`;
	},
	BreakStatement(node){
		return node.label ? 'break ' + node.label : 'break';
	},
	ContinueStatement(node){
		return node.label ? 'continue ' + node.label : 'continue';
	},
	LabeledStatement(node){
		return walk(node.label) + ':\n' + walk(node.body);
	},
	UpdateExpression(node){
		let result = walk(node.argument);
		if(node.prefix){
			return node.operator + result;
		}
		return result + node.operator;
	},
	ArrayExpression(node){
		return '[' + node.elements.map(walk) + ']';
	},
	ObjectExpression(node){
		return `{${node.properties.map(walk)}}`;
	},
	Property(node){
		let key = walk(node.key);
		if(node.shorthand){
			return key;
		}
		if(node.computed){
			key = `[${key}]`;
		}
		if(node.method){
			return FunctionExpression(node.value, key);
		}
		return key + ':' + walk(node.value);
	},
	NewExpression(node){
		return 'new ' + handler.CallExpression(node);
	},
	DebuggerStatement(node){
		return 'debugger';
	},
	ThisExpression(node){
		return 'this';
	},
	Super(node){
		return 'super';
	},
	SequenceExpression(node){
		return '(' + node.expressions.map(walk) + ')';
	},
	SwitchStatement(node){
		const body = addTab(node.cases.map(walk).join('\n'));
		return `switch(${walk(node.discriminant)}){\n${body}\n}`;
	},
	SwitchCase(node){
		const body = addTab(node.consequent.map(walk).join('\n'));
		if(node.test){
			return `case ${walk(node.test)}:\n${body}`;
		}
		return `default:\n${body}`;
	},
	ThrowStatement(node){
		return 'throw ' + walk(node.argument);
	},
	TryStatement(node){
		let result = `try{\n${addTab(walk(node.block))}\n}`;
		if(node.handler){
			result += walk(node.handler);
		}
		if(node.finalizer){
			result += `finally{\n${addTab(walk(node.finalizer))}\n}`;
		}
		return result;
	},
	CatchClause(node){
		return `catch(${walk(node.param)}){\n${addTab(walk(node.body))}\n}`;
	},
	WithStatement(node){
		return `with(${walk(node.object)}){\n${addTab(walk(node.body))}\n}`;
	},
	TemplateLiteral(node){
		return '`' + walk(node.quasis[0]) + node.expressions.map((v, i) => '${' + walk(v) + '}' + walk(node.quasis[i+1])).join('') + '`';
	},
	TemplateElement(node){
		return node.value.raw;
	},
	TaggedTemplateExpression(node){
		return walk(node.tag) + walk(node.quasi);
	}
};

fixBrackets('BinaryExpression', node => node.operator);
fixBrackets('UnaryExpression', UnaryOperator);
fixBrackets('ConditionalExpression', () => '?:');
fixBrackets('ArrowFunctionExpression', () => '=>');
fixBrackets('YieldExpression', () => 'yield');
fixBrackets('AwaitExpression', () => 'await');

function walk(node, outerOP, isRightOperand){
	if(node == null)return '';
	if(!handler[node.type])console.error(node);
	return handler[node.type](node, outerOP, isRightOperand);
}

if(__filename == process.argv[1]){
	const acorn = require('./acorn.js');
	const fs = require('fs');
	console.log(walk(acorn.parse(fs.readFileSync(process.argv[2], 'utf8'))));
}

module.exports = walk;
