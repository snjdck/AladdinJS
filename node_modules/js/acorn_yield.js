'use strict';

function getProperty(node, ctx){
	return node.computed ? '[' + this(node.property, ctx) + ']' : '.' + node.property.name;
}

const handler = {
	Program(node, ctx){
		return node.body.some(v => this(v, ctx));
	},
	BlockStatement(node, ctx, handler){
		return handler.Program.call(this, node, ctx, handler);
	},
	Identifier(node, ctx){
		return false;
	},
	FunctionDeclaration(node, ctx, handler){
		return false;
	},
	ArrowFunctionExpression(node, ctx){
		return false;
	},
	FunctionExpression(node, ctx){
		return false;
	},
	AwaitExpression(node, ctx){
		return true;
	},
	YieldExpression(node, ctx){
		return true;
	},
	ExpressionStatement(node, ctx){
		return this(node.expression, ctx);
	},
	CallExpression(node, ctx){
		return this(node.callee, ctx) || node.arguments.some(v => this(v, ctx));
	},
	SpreadElement(node, ctx){
		return this(node.argument, ctx);
	},
	RestElement(node, ctx){
		return false;
	},
	MemberExpression(node, ctx){
		return this(node.object, ctx) || this(node.property, ctx);
	},
	EmptyStatement(node, ctx){
		return false;
	},
	UnaryExpression(node, ctx){
		return this(node.argument, ctx);
	},
	BinaryExpression(node, ctx){
		return this(node.left, ctx) || this(node.right, ctx);
	},
	AssignmentExpression(node, ctx, handler){
		return handler.BinaryExpression.call(this, node, ctx, handler);
	},
	LogicalExpression(node, ctx, handler){
		return handler.BinaryExpression.call(this, node, ctx, handler);
	},
	Literal(node, ctx){
		return false;
	},
	VariableDeclaration(node, ctx){
		return node.declarations.some(v => this(v, ctx));
	},
	VariableDeclarator(node, ctx){
		return node.init && this(node.init, ctx);
	},
	ReturnStatement(node, ctx){
		return this(node.argument, ctx);
	},
	ConditionalExpression(node, ctx){
		return this(node.test, ctx) || this(node.consequent, ctx) || this(node.alternate, ctx);
	},
	IfStatement(node, ctx){
		let result = this(node.test, ctx) || this(node.consequent, ctx);
		if(node.alternate){
			return result || this(node.alternate, ctx);
		}
		return result;
	},
	WhileStatement(node, ctx){
		return this(node.test, ctx) || this(node.body, ctx);
	},
	DoWhileStatement(node, ctx){
		return this(node.test, ctx) || this(node.body, ctx);
	},
	ForStatement(node, ctx){
		return this(node.init, ctx) || this(node.test, ctx) || this(node.update, ctx) || this(node.body, ctx);
	},
	ForInStatement(node, ctx){
		return this(node.right, ctx) || this(node.body, ctx);
	},
	ForOfStatement(node, ctx){
		return this(node.right, ctx) || this(node.body, ctx);
	},
	BreakStatement(node, ctx){
		return false;
	},
	ContinueStatement(node, ctx){
		return false;
	},
	LabeledStatement(node, ctx){
		return this(node.body, ctx);
	},
	UpdateExpression(node, ctx){
		return this(node.argument, ctx);
	},
	ArrayExpression(node, ctx){
		return node.elements.some(v => this(v, ctx));
	},
	ObjectExpression(node, ctx){
		return node.properties.some(v => this(v.key, ctx) || this(v.value, ctx));
	},
	NewExpression(node, ctx, handler){
		return handler.CallExpression.call(this, node, ctx, handler);
	},
	DebuggerStatement(node, ctx){
		return false;
	},
	ThisExpression(node, ctx){
		return false;
	},
	SequenceExpression(node, ctx){
		return node.expressions.some(v => this(v, ctx));
	},
	SwitchStatement(node, ctx){
		return this(node.discriminant, ctx) || node.cases.some(v => this(v, ctx));
	},
	SwitchCase(node, ctx){
		const result = node.consequent.some(v => this(v, ctx));
		if(node.test){
			return result || this(node.test, ctx);
		}
		return result;
	},
	ThrowStatement(node, ctx){
		return this(node.argument, ctx);
	},
	TryStatement(node, ctx){
		let result = this(node.block, ctx);
		if(node.handler){
			result = result || this(node.handler, ctx);
		}
		if(node.finalizer){
			result = result || this(node.finalizer, ctx);
		}
		return result;
	},
	CatchClause(node, ctx){
		return this(node.body, ctx);
	},
	TemplateLiteral(node, ctx){
		return node.expressions.some(v => this(v, ctx));
	},
	TemplateElement(node, ctx){
		return false;
	},
	TaggedTemplateExpression(node, ctx){
		return this(node.tag, ctx) || this(node.quasi, ctx);
	}
};

function walk(node, ctx){
	return handler[node.type].call(walk, node, ctx, handler);
}

module.exports = walk;
