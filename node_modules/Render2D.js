function createMeshIndices(numVertexPerRow, numVertexPerCol, result=[])
{
	const numGridPerRow = numVertexPerRow - 1;
	const numGridPerCol = numVertexPerCol - 1;
	for(var row=0; row<numGridPerCol; ++row){
		for(var col=0; col<numGridPerRow; ++col){
			var a = col + numVertexPerRow * row;
			var b = col + numVertexPerRow * (row + 1);
			//三角形1, 三角形2
			result.push(a, a+1, b+1, a, b+1, b);
		}
	}
	return result;
}

class Render2D
{
	constructor(gl, mouseMgr){
		this.gl = gl;
		this.mouseMgr = mouseMgr;
		this.uniformData = new Float32Array(7 * 4);
		this.uniformBuffer = gl.createBuffer();
		this.vertexBuffer = gl.createBuffer();
		this.indexBuffer = gl.createBuffer();
		this.vao = gl.createVertexArray();
		
		gl.bindVertexArray(this.vao);

		gl.bindBuffer(gl.UNIFORM_BUFFER, this.uniformBuffer);
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			0, 0, 0, 0, 0, 0,
			0, 0, 1, 0, 0, 0,
			1, 0, 0,-1, 0, 0,
			1, 0, 0, 0, 0, 0,
			
			0, 0, 0, 0, 1, 0,
			0, 0, 1, 0, 1, 0,
			1, 0, 0,-1, 1, 0,
			1, 0, 0, 0, 1, 0,
			
			0, 1, 0, 0, 0,-1,
			0, 1, 1, 0, 0,-1,
			1, 1, 0,-1, 0,-1,
			1, 1, 0, 0, 0,-1,
			
			0, 1, 0, 0, 0, 0,
			0, 1, 1, 0, 0, 0,
			1, 1, 0,-1, 0, 0,
			1, 1, 0, 0, 0, 0
		]), gl.STATIC_DRAW);

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(createMeshIndices(4, 4)), gl.STATIC_DRAW);

		gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 24, 0);
		gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 24, 8);

		gl.enableVertexAttribArray(0);
		gl.enableVertexAttribArray(1);

		gl.bindVertexArray(null);
	}

	drawBegin(mode){
		const {gl, uniformData} = this;

		gl.disable(gl.DEPTH_TEST);
		if(mode == "pick"){
			gl.disable(gl.BLEND);
		}else{
			gl.enable(gl.BLEND);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		}
		
		let shaderName = mode == "pick" ? "shader2d&shader2d_pick" : "shader2d";
		var program = gl.__program__[shaderName];
		gl.useProgram(program);

		gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, this.uniformBuffer);

		gl.bindVertexArray(this.vao);

		uniformData[0] =  2 / gl.drawingBufferWidth;
		uniformData[1] = -2 / gl.drawingBufferHeight;
		uniformData[2] = -1;
		uniformData[3] =  1;

		gl.activeTexture(gl.TEXTURE0);
		gl.uniform1i(gl.getUniformLocation(program, "sampler0"), 0);

		if(mode == "pick"){
			this.uidLocation = gl.getUniformLocation(program, "uid");
			this.mouseMgr.pickBegin();
		}
	}

	drawBitmap(target, mode){
		const {worldTransform, texture, width, height} = target;
		const {gl, uniformData} = this;

		worldTransform.copyToArray(uniformData, 4);

		uniformData[12] = 1;
		uniformData[13] = 1;
		uniformData[14] = 1;
		uniformData[15] = 1;

		uniformData[16] = 0;
		uniformData[17] = 0;
		uniformData[18] = 0;
		uniformData[19] = 0;

		uniformData[20] = width;
		uniformData[21] = texture.width;
		uniformData[22] = height;
		uniformData[23] = texture.height;

		for(let i=0; i<4; ++i){
			uniformData[24+i] = texture.scale9grid[i];
		}

		gl.bufferData(gl.UNIFORM_BUFFER, uniformData, gl.DYNAMIC_DRAW);
		gl.bindTexture(gl.TEXTURE_2D, texture);

		if(mode == "pick"){
			gl.uniform1i(this.uidLocation, this.mouseMgr.pickRegister(target));
		}

		gl.drawElements(gl.TRIANGLES, 54, gl.UNSIGNED_BYTE, 0);
	}
}

module.exports = Render2D;