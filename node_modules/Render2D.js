"use strict";

const {VertexArray2D} = require("./vertexarrays");
const {UniformBuffer} = require("./uniformbuffers");
const batchDraw = require("./renderers/batchDraw");

class Render2D
{
	constructor(gl){
		this.gl = gl;
		this.contextRecorder = new ContextRecorder();
		this.vao = new VertexArray2D();
		this.uniformBuffer = new UniformBuffer(6, 1, gl.programMgr.MAX_VERTEX_UNIFORM_VECTORS);
		this.invalidateFlag = true;
		this.targetList = [];
		this.activeTexture = null;
		this.mode = null;
	}

	save(...keys){
		this.contextRecorder.save(this.gl, keys);
	}

	load(...keys){
		this.contextRecorder.load(this.gl, keys);
	}

	isPickMode(){
		return this.mode == "pick";
	}

	viewport(width, height){
		this.width = width;
		this.height = height;
		this.uniformBuffer.setFloats(0, 2 / width, -2 / height);
	}

	invalidate(){
		this.invalidateFlag = true;
	}

	drawBegin(){
		const {gl, vao, uniformBuffer} = this;

		let program = gl.programMgr.fetch(`shader2d&${this.mode}`);
		gl.useProgram(program);

		uniformBuffer.active(gl);
		vao.active(gl);

		gl.activeTexture(gl.TEXTURE0);
		gl.uniform1i(gl.getUniformLocation(program, "sampler0"), 0);

		gl.disable(gl.DEPTH_TEST);
		if(this.isPickMode()){
			gl.disable(gl.BLEND);
		}else{
			gl.enable(gl.BLEND);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		}
	}

	drawBitmap(target){
		let texture = target.texture.getRawAsset(this.gl);
		if(texture != this.activeTexture){
			this.submit();
		}
		this.targetList.push(target);
		this.activeTexture = texture;
	}

	submit(){
		if(this.targetList.length <= 0)return;
		if(this.invalidateFlag){
			this.drawBegin();
			this.invalidateFlag = false;
		}
		const {gl, vao, uniformBuffer, targetList} = this;
		gl.bindTexture(gl.TEXTURE_2D, this.activeTexture);
		let drawCount = batchDraw(gl, vao, uniformBuffer, targetList, this.updateUniform, this.isPickMode(), 2);
		
		gl.profileMgr.profile2d.drawCount += drawCount;
		gl.profileMgr.profile2d.textureSwitchCount++;

		targetList.length = 0;
		this.activeTexture = null;
	}

	updateUniform(uniformBuffer, target, index){
		let offset = 4 + 24 * index;
		const {worldTransform, texture, width, height} = target;
		
		worldTransform.copyToArray(uniformBuffer.floatView, offset);
		uniformBuffer.setFloatv(offset+8 , texture.xyuvMul);
		uniformBuffer.setFloatv(offset+12, texture.xyuvAdd);
		uniformBuffer.setFloatv(offset+20, texture.scale9grid);
		uniformBuffer.setFloats(offset+16, width, texture.width, height, texture.height);
	}

	drawScreen(){
		const {gl, vao} = this;
		vao.draw(gl);
	}
}

class StateStack
{
	constructor(){
		this.stateDict = new Map();
	}

	push(key, value){
		let {stateDict} = this;
		if(stateDict.has(key)){
			stateDict.get(key).push(value);
		}else{
			stateDict.set(key, [value]);
		}
	}

	pop(key){
		return this.stateDict.get(key).pop();
	}
}

class ContextRecorder
{
	constructor(){
		this.stateStack = new StateStack();
	}

	save(gl, keys){
		let {stateStack} = this;
		for(let key of keys){
			stateStack.push(key, gl.getParameter(key));
		}
	}

	load(gl, keys){
		let {stateStack} = this;
		for(let key of keys){
			let value = stateStack.pop(key);
			switch(key){
			case gl.FRAMEBUFFER_BINDING:
				gl.bindFramebuffer(gl.FRAMEBUFFER, value);
				break;
			case gl.CURRENT_PROGRAM:
				gl.useProgram(value);
				break;
			}
		}
	}
}

module.exports = Render2D;