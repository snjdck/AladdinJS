"use strict";

const ObjectGroup = require("../utils/ObjectGroup");

class RenderQueue
{
	constructor(gl){
		let context = {gl};
		let drawUnitGroup = new ObjectGroup();
		
		drawUnitGroup.addGroupRule(new TransparentGroupRule(context));
		drawUnitGroup.addGroupRule(new ShaderGroupRule(context));
		drawUnitGroup.addGroupRule(new TextureGroupRule(context));
		drawUnitGroup.addGroupRule(new MaterialGroupRule(context));
		drawUnitGroup.addGroupRule(new VaoGroupRule(context));
		draw = draw.bind(context);

		this.context = context;
		this.drawUnitGroup = drawUnitGroup;
	}

	draw(camera, drawUnitList){
		if(drawUnitList.length <= 0){
			return;
		}
		this.context.camera = camera;
		let {drawUnitGroup} = this;
		drawUnitGroup.group(drawUnitList);
		drawUnitGroup.update(draw);
	}
}

class GroupRule
{
	constructor(context){
		this.context = context;
	}
}
class TransparentGroupRule extends GroupRule
{
	calcKey(drawUnit){
		return drawUnit.material.isTransparent();
	}
	active(drawUnit){}
	sort(list){
		return list.sort((a, b) => a > b);
	}
}
class ShaderGroupRule extends GroupRule
{
	calcKey(drawUnit){
		return drawUnit.material.shader;
	}
	active(drawUnit){
		const {gl, camera} = this.context;
		gl.profileMgr.profile3d.shaderSwitchCount++;
		let program = gl.programMgr.fetch(drawUnit.material.shader);
		gl.useProgram(program);
		drawUnit.material.onActiveUniform(gl, camera, program);
	}
}
class TextureGroupRule extends GroupRule
{
	calcKey(drawUnit){
		return drawUnit.material.texture;
	}
	active(drawUnit){
		const {gl} = this.context;
		gl.profileMgr.profile3d.textureSwitchCount++;
		gl.bindTexture(gl.TEXTURE_2D, drawUnit.material.texture);
	}
}
class MaterialGroupRule extends GroupRule
{
	calcKey(drawUnit){
		return drawUnit.material.constructor.name;
	}
	active(drawUnit){
		const {gl} = this.context;
		gl.profileMgr.profile3d.stateSwitchCount++;
		let material = drawUnit.material;
		material.onActiveState(gl);
		this.context.material = material;
	}
}
class VaoGroupRule extends GroupRule
{
	calcKey(drawUnit){
		return drawUnit.vao;
	}
	active(drawUnit){
		const {gl, material} = this.context;
		gl.profileMgr.profile3d.vaoSwitchCount++;
		let vao = drawUnit.vao;
		vao.active(gl);
		material.onActiveVAO(gl, drawUnit);
		this.context.vao = vao;
	}
}
function draw(drawUnitList){
	const {gl, material} = this;
	material.draw(gl, this, drawUnitList);
}

module.exports = RenderQueue;