'use strict';

/*
const canvas = document.createElement('canvas');
document.body.appendChild(canvas);
DOMMatrix
DOMPoint
DOMQuad
DOMRect
DOMRectList
*/
//const bitmaprenderer = canvas.getContext('bitmaprenderer');

const DisplayObject2D = require('webgpu/DisplayObject2D');
const Vector2D = require('webgpu/math/Vector2D');
const {walkTree} = require('utils/traverseTree');
const {runAction, ActionBuilder, Sequence, Spawn, Delay, Repeat, CallFunc, nearestRotation} = require('game/engine/action/Action');

const MoveAction = ActionBuilder(
	({x, y}, value) => [[x, value.x ?? x + (value.dx ?? 0)], [y, value.y ?? y + (value.dy ?? 0)]],
	(target, [x, y]) => {target.x=x; target.y=y;}
);

const RotationAction = ActionBuilder(
	({rotation}, value) => [[rotation, nearestRotation(value.r ?? rotation + (value.dr ?? 0), rotation)]],
	(target, [v]) => target.rotation = v
);

const FaceToAction = ActionBuilder(
	({x, y, rotation}, value) => [[rotation, nearestRotation(Math.atan2(y - value.y, x - value.x) / Math.PI * 180, rotation)]],
	(target, [v]) => target.rotation = v
);

const FaceAndMoveAction = value => Sequence([
	FaceToAction({...value,speed:0.3}),
	MoveAction({...value,speed:1}),
])

const RunPathAction = ptlist => Repeat(Sequence([
	FaceAndMoveAction({x:150,y:200}),
	FaceAndMoveAction({x:300,y:400}),
	FaceAndMoveAction({x:500,y:200}),
	FaceAndMoveAction({x:700,y:400}),
	FaceAndMoveAction({x:900,y:200}),
	RotationAction({dr:90, speed:0.3}),
	MoveForwardAction({distance:200, speed:0.4}),
	RotationAction({dr:90, speed:0.3}),
	MoveForwardAction({distance:200, speed:0.4}),
	RotationAction({dr:90, speed:0.3}),
	MoveForwardAction({distance:200, speed:0.4}),
	RotationAction({dr:90, speed:0.3}),
	MoveForwardAction({distance:200, speed:0.4}),
]))

const MoveForwardAction = ActionBuilder(
	({x, y, rotation}, {distance}) => {
		const angle = rotation / 180 * Math.PI;
		const dx = distance * Math.cos(angle);
		const dy = distance * Math.sin(angle);
		return [[x, x - dx],[y, y - dy]];
	},
	(target, [x, y]) => {target.x=x; target.y=y;}
);

const FollowPathAction = (pathList, loop=true, pathThreshold=20) => function*(target){
	const {position} = target;
	if(loop){
		for(;;)
		for(let wayPoint of pathList){
			while(position.distance(wayPoint) > pathThreshold){
				yield target.seek(wayPoint);
			}
		}
	}else{
		for(let i=0, n=pathList.length; i<n; ++i){
			let wayPoint = pathList[i];
			if(i < n-1){
				while(position.distance(wayPoint) > pathThreshold)yield target.seek(wayPoint);
			}else{
				yield* ArriveAction(wayPoint)(target);
			}
		}
	}
}

const WanderAction = ({
	wanderDistance = 10,
	wanderRadius = 5,
	wanderRange = 1,
	wanderAngle = 0
}) => function*(target){
	const {steeringForce, velocity} = target;
	for(;;){
		steeringForce.add(velocity.normalize(null).multiply(wanderDistance));
		steeringForce.add(Vector2D.Polar(wanderRadius, wanderAngle));
		wanderAngle += wanderRange * (Math.random() - 0.5);
		yield;
	}
}


const PursueAction = other => SeekAction(target => other.position.add(target.getLookAheadOffset(other), null));
const EvadeAction = other => FleeAction(target => other.position.subtract(target.getLookAheadOffset(other), null));

const SeekAction = positionFn => function*(target){
	for(;;){
		yield target.seek(positionFn(target));
	}
};

const FleeAction = positionFn => function*(target){
	for(;;){
		yield target.steeringForce.subtract(target.getSeekSteerForce(positionFn(target)));
	}
};

const ArriveAction = wayPoint => function*(target){
	const {position} = target;
	while(position.distance(wayPoint) > 1)yield target.seek(wayPoint, 200);
	target.velocity.setTo(0, 0);
	target.position.copyFrom(wayPoint);
};


function forEverDo(handler, self){
	requestAnimationFrame(function fn(){
		requestAnimationFrame(fn);
		handler.call(self);
	});
}

class Scene extends DisplayObject2D
{
	constructor(ctx){
		super();
		this.ctx = ctx;
		this.clearFlag = true;
		forEverDo(this.onLoop, this);
		this.updateTree = walkTree(item => item.onUpdate?.());
		this.updateTransformTree = walkTree(item => {
			if(item.parent){
				item.transform.append(item.parent.worldTransform, item.worldTransform);
			}else{
				item.worldTransform.copyFrom(item.transform);
			}
		});
		this.drawTree = walkTree(item => item.onDraw?.(ctx));
	}

	onLoop(){
		const {ctx, clearFlag} = this;
		const {canvas} = ctx;
		if(clearFlag){
			ctx.resetTransform();//this affect clearRect
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}
		this.updateTree(this)
		this.updateTransformTree(this)
		this.drawTree(this)
	}
}

class Shape extends DisplayObject2D
{
	constructor(radius=10, fill='red'){
		super();
		this.radius = 10;
		this.fill = fill;
	}

	onDraw(ctx){
		const {width, height, originX, originY, radius} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.fillStyle = this.fill;
		ctx.beginPath();
		ctx.arc(0, 0, radius, 0, 2 * Math.PI);
		ctx.fill();
	}
}

class Text extends DisplayObject2D
{
	constructor(text='', fill='red'){
		super();
		this.fill = fill;
		this.text = text;
	}

	onDraw(ctx){
		const {width, height, originX, originY, radius} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.fillStyle = this.fill;
		ctx.font = '30px 宋体';
		ctx.fillText(this.text, 0, 0);
	}
}

class Bitmap extends DisplayObject2D
{
	constructor(texture, originX=0, originY=0){
		super();
		this.texture = texture;
		this.originX = originX;
		this.originY = originY;
		this.width = texture.width;
		this.height = texture.height;
	}

	runAction(action){
		return runAction(this, action);
	}

	onDraw(ctx){
		const {width, height, originX, originY, texture} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.drawImage(texture, -originX * width, -originY * height, width, height);
	}

	hitTestCircle(center, radius){
		return Math.hypot(this.x - center.x, this.y - center.y) <= radius;
		/*
		const {ctx} = this.root;
		ctx.resetTransform();
		return ctx.isPointInPath(area, this.x, this.y);
		*/
	}
}

class Vehicle extends Bitmap
{
	constructor(texture, originX=0, originY=0){
		super(texture, originX, originY);
		this.position = new Vector2D();
		this.velocity = new Vector2D();
		this.maxSpeed = 10;
		this.mass = 1;
		this.maxForce = 1;
		this.steeringForce = new Vector2D();
	}

	getSeekSteerForce(destPosition, arrivalThreshold){
		const {maxSpeed, velocity, position} = this;
		const desiredVelocity = destPosition.subtract(position, null);
		const ratio = arrivalThreshold ? Math.min(1, desiredVelocity.length / arrivalThreshold) : 1;
		return desiredVelocity.normalize().multiply(maxSpeed * ratio).subtract(velocity);
	}

	getLookAheadOffset({position, velocity}){
		let lookAheadTime = position.distance(this.position) / this.maxSpeed;
		return velocity.multiply(lookAheadTime, null);
	}

	seek(destPosition, arrivalThreshold){
		this.steeringForce.add(this.getSeekSteerForce(destPosition, arrivalThreshold));
	}

	onUpdate(){
		//return
		const {steeringForce, maxForce, velocity, position} = this;

		steeringForce.truncate(maxForce).divide(this.mass);
		velocity.add(steeringForce).truncate(this.maxSpeed);
		steeringForce.setTo(0, 0);
		position.add(velocity);
		
		//this.wrap();
		this.bounce();
		
		this.x = position.x;
		this.y = position.y;
		if(velocity.length > 0.01){
			this.rotation = velocity.angle / Math.PI * 180 - 180;
		}
	}

	wrap(){
		const position = this.position;
		const stage = this.root;
		if(position.x > stage.stageWidth) position.x = 0;
		if(position.x < 0) position.x = stage.stageWidth;
		if(position.y > stage.stageHeight) position.y = 0;
		if(position.y < 0) position.y = stage.stageHeight;
	}
		
		bounce(){
			const position = this.position;
			const stage = this.root;
			const velocity = this.velocity
			if(position.x > stage.stageWidth){
				position.x = stage.stageWidth;
				velocity.x *= -1;
			}else if(position.x < 0){
				position.x = 0;
				velocity.x *= -1;
			}
			if(position.y > stage.stageHeight){
				position.y = stage.stageHeight;
				velocity.y *= -1;
			}else if(position.y < 0){
				position.y = 0;
				velocity.y *= -1;
			}
		}

		

		

		
}

async function main(){

	const root = new Scene(canvas.getContext('2d', {alpha:false}));
	root.clearFlag = true;
	root.stageWidth = canvas.width
	root.stageHeight = canvas.height
/*
	root.addChild(Object.assign(new Bitmap(document.getElementById('bg')), {
		width: canvas.width,
		height: canvas.height
	}));
*/

	function createCar(x,y,speed){
		let carImage = new Vehicle(document.getElementById('car'), 0.5, 0.5);
		carImage.position.setTo(x,y)
		carImage.width = 50
		carImage.height =38
		carImage.maxSpeed = speed
		return carImage
	}
	let heroCar = function(){
		let carImage = new Bitmap(document.getElementById('car'), 0.5, 0.5);
		carImage.width = 50
		carImage.height =38
		return carImage
	}()
	root.addChild(heroCar);


	let carList = [createCar(
		Math.random() * canvas.width,
		Math.random() * canvas.height,
		5*Math.random() + 5
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			5*Math.random() + 5
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
	]
	carList.forEach(carImage => root.addChild(carImage));

	const label = root.addChild(Object.assign(new Text('hello'), {
		x:0,
		y:100
	}));
	//isPointInPath
void function(){

	let promise = heroCar.runAction(RunPathAction())
}()


	canvas.addEventListener('click', evt => {
		console.log('click',evt.offsetX, evt.offsetY);
		//carImage.seek(new Vector2D(offsetX, offsetY))
		//carImage.faceTo(offsetX, offsetY,300);
		//carImage.rotation = new Vector2D(offsetX, offsetY).subtract(carImage.position).angle
	})
//*
	let lastOP;
	canvas.addEventListener('mousedown',evt => {
		let offsetX = evt.offsetX;
		let offsetY = evt.offsetY;
		lastOP?.cancel()
		lastOP = carList[5].runAction(ArriveAction(new Vector2D(offsetX, offsetY)))
	})
//*
	carList[0].runAction(SeekAction(() => carList[1].position))
	carList[0].addChild(new Text('Seek'))
	carList[1].runAction(FleeAction(() => carList[0].position))
	carList[1].addChild(new Text('Flee'))
	//*/
//*
	carList[2].runAction(PursueAction(carList[3]))
	carList[2].addChild(new Text('Pursue'))
	carList[3].runAction(EvadeAction(carList[2]))
	carList[3].addChild(new Text('Evade'))

	carList[4].addChild(new Text('follow'))
	carList[4].runAction(FollowPathAction([
		new Vector2D(100,100),
		new Vector2D(600,100),
		new Vector2D(500,500),
		new Vector2D(100,100),
	]))
//*/
}

window.addEventListener('load', main);//DOMContentLoaded
