'use strict';

/*
const canvas = document.createElement('canvas');
document.body.appendChild(canvas);
DOMMatrix
DOMPoint
DOMQuad
DOMRect
DOMRectList
*/
//const bitmaprenderer = canvas.getContext('bitmaprenderer');

const {Tween} = require('utils/tween');
const DisplayObject2D = require('webgpu/DisplayObject2D');
const traverseTree = require('utils/traverseTree');

function forEverDo(handler, self){
	requestAnimationFrame(function fn(){
		requestAnimationFrame(fn);
		handler.call(self);
	});
}

class Scene extends DisplayObject2D
{
	constructor(ctx){
		super();
		this.ctx = ctx;
		this.clearFlag = true;
		forEverDo(this.onLoop, this);
	}

	onLoop(){
		const {ctx, clearFlag} = this;
		const {canvas} = ctx;
		if(clearFlag){
			ctx.resetTransform();//this affect clearRect
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}
		DisplayObject2D.updateWorldTransform(this);
		traverseTree(this, item => item.onDraw?.(ctx));
	}
}

class Shape extends DisplayObject2D
{
	constructor(radius=10, fill='red'){
		super();
		this.radius = 10;
		this.fill = fill;
	}

	onDraw(ctx){
		return
		const {width, height, originX, originY, radius} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.fillStyle = this.fill;
		ctx.beginPath();
		ctx.arc(0, 0, radius, 0, 2 * Math.PI);
		ctx.fill();
	}
}

class Text extends DisplayObject2D
{
	constructor(text='', fill='red'){
		super();
		this.fill = fill;
		this.text = text;
	}

	onDraw(ctx){
		const {width, height, originX, originY, radius} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.fillStyle = this.fill;
		ctx.font = '50px 宋体';
		ctx.fillText(this.text, 0, 0);
	}
}

class Bitmap extends DisplayObject2D
{
	constructor(texture, originX=0, originY=0){
		super();
		this.texture = texture;
		this.originX = originX;
		this.originY = originY;
		this.width = texture.width;
		this.height = texture.height;
	}

	onDraw(ctx){
		const {width, height, originX, originY, texture} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.drawImage(texture, -originX * width, -originY * height, width, height);
	}

	faceTo(x, y, speed){
		return new Promise(resolve => {
			let rotation = Math.atan2(this.y - y, this.x - x) / Math.PI * 180;
			let diff;
			for(;;){
				diff = Math.abs(this.rotation - rotation);
				if(diff <= 180)break;
				if(rotation > this.rotation){
					rotation -= 360;
				}else{
					rotation += 360;
				}
			}
			const time = 1000 * diff / speed;
			new Tween(this, time, {rotation}, null, resolve).start();
		});
	}

	moveTo(x, y, speed){
		return new Promise(resolve => {
			const len = Math.hypot(this.x - x, this.y - y);
			const time = 1000 * len / speed;
			new Tween(this, time, {x, y}, null, resolve).start();
		});
	}

	hitTestCircle(center, radius){
		return Math.hypot(this.x - center.x, this.y - center.y) <= radius;
		/*
		const {ctx} = this.root;
		ctx.resetTransform();
		return ctx.isPointInPath(area, this.x, this.y);
		*/
	}
}

class Item extends Bitmap
{
	constructor(fromPt, scorePt){
		super(document.getElementById('item'), 0.5, 0.5);
		this.width = 40;
		this.height = 40;
		this.x = fromPt[0];
		this.y = fromPt[1];
		this.scorePt = scorePt;
	}
}

async function main(){

	const root = new Scene(canvas.getContext('2d', {alpha:false}));
	root.clearFlag = false;

	root.addChild(Object.assign(new Bitmap(document.getElementById('bg')), {
		width: canvas.width,
		height: canvas.height
	}));



	let carImage = new Bitmap(document.getElementById('car'), 0.5, 0.5);
	carImage.x = 770
	carImage.y = 540
	carImage.width = 200
	carImage.height =150
	carImage.goTo = function(x, y){
		return this.faceTo(x, y, 300).then(() => this.moveTo(x, y, 400));
	}
	root.addChild(carImage);

	const label = root.addChild(Object.assign(new Text('hello'), {
		x:0,
		y:100
	}));
	//isPointInPath



	const redList = [
		[632,533],
		[632,412],
		[247,412],
		[247,533],
		[115,533],
		[115,174],
		[250,174],
		[250,315],
		[250,50],
		[400,170],
		[1026,171],
		[1026,302],
		[1148,304],
		[1148,167],
		[1024,532],
		[875,532],
	];

	const itemList = [
		root.addChild(new Item(redList[7], 8)),
		root.addChild(new Item(redList[12], 13)),
	];

	const ptList = [
		{op:'move', pt:0},
		{op:'move', pt:1},
		{op:'move', pt:2},
		{op:'move', pt:3},
		{op:'move', pt:4},
		{op:'move', pt:5},
		{op:'move', pt:6},
		{op:'move', pt:7},
		{op:'pickup'},
		{op:'move', pt:8},
		{op:'drop'},
		{op:'move', pt:6},
		{op:'move', pt:9},
		{op:'move', pt:10},
		{op:'move', pt:11},
		{op:'move', pt:12},
		{op:'pickup'},
		{op:'move', pt:11},
		{op:'move', pt:10},
		{op:'move', pt:13},
		{op:'drop'},
		{op:'move', pt:10},
		{op:'move', pt:14},
		{op:'move', pt:15},
	];

	const circleList = redList.map(v => root.addChild(Object.assign(new Shape(), {x:v[0], y:v[1]})))
	//*

	forEverDo(() => {
		for(let circle of circleList){
			if(circle.arrived)continue;
			if(carImage.hitTestCircle(circle, circle.radius)){
				circle.arrived = true;
			}
		}
		
	});
	function calcScore(){
		let score = circleList.reduce((total, v) => total + (v.arrived ? 5 : 0), 0);
		score += itemList.reduce((total, v) => total + (v.hitTestCircle({x:redList[v.scorePt][0],y:redList[v.scorePt][1]}, 20) ? 10 : 0), 0)
		return score;
	}

	for(const {op, pt} of ptList){
		if(op == 'move'){
			await carImage.goTo(...redList[pt]);
		}else if(op == 'pickup'){
			let item = itemList.find(item => carImage.hitTestCircle(item, 20))
			if(item){
				carImage.addChild(item);
				item.x = item.y = 0;
			}
		}else if(op == 'drop'){
			if(carImage.numChildren > 0){
				let item = carImage.removeChildAt(0);
				item.x = carImage.x;
				item.y = carImage.y;
				carImage.parent.addChild(item);
			}
		}
		label.text = '总分:' + calcScore();
	}
	//*/
	

	canvas.addEventListener('click', evt => {
		console.log('click',evt.offsetX, evt.offsetY);
	})
}

window.addEventListener('load', main);//DOMContentLoaded
