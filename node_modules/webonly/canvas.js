'use strict';

/*
const canvas = document.createElement('canvas');
document.body.appendChild(canvas);
DOMMatrix
DOMPoint
DOMQuad
DOMRect
DOMRectList
*/
//const bitmaprenderer = canvas.getContext('bitmaprenderer');

const {Tween} = require('utils/tween');
const DisplayObject2D = require('webgpu/DisplayObject2D');
const Vector2D = require('webgpu/math/Vector2D');
const {walkTree} = require('utils/traverseTree');

function forEverDo(handler, self){
	requestAnimationFrame(function fn(){
		requestAnimationFrame(fn);
		handler.call(self);
	});
}

class Scene extends DisplayObject2D
{
	constructor(ctx){
		super();
		this.ctx = ctx;
		this.clearFlag = true;
		forEverDo(this.onLoop, this);
		this.updateTree = walkTree(item => item.onUpdate?.());
		this.updateTransformTree = walkTree(item => {
			if(item.parent){
				item.transform.append(item.parent.worldTransform, item.worldTransform);
			}else{
				item.worldTransform.copyFrom(item.transform);
			}
		});
		this.drawTree = walkTree(item => item.onDraw?.(ctx));
	}

	onLoop(){
		const {ctx, clearFlag} = this;
		const {canvas} = ctx;
		if(clearFlag){
			ctx.resetTransform();//this affect clearRect
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}
		this.updateTree(this)
		this.updateTransformTree(this)
		this.drawTree(this)
	}
}

class Shape extends DisplayObject2D
{
	constructor(radius=10, fill='red'){
		super();
		this.radius = 10;
		this.fill = fill;
	}

	onDraw(ctx){
		const {width, height, originX, originY, radius} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.fillStyle = this.fill;
		ctx.beginPath();
		ctx.arc(0, 0, radius, 0, 2 * Math.PI);
		ctx.fill();
	}
}

class Text extends DisplayObject2D
{
	constructor(text='', fill='red'){
		super();
		this.fill = fill;
		this.text = text;
	}

	onDraw(ctx){
		const {width, height, originX, originY, radius} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.fillStyle = this.fill;
		ctx.font = '50px 宋体';
		ctx.fillText(this.text, 0, 0);
	}
}

class Bitmap extends DisplayObject2D
{
	constructor(texture, originX=0, originY=0){
		super();
		this.texture = texture;
		this.originX = originX;
		this.originY = originY;
		this.width = texture.width;
		this.height = texture.height;
	}

	onDraw(ctx){
		const {width, height, originX, originY, texture} = this;
		const {a,b,c,d,tx,ty} = this.worldTransform;
		ctx.setTransform(a, b, c, d, tx, ty);
		ctx.drawImage(texture, -originX * width, -originY * height, width, height);
	}

	faceTo2(rotation, speed){
		let diff;
		for(;;){
			diff = Math.abs(this.rotation - rotation);
			if(diff <= 180)break;
			if(rotation > this.rotation){
				rotation -= 360;
			}else{
				rotation += 360;
			}
		}
		const time = 1000 * diff / speed;
		return new Tween(this, time, {rotation}).start();
	}

	faceTo(x, y, speed){
		return this.faceTo2(Math.atan2(this.y - y, this.x - x) / Math.PI * 180, speed);
	}

	moveTo(x, y, speed){
		const len = Math.hypot(this.x - x, this.y - y);
		const time = 1000 * len / speed;
		return new Tween(this, time, {x, y}).start();
	}

	goTo(x, y){
		return this.faceTo(x, y, 300).then(() => this.moveTo(x, y, 400));
	}

	moveForward(distance, speed){
		const angle = this.rotation / 180 * Math.PI;
		const dx = distance * Math.cos(angle);
		const dy = distance * Math.sin(angle);
		return this.moveTo(this.x - dx, this.y - dy, speed);
	}

	turn(value, speed){
		return this.faceTo2(this.rotation + value, speed);
	}

	turnLeft(speed){
		return this.turn(-90, speed);
	}

	turnRight(speed){
		return this.turn(90, speed);
	}

	hitTestCircle(center, radius){
		return Math.hypot(this.x - center.x, this.y - center.y) <= radius;
		/*
		const {ctx} = this.root;
		ctx.resetTransform();
		return ctx.isPointInPath(area, this.x, this.y);
		*/
	}
}

class Vehicle extends Bitmap
{
	constructor(texture, originX=0, originY=0){
		super(texture, originX, originY);
		this.position = new Vector2D();
		this.velocity = new Vector2D();
		this.maxSpeed = 10;
		this.mass = 1;
		this.maxForce = 1;
		this.steeringForce = new Vector2D();
	}

	getSeekSteerForce(target){
		const {maxSpeed, velocity, position} = this;
		let desiredVelocity = target.subtract(position, null);
		return desiredVelocity.normalize().multiply(maxSpeed).subtract(velocity);
	}

	seek(target){
		this.steeringForce.add(this.getSeekSteerForce(target));
	}

	flee(target){
		this.steeringForce.subtract(this.getSeekSteerForce(target));
	}

	onUpdate(){
		//return
		const {steeringForce, maxForce, velocity, position} = this;

		steeringForce.truncate(maxForce).divide(this.mass);
		velocity.add(steeringForce).truncate(this.maxSpeed);
		steeringForce.setTo(0, 0);
		position.add(velocity);
		
		//this.wrap();
		this.bounce();
		
		this.x = position.x;
		this.y = position.y;
		if(velocity.length > 0.01){
			this.rotation = velocity.angle / Math.PI * 180 - 180;
		}
	}

	wrap(){
		const position = this.position;
		const stage = this.root;
		if(position.x > stage.stageWidth) position.x = 0;
		if(position.x < 0) position.x = stage.stageWidth;
		if(position.y > stage.stageHeight) position.y = 0;
		if(position.y < 0) position.y = stage.stageHeight;
	}
		
		bounce(){
			const position = this.position;
			const stage = this.root;
			const velocity = this.velocity
			if(position.x > stage.stageWidth){
				position.x = stage.stageWidth;
				velocity.x *= -1;
			}else if(position.x < 0){
				position.x = 0;
				velocity.x *= -1;
			}
			if(position.y > stage.stageHeight){
				position.y = stage.stageHeight;
				velocity.y *= -1;
			}else if(position.y < 0){
				position.y = 0;
				velocity.y *= -1;
			}
		}

		getLookAheadOffset(target){
			var lookAheadTime = this.position.distance(target.position) / this.maxSpeed;
			return target.velocity.multiply(lookAheadTime,null);
		}

		pursue(target){
			this.seek(target.position.add(this.getLookAheadOffset(target),null));
		}
		
		evade(target){
			this.flee(target.position.subtract(this.getLookAheadOffset(target),null));
		}

		arrive(target)
		{
			const arrivalThreshold = 200;
			const {steeringForce, maxSpeed, velocity, position} = this;
			const desiredVelocity = target.subtract(position,null);
			desiredVelocity.length = maxSpeed * Math.min(1, desiredVelocity.length / arrivalThreshold);
			steeringForce.add(desiredVelocity.subtract(velocity));
		}
}

function createWander(){
	const wanderDistance = 10;
	const wanderRadius = 5;
	const wanderRange = 1
	let wanderAngle = 0;
	return function(){
		const {steeringForce, velocity} = this;
		steeringForce.add(velocity.normalize(null).multiply(wanderDistance));
		steeringForce.add(Vector2D.Polar(wanderRadius, wanderAngle));
		wanderAngle += wanderRange * (Math.random() - 0.5);
	}
}

function createPathInfo(path, loop=true, index=0){
	const pathThreshold = 20;
	return function(){
		const {position} = this;
		const wayPoint = path[index];
		if(position.distance(wayPoint) <= pathThreshold){
			if(index < path.length - 1){
				++index;
			}else if(loop){
				index = 0;
			}
		}
		if(loop || index < path.length - 1){
			this.seek(wayPoint);
		}else{
			this.arrive(wayPoint);
		}
	}
}

/*
class Item extends Bitmap
{
	constructor(fromPt, scorePt){
		super(document.getElementById('item'), 0.5, 0.5);
		this.width = 40;
		this.height = 40;
		this.x = fromPt[0];
		this.y = fromPt[1];
		this.scorePt = scorePt;
	}
}
*/
async function main(){

	const root = new Scene(canvas.getContext('2d', {alpha:false}));
	root.clearFlag = true;
	root.stageWidth = canvas.width
	root.stageHeight = canvas.height
/*
	root.addChild(Object.assign(new Bitmap(document.getElementById('bg')), {
		width: canvas.width,
		height: canvas.height
	}));
*/

	function createCar(x,y,speed){
		let carImage = new Vehicle(document.getElementById('car'), 0.5, 0.5);
		carImage.position.setTo(x,y)
		carImage.width = 50
		carImage.height =38
		carImage.maxSpeed = speed
		return carImage
	}


	let carList = [createCar(
		Math.random() * canvas.width,
		Math.random() * canvas.height,
		5*Math.random() + 5
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			5*Math.random() + 5
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		),
		createCar(
			Math.random() * canvas.width,
			Math.random() * canvas.height,
			10*Math.random() + 10
		)
	]
	carList.forEach(carImage => root.addChild(carImage))
	;

	const label = root.addChild(Object.assign(new Text('hello'), {
		x:0,
		y:100
	}));
	//isPointInPath



	canvas.addEventListener('click', evt => {
		console.log('click',evt.offsetX, evt.offsetY);
		//carImage.seek(new Vector2D(offsetX, offsetY))
		//carImage.faceTo(offsetX, offsetY,300);
		//carImage.rotation = new Vector2D(offsetX, offsetY).subtract(carImage.position).angle
	})
//*
	let offsetX=0,offsetY=0
	canvas.addEventListener('mousedown',evt => {
		offsetX = evt.offsetX;
		offsetY = evt.offsetY;
		//carList[0].seek(new Vector2D(offsetX, offsetY))
		//carList[1].flee(new Vector2D(offsetX, offsetY))
		//carList[0].seek(carList[1].position)
		//carList[1].flee(carList[0].position)
		
	})
//*//
	carList[6].followPath = createPathInfo([
			new Vector2D(150,200),
			new Vector2D(300,400),
			new Vector2D(500,200),
			new Vector2D(700,400),
			new Vector2D(900,200),
		],false);

	carList[5].wander = createWander();
	forEverDo(()=>{
		//*
		carList[0].seek(carList[1].position)
		carList[1].flee(carList[0].position)
		carList[2].pursue(carList[3])
		carList[3].evade(carList[2])
		//*/
		carList[4].arrive(new Vector2D(offsetX, offsetY))

		carList[5].wander();
		carList[6].followPath()
	}) 

}

window.addEventListener('load', main);//DOMContentLoaded
