
const {waitWhen} = require('utils/events');
const retry = require('utils/function/retry');
const zlib = require('zlib');
const crypto = require('crypto');

const codeText = require('./ESP32_bin');
const codeData = Buffer.from('CMD8Pw==', 'base64');

const {delay, ints_to_buffer, align_data, encode_c0db, checker_c0db} = require('./helper');


	async function reset(serial, dtr){
		await serial.setControlSignals({dtr:false, rts:true});
		await serial.setControlSignals({dtr, rts:false});
	}

	async function upload(serial, data, offset=0x1000, progressFn=null){
		try{
			await sync(serial, Buffer.alloc(36, 0x55));
			await write_stub(serial);
			await write_flash(serial, data, offset, progressFn);
			await check_flash_md5(serial, data, offset);
		}finally{
			await reset(serial, false);
		}
	}

	async function sync(serial, data){
		await reset(serial, true);
		await delay(20);
		await retry(() => send_cmd(serial, 8, data, 20), 7);
		await delay(100);
	}

	function recv(serial, timeout=1000){
		return waitWhen(serial, 'data', timeout, checker_c0db());
	}
/*
	function read_reg(address){
		return this.send_cmd(0xA, ints_to_buffer(address)).then(v => v[0]);
	}

	function write_reg(address, value){
		return this.send_cmd(0x9, ints_to_buffer(address, value, 0xFFFFFFFF, 0));
	}
*/
	async function check_flash_md5(serial, data, offset){
		const timeout = Math.max(3000, 8000 * data.length / 0x100000);//speed=8s/M
		const result = await send_cmd(serial, 0x13, ints_to_buffer(offset, data.length, 0, 0), timeout);
		const md5_old = crypto.createHash('md5').update(data).digest('hex');
		const md5_new = result[1].slice(0, 16).map(v => v.toString(16).padStart(2, '0')).join('');
		console.assert(md5_old === md5_new);
	}
/*
	async function change_bitrate(bitrate){
		await this.send_cmd(0xF, ints_to_buffer(bitrate, this.bitrate));
		await delay(1000)
		//await this.update(bitrate);
		//return
		await this.disconnect();
		await delay(50);
		await this.connect(this.port, bitrate);
	}
*/
	async function write_dataframe(serial, cmd, frameSize, data, progressFn=null){
		const blockCount = Math.ceil(data.length / frameSize);
		for(let i=0; i<blockCount; ++i){
			const packet = data.slice(frameSize * i, frameSize * (i + 1));
			const payload = Buffer.concat([ints_to_buffer(packet.length, i, 0, 0), packet]);
			await send_cmd(serial, cmd, payload);
			progressFn?.((frameSize * i + packet.length) / data.length);
		}
	}

	async function write_stub(serial){
		const ESP_RAM_BLOCK = 0x1800;
		await send_cmd(serial, 5, ints_to_buffer(codeText.length, Math.ceil(codeText.length / ESP_RAM_BLOCK), ESP_RAM_BLOCK, 0x400be000));
		await write_dataframe(serial, 7, ESP_RAM_BLOCK, codeText);
		await send_cmd(serial, 5, ints_to_buffer(codeData.length, Math.ceil(codeData.length / ESP_RAM_BLOCK), ESP_RAM_BLOCK, 0x3ffdeba8));
		await write_dataframe(serial, 7, ESP_RAM_BLOCK, codeData);
		await send_cmd(serial, 6, ints_to_buffer(0, 0x400be598));
		console.assert(Buffer.from(await recv(serial)).toString() == 'OHAI');
	}

	async function write_flash(serial, data, offset, progressFn=null){
		const FLASH_WRITE_SIZE = 0x4000;
		data = align_data(data, 4, 0xFF);
		const old_size = data.length;
		data = zlib.deflateSync(data, {level:9});
		await send_cmd(serial, 0x10, ints_to_buffer(old_size, Math.ceil(data.length / FLASH_WRITE_SIZE), FLASH_WRITE_SIZE, offset));
		await write_dataframe(serial, 0x11, FLASH_WRITE_SIZE, data, progressFn);
		await send_cmd(serial, 0x12, ints_to_buffer(1));//0==reboot
	}


const send_cmd = function(){
	function checksum(data, offset){
		let result = 0xEF;
		for(let i=offset, n=data.length; i<n; ++i){
			result ^= data[i];
		}
		return result;
	}
	return async function(serial, op, data, timeout=1000){
		const head = ints_to_buffer(op << 8 | data.length << 16, checksum(data, 16));
		await serial.send_buffer(encode_c0db(Buffer.concat([head, data])));
		const result = await recv(serial, timeout);
		console.assert(result.length === 8 + (result[2] | result[3] << 8));
		if(result[0] == 1 && result[1] == op){
			return [Buffer.from(result).readUInt32LE(4), result.slice(8)];
		}
		return Promise.reject();
	}
}();

exports.upload = upload;
