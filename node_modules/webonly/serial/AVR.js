'use strict';

const {composeFactory} = require('net/packet');
const {LoopRange} = require('utils/counter');
const {delay} = require('./helper');

function isEqual(source, target, length, sourceOffset, targetOffest){
	for(let i=0; i<length; ++i){
		if(source[sourceOffset + i] != target[targetOffest + i]){
			return false;
		}
	}
	return true;
}

const writeFactory = (pageSize, addressFn, sendFn, onWrite) => async function(serial, payload, progressFn){
	for(let address=0, total=payload.length; address < total;){
		const bytesSend = Math.min(pageSize, total - address);
		await sendFn(serial, addressFn(address));
		await sendFn(serial, onWrite(payload.slice(address, address + bytesSend)));
		address += bytesSend;
		progressFn(address / total);
	}
}

const readFactory = (pageSize, addressFn, sendFn, onRead) => async function(serial, payload, progressFn){
	for(let address=0, total=payload.length; address < total;){
		const bytesSend = Math.min(pageSize, total - address);
		await sendFn(serial, addressFn(address));
		const [packet, stripFn] = onRead(bytesSend);
		const data = await sendFn(serial, packet, bytesSend).then(stripFn);
		if(!isEqual(payload, data, bytesSend, address, 0))return false;
		address += bytesSend;
		progressFn(address / total);
	}
	return true;
}

/*
payload = array
resetFn = () => Promise<Void>
sendFn = (array, recvCount=0) => Promise<Array>
progressFn = (percent) => Void
//*/
function uploadFactory(pageSize, encoder, checker, onEnter, onLeave, addressFn, onWrite, onRead){
	async function sendFn(serial, value, recvCount=0){
		await serial.send_buffer(encoder(value));
		return await waitWhen(serial, 'data', 500, checker([], recvCount));
	}
	const doWrite = writeFactory(pageSize, addressFn, sendFn, onWrite);
	const doRead = readFactory(pageSize, addressFn, sendFn, onRead);
	return async function(serial, payload, progressFn, verifyFlag=false){
		let success;
		await serial.setControlSignals({dtr:false});
		await serial.setControlSignals({dtr:true});
		await delay(400);
		await sendFn(serial, onEnter);
		if(verifyFlag){
			await doWrite(serial, payload, v => progressFn(0.5 * v));
			success = await doRead(serial, payload, v => progressFn(0.5 * (v + 1)));
		}else{
			await doWrite(serial, payload, progressFn);
			success = true;
		}
		await sendFn(serial, onLeave);
		return success;
	}
}

const upload328p = uploadFactory(
	0x80,
	v => Uint8Array.from(v),
	composeFactory(
		(v, buffer) => buffer.push(...new Uint8Array(v)),
		(v, recvCount) => v.length == 2 + recvCount && v[0] == 0x14 && v[1+recvCount] == 0x10,
		v => v.slice(1, -1)
	),
	[0x50, 0x20],
	[0x51, 0x20],
	address => [0x55, address >> 1 & 0xFF, address >> 9 & 0xFF, 0x20],
	data => [0x64, data.length >> 8, data.length & 0xFF, 0x46, ...data, 0x20],
	bytesSend => [[0x74, bytesSend >> 8, bytesSend & 0xFF, 0x46, 0x20]]
);

const uploadMega = (checksum => uploadFactory(
	0x100,
	(index => v => {
		const buffer = Uint8Array.of(0x1B, index(), v.length >> 8, v.length & 0xFF, 0x0E, ...v, 0);
		buffer[buffer.length-1] = checksum(buffer);
		return buffer;
	})(LoopRange(256)),
	composeFactory(
		(v, buffer) => buffer.push(...new Uint8Array(v)),
		v => v.length >= 6 && v[0] == 0x1B && v[4] == 0x0E && (v[2] << 8 | v[3]) == v.length - 6 && !checksum(v),
		v => v.slice(5, -1)
	),
	[0x10, 0xc8, 0x64, 0x19, 0x20, 0x00, 0x53, 0x03, 0xac, 0x53, 0x00, 0x00],
	[0x11, 0x01, 0x01],
	address => [0x06, 0x80, address >> 17 & 0xFF, address >> 9 & 0xFF, address >> 1 & 0xFF],
	data => [0x13, data.length >> 8, data.length & 0xFF, 0xc1, 0x0a, 0x40, 0x4c, 0x20, 0x00, 0x00, ...data],
	bytesSend => [[0x14, bytesSend >> 8, bytesSend & 0xFF, 0x20], v => v.slice(2, -1)]
))((f => v => v.reduce(f, 0))((s, v) => s ^ v));

exports.upload328p = upload328p;
exports.uploadMega = uploadMega;
