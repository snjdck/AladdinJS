'use strict';

const {composeFactory} = require('../net/packet');

const delay = v => new Promise(resolve => setTimeout(resolve, v * 1000));

function isEqual(source, target, length, sourceOffset, targetOffest){
	for(let i=0; i<length; ++i){
		if(source[sourceOffset + i] != target[targetOffest + i]){
			return false;
		}
	}
	return true;
}

const checker328p = function(){
	const checker = composeFactory(
		(v, buffer) => buffer.push(...new Uint8Array(v)),
		(buffer, recvCount) => (buffer.length == 2 + recvCount) && (buffer[0] == 0x14 && buffer[1+recvCount] == 0x10),
		buffer => buffer.slice(1, -1)
	);
	return recvCount => checker([], recvCount);
}();

const checkerMega = function(){
	const checker = composeFactory(
		(v, buffer) => buffer.push(...new Uint8Array(v)),
		buffer => (buffer.length >= 6) && (buffer[2] << 8 | buffer[3]) == buffer.length - 6,
		buffer => buffer.slice(5, -1)
	);
	return () => checker([]);
}();

const writeFactory = (pageSize, addressFn, onWrite) => async function(payload, sendFn, progressFn){
	for(let address=0, total=payload.length; address < total;){
		const bytesSend = Math.min(pageSize, total - address);
		await sendFn(addressFn(address));
		await sendFn(onWrite(payload.slice(address, address + bytesSend)));
		address += bytesSend;
		progressFn(address / total);
	}
}

const readFactory = (pageSize, addressFn, onRead) => async function(payload, sendFn, progressFn){
	for(let address=0, total=payload.length; address < total;){
		const bytesSend = Math.min(pageSize, total - address);
		await sendFn(addressFn(address));
		const data = await onRead(sendFn, bytesSend);
		if(!isEqual(payload, data, bytesSend, address, 0))return false;
		address += bytesSend;
		progressFn(address / total);
	}
	return true;
}

/*
payload = array
resetFn = () => Promise<Void>
sendFn = (array, recvCount=0) => Promise<Array>
progressFn = (percent) => Void
//*/
function uploadFactory(pageSize, onEnter, onLeave, addressFn, onWrite, onRead){
	const doWrite = writeFactory(pageSize, addressFn, onWrite);
	const doRead = readFactory(pageSize, addressFn, onRead);
	return async function(payload, resetFn, sendFn, progressFn, verifyFlag=false){
		let success;
		await resetFn();
		await delay(0.4);
		await sendFn(onEnter());
		if(verifyFlag){
			await doWrite(payload, sendFn, v => progressFn(0.5 * v));
			success = await doRead(payload, sendFn, v => progressFn(0.5 * (v + 1)));
		}else{
			await doWrite(payload, sendFn, progressFn);
			success = true;
		}
		await sendFn(onLeave());
		return success;
	}
}

const upload328p = uploadFactory(
	0x80,
	() => [0x50, 0x20],
	() => [0x51, 0x20],
	address => [0x55, address >> 1 & 0xFF, address >> 9 & 0xFF, 0x20],
	data => [0x64, data.length >> 8, data.length & 0xFF, 0x46, ...data, 0x20],
	(sendFn, bytesSend) => sendFn([0x74, bytesSend >> 8, bytesSend & 0xFF, 0x46, 0x20], bytesSend)
);

const uploadMega = (encode => uploadFactory(
	0x100,
	() => encode([0x10, 0xc8, 0x64, 0x19, 0x20, 0x00, 0x53, 0x03, 0xac, 0x53, 0x00, 0x00]),
	() => encode([0x11, 0x01, 0x01]),
	address => encode([0x06, 0x80, address >> 17 & 0xFF, address >> 9 & 0xFF, address >> 1 & 0xFF]),
	data => encode([0x13, data.length >> 8, data.length & 0xFF, 0xc1, 0x0a, 0x40, 0x4c, 0x20, 0x00, 0x00, ...data]),
	(sendFn, bytesSend) => sendFn(encode([0x14, bytesSend >> 8, bytesSend & 0xFF, 0x20])).then(v => v.slice(2, -1))
))(function(){
	const index = (v => () => v = v + 1 & 0xFF)(0);
	const checksum = v => v.reduce((s, v) => s ^ v, 0);
	return function(value){
		const buffer = Buffer.from([0x1B, index(), 0, 0, 0x0E, ...value, 0]);
		buffer.writeUInt16BE(value.length, 2);
		buffer.writeUInt8(checksum(buffer), buffer.length - 1);
		return buffer;
	}
}());

exports.checker328p = checker328p;
exports.checkerMega = checkerMega;
exports.upload328p = upload328p;
exports.uploadMega = uploadMega;
