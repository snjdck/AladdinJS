
const {composeFactory} = require('net/packet');

const delay = milliseconds => new Promise(resolve => setTimeout(resolve, milliseconds));

const ints_to_buffer = function(...ints){
	const count = ints.length;
	const buffer = Buffer.allocUnsafe(count << 2);
	for(let i=0; i<count; ++i){
		buffer.writeInt32LE(ints[i] | 0, i << 2);
	}
	return buffer;
};

const align_data = function(){
	const calcPad = (length, align) => (align - length % align) % align;
	return function(data, align, fill=0){
		const pad = calcPad(data.length, align);
		return pad > 0 ? Buffer.concat([data, Buffer.alloc(pad, fill)]) : data;
	}
}();

const encode_c0db = function(){
	function mapFn(v){
		if(v == 0xc0)return [0xdb, 0xdc];
		if(v == 0xdb)return [0xdb, 0xdd];
		return v;
	}
	return buffer => Buffer.from([0xc0, ...Array.from(buffer, mapFn).flat(), 0xc0]);
}();

const decode_c0db = function(){
	function reduceFn(result, v){
		const lastIndex = result.length - 1;
		if(result[lastIndex] != 0xdb){
			result.push(v);
		}else if(v == 0xdc){
			result[lastIndex] = 0xc0;
		}else if(v != 0xdd){
			result.push(v);
		}
		return result;
	}
	return list => list.reduce(reduceFn, []);
}();

const checker_c0db = function(){
	const replyFn = composeFactory(
		(v, buffer) => buffer.push(...Buffer.from(v)),
		buffer => buffer[0] == 0xc0 && buffer.indexOf(0xc0, 1) > 0,
		buffer => {
			const index = buffer.indexOf(0xc0, 1);
			return decode_c0db(buffer.slice(1, index));
		}
	);
	return () => replyFn([]);
}();

const value_checker = function(){
	const replyFn = composeFactory(
		(v, buffer) => buffer.push(...Buffer.from(v)),
		(buffer, f) => f(Buffer.from(buffer))
	);
	return f => replyFn([], f);
}();

const text_checker = f => value_checker(v => f(v.toString()));

exports.delay = delay;
exports.ints_to_buffer = ints_to_buffer;
exports.align_data = align_data;
exports.encode_c0db = encode_c0db;
exports.checker_c0db = checker_c0db;

exports.value_checker = value_checker;
exports.text_checker = text_checker;
