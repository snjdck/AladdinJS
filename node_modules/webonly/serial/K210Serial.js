
const ChromeSerial = require('webonly/chrome/ChromeSerial');
const {waitWhen} = require('utils/events');
const crypto = require('crypto');
const crc32 = require('fileformats/crc32');
const {delay, ints_to_buffer, align_data, encode_c0db, checker_c0db} = require('./helper');

const ISP_PROG = require('./K210_bin');

class Serial extends ChromeSerial
{
	async reset(rts=false){
		await this.setControlSignals({dtr:true, rts:false});
		await delay(20);
		await this.setControlSignals({dtr:false, rts});
		await delay(20);
	}

	async upload(data, offset=0, progressFn=null){
		await this.reset(true);
		await this.write_bootloader(progressFn);
		await this.change_bitrate(1500000);
		await this.write_flash(data, offset, progressFn);
		await this.update(115200);
		await this.reset();
	}

	async change_bitrate(bitrate){
		await this.send_cmd(0xd6, ints_to_buffer(0, 4, bitrate), -1);
		await delay(50);
		await this.update(bitrate);
	}

	async write_dataframe(cmd, frameSize, data, offset, progressFn=null){
		for(let i=0, n=data.length; i<n; i+=frameSize){
			const packet = data.slice(i, i+frameSize);
			const payload = Buffer.concat([ints_to_buffer(offset+i, packet.length), packet]);
			await this.send_cmd(cmd, payload);
			progressFn?.((i + packet.length) / data.length);
		}
	}

	async write_bootloader(progressFn=null){
		const address = 0x80000000;
		await this.write_dataframe(0xc3, 1024, ISP_PROG, address, progressFn);
		await this.send_cmd(0xc5, ints_to_buffer(address, 0), -1);//reboot
		await delay(50);
	}

	async write_flash(data, offset=0, progressFn=null){
		if(offset == 0){
			const dataNew = Buffer.concat([Buffer.alloc(5), data]);
			dataNew.writeUInt32LE(data.length, 1);
			const sha256 = crypto.createHash('sha256').update(dataNew).digest();
			data = Buffer.concat([dataNew, sha256]);
		}
		data = align_data(data, 4096);
		await this.send_cmd(0xd7, ints_to_buffer(1, 0));//chipType=1(on-board), 0(in-chip)
		await this.write_dataframe(0xd4, 65536, data, offset, progressFn);
	}

	async send_cmd(op, data, timeout=1000){
		const head = ints_to_buffer(op, crc32(data));
		await this.send_buffer(encode_c0db(Buffer.concat([head, data])));
		if(timeout < 0)return;
		const result = await waitWhen(this, 'data', timeout, checker_c0db());
		if(result.length === 2 && result[0] === op && result[1] === 0xE0)return;
		return Promise.reject();
	}
}

module.exports = Serial;