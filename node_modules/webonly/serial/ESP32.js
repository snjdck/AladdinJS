
const {waitWhen} = require('utils/events');
const retry = require('utils/function/retry');
const {to_frame} = require('utils/sender');
const zlib = require('zlib');
const crypto = require('crypto');

const codeText = require('./ESP32_bin');
const codeData = Buffer.from('CMD8Pw==', 'base64');

const {delay, ints_to_buffer, prependInts, align_data, encode_c0db, checker_c0db, value_checker} = require('./helper');

async function reset(serial, dtr){
	await serial.setControlSignals({dtr:false, rts:true});
	await serial.setControlSignals({dtr, rts:false});
}

async function upload(serial, data, offset=0x1000, progressFn=null){
	try{
		progressFn?.('sync');
		await sync(serial, Buffer.alloc(36, 0x55));
		progressFn?.('write_stub');
		await write_stub(serial);
		progressFn?.('erase_flash');
		await erase_flash(serial);
		progressFn?.('write_flash');
		await write_flash(serial, data, offset, progressFn);
		progressFn?.('check_flash_md5');
		await check_flash_md5(serial, data, offset);
	}finally{
		await reset(serial, false);
	}
}

async function sync(serial, data){
	await reset(serial, true);
	await waitWhen(serial, 'data', 50, value_checker(v => v.toString().endsWith('\r\nwaiting for download\r\n')));
	const signal = waitWhen(serial, 'data', 500, value_checker(v => v.length == 14 * 8));
	await retry(() => send_cmd(serial, 8, data, 20), 7);
	await signal;
}
/*
const read_reg = (serial, address) => send_cmd(serial, 0xA, ints_to_buffer(address));

async function change_bitrate(serial, bitrate){
	await send_cmd(serial, 0xF, ints_to_buffer(bitrate, 115200));
	await delay(50);
	await serial.update(bitrate);
}
*/
async function check_flash_md5(serial, data, offset){
	const timeout = Math.max(3000, 8000 * data.length / 0x100000);//speed=8s/M
	const result = await send_cmd(serial, 0x13, ints_to_buffer(offset, data.length, 0, 0), timeout);
	if(!Buffer.compare(Buffer.from(result), crypto.createHash('md5').update(data).digest()))return;
	return Promise.reject('flash verify failed');
}

async function write_dataframe(serial, cmd, frameSize, data, progressFn=null){
	for(let [payload, totalSize] of to_frame(data, frameSize, (v, i) => prependInts(v, v.length, i, 0, 0))){
		await send_cmd(serial, cmd, payload);
		progressFn?.(totalSize / data.length);
	}
}

async function write_stub(serial){
	const ESP_RAM_BLOCK = 0x1800;
	await send_cmd(serial, 5, ints_to_buffer(codeText.length, Math.ceil(codeText.length / ESP_RAM_BLOCK), ESP_RAM_BLOCK, 0x400be000));
	await write_dataframe(serial, 7, ESP_RAM_BLOCK, codeText);
	await send_cmd(serial, 5, ints_to_buffer(codeData.length, Math.ceil(codeData.length / ESP_RAM_BLOCK), ESP_RAM_BLOCK, 0x3ffdeba8));
	await write_dataframe(serial, 7, ESP_RAM_BLOCK, codeData);
	await send_cmd(serial, 6, ints_to_buffer(0, 0x400be598));
	if(Buffer.from(await recv(serial, 1000)).toString() == 'OHAI')return;
	return Promise.reject();
}

async function write_flash(serial, data, offset, progressFn=null){
	const FLASH_WRITE_SIZE = 0x4000;
	data = align_data(data, 4, 0xFF);
	const old_size = data.length;
	data = zlib.deflateSync(data, {level:9});
	await send_cmd(serial, 0x10, ints_to_buffer(old_size, Math.ceil(data.length / FLASH_WRITE_SIZE), FLASH_WRITE_SIZE, offset));
	await write_dataframe(serial, 0x11, FLASH_WRITE_SIZE, data, progressFn);
	await send_cmd(serial, 0x12, ints_to_buffer(1));//0==reboot
}

const erase_flash = serial => send_cmd(serial, 0xD0, Buffer.alloc(0), 20000);

const recv = (serial, timeout) => waitWhen(serial, 'data', timeout, checker_c0db());

const send_cmd = function(){
	const checksum = (f => data => data.slice(16).reduce(f, 0xEF))((s, v) => s ^ v);
	return async function(serial, op, data, timeout=1000){
		await serial.send_buffer(encode_c0db(prependInts(data, op << 8 | data.length << 16, checksum(data))));
		const result = await recv(serial, timeout);
		if(result.length < 8 || result[0] != 1 || result[1] != op || (result[2] | result[3] << 8) != result.length - 8){
			return Promise.reject();
		}
		if(op == 0x0A)return Buffer.from(result).readUInt32LE(4);//read_reg
		return result.slice(8, -2);
	}
}();

exports.upload = upload;
