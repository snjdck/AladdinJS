
const {waitWhen} = require('utils/events');
const retry = require('utils/function/retry');
const {to_frame} = require('utils/sender');
const zlib = require('zlib');
const crypto = require('crypto');

const stub = {
	"entry": 0x400BE5EC,
	"text": Buffer.from("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", 'base64'),
	"text_start": 0x400BE000,
	"data": Buffer.from("DMD8P+znC0B/6AtAZ+0LQAbpC0Cf6AtABukLQGXpC0CC6gtA9OoLQJ3qC0CV5wtAGuoLQHTqC0CI6QtAGOsLQLDpC0AY6wtAbegLQMroC0AG6QtAZekLQIXoC0DI6wtAKe0LQLjmC0BL7QtAuOYLQLjmC0C45gtAuOYLQLjmC0C45gtAuOYLQLjmC0Bv6wtAuOYLQEnsC0Ap7QtA", 'base64'),
	"data_start": 0x3FFDEBA8,
	"bss_start": 1073528832
}

const {delay, ints_to_buffer, prependInts, align_data, encode_c0db, checker_c0db, value_checker} = require('./helper');

async function reset(serial, dtr){
	await serial.setControlSignals({dtr:false, rts:true});
	await serial.setControlSignals({dtr, rts:false});
}

async function upload(serial, data, offset=0x1000, progressFn=null){
	const bitrate = 115200;
	const bitrate_fast = bitrate << 3;
	const useFastBitrate = offset == 0;
	data = align_data(data, 4, 0xFF);
	try{
		progressFn?.('sync');
		await sync(serial, Buffer.alloc(36, 0x55));
		progressFn?.('write_stub');
		await write_stub(serial);
		if(useFastBitrate){
			await send_cmd(serial, 0x0F, ints_to_buffer(bitrate_fast, bitrate));
			await serial.update(bitrate_fast);
		}
		progressFn?.('write_flash');
		await write_flash(serial, data, offset, progressFn);
		progressFn?.('check_flash_md5');
		await check_flash_md5(serial, data, offset);
	}finally{
		if(useFastBitrate){
			await serial.update(bitrate);
		}
		await reset(serial, false);
	}
}

async function sync(serial, data){
	await reset(serial, true);
	await waitWhen(serial, 'data', 50, value_checker(v => v.toString().endsWith('\r\nwaiting for download\r\n')));
	const signal = waitWhen(serial, 'data', 500, value_checker(v => v.length == 14 * 8));
	await retry(() => send_cmd(serial, 8, data, 20), 7);
	await signal;
}
/*
const read_reg = (serial, address) => send_cmd(serial, 0xA, ints_to_buffer(address));

async function change_bitrate(serial, bitrate){
	await send_cmd(serial, 0xF, ints_to_buffer(bitrate, 115200));
	await delay(50);
	await serial.update(bitrate);
}
*/
async function check_flash_md5(serial, data, offset){
	const timeout = Math.max(3000, 8000 * data.length / 0x100000);//speed=8s/M
	const result = await send_cmd(serial, 0x13, ints_to_buffer(offset, data.length, 0, 0), timeout);
	if(!Buffer.compare(Buffer.from(result), crypto.createHash('md5').update(data).digest()))return;
	return Promise.reject('flash verify failed');
}

async function write_dataframe(serial, cmd, frameSize, data, progressFn=null){
	for(let [payload, totalSize] of to_frame(data, frameSize, (v, i) => prependInts(v, v.length, i, 0, 0))){
		await send_cmd(serial, cmd, payload, 10000);
		progressFn?.(totalSize / data.length);
	}
}

async function write_stub(serial){
	const ESP_RAM_BLOCK = 0x1800;
	await send_cmd(serial, 5, ints_to_buffer(stub.text.length, Math.ceil(stub.text.length / ESP_RAM_BLOCK), ESP_RAM_BLOCK, stub.text_start));
	await write_dataframe(serial, 7, ESP_RAM_BLOCK, stub.text);
	await send_cmd(serial, 5, ints_to_buffer(stub.data.length, Math.ceil(stub.data.length / ESP_RAM_BLOCK), ESP_RAM_BLOCK, stub.data_start));
	await write_dataframe(serial, 7, ESP_RAM_BLOCK, stub.data);
	await send_cmd(serial, 6, ints_to_buffer(0, stub.entry));
	if(Buffer.from(await recv(serial, 1000)).toString() == 'OHAI')return;
	return Promise.reject();
}

async function write_flash(serial, data, offset, progressFn=null){
	const FLASH_WRITE_SIZE = 0x4000;
	const old_size = data.length;
	data = zlib.deflateSync(data, {level:9});
	await send_cmd(serial, 0x10, ints_to_buffer(old_size, Math.ceil(data.length / FLASH_WRITE_SIZE), FLASH_WRITE_SIZE, offset));
	await write_dataframe(serial, 0x11, FLASH_WRITE_SIZE, data, progressFn);
	await send_cmd(serial, 0x12, ints_to_buffer(1));//0==reboot
}

const read_reg = (serial, address) => send_cmd(serial, 0xA, ints_to_buffer(address));
const write_reg = (serial, address, value) => send_cmd(serial, 0x9, ints_to_buffer(address, value, 0xFFFFFFFF, 0));
const erase_flash = serial => send_cmd(serial, 0xD0, Buffer.alloc(0), 30000);

const recv = (serial, timeout) => waitWhen(serial, 'data', timeout, checker_c0db());

const send_cmd = function(){
	const checksum = (f => data => data.slice(16).reduce(f, 0xEF))((s, v) => s ^ v);
	return async function(serial, op, data, timeout=2000){
		await serial.send_buffer(encode_c0db(prependInts(data, op << 8 | data.length << 16, checksum(data))));
		const result = await recv(serial, timeout);
		if(result.length < 8 || result[0] != 1 || result[1] != op || (result[2] | result[3] << 8) != result.length - 8){
			return Promise.reject();
		}
		if(op == 0x0A)return Buffer.from(result).readUInt32LE(4);//read_reg
		return result.slice(8, -2);
	}
}();

exports.upload = upload;
