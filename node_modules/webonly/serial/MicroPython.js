
const {waitWhen} = require('utils/events');
const {castUnicode} = require('utils/text');
const {cut, cut_json} = require('utils/sender');
const {regexp_checker} = require('./helper');

const stepDo = (i, n, step) => (i + 1) % step == 0 || i + 1 == n;

const mode_fn = (value, regexp) => async (serial, timeout=5000) => {
	await serial.send_buffer(Buffer.from([value]));
	return regexp && waitWhen(serial, 'data', timeout, regexp_checker(regexp));
}

const enter_raw_repl = mode_fn(1, /^(\r\n)?raw REPL; CTRL-B to exit\r\n>$/);
const leave_raw_repl = mode_fn(2, /^\r\nMicroPython .+\r\nType "help\(\)" for more information\.\r\n>>> $/); 
const interrupt_repl = mode_fn(3);
const reset_repl = mode_fn(4, /\bsoft reboot\r\n/);
const exec_raw_repl = mode_fn(4, /^OK.*\x04.*\x04>$/s);

async function exec_raw(serial){
	const result = await exec_raw_repl(serial);
	const [data, error] = Buffer.from(result.slice(2, -2)).toString().split('\x04');
	return error ? Promise.reject(error) : data;
}

async function raw_repl_do(serial, task){
	await enter_raw_repl(serial);
	try{
		await task(serial);
	}finally{
		await leave_raw_repl(serial);
	}
}
/*
function gen_upload_code(name, data, hexFlag=false){
	const result = [];
	if(typeof data === 'string'){
		result.push(`f=open('${castUnicode(name)}','w')\r`);
		result.push(`exec('def s(v): f.write(v)')\r`);
		for(let value of cut_json(castUnicode(data), 58)){//less than 64
			result.push(`s(${JSON.stringify(value)})\r`);
		}
	}else if(hexFlag){
		result.push(`f=open('${castUnicode(name)}','wb')\r`);
		result.push(`b=lambda v:bytes(int(v[i:i+2],16)for i in range(0,len(v),2))\r`);
		result.push(`exec('def s(v): f.write(b(v))')\r`);
		for(let value of cut(data, 29)){//less than 64
			result.push(`s('${value.toString('hex')}')\r`);
		}
	}else{
		result.push(`f=open('${castUnicode(name)}','wb')\r`);
		result.push(`from binascii import a2b_base64\r`);
		result.push(`exec('def s(v): f.write(a2b_base64(v))')\r`);
		for(let value of cut(data, 42)){//less than 64
			result.push(`s('${value.toString('base64')}')\r`);
		}
	}
	result.push(`f.close()\r`);
	return result;
}
*/
const download_file = function(){
	function* gen_code(name, offset, length){
		if(offset == 0){
			yield 'def d(p,i,n):\r';
			yield '\timport sys\r';
			yield '\timport binascii as b\r';
			yield '\twith open(p,"b")as f:\r';
			yield `\t\tf.seek(i)\r`;
			yield `\t\tsys.stdout.write(b.b2a_base64(f.read(n))[:-1])\r`;
		}
		yield `d("${name}",${offset},${length})`;
	}
	async function download(serial, name, offset, length){
		const code = Array.from(gen_code(castUnicode(name), offset, length)).join('');
		await serial.send_buffer(Buffer.from(code));
		return Buffer.from(await exec_raw(serial), 'base64');
	}
	return async function*(serial, name, length){
		const batch = 192;
		for(let i=0; i<length; i+=batch){
			yield await serial.queueDo(() => download(serial, name, i, batch));
		}
	}
}();

const upload_file = function(){
	function* gen_code(name, offset, length){
		if(offset == 0){
			yield 'def u(p,m,n):\r';
			yield '\timport sys\r';
			yield '\timport binascii as b\r';
			yield '\twith open(p,("wb","ab")[m])as f:\r';
			yield `\t\tf.write(b.a2b_base64(sys.stdin.read(n)))\r`;
		}
		yield `u("${name}",${offset>0?1:0},${length})`;
	}
	async function upload(serial, name, offset, data){
		const text = data.toString('base64');
		const code = Array.from(gen_code(castUnicode(name), offset, text.length)).join('');
		await serial.send_buffer(Buffer.from(code));
		const signal = exec_raw(serial);
		await serial.send_buffer(Buffer.from(text));
		await signal;
	}
	return async function*(serial, name, data){
		let i = 0;
		for(let v of cut(data, 192)){
			await serial.queueDo(() => upload(serial, name, i, v));
			yield i += v.length;
		}
	}
}();

function gen_ilistdir(name){
	const result = [];
	result.push('import os;import json\r');
	result.push('f=lambda v:[v[0],int(v[1]==0x4000),v[3]]\r');
	result.push(`os.chdir("${castUnicode(name)}")\r`);
	result.push('print(json.dumps(list(map(f,os.ilistdir()))),end="")\r');
	return result;
}

const gen_exec_file = (file, execFlag=false) => execFlag ? `exec(open("${file}").read())` : `execfile("${file}")`;
const gen_exec_code = code => `exec(${castUnicode(JSON.stringify(code))})`;
const get_size = name => `import os;print(os.stat("${castUnicode(name)}")[6],end='')`;
/*
async function upload_file(serial, name, data, hexFlag=false, progress=null){
	const step = 32;
	const code = gen_upload_code(name, data, hexFlag);
	for(let i=0, n=code.length; i<n; ++i){
		await serial.send_buffer(Buffer.from(code[i]));
		if(stepDo(i, n, step))await exec_raw(serial);
		if(progress?.((i + 1) / n))return;
	}
}
*/
exports.enter_raw_repl = enter_raw_repl;
exports.leave_raw_repl = leave_raw_repl;
exports.interrupt_repl = interrupt_repl;
exports.reset_repl = reset_repl;
exports.exec_raw = exec_raw;

exports.gen_exec_file = gen_exec_file;
exports.gen_exec_code = gen_exec_code;

exports.upload_file = upload_file;
