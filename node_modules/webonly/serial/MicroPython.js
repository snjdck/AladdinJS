
const {waitWhen} = require('utils/events');
const {castUnicode} = require('utils/text');
const {cut, cut_json} = require('utils/sender');
const {regexp_checker} = require('./helper');

const stepDo = (i, n, step) => (i + 1) % step == 0 || i + 1 == n;

const mode_fn = (value, regexp) => async (serial, timeout=5000) => {
	await serial.send_buffer(Buffer.from([value]));
	return regexp && waitWhen(serial, 'data', timeout, regexp_checker(regexp));
}

const enter_raw_repl = mode_fn(1, /^(\r\n)?raw REPL; CTRL-B to exit\r\n>$/);
const leave_raw_repl = mode_fn(2, /^\r\nMicroPython .+\r\nType "help\(\)" for more information\.\r\n>>> $/); 
const interrupt = mode_fn(3);
const reset = mode_fn(4, /\bsoft reboot\r\n/);
const exec_raw_repl = mode_fn(4, /^OK.*\x04.*\x04>$/s);

async function exec_raw(serial){
	const result = await exec_raw_repl(serial);
	const [data, error] = Buffer.from(result.slice(2, -2)).toString().split('\x04');
	return error ? Promise.reject(error) : data;
}
/*
function gen_upload_code(name, data, hexFlag=false){
	const result = [];
	if(typeof data === 'string'){
		result.push(`f=open('${castUnicode(name)}','w')\r`);
		result.push(`exec('def s(v): f.write(v)')\r`);
		for(let value of cut_json(castUnicode(data), 58)){//less than 64
			result.push(`s(${JSON.stringify(value)})\r`);
		}
	}else if(hexFlag){
		result.push(`f=open('${castUnicode(name)}','wb')\r`);
		result.push(`b=lambda v:bytes(int(v[i:i+2],16)for i in range(0,len(v),2))\r`);
		result.push(`exec('def s(v): f.write(b(v))')\r`);
		for(let value of cut(data, 29)){//less than 64
			result.push(`s('${value.toString('hex')}')\r`);
		}
	}else{
		result.push(`f=open('${castUnicode(name)}','wb')\r`);
		result.push(`from binascii import a2b_base64\r`);
		result.push(`exec('def s(v): f.write(a2b_base64(v))')\r`);
		for(let value of cut(data, 42)){//less than 64
			result.push(`s('${value.toString('base64')}')\r`);
		}
	}
	result.push(`f.close()\r`);
	return result;
}
*/
const download_file = function(){
	function* gen_code(name, offset, length){
		if(offset==0)yield 'import sys;from binascii import b2a_base64\r';
		yield `with open("${name}",'b') as f:\r`;
		yield `\tf.seek(${offset})\r`;
		yield `\tsys.stdout.write(b2a_base64(f.read(${length}))[:-1])`;
	}
	return async (serial, name, offset, length) => {
		for(let code of gen_code(castUnicode(name), offset, length)){
			await serial.send_buffer(Buffer.from(code));
		}
		const text = await exec_raw(serial);
		return Buffer.from(text, 'base64');
	}
}();

const upload_file = function(){
	function* gen_code(name, offset, length){
		if(offset==0)yield 'import sys;from binascii import a2b_base64\r';
		yield `with open("${name}",'${offset>0?'a':'w'}b') as f:\r`;
		yield `\tf.write(a2b_base64(sys.stdin.read(${length})))`;
	}
	return async (serial, name, offset, data) => {
		const text = data.toString('base64');
		for(let code of gen_code(castUnicode(name), offset, text.length)){
			await serial.send_buffer(Buffer.from(code));
		}
		const signal = exec_raw(serial);
		await serial.send_buffer(Buffer.from(text));
		await signal;
	}
}();

function gen_ilistdir(name){
	const result = [];
	result.push('import os;import json\r');
	result.push('f=lambda v:[v[0],int(v[1]==0x4000),v[3]]\r');
	result.push(`os.chdir('${castUnicode(name)}')\r`);
	result.push('print(json.dumps(list(map(f,os.ilistdir()))),end="")\r');
	return result;
}

const gen_exec_file = (file, execFlag=false) => execFlag ? `exec(open("${file}").read())` : `execfile("${file}")`;
const gen_exec_code = code => `exec(${JSON.stringify(castUnicode(code))})`;
const get_size = name => `import os;print(os.stat(${JSON.stringify(name)})[6],end='')`;
/*
async function upload_file(serial, name, data, hexFlag=false, progress=null){
	const step = 32;
	const code = gen_upload_code(name, data, hexFlag);
	for(let i=0, n=code.length; i<n; ++i){
		await serial.send_buffer(Buffer.from(code[i]));
		if(stepDo(i, n, step))await exec_raw(serial);
		if(progress?.((i + 1) / n))return;
	}
}
*/
exports.enter_raw_repl = enter_raw_repl;
exports.leave_raw_repl = leave_raw_repl;
exports.interrupt = interrupt;
exports.reset = reset;
exports.exec_raw = exec_raw;

exports.gen_exec_file = gen_exec_file;
exports.gen_exec_code = gen_exec_code;

exports.upload_file = upload_file;
