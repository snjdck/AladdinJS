
const {waitWhen} = require('utils/events');
const {castUnicode} = require('utils/text');
const {cut, cut_json} = require('utils/sender');
const {composeFactory} = require('net/packet');

const stepDo = (i, n, step) => (i + 1) % step == 0 || i + 1 == n;

async function enter_raw_repl(serial){
	await serial.send_buffer(Buffer.from([1]));
	await recv(serial, '\r\nraw REPL;', '\r\n>');
}

async function leave_raw_repl(serial){
	await serial.send_buffer(Buffer.from([2]));
	await recv(serial, '\r\n', '\r\n>>> ');
}

async function interrupt(serial){
	await serial.send_buffer(Buffer.from([3]));
	await recv(serial, '', '\r\n>>> ');
}

async function reset(serial){
	//await interrupt(serial);
	await serial.send_buffer(Buffer.from([4]));
	await recv(serial, '\r\n', '');
}

async function exec_raw_repl(serial, code, step, progress){
	for(let i=0, n=code.length; i<n; ++i){
		await serial.send_buffer(Buffer.from(code[i]));
		if(stepDo(i, n, step)){
			await serial.send_buffer(Buffer.from([4]));
			const result = await recv(serial, 'OK', '\x04>');
			const [data, error] = result.split('\x04');
			if(error)return Promise.reject(error);
		}
		progress?.((i + 1) / n);
	}
}

const recv = function(){
	const replyFn = composeFactory(
		(v, buffer) => buffer.push(...Buffer.from(v)),
		(buffer, begin, end) => {
			const text = Buffer.from(buffer).toString();
			return text.startsWith(begin) && text.endsWith(end);
		},
		(buffer, begin, end) => {
			const text = Buffer.from(buffer).toString();
			return text.slice(begin.length, text.length - end.length);
		}
	);
	return function(serial, begin, end, timeout=5000){
		return waitWhen(serial, 'data', timeout, replyFn([], begin, end));
	}
}();

function gen_upload_code(name, data, hexFlag=false){
	const result = [];
	if(typeof data === 'string'){
		result.push(`f=open('${castUnicode(name)}','w')\r`);
		result.push(`exec('def s(v): f.write(v)')\r`);
		for(let value of cut_json(castUnicode(data), 58)){//less than 64
			result.push(`s(${JSON.stringify(value)})\r`);
		}
	}else if(hexFlag){
		result.push(`f=open('${castUnicode(name)}','wb')\r`);
		result.push(`b=lambda v:bytes(int(v[i:i+2],16)for i in range(0,len(v),2))\r`);
		result.push(`exec('def s(v): f.write(b(v))')\r`);
		for(let value of cut(data, 29)){//less than 64
			result.push(`s('${value.toString('hex')}')\r`);
		}
	}else{
		result.push(`f=open('${castUnicode(name)}','wb')\r`);
		result.push(`from binascii import a2b_base64\r`);
		result.push(`exec('def s(v): f.write(a2b_base64(v))')\r`);
		for(let value of cut(data, 42)){//less than 64
			result.push(`s('${value.toString('base64')}')\r`);
		}
	}
	result.push(`f.close()\r`);
	return result;
}

const gen_exec_file = (file, execFlag=false) => execFlag ? `exec(open("${file}").read())` : `execfile("${file}")`;
const gen_exec_code = code => `exec(${JSON.stringify(castUnicode(code))})`;

async function send_code(serial, code, waitFlag=true){
	await serial.send_buffer(Buffer.from(code));
	if(!waitFlag)return;
	let result = await recv(serial, code, '>>> ');
	result = result.trim();
	if(result.startsWith('Traceback (most recent call last):\r\n')){
		return Promise.reject(result);
	}
	return result;
}

async function send_code_raw(serial, code){
	await serial.send_buffer(Buffer.from(code + '\x04'));
	const result = await recv(serial, 'OK', '\x04>');
	const [data, error] = result.split('\x04');
	return error ? Promise.reject(error) : data;
}

async function upload_file(serial, name, data, hexFlag=false, progress=null){
	const result = gen_upload_code(name, data, hexFlag);
	try{
		await enter_raw_repl(serial);
		await exec_raw_repl(serial, result, 32, progress);
	}finally{
		await leave_raw_repl(serial);
	}
}

exports.interrupt = interrupt;
exports.reset = reset;

exports.gen_exec_file = gen_exec_file;
exports.gen_exec_code = gen_exec_code;

exports.upload_file = upload_file;
exports.send_code = send_code;
exports.send_code_raw = send_code_raw;
