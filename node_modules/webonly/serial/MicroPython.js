
const {waitWhen} = require('utils/events');
const {castUnicode} = require('utils/text');
const {cut, cut_json} = require('utils/sender');
const {regexp_checker} = require('./helper');

const stepDo = (i, n, step) => (i + 1) % step == 0 || i + 1 == n;

const mode_fn = (value, regexp) => async (serial, timeout=2000) => {
	await serial.send_buffer(Buffer.from([value]));
	return waitWhen(serial, 'data', timeout, regexp_checker(regexp));
}

const enter_raw_repl = mode_fn(1, /^(\r\n)?raw REPL; CTRL-B to exit\r\n>$/);
const leave_raw_repl = mode_fn(2, /^\r\nMicroPython .+\r\nType "help\(\)" for more information\.\r\n>>> $/); 
const interrupt_repl = mode_fn(3, /\r\n>>> $/);
const reset_repl = mode_fn(4, /\bsoft reboot\r\n/);
const exec_raw_repl = mode_fn(4, /^OK.*\x04.*\x04>$/s);

async function exec_raw(serial){
	const result = await exec_raw_repl(serial);
	const [data, error] = Buffer.from(result.slice(2, -2)).toString().split('\x04');
	return error ? Promise.reject(error) : data;
}

async function raw_repl_do(serial, task){
	await enter_raw_repl(serial);
	try{
		await task(serial);
	}finally{
		await leave_raw_repl(serial);
	}
}

function* gen_upload_code(name, data, hexFlag=false){
	const isStr = typeof data == 'string';
	yield `f=open("${castUnicode(name)}",'w${isStr?'':'b'}')\r`;
	if(isStr){
		yield `def s(v): f.write(v)\r`;
		for(let value of cut_json(castUnicode(data), 58)){//less than 64
			yield `s(${JSON.stringify(value)})\r`;
		}
	}else if(hexFlag){
		yield `b=lambda v:bytes(int(v[i:i+2],16)for i in range(0,len(v),2))\r`;
		yield `def s(v): f.write(b(v))\r`;
		for(let value of cut(data, 29)){//less than 64
			yield `s('${value.toString('hex')}')\r`;
		}
	}else{
		yield `from binascii import a2b_base64\r`;
		yield `def s(v): f.write(a2b_base64(v))\r`;
		for(let value of cut(data, 42)){//less than 64
			yield `s('${value.toString('base64')}')\r`;
		}
	}
	yield `f.close()\r`;
}

const download_file = function(){
	function* gen_code(name, offset, length){
		if(offset == 0){
			yield 'def d(p,i,n):\r';
			yield '\timport sys\r';
			yield '\timport binascii as b\r';
			yield '\twith open(p,"b")as f:\r';
			yield `\t\tf.seek(i)\r`;
			yield `\t\tsys.stdout.write(b.b2a_base64(f.read(n))[:-1])\r`;
		}
		yield `d("${name}",${offset},${length})`;
	}
	async function download(serial, name, offset, length){
		const code = Array.from(gen_code(castUnicode(name), offset, length)).join('');
		await serial.send_buffer(Buffer.from(code));
		return Buffer.from(await exec_raw(serial), 'base64');
	}
	return async function*(serial, name, length){
		const batch = 1536;
		for(let i=0; i<length; i+=batch){
			yield await serial.queueDo(() => download(serial, name, i, batch));
		}
	}
}();

const upload_file = function(){
	function* gen_code(name, offset, data){
		if(offset == 0){
			yield 'def u(p,m,d):\r';
			yield '\timport sys\r';
			yield '\timport binascii as b\r';
			yield '\twith open(p,("wb","ab")[m])as f:\r';
			yield `\t\tf.write(b.a2b_base64(d))\r`;
		}
		yield `u("${name}",${offset>0?1:0},"${data}")`;
	}
	async function upload(serial, name, offset, data){
		const code = Array.from(gen_code(castUnicode(name), offset, data.toString('base64'))).join('');
		await serial.send_buffer(Buffer.from(code));
		await exec_raw(serial);
	}
	return async function*(serial, name, data){
		let i = 0;
		for(let v of cut(data, 1536)){
			await serial.queueDo(() => upload(serial, name, i, v));
			yield i += v.length;
		}
	}
}();

function* gen_ilistdir(name){
	yield 'import os\r'
	yield 'import json\r'
	yield 'def g(l):\r'
	yield '\tyield os.getcwd()\r'
	yield '\tyield [v[0] for v in l if v[1] == 0x4000]\r'
	yield '\tyield [[v[0],v[3]] for v in l if v[1] == 0x8000]\r'
	yield `os.chdir("${castUnicode(name)}")\r`;
	yield `print(json.dumps(list(g(list(os.ilistdir()))),separators=(',',':')),end='')\r`
}

const gen_exec_file = (file, execFlag=false) => execFlag ? `exec(open("${file}").read())` : `execfile("${file}")`;
const get_size = name => `import os;print(os.stat("${castUnicode(name)}")[6],end='')`;
/*
async function upload_file(serial, name, data, hexFlag=false, progress=null){
	const step = 32;
	const code = gen_upload_code(name, data, hexFlag);
	for(let i=0, n=code.length; i<n; ++i){
		await serial.send_buffer(Buffer.from(code[i]));
		if(stepDo(i, n, step))await exec_raw(serial);
		if(progress?.((i + 1) / n))return;
	}
}
*/
exports.enter_raw_repl = enter_raw_repl;
exports.leave_raw_repl = leave_raw_repl;
exports.interrupt_repl = interrupt_repl;
exports.reset_repl = reset_repl;
exports.exec_raw = exec_raw;

exports.gen_exec_file = gen_exec_file;
exports.gen_exec_code = gen_exec_code;

exports.upload_file = upload_file;
