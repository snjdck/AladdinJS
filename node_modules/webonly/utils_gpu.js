
const textureFormat = navigator.gpu.getPreferredCanvasFormat();//bgra8unorm
const textureUsage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;

async function requestDevice(){
	const adapter = await navigator.gpu.requestAdapter();
	console.log('adapter', Array.from(adapter.features), adapter.limits);
	//const device = await adapter.requestDevice();
	const device = await adapter.requestDevice({
		requiredLimits:{
			//maxColorAttachmentBytesPerSample: 64
		},
		requiredFeatures:[]
	});
	console.log('device', Array.from(device.features), device.limits);
	return device;
}

function requestSwapChain(canvas, device){
	const swapChain = canvas.getContext('webgpu');
	swapChain.configure({
		device,
		format: textureFormat,
		usage: GPUTextureUsage.COPY_DST,
		alphaMode: 'opaque',//premultiplied
		colorSpace: 'srgb',//display-p3
	});
	return swapChain;
}

function createDepthTexture(device, width, height){
	return device.createTexture({
		size: [width, height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.RENDER_ATTACHMENT
	});
}

function createTexture(device, width, height, depthOrArrayLayers=1, usage=textureUsage){
	return device.createTexture({
		dimension: '2d',
		format: textureFormat,
		size: [width, height, depthOrArrayLayers],
		usage,
	});
}

async function createTextureArray(device, imageList){
	const width = Math.max(...imageList.map(v => v.naturalWidth));
	const height = Math.max(...imageList.map(v => v.naturalHeight));
	const arrayLayerCount = imageList.length;
	const resizeOption = {resizeWidth: width, resizeHeight: height, resizeQuality: 'high'};
	const texture = createTexture(device, width, height, arrayLayerCount);
	for(let i=0; i<arrayLayerCount; ++i){
		device.queue.copyExternalImageToTexture(
			{source: await createImageBitmap(imageList[i], resizeOption)},
			{texture, origin: [0, 0, i]},
			[width, height, 1]
		);
	}
	return texture;
}

const createBuffer = (device, usage, size, mappedAtCreation=false) => device.createBuffer({usage, size, mappedAtCreation});

function createBufferWith(device, usage, data){
	const buffer = createBuffer(device, usage, data.byteLength, true);
	const mapping = buffer.getMappedRange();
	new data.constructor(mapping).set(data);
	buffer.unmap();
	return buffer;
}

const sortEntryFn = (a, b) => a.binding - b.binding;

const calcBindGroupLayoutSign = function(){
	function* sign(desc){
		yield desc.binding;
		yield desc.visibility;
		if(desc.buffer){
			yield desc.buffer.type ?? 'uniform';//storage, read-only-storage
			yield desc.buffer.hasDynamicOffset ? 1 : 0;
			yield desc.buffer.minBindingSize ?? 0;
		}else if(desc.sampler){
			yield desc.sampler.type ?? 'filtering';//non-filtering, comparison
		}else if(desc.storageTexture){
			yield desc.storageTexture.access ?? 'write-only';//read-only, read-write
			yield desc.storageTexture.viewDimension ?? '2d';//1d, 3d, 2d-array, cube, cube-array
			yield desc.storageTexture.format;
		}else if(desc.texture){
			yield desc.texture.sampleType ?? 'float';//depth, sint, uint, unfilterable-float
			yield desc.texture.viewDimension ?? '2d';
			yield desc.texture.multisampled ? 1 : 0;
		}else if(desc.externalTexture){
		}
	}
	const mapFn = v => Array.from(sign(v)).join(',');
	return entries => entries.toSorted(sortEntryFn).map(mapFn).join('&');
}();
const calcPipelineLayoutSign = bindGroupLayouts => bindGroupLayouts.map(calcBindGroupLayoutSign).join('|');

const calcSamplerSign = function(){
	function* sign(desc){
		yield desc.addressModeU ?? 'clamp-to-edge';//repeat, mirror-repeat
		yield desc.addressModeV ?? 'clamp-to-edge';
		yield desc.addressModeW ?? 'clamp-to-edge';
		yield desc.minFilter ?? 'nearest';//linear
		yield desc.magFilter ?? 'nearest';
		yield desc.mipmapFilter ?? 'nearest';
		yield desc.lodMinClamp ?? 0;
		yield desc.lodMaxClamp ?? 32;
		yield desc.maxAnisotropy ?? 1;//1-16
		yield desc.compare;//never, always, equal, not-equal, less, less-equal, greater, greater-equal
	}
	return desc => Array.from(sign(desc)).join(',');
}();

const calcPipelineSign = function(){
	function* signShaderModule(desc){
		yield desc?.entryPoint;
		yield desc?.code && desc.code;
	}
	function* signBlend(desc){
		yield desc?.srcFactor ?? 'one';
		yield desc?.operation ?? 'add';
		yield desc?.dstFactor ?? 'zero';
	}
	function* signStencil(desc){
		yield desc?.compare ?? 'always';
		yield desc?.depthFailOp ?? 'keep';
		yield desc?.failOp ?? 'keep';
		yield desc?.passOp ?? 'keep';
	}
	function* sign(desc){
		yield calcPipelineLayoutSign(desc.groups);

		if(desc.compute){
			yield* signShaderModule(desc.compute);
			return;
		}

		yield* signShaderModule(desc.vertex);
		if(desc.vertex?.buffers){
			for(let buffer of desc.vertex.buffers){
				yield buffer.arrayStride;
				yield buffer.stepMode ?? 'vertex';//instance
				for(let attribute of buffer.attributes.toSorted(sortFn)){
					yield attribute.shaderLocation;
					yield attribute.format;
					yield attribute.offset;
				}
			}
		}

		yield* signShaderModule(desc.fragment);
		if(desc.fragment?.targets){
			for(let target of desc.fragment.targets){
				yield target.writeMask ?? GPUColorWrite.ALL;
				yield target.format;
				yield target.blend != null;//need
				yield* signBlend(target.blend?.color);
				yield* signBlend(target.blend?.alpha);
			}
		}

		yield desc.depthStencil?.format;
		yield desc.depthStencil?.depthWriteEnabled;
		yield desc.depthStencil?.depthCompare;
		yield desc.depthStencil?.stencilReadMask ?? 0xFFFFFFFF;
		yield desc.depthStencil?.stencilWriteMask ?? 0xFFFFFFFF;
		yield desc.depthStencil?.depthBias ?? 0;
		yield desc.depthStencil?.depthBiasSlopeScale ?? 0;
		yield desc.depthStencil?.depthBiasClamp ?? 0;
		yield* signStencil(desc.depthStencil?.stencilFront);
		yield* signStencil(desc.depthStencil?.stencilBack);

		yield desc.primitive?.cullMode ?? 'none';//none, back, front
		yield desc.primitive?.frontFace ?? 'ccw';//cw, ccw
		yield desc.primitive?.topology ?? 'triangle-list';//point-list, line-list, line-strip, triangle-list, triangle-strip
		yield desc.primitive?.stripIndexFormat;//uint16, uint32
		yield desc.primitive?.unclippedDepth ?? false;

		yield desc.multisample?.alphaToCoverageEnabled ?? false;
		yield desc.multisample?.count ?? 1;
		yield desc.multisample?.mask ?? 0xFFFFFFFF;
	}
	const sortFn = (a, b) => a.shaderLocation - b.shaderLocation;
	return desc => Array.from(sign(desc)).join(',');
}();

const calcResourceDefs = function(){
	const calcSampledType = v => {
		switch(v){
			case 'sint':return 'i32';
			case 'uint':return 'u32';
		}
		return 'f32';
	}
	const calcBufferType = v => {
		switch(v){
			case 'storage':return 'storage,read_write';
			case 'read-only-storage':return 'storage,read';
		}
		return 'uniform';
	}
	const calcAccess = v => {
		switch(v){
			case 'read-only':return 'read';
			case 'write-only':return 'write';
			case 'read-write':return 'read_write';
		}
	}
	const castText = v => v.replace('-', '_');
	const calcCode = (group, v) => {
		let name = v.name;
		let type;
		if(v.sampler){
			type = v.sampler.type == 'comparison' ? 'sampler_comparison' : 'sampler';
		}else if(v.buffer){
			name = `<${calcBufferType(v.buffer.type)}> ${name}`;
			type = v.type;
		}else if(v.texture){
			const {sampleType, viewDimension='2d', multisampled=false} = v.texture;
			if(multisampled){
				type = sampleType == 'depth' ? 'texture_depth_multisampled_2d' : `texture_multisampled_2d<${calcSampledType(sampleType)}>`;
			}else if(sampleType == 'depth'){
				type = 'texture_depth_' + castText(viewDimension);
			}else{
				type = 'texture_' + castText(viewDimension) + `<${calcSampledType(sampleType)}>`;
			}
		}else if(v.storageTexture){
			const {format, viewDimension='2d', access='write-only'} = v.storageTexture;
			type = 'texture_storage_' + castText(viewDimension) + `<${format},${calcAccess(access)}>`;
		}else if(v.externalTexture){
			type = 'texture_external';
		}
		return `@group(${group}) @binding(${v.binding}) var ${name}:${type};\n`;
	}
	return (groups, visibility) => {
		const result = [];
		for(let [i, entries] of Object.entries(groups)){
			for(let entry of entries.toSorted(sortEntryFn)){
				if(entry.visibility & visibility){
					result.push(calcCode(i, entry));
				}
			}
		}
		return result.join('');
	}
}();

exports.textureFormat = textureFormat;
exports.requestDevice = requestDevice;
exports.requestSwapChain = requestSwapChain;
exports.createTexture = createTexture;
exports.createTextureArray = createTextureArray;
exports.createDepthTexture = createDepthTexture;
exports.createBuffer = createBuffer;
exports.createBufferWith = createBufferWith;
exports.calcBindGroupLayoutSign = calcBindGroupLayoutSign;
exports.calcPipelineLayoutSign = calcPipelineLayoutSign;
exports.calcSamplerSign = calcSamplerSign;
exports.calcPipelineSign = calcPipelineSign;
exports.calcResourceDefs = calcResourceDefs;
