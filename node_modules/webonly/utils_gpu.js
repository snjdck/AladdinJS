
const textureFormat = navigator.gpu.getPreferredCanvasFormat();//bgra8unorm
const textureUsage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;

async function requestDevice(){
	const adapter = await navigator.gpu.requestAdapter();
	const device = await adapter.requestDevice();
	return device;
}

function requestSwapChain(canvas, device){
	const swapChain = canvas.getContext('webgpu');
	swapChain.configure({
		device,
		format: textureFormat,
		usage: GPUTextureUsage.RENDER_ATTACHMENT,
		alphaMode: 'opaque',//premultiplied
		colorSpace: 'srgb',//display-p3
	});
	return swapChain;
}

function createDepthTexture(device, width, height){
	return device.createTexture({
		size: [width, height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.RENDER_ATTACHMENT
	});
}

function createTexture(device, width, height, depthOrArrayLayers=1, usage=textureUsage){
	return device.createTexture({
		dimension: '2d',
		format: textureFormat,
		size: [width, height, depthOrArrayLayers],
		usage,
	});
}

function createTextureWithImage(device, image){
	const texture = createTexture(device, image.width, image.height);
	device.queue.copyExternalImageToTexture(
		{source: image, origin:[0, 0], flipY:false},
		{texture, mipLevel: 0, origin: [0, 0, 0]},
		[image.width, image.height, 1]
	);
	return texture;
}

async function createTextureArray(device, imageList){
	const width = Math.max(...imageList.map(v => v.naturalWidth));
	const height = Math.max(...imageList.map(v => v.naturalHeight));
	const arrayLayerCount = imageList.length;
	const resizeOption = {resizeWidth: width, resizeHeight: height, resizeQuality: 'high'};
	const texture = createTexture(device, width, height, arrayLayerCount);
	for(let i=0; i<arrayLayerCount; ++i){
		device.queue.copyExternalImageToTexture(
			{source: await createImageBitmap(imageList[i], resizeOption)},
			{texture, origin: [0, 0, i]},
			[width, height, 1]
		);
	}
	return texture;
}

const createBuffer = (device, usage, size, mappedAtCreation=false) => device.createBuffer({usage, size, mappedAtCreation});

function createBufferWith(device, usage, data){
	const buffer = createBuffer(device, usage, data.byteLength, true);
	const mapping = buffer.getMappedRange();
	new data.constructor(mapping).set(data);
	buffer.unmap();
	return buffer;
}

const createPipelineLayout = (device, bindGroupLayouts) => device.createPipelineLayout({bindGroupLayouts});
const createShaderModule = (device, code) => device.createShaderModule({code});

function setViewport(renderPassEncoder, rect, minDepth=0, maxDepth=1){
	renderPassEncoder.setViewport(rect.x, rect.y, rect.width, rect.height, minDepth, maxDepth);
}

const createBindGroupLayout = function(){
	const fn = (entry, binding) => entry ? {binding, visibility: entry[0], [entry[1]]: entry[2] ?? {}} : [];
	return (device, entries) => device.createBindGroupLayout({entries: entries.flatMap(fn)});
}();

const createBindGroup = function(){
	const fn = (resource, binding) => resource ? {binding, resource} : [];
	return (device, layout, entries) => device.createBindGroup({layout, entries: entries.flatMap(fn)});
}();

exports.textureFormat = textureFormat;
exports.requestDevice = requestDevice;
exports.requestSwapChain = requestSwapChain;
exports.createTexture = createTexture;
exports.createTextureWithImage = createTextureWithImage;
exports.createTextureArray = createTextureArray;
exports.createDepthTexture = createDepthTexture;
exports.createBuffer = createBuffer;
exports.createBufferWith = createBufferWith;
exports.createPipelineLayout = createPipelineLayout;
exports.createShaderModule = createShaderModule;
exports.setViewport = setViewport;
exports.createBindGroupLayout = createBindGroupLayout;
exports.createBindGroup = createBindGroup;
