'use strict';

const EventEmitter = require('events');
const {waitWhen} = require('utils/events');
const {limitSend} = require('utils/sender');

async function check(){
	const {bluetooth} = navigator;
	if(!bluetooth)return 1;
	if(!await bluetooth.getAvailability())return 2;
	return 0;
}

function requestDevice(option){
	const {bluetooth} = navigator;
	return bluetooth.requestDevice(option).catch(error => {
		if(error instanceof DOMException){
			if(error.code == DOMException.NOT_FOUND_ERR){
				return;//user cancel select
			}
		}
		throw error;
	});
}

function getService(server, serviceID, characteristicIDs){
	return server.getPrimaryService(serviceID).then(
		service => Promise.all(characteristicIDs.map(id => service.getCharacteristic(id)))
	);
}

class Serial extends EventEmitter
{
	static async from(gatt){
		const [sendMod, readMod] = await getService(gatt, 0xf100, [0xf101, 0xf102]);
		const [resetMod] = await getService(gatt, 0xf200, [0xf202]);
		await readMod.startNotifications();
		return new this(readMod, sendMod, resetMod);
	}

	constructor(readMod, sendMod, resetMod){
		super();
		this.resetMod = resetMod;
		readMod.addEventListener('characteristicvaluechanged', evt => this.emit('data', evt.target.value.buffer));
		this.send_raw = limitSend(ab => sendMod.writeValue(ab), 20);
	}

	setControlSignals({dtr}){
		return this.resetMod.writeValue(new Uint8Array([dtr?0:1]).buffer);
	}

	send_buffer({buffer, byteOffset, length}){
		return this.send_raw(buffer.slice(byteOffset, byteOffset+length));
	}
}

exports.check = check;
exports.requestDevice = requestDevice;
exports.Serial = Serial;
