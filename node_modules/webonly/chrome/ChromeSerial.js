'use strict';
const EventEmitter = nw.require('events');
const nw_version = nw.require('process').versions.nw;
const {serial, runtime} = chrome;

const getDevices = function(){
	const filterPorts = function(){
		function filter({path, vendorId, productId}){
			if(!(path && vendorId && productId))return;
			if(path.startsWith('/dev/tty.'))return;
			return !this.has(path) && this.add(path);
		}
		return ports => ports.filter(filter, new Set());
	}();
	const newFilter = filter => ports => ports.filter(p => filter.some(f => p.productId == f.pid && p.vendorId == f.vid));
	const getDevices = callback => serial.getDevices(callback);
	const castPorts = ports => ports.map(p => p.path).sort();
	return filter => new Promise(getDevices).then(filterPorts).then(filter && newFilter(filter)).then(castPorts);
}();

function listenEvent(event, connectionId, callback){
	function fn(info){
		if(info.connectionId != connectionId)return;
		callback(info);
	}
	event.addListener(fn);
	return () => event.removeListener(fn);
}

const listenError = (connectionId, callback) => listenEvent(serial.onReceiveError, connectionId, info => callback(info.error));
const listenData = (connectionId, callback) => listenEvent(serial.onReceive, connectionId, info => callback(info.data));

class Serial extends EventEmitter
{
	static enum = getDevices;

	constructor(){
		super();
		this.connectionId = 0;
	}

	isConnected(){
		return this.connectionId > 0;
	}

	invoke(method, ...args){
		if(method != 'connect')args.unshift(this.connectionId);
		return new Promise((resolve, reject) => serial[method](...args, v => v !== undefined ? resolve(v) : reject(runtime.lastError.message)));
	}

	_onClosed(error){
		this._disconnect();
		if(this.silentFlag){
			//(error == 'disconnected' || error == 'break')
			this.silentFlag = false;
			return;
		}
		this.emit('closed', error);//disconnected, device_lost
	}

	async connect(port, bitrate=115200){
		const {connectionId} = await this.invoke('connect', port, {bitrate, name:port});
		this._connect(connectionId);
	}

	_connect(connectionId){
		this.connectionId = connectionId;
		this.cancelError = listenError(connectionId, error => this._onClosed(error));
		this.cancelData = listenData(connectionId, data => this.emit('data', data));
	}

	async disconnect(silentFlag=false){
		this.silentFlag = silentFlag;
		const ok = await this.invoke('disconnect');
		if(ok && nw_version == '0.36.4')this._onClosed('disconnected');
		return ok;
	}

	_disconnect(){
		this.connectionId = 0;
		this.cancelError();
		this.cancelData();
		this.cancelError = null;
		this.cancelData = null;
	}

	async send_raw(ab){
		const {bytesSent, error} = await this.invoke('send', ab);
		if(error)return Promise.reject(error);
		if(bytesSent >= ab.byteLength)return;
		await this.send_raw(ab.slice(bytesSent));
	}

	send_buffer({buffer, byteOffset, length}){
		return this.send_raw(buffer.slice(byteOffset, byteOffset+length));
	}

	update(bitrate){
		return this.invoke('update', {bitrate});
	}

	setControlSignals(data){//{dtr, rts}, Data Terminal Ready, Request To Send
		return this.invoke('setControlSignals', data);
	}

	async reconnect(handler){
		const {name, bitrate} = await this.invoke('getInfo');
		await this.disconnect(true);
		try{
			await handler(name);
		}finally{
			this.connect(name, bitrate);
		}
	}
}

module.exports = Serial;