'use strict';
const EventEmitter = nw.require('events');
const isMacOS = nw.require('os').platform() === 'darwin';
const nw_version = nw.require('process').versions.nw;
const {serial, runtime} = chrome;

const getDevices = function(){
	function filterPorts(ports){
		if(isMacOS){
			ports = ports.filter(({path}) => path.startsWith('/dev/cu.'));
		}
		ports.sort((a, b) => Object.keys(b).length - Object.keys(a).length);
		return ports.filter(function({path}){
			if(this.has(path))return false;
			this.add(path);
			return true;
		}, new Set());
	}
	return () => new Promise(resolve => serial.getDevices(ports => resolve(filterPorts(ports))));
}();

const safeInvoke = (method, a, b) => new Promise((resolve, reject) => serial[method](a, b, v => v ? resolve(v) : reject(runtime.lastError.message)));

function listenEvent(event, connectionId, callback){
	function fn(info){
		if(info.connectionId != connectionId)return;
		callback(info);
	}
	event.addListener(fn);
	return () => event.removeListener(fn);
}

class Serial extends EventEmitter
{
	static enum = getDevices;
	static filter(ports, filter){
		return ports.filter(({productId, vendorId}) => filter.some(({pid, vid}) => productId === pid && vendorId === vid));
	}

	constructor(){
		super();
		this.connectionId = 0;
	}

	isConnected(){
		return this.connectionId > 0;
	}

	invoke(method, ...args){
		return new Promise(resolve => serial[method](this.connectionId, ...args, resolve));
	}

	_connect(connectionId){
		this.connectionId = connectionId;
		this.cancelError = listenEvent(serial.onReceiveError, connectionId, ({error}) => this._onClosed(error));
		this.cancelData = listenEvent(serial.onReceive, connectionId, ({data}) => this.emit('data', data));
	}

	_disconnect(){
		this.connectionId = 0;
		this.cancelError();
		this.cancelData();
		this.cancelError = null;
		this.cancelData = null;
	}

	_onClosed(error){
		this._disconnect();
		if(this.silentFlag){
			//(error == 'disconnected' || error == 'break')
			this.silentFlag = false;
			return;
		}
		this.emit('closed', error);//disconnected, device_lost
	}

	connect(port, bitrate=115200){
		return safeInvoke('connect', port, {bitrate}).then(({connectionId}) => {
			this.port = port;
			this.bitrate = bitrate;
			this._connect(connectionId);
		});
	}

	disconnect(silentFlag=false){
		this.silentFlag = silentFlag;
		return this.invoke('disconnect').then(ok => {
			if(ok && nw_version == '0.36.4'){
				this._onClosed('disconnected');
			}
			return ok;
		});
	}

	send_raw(ab){
		return safeInvoke('send', this.connectionId, ab).then(({bytesSent, error}) => {
			if(bytesSent == ab.byteLength)return;
			return this.send_raw(ab.slice(bytesSent));
		});
	}

	send_buffer({buffer, byteOffset, length}){
		return this.send_raw(buffer.slice(byteOffset, byteOffset+length));
	}

	update(bitrate, ctsFlowControl=false, dataBits='eight', stopBits='one', parityBit='no'){
		return this.invoke('update', {bitrate});
	}

	setControlSignals(data){//{dtr, rts}, Data Terminal Ready, Request To Send
		return this.invoke('setControlSignals', data);
	}

	reconnect(handler){
		return this.disconnect(true).then(handler).finally(() => this.connect(this.port, this.bitrate));
	}

	async borrow(target, handler){
		target._connect(this.connectionId);
		try{
			await handler(target);
		}finally{
			target._disconnect();
		}
	}
}

module.exports = Serial;