'use strict';
const EventEmitter = nw.require('events');
const isMacOS = nw.require('os').platform() === 'darwin';
const nw_version = nw.require('process').versions.nw;
const {serial, runtime} = chrome;

const getDevices = function(){
	function filterPorts(ports){
		if(isMacOS){
			ports = ports.filter(({path}) => path.startsWith('/dev/cu.'));
		}
		ports.sort((a, b) => Object.keys(b).length - Object.keys(a).length);
		return ports.filter(function({path}){
			if(this.has(path))return false;
			this.add(path);
			return true;
		}, new Set());
	}
	return () => new Promise(resolve => serial.getDevices(ports => resolve(filterPorts(ports))));
}();

const connect = (port, bitrate) => new Promise((resolve, reject) => serial.connect(port, {bitrate}, info => info ? resolve(info.connectionId) : reject(runtime.lastError.message)));
const disconnect = connectionId => new Promise((resolve, reject) => serial.disconnect(connectionId, resolve));//resolve(bool)
const flush = connectionId => new Promise((resolve, reject) => serial.flush(connectionId, resolve));//resolve(bool)
const update = (connectionId, bitrate) => new Promise((resolve, reject) => serial.update(connectionId, {bitrate}, resolve));//resolve(bool)
const send = (connectionId, ab) => new Promise((resolve, reject) => serial.send(connectionId, ab, info => info ? resolve(info) : reject(runtime.lastError.message)));
//{dtr, rts}, Data Terminal Ready, Request To Send
const setControlSignals = (connectionId, data) => new Promise((resolve, reject) => serial.setControlSignals(connectionId, data, resolve));//resolve(bool)

function listenEvent(event, connectionId, callback){
	function fn(info){
		if(info.connectionId != connectionId)return;
		callback(info);
	}
	event.addListener(fn);
	return () => event.removeListener(fn);
}

const listenError = (connectionId, callback) => listenEvent(serial.onReceiveError, connectionId, info => callback(info.error));
const listenData = (connectionId, callback) => listenEvent(serial.onReceive, connectionId, info => callback(info.data));

class Serial extends EventEmitter
{
	static enum = getDevices;
	static filter(ports, filter){
		return ports.filter(({productId, vendorId}) => filter.some(({pid, vid}) => productId === pid && vendorId === vid));
	}

	constructor(){
		super();
		this.connectionId = 0;
	}

	isConnected(){
		return this.connectionId > 0;
	}

	_onClosed(error){
		this.connectionId = 0;
		this.cancelError();
		this.cancelData();
		if(this.silentFlag){
			//(error == 'disconnected' || error == 'break')
			this.silentFlag = false;
			return;
		}
		this.emit('closed', error);//disconnected, device_lost
	}

	connect(port, bitrate=115200){
		return connect(port, bitrate).then(connectionId => {
			this.port = port;
			this.bitrate = bitrate;
			this.connectionId = connectionId;
			this.cancelError = listenError(connectionId, error => this._onClosed(error));
			this.cancelData = listenData(connectionId, data => this.emit('data', data));
		});
	}

	disconnect(silentFlag=false){
		this.silentFlag = silentFlag;
		return disconnect(this.connectionId).then(ok => {
			if(ok && nw_version == '0.36.4'){
				this._onClosed('disconnected');
			}
			return ok;
		});
	}

	send_raw(ab){
		return send(this.connectionId, ab).then(({bytesSent, error}) => {
			if(bytesSent == ab.byteLength)return;
			return this.send_raw(ab.slice(bytesSent));
		});
	}

	send_buffer({buffer, byteOffset, length}){
		return this.send_raw(buffer.slice(byteOffset, byteOffset+length));
	}

	update(bitrate){
		return update(this.connectionId, bitrate);
	}

	flush(){
		return flush(this.connectionId);
	}

	setControlSignals(data){
		return setControlSignals(this.connectionId, data);
	}

	reconnect(handler){
		return this.disconnect(true).then(handler).finally(() => this.connect(this.port, this.bitrate));
	}
}

module.exports = Serial;