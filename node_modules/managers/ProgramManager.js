"use strict";

class ProgramManager
{
	constructor(gl){
		this.gl = gl;
		this.programDict = Object.create(null);
		this.vsDict = Object.create(null);
		this.fsDict = Object.create(null);
	}

	fetch(name){
		return newCacheFunc(this.programDict, name, () => this.newProgram(name));
	}

	newProgram(name){
		let [vn, fn] = name.split("&", 2);
		let program = this.createProgram(`${vn}.vs`, `${fn}.fs`);
		this.calcProgramInfo(program, name);
		return program;
	}

	createProgram(vName, fName){
		let {gl} = this;
		let program = gl.createProgram();
		gl.attachShader(program, this.newShader(vName, gl.VERTEX_SHADER));
		gl.attachShader(program, this.newShader(fName, gl.FRAGMENT_SHADER));
		gl.linkProgram(program);
		if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
			let info = gl.getProgramInfoLog(program);
			alert(info);
			throw new Error(info);
		}
		return program;
	}

	newShader(name, type){
		let {vsDict, fsDict, gl} = this;
		let shaderDict = (type == gl.VERTEX_SHADER) ? vsDict : (type == gl.FRAGMENT_SHADER) ? fsDict : null;
		return newCacheFunc(shaderDict, name, () => this.createShader(loadSource(name), type));
	}

	createShader(source, type){
		let {gl} = this;
		let shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
			let info = gl.getShaderInfoLog(shader);
			alert(info);
			throw new Error(info);
		}
		return shader;
	}

	calcProgramInfo(program, name){
		let {gl} = this;
		
		for(let key of ["ACTIVE_ATTRIBUTES", "ACTIVE_UNIFORMS", "ACTIVE_UNIFORM_BLOCKS"]){
			program[key] = gl.getProgramParameter(program, gl[key]);
		}
		if(program.ACTIVE_UNIFORM_BLOCKS > 0){
			let uniformIndices = [];
			for(let i=0; i<program.ACTIVE_UNIFORM_BLOCKS; ++i){
				uniformIndices[i] = i;
			}
			console.log("index", gl.getUniformBlockIndex(program, "_"), uniformIndices);
			for(let key of ["UNIFORM_OFFSET", "UNIFORM_SIZE", "UNIFORM_BLOCK_INDEX", "UNIFORM_TYPE", "UNIFORM_ARRAY_STRIDE", "UNIFORM_MATRIX_STRIDE", "UNIFORM_IS_ROW_MAJOR"]){
				program[key] = gl.getActiveUniforms(program, uniformIndices, gl[key]);
			}
			program.uniformBlockSizeList = uniformIndices.map(
				i => gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE) >> 4
			);
		}
		program.name = name;
		console.log(program);
	}
}

function loadSource(path){
	let fs = require("fs");
	let source = fs.readFileSync(`shaders/${path}`, "utf8");
	return source.replace(/^#include\s*<(.+)>$/gm, function(){
		return loadSource(arguments[1]);
	});
}

function newCacheFunc(dict, name, createFun){
	let value = dict[name];
	if(!value){
		dict[name] = value = createFun();
	}
	return value;
}

module.exports = ProgramManager;
