"use strict";

const SyntaxTreeFactory = require("../SyntaxTreeFactory");

const {
	BLOCK_TYPE_EXPRESSION,
	BLOCK_TYPE_STATEMENT,
	BLOCK_TYPE_BREAK,
	BLOCK_TYPE_CONTINUE,
	BLOCK_TYPE_FOR,
	BLOCK_TYPE_IF,
	BLOCK_TYPE_ELSE_IF,
	BLOCK_TYPE_ELSE,

	BLOCK_TYPE_ARDUINO,

	INSERT_PT_BELOW,
	INSERT_PT_ABOVE,
	INSERT_PT_SUB,
	INSERT_PT_WRAP,
	INSERT_PT_CHILD
} = require("./BlockConst");

function collectArgs(block)
{
	var n = block.defaultArgBlockList.length;
	var argList = [];
	for(var i=0; i<n; ++i){
		argList[i] = outputArg(block, i);
	}
	return argList;
}

function outputArg(block, index){
	var argBlock = block.argBlockList[index];
	if(argBlock != null){
		return SyntaxTreeFactory.NewExpression(argBlock.cmd, collectArgs(argBlock));
	}
	var value = block.defaultArgBlockList[index].text;
	return SyntaxTreeFactory.NewString(value);
}

function outputCodeAll(block)
{
	var result = [];
	while(block != null){
		result.push(outputCodeSelf(block));
		block = block.nextBlock;
	}
	return result;
}

function outputCodeSelf(block)
{
	switch(block.type){
		case BLOCK_TYPE_BREAK:
			return SyntaxTreeFactory.Break();
		case BLOCK_TYPE_CONTINUE:
			return SyntaxTreeFactory.Continue();
		case BLOCK_TYPE_STATEMENT:
			return SyntaxTreeFactory.NewStatement(block.cmd, collectArgs(block));
		case BLOCK_TYPE_FOR:
			return SyntaxTreeFactory.NewWhile(outputArg(block, 0), outputCodeAll(block.subBlock1));
		case BLOCK_TYPE_IF:
			return SyntaxTreeFactory.NewIf(outputArg(block, 0), outputCodeAll(block.subBlock1));
		case BLOCK_TYPE_ELSE_IF:
			return SyntaxTreeFactory.NewElseIf(outputArg(block, 0), outputCodeAll(block.subBlock1));
		case BLOCK_TYPE_ELSE:
			return SyntaxTreeFactory.NewElse(outputCodeAll(block.subBlock1));
		case BLOCK_TYPE_ARDUINO:
			return {
				"type":"arduino",
				"setup":outputCodeAll(block.subBlock1),
				"loop":outputCodeAll(block.subBlock2)
			};
	}
}

module.exports = {
	outputCodeAll,
	outputCodeSelf
};