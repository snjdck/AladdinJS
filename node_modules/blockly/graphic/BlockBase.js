"use strict";

const {
	BLOCK_TYPE_EXPRESSION,
	BLOCK_TYPE_STATEMENT,
	BLOCK_TYPE_BREAK,
	BLOCK_TYPE_CONTINUE,
	BLOCK_TYPE_FOR,
	BLOCK_TYPE_IF,
	BLOCK_TYPE_ELSE_IF,
	BLOCK_TYPE_ELSE,

	BLOCK_TYPE_ARDUINO,

	INSERT_PT_BELOW,
	INSERT_PT_ABOVE,
	INSERT_PT_SUB,
	INSERT_PT_WRAP,
	INSERT_PT_CHILD
} = require("./BlockConst");

class BlockBase
{
	constructor(){
		this.svg = SVG.createElement("g");
		this.svg.block = this;

		this.bg = SVG.createElement("path", {
			"stroke":"blue",
			"fill":"#cccccc"
		});
		this.svg.appendChild(this.bg);

		this.type = 0;
		this.flag = 0;
		this._nextBlock = null;
		this._prevBlock = null;
		this._parentBlock = null;

		this.defaultArgBlockList = [];
		this.argBlockList = [];

		this._subBlockList = [];

		this.cmd = null;
		this._totalWidth = 0;
	}

	clone(dock){
		let copy = new BlockBase();
		dock.appendChild(copy.svg);
		copy.setSpec(this.spec);
		return copy;
	}

	setSpec(info){
		this.spec = info;
		this.id = info.id;
		this.type = info.type;
		this.specNodeList = Spec.parse(info.data);
		this.onSetSpec(this.specNodeList);
	}

	onSetSpec(nodeList){
		for(let node of nodeList){
			let element;
			if(node.type == "label"){
				element = new BlockLabel(node.value);
			}else if(node.type == "number"){
				element = new BlockArg(this, node, this.defaultArgBlockList.length);
				this.defaultArgBlockList.push(element);
			}
			this.svg.appendChild(element.svg);
		}
		this.layoutChildren();
		this.drawBg();
	}

	getArgBlockAt(index){
		return this.argBlockList[index] || this.defaultArgBlockList[index];
	}

	tryAccept(dragTarget){
		for(let i=0, n=this.defaultArgBlockList.length; i<n; ++i){
			let argBlock = this.argBlockList[i];
			if(argBlock != null){
				let result = argBlock.tryAccept(dragTarget);
				if(result)return result;
			}
			if(dragTarget.hitTestObject(this.getArgBlockAt(i))){
				return new InsertPtInfo(this, INSERT_PT_CHILD, i);
			}
		}
	}

	hitTestObject(other){
		//getBBox()
		let rect1 = this.svg.getBoundingClientRect();
		let rect2 = other.svg.getBoundingClientRect();
		return !(rect1.right <= rect2.left || rect1.left >= rect2.right || rect1.bottom <= rect2.top || rect1.top >= rect2.bottom);
	}
	
	tryLink(dragTarget){
		if(!this.isElseBlock()){
			if(!dragTarget.isFinalBlock() && dragTarget.isNearTo(this.x, this.y - dragTarget.getTotalBlockHeight())){
				return new InsertPtInfo(this, INSERT_PT_ABOVE);
			}
			if(dragTarget.isControlBlock()){
				if(null == dragTarget.subBlock1 && dragTarget.isNearTo(this.x, this.y - dragTarget.getPositionSub(0))){
					return new InsertPtInfo(this, INSERT_PT_WRAP, 0);
				}
				if(dragTarget.hasSubBlock2() && null == dragTarget.subBlock2 && dragTarget.isNearTo(this.x, this.y - dragTarget.getPositionSub(1))){
					return new InsertPtInfo(this, INSERT_PT_WRAP, 1);
				}
			}
		}
		var ptList = insertPtsFilter.filter(collectInsertPt(this), dragTarget.type);
		for(let ptInfo of ptList){
			let target = ptInfo.block;
			switch(ptInfo.type){
				case INSERT_PT_BELOW:
					if(dragTarget.isNearTo(target.x, target.y + target.getBlockHeight())){
						return ptInfo;
					}
					break;
				case INSERT_PT_SUB:
					if(dragTarget.isNearTo(target.x, target.y + target.getPositionSub(ptInfo.index))){
						return ptInfo;
					}
					break;
			}
		}
	}

	getSubBlock(index){
		return this._subBlockList[index];
	}

	setSubBlock(index, value){
		let subBlock = this.getSubBlock(index);
		if(value == subBlock){
			return;
		}
		if(subBlock != null){
			subBlock._parentBlock = null;
		}
		this._subBlockList[index] = value;
		if(value != null){
			value._parentBlock = this;
		}
	}
	
	get subBlock1(){ return this.getSubBlock(0); }
	get subBlock2(){ return this.getSubBlock(1); }
	set subBlock1(value){ this.setSubBlock(0, value); }
	set subBlock2(value){ this.setSubBlock(1, value); }

	get parentBlock(){
		return this._parentBlock;
	}
	
	get prevBlock(){
		return this._prevBlock;
	}
	
	get nextBlock(){
		return this._nextBlock;
	}
	
	set prevBlock(value){
		let old = this._prevBlock;
		if(value == old){
			return;
		}
		if(old != null){
			old._nextBlock = null;
		}
		this._prevBlock = value;
		if(value != null){
			value.nextBlock = this;
		}
	}
	
	set nextBlock(value){
		let old = this._nextBlock;
		if(value == old){
			return;
		}
		if(old != null){
			old._prevBlock = null;
		}
		this._nextBlock = value;
		if(value != null){
			value.prevBlock = this;
		}
	}
	
	get topBlock(){
		var block = this;
		while(block.prevBlock != null){
			block = block.prevBlock;
		}
		return block;
	}
	
	get lastBlock(){
		var block = this;
		while(block.nextBlock != null){
			block = block.nextBlock;
		}
		return block;
	}
	
	isIfBlock(){
		return this.type == BLOCK_TYPE_IF || this.type == BLOCK_TYPE_ELSE_IF;
	}
	
	isElseBlock(){
		return this.type == BLOCK_TYPE_ELSE || this.type == BLOCK_TYPE_ELSE_IF;
	}
	
	hasSubBlock2(){
		return this.type == BLOCK_TYPE_ARDUINO;
	}
	
	isExpression(){
		return this.type == BLOCK_TYPE_EXPRESSION;
	}
	
	isSubBlock(){
		let parent = this._parentBlock;
		return parent != null && parent._subBlockList.includes(this);
	}
	
	isControlBlock(){
		switch(this.type){
			case BLOCK_TYPE_FOR:
			case BLOCK_TYPE_IF:
			case BLOCK_TYPE_ELSE_IF:
			case BLOCK_TYPE_ELSE:
			case BLOCK_TYPE_ARDUINO:
				return true;
		}
		return false;
	}
	
	isTopBlock(){
		if(this.isExpression() || this.isSubBlock()){
			return false;
		}
		return null == this.prevBlock;
	}
	
	isFinalBlock(){
		switch(this.type){
			case BLOCK_TYPE_BREAK:
			case BLOCK_TYPE_CONTINUE:
				return true;
		}
		return false;
	}
	
	addBlockToLast(value){
		this.lastBlock.nextBlock = value;
	}
	
	layoutAfterInsertAbove(){
		var nextBlock = this;
		var block = this.prevBlock;
		while(block != null){
			block.doLayout(nextBlock.x, nextBlock.y - block.getBlockHeight());
			nextBlock = block;
			block = block.prevBlock;
		}
	}
	
	layoutAfterInsertBelow(){
		var prevBlock = this;
		var block = this.nextBlock;
		while(block != null){
			block.doLayout(prevBlock.x, prevBlock.y + prevBlock.getBlockHeight());
			prevBlock = block;
			block = block.nextBlock;
		}
	}
	
	doLayout(px, py){
		this.x = px;
		this.y = py;
		this.svg.setAttribute("transform", `translate(${px},${py})`);
		this.relayout();
	}
	
	relayout(){
		this.layoutSubBlock();
		this.layoutChildren();
	}
	
	getTotalBlockWidth(){
		var result = 0;
		var block = this;
		while(block != null){
			result = Math.max(result, block.getBlockWidth());
			block = block.nextBlock;
		}
		return result;
	}
	
	getTotalBlockHeight(){
		var result = 0;
		var block = this;
		while(block != null){
			result += block.getBlockHeight();
			block = block.nextBlock;
		}
		return result;
	}
	
	getBlockWidth(){
		return this.svg.getBBox().width;
	}
	
	getBlockHeight(){
		return this.svg.getBBox().height - (this.isFinalBlock() ? 0 : drawer.b);
	}
	
	getPositionSub(index=0){
		let result = 20;
		for(let i=0; i<index; ++i){
			result += this.getSubHeight(i) + drawer.armH;
		}
		return result;
	}

	getSubHeight(index){
		let subBlock = this.getSubBlock(index);
		return subBlock != null ? subBlock.getTotalBlockHeight() : 10;
	}

	drawBg(){
		var w = this._totalWidth;
		var h = 20;

		let d;
		
		switch(this.type){
			case BLOCK_TYPE_EXPRESSION:
				d = drawer.drawExpression(w, h);
				break;
			case BLOCK_TYPE_FOR:
			case BLOCK_TYPE_IF:
			case BLOCK_TYPE_ELSE_IF:
			case BLOCK_TYPE_ELSE:
				d = drawer.drawStatement(w, h, true, true, this.getSubHeight(0));
				break;
			case BLOCK_TYPE_ARDUINO:
				d = drawer.drawStatement(w, h, false, false, this.getSubHeight(0), this.getSubHeight(1));
				break;
			default:
				d = drawer.drawStatement(w, h, true, !this.isFinalBlock());
		}
		this.bg.setAttribute("d", d);
	}
	
	setChildBlockAt(block, index){
		if(block == this.argBlockList[index]){
			return;
		}
		
		var oldBlock = this.argBlockList[index];
		
		if(oldBlock != null){
			oldBlock._parentBlock = null;
			oldBlock.x += 10;
			oldBlock.y += 10;
		}
		
		this.argBlockList[index] = block;
		
		if(block != null){
			block._parentBlock = this;
		}
		
		this.layoutChildren();
		this.drawBg();
	}
	
	hasChildBlock(block){
		return this.argBlockList.includes(block);
	}
	
	removeFromParentBlock(){
		if(this._parentBlock != null){
			this._parentBlock.removeChildBlock(this);
		}
	}
	
	removeChildBlock(block){
		var index = this.argBlockList.indexOf(block);
		if(index < 0)return;
		this.argBlockList[index] = null;
		block._parentBlock = null;
		this.notifyChildChanged();
	}
	
	notifyChildChanged(){
		var b = this;
		while(b != null){
			b.layoutChildren();
			b.drawBg();
			if(b.isSubBlock())break;
			b = b.parentBlock;
		}
	}

	setXY(x, y){
		this.x = x;
		this.y = y;
		this.svg.setAttribute("transform", `translate(${x},${y})`);
	}

	setPositionBySub(index){
		let child = this.getSubBlock(index);
		this.setXY(child.x - drawer.armW, child.y - this.getPositionSub(index));
	}
	
	layoutSubBlock(except=-1){
		for(let i=0, n=this._subBlockList.length; i<n; ++i){
			if(i == except)continue;
			let subBlock = this.getSubBlock(i);
			if(subBlock == null)continue;
			subBlock.doLayout(this.x + drawer.armW, this.y + this.getPositionSub(i));
			subBlock.layoutAfterInsertBelow();
		}
	}
	
	layoutChildren(){
		const childNodes = this.svg.childNodes;
		let offsetX = 2;
		for(let i=0, n=childNodes.length; i<n; ++i){
			let obj = childNodes[i];
			if(obj.nodeName == "path"){
				continue;
			}
			let index = this.defaultArgBlockList.indexOf(obj.block);
			if(index >= 0 && this.argBlockList[index]){
				obj.style.display = "none"
				let argBlock = this.argBlockList[index];
				argBlock.doLayout(this.x + offsetX, this.y);
				offsetX += argBlock.getBlockWidth();
			}else{
				obj.style.display = "block";
				setSvgXY(obj, offsetX, 0);
				offsetX += obj.getBBox().width;
			}
		}
		this._totalWidth = offsetX;
	}
	
	dragBegin(){
		let {parentBlock} = this;
		if(this.isExpression()){
			this.removeFromParentBlock();
		}else{
			let topParent = this.topBlock.parentBlock;
			this.prevBlock = null;
			if(parentBlock != null){
				let index = parentBlock._subBlockList.indexOf(this);
				if(index >= 0){
					parentBlock.setSubBlock(index, null);
				}
			}
			if(topParent != null){
				topParent.redrawControlBlockRecursively();
			}
		}
		this.swapToTopLayer();
	}
	
	getArgLayerCount(){
		var result = 0;
		for(var i=0; i<this.defaultArgBlockList.length; ++i){
			let argBlock = this.argBlockList[i];
			if(argBlock != null){
				result += 1 + argBlock.getArgLayerCount();
			}
		}
		return result;
	}
	
	getChildLayerCount(){
		var result = this.getArgLayerCount();
		for(let block of this._subBlockList){
			while(block != null){
				result += 1 + block.getChildLayerCount();
				block = block.nextBlock;
			}
		}
		return result;
	}
	
	swapToTopLayer(){
		let {parentNode} = this.svg;
		let childNodes = parentNode.childNodes;
		let topIndex = childNodes.length - 1;
		
		if(Array.from(childNodes).indexOf(this.svg) + this.getChildLayerCount() == topIndex){
			return;
		}
		parentNode.appendChild(this.svg);
		for(var i=0; i<this.defaultArgBlockList.length; ++i){
			let block = this.argBlockList[i];
			if(block != null){
				block.swapToTopLayer();
			}
		}
		for(let block of this._subBlockList){
			while(block != null){
				block.swapToTopLayer();
				block = block.nextBlock;
			}
		}
	}
	
	redrawControlBlockRecursively(){
		var topParent = this;
		do{
			topParent.redrawControlBlock();
			topParent = topParent.topBlock.parentBlock;
		}while(topParent != null);
	}
	
	redrawControlBlock(){
		this.drawBg();
		this.layoutSubBlock();
		this.layoutAfterInsertBelow();
	}
	
	isNearTo(px, py){
		return Math.abs(this.x - px) <= 10 && Math.abs(this.y - py) <= 10;
	}

	enableDrag(){
		let block = this;
		let {svg} = this;
		svg.onmousedown = this.onMouseDown;
	}

	notifyDragEvt(evtType){
		let dragEvt = new Event(evtType);
		dragEvt.block = this;
		return this.svg.viewportElement.dispatchEvent(dragEvt);
	}

	get rootScale(){
		return parseFloat(this.svg.viewportElement.dataset.scale) || 1;
	}

	onMouseDown(e){
		let block = this.block;
		let svg = this;
		let {x:dx, y:dy} = e;
		let offsetX, offsetY;
		if(svg.transform.baseVal.length > 0){
			let matrix = svg.transform.baseVal.getItem(0).matrix;
			offsetX = matrix.e;
			offsetY = matrix.f;
		}

		block.dragBegin();
		block.bg.appendChild(blockDragAni);

		block.notifyDragEvt("block_drag_begin");

		let scale = 1 / block.rootScale;
		let dropTarget;

		function onMouseMove(e){
			let x = Math.min(Math.max(offsetX + scale * (e.x - dx), 0), svg.viewportElement.getAttribute("width")  - block.getTotalBlockWidth());
			let y = Math.min(Math.max(offsetY + scale * (e.y - dy), 0), svg.viewportElement.getAttribute("height") - block.getTotalBlockHeight());
			block.setXY(x, y);
			block.relayout();
			block.layoutAfterInsertBelow();
			dropTarget = block.findDropTarget();
			indicator.indicate(block, dropTarget, svg.parentNode);
		}

		window.addEventListener("mousemove", onMouseMove);
		window.addEventListener("mouseup", function(){
			window.removeEventListener("mousemove", onMouseMove);
			indicator.clear();
			let deleteFlag = !block.notifyDragEvt("block_drag_end");
			if(deleteFlag)return;
			block.bg.removeChild(blockDragAni);
			if(dropTarget != null){
				dropTarget.insert(block);
			}
		}, {once:true});
	}

	findDropTarget(){
		let result;
		for(let {block} of this.svg.parentNode.childNodes){
			if(block == null || block == this)continue;
			if(this.isExpression()){
				if(block.isExpression() && block.parentBlock){
					continue;
				}
				result = block.tryAccept(this);
			}else if(block.isTopBlock()){
				result = block.tryLink(this);
			}
			if(result)break;
		}
		return result;
	}

	enableClone(dest){
		let block = this;
		let source = this.svg.parentNode;
		source.onmousedown = function(e){
			let rect1 = dest.getBoundingClientRect();
			let rect2 = this.getBoundingClientRect();
			let copy = block.clone(dest);
			let scale = 1 / copy.rootScale;
			copy.setXY((rect2.left - rect1.left) * scale, (rect2.top - rect1.top) * scale);
			copy.enableDrag();
			copy.onMouseDown.call(copy.svg, e);
		}
	}

	moveToTrash(){
		let {svg} = this;
		let viewport = svg.parentNode;
		for(let child of this.argBlockList){
			if(child){
				viewport.removeChild(child.svg);
			}
		}
		for(let subBlock of this._subBlockList){
			if(subBlock){
				subBlock.moveToTrash();
			}
		}
		let block = this;
		while(block != null){
			viewport.removeChild(block.svg);
			block = block.nextBlock;
		}
	}
}

function collectInsertPt(block, result=[]){
	while(block != null){
		switch(block.type){
			case BLOCK_TYPE_ARDUINO:
				result.push(new InsertPtInfo(block, INSERT_PT_SUB, 0));
				result.push(new InsertPtInfo(block, INSERT_PT_SUB, 1));
				collectInsertPt(block.subBlock1, result);
				collectInsertPt(block.subBlock2, result);
				break;
			case BLOCK_TYPE_IF:
			case BLOCK_TYPE_ELSE_IF:
			case BLOCK_TYPE_ELSE:
			case BLOCK_TYPE_FOR:
				result.push(new InsertPtInfo(block, INSERT_PT_SUB));
				collectInsertPt(block.subBlock1, result);
				//fall through
			case BLOCK_TYPE_STATEMENT:
				result.push(new InsertPtInfo(block, INSERT_PT_BELOW));
				break;
		}
		block = block.nextBlock;
	}
	return result;
}

function setSvgXY(svg, x, y){
	svg.setAttribute("transform", `translate(${x},${y})`);
}

class BlockLabel
{
	constructor(label){
		this.svg = SVG.createText(label, {
			x:0,
			y:16,
			"text-anchor":"start",
			"style":"user-select:none;font-size: 12px;"
		});
	}
}

class BlockArg
{
	constructor(block, type, argIndex){
		this.block = block;
		this.type = type;
		this.argIndex = argIndex;

		this.svg = SVG.createElement("g");
		this.svg.block = this;

		this.bg = SVG.createElement("rect", {
			"fill":"#FFFF00",
			"stroke":"#3373CC",
			"fill-opacity":"1",
			"width":40,
			"height":16
		});
		this.label = SVG.createText("", {
			x:12,
			y:24,
			"text-anchor":"middle",
			"style":"user-select:none;font-size: 14px;"
		});
		this.svg.appendChild(this.bg);
		this.svg.appendChild(this.label);
	}

	setText(value){
		this.label.innerHTML = value;
	}
/*
	element.onclick = function(e){
					let textInput = document.getElementById("textInput");
					textInput.onblur = function(){
						textInput.parentNode.style.display = "none";
						label.innerHTML = textInput.value;
					}
					textInput.parentNode.style.display = "block";
					let bound = label.getBoundingClientRect();
					console.log(bound)
					textInput.parentNode.style.left = bound.left + "px";
					textInput.parentNode.style.top = bound.top + "px";
					textInput.value = label.innerHTML;
					textInput.focus();
				}
				*/
}

module.exports = BlockBase;

const Spec = require("./Spec");
const SVG = require("fileformats/svg");
const InsertPtInfo = require("./InsertPtInfo");
const InsertPtIndicator = require("./InsertPtIndicator");
const drawer = require("./BlockDrawer");

const insertPtsFilter = require("./InsertPtsFilter");
const indicator = new InsertPtIndicator();

const blockDragAni = SVG.createElement("animate", {
	"attributeType":"XML",
	"repeatCount":"indefinite",
	"attributeName":"stroke-opacity",
	"dur":"1s",
	"values":"1;0;1"
});