"use strict";

const {
	INSERT_PT_BELOW,
	INSERT_PT_ABOVE,
	INSERT_PT_SUB,
	INSERT_PT_WRAP,
	INSERT_PT_CHILD
} = require("./BlockConst");

class InsertPtInfo
{
	constructor(block, type, index=0){
		this.block = block;
		this.type = type;
		this.index = index;
	}
	
	insert(target){
		if(target.isExpression()){
			this.insertExpression(target);
		}else{
			this.insertStatement(target);
		}
	}
	
	insertExpression(target){
		let {block, index} = this;
		block.setChildBlockAt(target, index);
		block.notifyChildChanged();
	}
	
	insertStatement(target){
		let {block, index} = this;
		switch(this.type){
			case INSERT_PT_BELOW:
				if(!target.isFinalBlock()){
					target.addBlockToLast(block.nextBlock);
				}
				target.prevBlock = block;
				block.layoutAfterInsertBelow();
				let topParent = block.topBlock.parentBlock;
				if(topParent != null){
					topParent.redrawControlBlockRecursively();
				}
				break;
			case INSERT_PT_ABOVE:
				target.prevBlock = block.prevBlock;
				target.addBlockToLast(block);
				block.layoutAfterInsertAbove();
				break;
			case INSERT_PT_SUB:
				if(0 == index){
					if(!target.isFinalBlock()){
						target.addBlockToLast(block.subBlock1);
					}
					block.subBlock1 = target;
				}else{
					if(!target.isFinalBlock()){
						target.addBlockToLast(block.subBlock2);
					}
					block.subBlock2 = target;
				}
				block.redrawControlBlockRecursively();
				break;
			case INSERT_PT_WRAP:
				target.setSubBlock(index, block);
				target.setPositionBySub(index);
				target.layoutChildren();
				target.drawBg();
				target.layoutAfterInsertBelow();
				target.swapToTopLayer();
				break;
		}
	}
}

module.exports = InsertPtInfo;
