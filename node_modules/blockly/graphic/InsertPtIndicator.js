"use strict";

const {
	INSERT_PT_BELOW,
	INSERT_PT_ABOVE,
	INSERT_PT_SUB,
	INSERT_PT_WRAP,
	INSERT_PT_CHILD
} = require("./BlockConst");

const RECT_H = 4;

class InsertPtIndicator
{
	constructor(){
		this.svg = SVG.createElement("path", {
			"fill":"#00FF00",
			"fill-opacity":0,
			"stroke-dasharray":"10,4",
			"stroke":"#FF0000"
		});
		this.svg.appendChild(SVG.createElement("animate", {
			"attributeType":"XML",
			"repeatCount":"indefinite",
			"attributeName":"stroke-dashoffset",
			"dur":"1s",
			"from":"0",
			"to":"14"
		}));
	}
	
	clear(){
		let {svg} = this;
		if(svg.parentNode){
			svg.parentNode.removeChild(svg);
		}
	}
	
	indicate(dragTarget, insertPt, dock){
		if(null == insertPt){
			this.clear();
			return;
		}
		let {svg} = this;
		if(!svg.parentNode){
			dock.appendChild(svg);
		}
		let block = insertPt.block;
		let path;
		switch(insertPt.type){
			case INSERT_PT_ABOVE:
				var dragTargetTotalHeight = dragTarget.getTotalBlockHeight();
				this.beginDrawOutline(block.x, block.y - dragTargetTotalHeight);
				path = drawer.drawStatement(dragTarget.getTotalBlockWidth(), dragTargetTotalHeight);
				break;
			case INSERT_PT_BELOW:
				this.beginDrawOutline(block.x, block.y + block.getBlockHeight());
				path = drawer.drawStatement(dragTarget.getTotalBlockWidth(), block.nextBlock ? 4 : dragTarget.getTotalBlockHeight());
				break;
			case INSERT_PT_CHILD:
				let child = block.getArgBlockAt(insertPt.index);
				let viewport = child.svg.viewportElement.getBoundingClientRect();
				let rect = child.svg.getBoundingClientRect();
				let x = rect.left - viewport.left;
				let y = rect.top - viewport.top;
				path = this.drawRect(x, y, 20);
				break;
			case INSERT_PT_SUB:
				this.beginDrawOutline(block.x + drawer.armW, block.y + block.getPositionSub(insertPt.index));
				path = drawer.drawStatement(dragTarget.getTotalBlockWidth(), 2);
				break;
			case INSERT_PT_WRAP:
				this.beginDrawOutline(
					block.x - drawer.armW,
					block.y - dragTarget.getPositionSub(insertPt.index)
				);
				if(!dragTarget.hasSubBlock2()){
					path = drawer.drawStatement(dragTarget.getBlockWidth(), dragTarget.getPositionSub(0), true, true, block.getTotalBlockHeight());
				}else if(0 == insertPt.index){
					path = drawer.drawStatement(dragTarget.getBlockWidth(), dragTarget.getPositionSub(0), true, true, block.getTotalBlockHeight(), dragTarget.getSubHeight(1));
				}else{
					path = drawer.drawStatement(dragTarget.getBlockWidth(), dragTarget.getPositionSub(0), true, true, dragTarget.getSubHeight(0), block.getTotalBlockHeight());
				}
				break;
		}
		if(path){
			this.svg.setAttribute("d", path);
		}
	}
	
	drawRect(px, py, w){
		this.svg.removeAttribute("transform");
		return `M ${px},${py} h ${w} v ${RECT_H} h ${-w} z`;
	}
	
	beginDrawOutline(offsetX, offsetY){
		this.svg.setAttribute("transform", `translate(${offsetX},${offsetY})`);
	}
}

module.exports = InsertPtIndicator;

const SVG = require("fileformats/svg");
const drawer = require("./BlockDrawer");
