'use strict';

const js_vm = require('./js_vm');

const funcDefBlockNames = ['procedures_defreturn', 'procedures_defnoreturn', 'procedures_definition'];
const funcCallBlockNames = ['procedures_callreturn', 'procedures_callnoreturn', 'procedures_call'];
const quote = JSON.stringify;
const identity = v => v;
const isVarName = (regExp => name => regExp.test(name))(/^[a-z_A-Z]\w*$/);
const generateKey = (k, dotFlag=true) => isVarName(k) ? dotFlag ? `.${k}` : k : `[${quote(k)}]`;
const generateFuncDef = (name, body, args='') => `*${generateKey(name, false)}(${args}){\n${body}}`;

const castBlock = function(){
	const castToArray = v => v == null ? [] : Array.isArray(v) ? v : [v];
	const castToDict = (v, mapFn) => castToArray(v).reduce((dict, v) => (dict[v.name] = mapFn(v), dict), Object.create(null));
	//const castVarName = v => '_' + v.replace(/\W/g, c => c.charCodeAt().toString(36));
	const insertYieldFlag = (tab, code='') => `{\n${tab+'\t'}yield yieldFlag\n${code}${tab}}`;
	const variables_set = (k, v) => `\t$.variables_set({VAR:${quote(k)},VALUE:${v}})\n`;
	const generateObject = list => `{${list.map(([k, v]) => (isVarName(k) ? k : quote(k)) + ':' + v)}}`;
	const castArg = ({block, shadow}) => castBlock(block || shadow);
	const castArgList = ({field, value}, mapFn=identity) => [
		...castToArray(field).map(v => [v.name, quote(v['#text'])]),
		...castToArray(value).map(v => [mapFn(v.name), castArg(v)])
	];
	return function(block, offset=0){
		const opcode = block.type;
		const tab = '\t'.repeat(offset);
		if(opcode === 'controls_flow_statements'){
			return tab + block.field['#text'].toLowerCase();
		}
		if(opcode === 'logic_ternary'){
			const {IF, THEN, ELSE} = castToDict(block.value, castArg);
			return `((${IF || 0}) ? (${THEN || 0}) : (${ELSE || 0}))`;
		}
		if(opcode == 'control_wait'){
			return tab + `for(let end=performance.now()+1000*(${
				castArg(block.value)
			});performance.now()<end;)yield yieldOneTickFlag;`;
		}
		if(opcode == 'control_forever'){
			const {statement} = block;
			if(!statement)return tab + 'yield suspendFlag';
			const code = castBlockList(statement.block, offset+1);
			return tab + `for(;;)` + insertYieldFlag(tab, code);
		}
		if(opcode == 'control_if'){
			const {value, statement} = block;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `if(${castArg(value)}){\n${code}${tab}}`;
		}
		if(opcode == 'control_if_else'){
			const statement = castToDict(block.statement, v => castBlockList(v.block, offset+1));
			return tab + `if(${castArg(block.value)}){\n${statement.SUBSTACK || ''}${tab}}else{\n${statement.SUBSTACK2 || ''}${tab}}`;
		}
		if(opcode == 'control_wait_until'){
			return tab + `while(!(${castArg(block.value)}))` + insertYieldFlag(tab);
		}
		if(opcode == 'control_repeat_until'){
			const {value, statement} = block;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `while(!(${castArg(value)}))` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_if'){
			const elseifCount = block.mutation ? Number(block.mutation['elseif']) : 0;
			const elseCount   = block.mutation ? Number(block.mutation['else'])   : 0;
			const value = castToDict(block.value, castArg);
			const statement = castToDict(block.statement, v => castBlockList(v.block, offset+1));
			let result = `${tab}if(${value.IF0 || false}){\n${statement.DO0 || ''}${tab}}`;
			for(let i=1; i<=elseifCount; ++i){
				result += `else if(${value['IF'+i] || false}){\n${statement['DO'+i] || ''}${tab}}`;
			}
			if(elseCount > 0){
				result += `else{\n${statement.ELSE || ''}${tab}}`;
			}
			return result;
		}
		if(opcode === 'controls_repeat_ext'){
			const {value, statement} = block;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let i=${castArg(value)};i>0;--i)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_for'){
			const value = castToDict(block.value, castArg);
			let code = tab + variables_set(block.field['#text'], 'i');
			if(block.statement)code += castBlockList(block.statement.block, offset+1);
			return tab + `for(let i=${value.FROM}, n=${value.TO}, s=${value.BY};i<=n;i+=s)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_forEach'){
			const list = block.value ? castArg(block.value) : '[]';
			let code = tab + variables_set(block.field['#text'], 'i');
			if(block.statement)code += castBlockList(block.statement.block, offset+1);
			return tab + `for(let i of ${list})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_whileUntil'){
			const {value, statement} = block;
			const condition = block.field['#text'] === 'UNTIL' ? `!(${castArg(value)})` : castArg(value);
			let code = castBlockList(statement && statement.block, offset+1);
			return tab + `while(${condition})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'procedures_ifreturn'){
			const args = castToDict(block.value, castArg);
			return tab + `if(${args.CONDITION || false})return${args.VALUE ? ' ' + args.VALUE : ''};`;
		}
		if(opcode === 'procedures_param'){
			return `args${generateKey(block.field['#text'])}`;
		}
		if(opcode === 'procedures_definition'){
			const {statement} = block;
			const value = castToDict(block.value, castArg);
			const result = [];
			if(statement)result.push(castBlockList(statement.block));
			if(value.OUTPUT)result.push(`\treturn ${value.OUTPUT}\n`);
			return result.join('');
		}
		if(funcDefBlockNames.includes(opcode)){
			const {mutation, statement, value} = block;
			const result = mutation ? castToArray(mutation.arg).map(v => variables_set(v.name, `args${generateKey(v.name)}`)) : [];
			if(statement)result.push(castBlockList(statement.block));
			if(value)result.push(`\treturn ${castArg(value)}\n`);
			return result.join('');
		}
		if(funcCallBlockNames.includes(opcode)){
			const args = castToArray(block.mutation.arg).map(v => v.name);
			return tab + `yield* fn${generateKey(block.mutation.name)}(${generateObject(castArgList(block, v => args[v.slice(3)]))})`;
		}
		if(opcode == 'logic_boolean')return block.field['#text'] == 'TRUE';
		const blockData = block.data && block.data['#text'];
		if(opcode == 'text' || blockData == 'isConstText')return quote(block.field['#text'] || '');
		if(opcode == 'math_number' || blockData == 'isConstNumber')return block.field['#text'];
		const prefix = (blockData == 'isAsyncFunc') ? 'yield ' : '';
		return tab + prefix + `$${generateKey(opcode)}(${generateObject(castArgList(block))})`;
	}
}();

function castBlockList(block, offset=1){
	let result = [];
	while(block){
		result.push(castBlock(block, offset));
		block = block.next && block.next.block;
	}
	return result.map(v => v + '\n').join('');
}

function genFunction(blocks, startBlockName){
	const fnDefBlocks = blocks.filter(v => funcDefBlockNames.includes(v.type));
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	let code = 'return $ => {\nlet fn = {';
	code += fnDefBlocks.map(v => generateFuncDef(v.field['#text'], castBlock(v), 'args'));
	code += '}\nreturn {';
	code += startBlocks.map(v => generateFuncDef(v.id, castBlockList(v.next && v.next.block)));
	code += '}\n}';
	console.log(code);
	return js_vm.wrap(code);
}

function exec(blocks, startBlockName, context){
	if(blocks == null)return;
	if(!Array.isArray(blocks))blocks = [blocks];
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	if(startBlocks.length <= 0)return;
	const factory = genFunction(blocks, startBlockName)(context);
	startBlocks.map(v => factory[v.id]()).forEach(js_vm.exec);
}

exports.exec = exec;
exports.stop = js_vm.stop;
Object.defineProperty(exports, 'onfinish', {
	set(value){
		if(value){
			js_vm.on('finish', value);
		}else{
			js_vm.off('finish', this._onfinish);
		}
		this._onfinish = value;
	}
});
