'use strict';

const yieldFlag = Symbol();
const yieldOneTickFlag = Symbol();
const suspendFlag = Symbol();

const threadList = [];

requestAnimationFrame(function(){
	const finishThreads = [];
	const reviveThreads = [];
	return function loop(timestamp){
		requestAnimationFrame(loop);
		const timeEnd = timestamp + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				threadList.splice(threadList.indexOf(thread), 1);
				console.log('thread done!', thread.returnValue);
				if(threadList.length == 0){
					const {onfinish} = module.exports;
					if(onfinish)onfinish();
					return;
				}
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

const funcDefBlockNames = ['procedures_defreturn', 'procedures_defnoreturn'];

const castBlockList = function(){
	const castToArray = v => v == null ? [] : Array.isArray(v) ? v : [v];
	const castToDict = (v, mapFn) => castToArray(v).reduce((dict, v) => (dict[v.name] = mapFn(v), dict), Object.create(null));
	const quote = JSON.stringify;
	const isVarName = (regExp => name => regExp.test(name))(/^[a-z_A-Z]\w*$/);
	//const castVarName = v => '_' + v.replace(/\W/g, c => c.charCodeAt().toString(36));
	const insertYieldFlag = (tab, code='') => `{\n${tab+'\t'}yield yieldFlag\n${code}${tab}}`;
	const castArg = ({block, shadow}) => castBlock(block || shadow);
	const castArgList = ({field, value}) => [
		...castToArray(field).map(v => [v.name, quote(v['#text'])]),
		...castToArray(value).map(v => [v.name, castArg(v)])
	];
	function castBlock(block, offset=0){
		const tab = '\t'.repeat(offset);
		let opcode = block.type;
		if(opcode === 'controls_flow_statements'){
			return tab + block.field['#text'].toLowerCase();
		}
		if(opcode === 'logic_ternary'){
			const {IF, THEN, ELSE} = castToDict(block.value, castArg);
			return `((${IF || 0}) ? (${THEN || 0}) : (${ELSE || 0}))`;
		}
		if(opcode == 'control_wait'){
			return tab + `for(let end=performance.now()+1000*(${
				castArg(block.value)
			});performance.now()<end;)yield yieldOneTickFlag;`;
		}
		if(opcode === 'controls_if'){
			const elseifCount = block.mutation ? Number(block.mutation['elseif']) : 0;
			const elseCount   = block.mutation ? Number(block.mutation['else'])   : 0;
			const value = castToDict(block.value, castArg);
			const statement = castToDict(block.statement, v => castBlockList(v.block, offset+1));
			let result = `${tab}if(${value.IF0 || false}){\n${statement.DO0 || ''}${tab}}`;
			for(let i=1; i<=elseifCount; ++i){
				result += `else if(${value['IF'+i] || false}){\n${statement['DO'+i] || ''}${tab}}`;
			}
			if(elseCount > 0){
				result += `else{\n${statement.ELSE || ''}${tab}}`;
			}
			return result;
		}
		if(opcode === 'controls_repeat_ext'){
			const {value, statement} = block;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let i=${castArg(value)};i>0;--i)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_for'){
			const value = castToDict(block.value, castArg);
			let code = tab + `\tcontext.variables_set({VAR:${quote(block.field['#text'])},VALUE:i})\n`;
			if(block.statement)code += castBlockList(block.statement.block, offset+1);
			return tab + `for(let i=${value.FROM}, n=${value.TO}, s=${value.BY};i<=n;i+=s)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_forEach'){
			const list = block.value ? castArg(block.value) : '[]';
			let code = tab + `\tcontext.variables_set({VAR:${quote(block.field['#text'])},VALUE:i})\n`;
			if(block.statement)code += castBlockList(block.statement.block, offset+1);
			return tab + `for(let i of ${list})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_whileUntil'){
			const {value, statement} = block;
			const condition = block.field['#text'] === 'UNTIL' ? `!(${castArg(value)})` : castArg(value);
			let code = castBlockList(statement && statement.block, offset+1);
			return tab + `while(${condition})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'procedures_ifreturn'){
			if(!block.value){
				return tab + `if(false)return;`;
			}
			if(Array.isArray(block.value)){
				let condition = block.value.find(v => v.name == 'CONDITION');
				let value = block.value.find(v => v.name == 'VALUE');
				return tab + `if(${castArg(condition)})return ${castArg(value)};`;
			}
			if(block.value.name === 'CONDITION'){
				return tab + `if(${castArg(block.value)})return;`;
			}
			if(block.value.name === 'VALUE'){
				return tab + `if(false)return ${castArg(block.value)};`;
			}
		}
		if(funcDefBlockNames.includes(opcode)){
			let result = `fn[${quote(block.field['#text'])}] = function*(args){\n`;
			if(block.mutation){
				let args = castToArray(block.mutation.arg);
				for(let arg of args){
					let key = quote(arg.name);
					result += `\t$.variables_set({VAR:${key}, VALUE:args[${key}]})\n`;
				}
			}
			if(block.statement){
				result += castBlockList(block.statement.block);
			}
			if(block.value){
				result += `\treturn ${castArg(block.value)};\n`;
			}
			return result + `}`;
		}
		if(opcode === 'procedures_callnoreturn' || opcode === 'procedures_callreturn'){
			const prefix = opcode === 'procedures_callnoreturn' ? tab : '';
			let name = prefix + `yield* fn[${quote(block.mutation.name)}]`;
			if(!block.value)return name + '({})';
			const value = castToArray(block.value);
			const args = castToArray(block.mutation.arg);
			return name + '(' + value.map(v => quote(args[v.name.slice(3)].name) + ':' + castBlock(v.block)) + ')';
		}
		opcode = isVarName(opcode) ? '.' + opcode : `['${opcode}']`;
		const isAsyncFunc = block.data && block.data['#text'] == 'isAsyncFunc';
		return tab + (isAsyncFunc ? 'yield ' : '') + `$${opcode}({${
			castArgList(block).map(([k, v]) => (isVarName(k) ? k : quote(k)) + ':' + v)
		}})`;
	}
	return function(block, offset=1){
		let result = [];
		while(block){
			result.push(castBlock(block, offset));
			block = block.next && block.next.block;
		}
		return result.map(v => v + '\n').join('');
	}
}();

function genFunction(blocks, startBlockName){
	const fnDefBlocks = blocks.filter(v => funcDefBlockNames.includes(v.type));
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	let code = 'return $ => {\n';
	if(fnDefBlocks.length > 0){
		code += 'const fn = Object.create(null);\n';
		code += fnDefBlocks.map(v => castBlockList(v)).join('');
	}
	code += 'return {';
	code += startBlocks.map(v => `*['${v.id}'](){\n${castBlockList(v.next && v.next.block)}}`);
	code += '}\n}';
	console.log(code);
	//return console.log;
	return Function('yieldFlag', 'yieldOneTickFlag', code)(yieldFlag, yieldOneTickFlag);
}

function exec(blocks, startBlockName, context){
	if(blocks == null)return;
	if(!Array.isArray(blocks))blocks = [blocks];
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	if(startBlocks.length <= 0)return;
	const factory = genFunction(blocks, startBlockName)(context);
	threadList.push(...startBlocks.map(v => factory[v.id]()));
}

function stop(){
	threadList.length = 0;
}

exports.exec = exec;
exports.stop = stop;
exports.onfinish = null;
