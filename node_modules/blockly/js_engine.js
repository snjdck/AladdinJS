'use strict';

const yieldFlag = Symbol();
const yieldOneTickFlag = Symbol();
const suspendFlag = Symbol();

const threadList = [];

requestAnimationFrame(function(){
	const finishThreads = [];
	const reviveThreads = [];
	return function loop(timestamp){
		requestAnimationFrame(loop);
		const timeEnd = timestamp + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				threadList.splice(threadList.indexOf(thread), 1);
				console.log('thread done!', thread.returnValue);
				if(threadList.length == 0){
					const {onfinish} = module.exports;
					if(onfinish)onfinish();
					return;
				}
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

const castBlockList = function(){
	const quote = (regExp => v => `'${v.replace(regExp, "\\'")}'`)(/'/g);
	const isVarName = (regExp => name => regExp.test(name))(/^[a-z_A-Z]\w*$/);
	const castVarName = v => '_' + v.replace(/\W/g, c => c.charCodeAt().toString(36));
	const insertYieldFlag = (tab, code='') => `{\n${tab+'\t'}yield yieldFlag\n${code}${tab}}`;
	function castArg({name, shadow, block}){
		let value;
		if(block){
			value = castBlock(block);
		}else{
			let {field, type} = shadow;
			value = field['#text'] || "";
			if(type.endsWith('_number') || type.endsWith('integer')){
				value = parseFloat(value);
			}else{
				value = quote(value);
			}
		}
		return [name, value];
	}
	function castArgList({field, value}){
		if(!(field || value)){
			return [];
		}
		if(field){
			if(!Array.isArray(field))
				field = [field];
			field = field.map(v => [v.name, quote(v['#text'])]);
		}
		if(value){
			if(!Array.isArray(value))
				value = [value];
			value = value.map(castArg);
		}
		return (field && value) ? field.concat(value) : (field || value);
	}
	function castBlock(block, offset=0){
		const tab = '\t'.repeat(offset);
		let opcode = block.type;
		if(opcode.startsWith('argument_reporter_')){
			return castVarName(block.field['#text']);
		}
		if(opcode == 'control_wait'){
			return tab + `for(const end=performance.now()+1000*(${
				castArg(block.value)[1]
			});performance.now()<end;)yield yieldOneTickFlag;`;
		}
		if(opcode === 'control_repeat'){
			if(!block.statement){
				return `${tab}void(${castArg(block.value)[1]})`;
			}
			let code = castBlockList(block.statement.block, offset+1);
			return tab + `for(let i=${castArg(block.value)[1]};i>0;--i)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'control_if_else'){
			if(!block.statement){
				opcode = 'control_if';
			}else{
				let condition = block.value ? castArg(block.value)[1] : false;
				if(Array.isArray(block.statement)){
					let statement = block.statement.reduce((prev, {name, block}) => {
						prev[name] = block;
						return prev;
					},{});
					let code1 = castBlockList(statement['SUBSTACK'], offset+1);
					let code2 = castBlockList(statement['SUBSTACK2'], offset+1);
					return `${tab}if(${condition}){\n${code1}${tab}}else{\n${code2}${tab}}`;
				}
				let code = castBlockList(block.statement.block, offset+1);
				if(block.statement.name === 'SUBSTACK'){
					return `${tab}if(${condition}){\n${code}${tab}}`;
				}
				return `${tab}if(${condition}){\n${tab}}else{\n${code}${tab}}`;
			}
		}
		if(opcode === 'control_if'){
			if(!block.value){
				return tab + '//pass control_if';
			}
			let condition = castArg(block.value)[1];
			if(block.statement){
				return `${tab}if(${condition}){\n${castBlockList(block.statement.block, offset+1)}${tab}}`;
			}
			return `${tab}void(${condition})`;
		}
		if(opcode === 'control_repeat_until'){
			if(!block.statement){
				opcode = 'control_wait_until';
			}else if(!block.value){
				opcode = 'control_forever';
			}else{
				let condition = castArg(block.value)[1];
				let code = castBlockList(block.statement.block, offset+1);
				return tab + `while(!(${condition}))` + insertYieldFlag(tab, code);
			}
		}
		if(opcode === 'control_wait_until'){
			if(!block.value){
				return tab + 'yield suspendFlag';
			}
			let condition = castArg(block.value)[1];
			return tab + `while(!(${condition}))` + insertYieldFlag(tab);
		}
		if(opcode === 'control_forever'){
			if(!block.statement){
				return tab + 'yield suspendFlag';
			}
			return tab + 'for(;;)' + insertYieldFlag(tab, castBlockList(block.statement.block, offset+1));
		}
		if(opcode === 'procedures_call'){
			let {proccode, argumentids} = block.mutation;
			let args = JSON.parse(argumentids).map(function(v){
				let result = this.find(([k]) => v == k);
				return result ? result[1] : 0;
			}, castArgList(block));
			return tab + `yield* ${castVarName(proccode)}(${args})`;
		}
		if(opcode === 'procedures_definition'){
			let {mutation} = block.statement.shadow;
			return `function* ${castVarName(mutation.proccode)}(${
				JSON.parse(mutation.argumentnames).map(castVarName)
			}){`;
		}
		opcode = isVarName(opcode) ? '.' + opcode : `['${opcode}']`;
		return tab + `yield context${opcode}({${
			castArgList(block).map(([k, v]) => (isVarName(k) ? k : quote(k)) + ':' + v)
		}})`;
	}
	return function(block, offset=1){
		let result = [];
		while(block){
			result.push(castBlock(block, offset));
			block = block.next && block.next.block;
		}
		return result.map(v => v + '\n').join('');
	}
}();

function genFunction(blocks, startBlockName){
	const fnDefBlocks = blocks.filter(v => v.type === 'procedures_definition');
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	let code = 'return context => {\n';
	code += fnDefBlocks.map(v => castBlockList(v) + '}\n').join('');
	code += 'return {';
	code += startBlocks.map(v => `*['${v.id}'](){\n${castBlockList(v)}}`);
	code += '}\n}';
	return Function('yieldFlag', 'yieldOneTickFlag', 'suspendFlag', code)(yieldFlag, yieldOneTickFlag, suspendFlag);
}

function exec(blocks, startBlockName, context){
	if(blocks == null)return;
	if(!Array.isArray(blocks))blocks = [blocks];
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	if(startBlocks.length <= 0)return;
	const factory = genFunction(blocks, startBlockName)(context);
	threadList.push(...startBlocks.map(v => factory[v.id]()));
}

function stop(){
	threadList.length = 0;
}

exports.exec = exec;
exports.stop = stop;
exports.onfinish = null;
