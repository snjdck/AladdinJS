'use strict';

const yieldFlag = Symbol();
const yieldOneTickFlag = Symbol();
const suspendFlag = Symbol();

const threadList = [];

requestAnimationFrame(function(){
	const finishThreads = [];
	const reviveThreads = [];
	return function loop(timestamp){
		requestAnimationFrame(loop);
		const timeEnd = timestamp + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				threadList.splice(threadList.indexOf(thread), 1);
				console.log('thread done!', thread.returnValue);
				if(threadList.length == 0){
					const {onfinish} = module.exports;
					if(onfinish)onfinish();
					return;
				}
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

const funcDefBlockNames = ['procedures_defreturn', 'procedures_defnoreturn'];
const quote = JSON.stringify;
const identity = v => v;
const isVarName = (regExp => name => regExp.test(name))(/^[a-z_A-Z]\w*$/);
const generateKey = (k, dotFlag=true) => isVarName(k) ? dotFlag ? `.${k}` : k : `[${quote(k)}]`;
const generateFuncDef = (name, body, args='') => `*${generateKey(name, false)}(${args}){\n${body}}`;

const castBlock = function(){
	const castToArray = v => v == null ? [] : Array.isArray(v) ? v : [v];
	const castToDict = (v, mapFn) => castToArray(v).reduce((dict, v) => (dict[v.name] = mapFn(v), dict), Object.create(null));
	//const castVarName = v => '_' + v.replace(/\W/g, c => c.charCodeAt().toString(36));
	const insertYieldFlag = (tab, code='') => `{\n${tab+'\t'}yield yieldFlag\n${code}${tab}}`;
	const variables_set = (k, v) => `\t$.variables_set({VAR:${quote(k)},VALUE:${v}})\n`;
	const generateObject = list => `{${list.map(([k, v]) => (isVarName(k) ? k : quote(k)) + ':' + v)}}`;
	const castArg = ({block, shadow}) => castBlock(block || shadow);
	const castArgList = ({field, value}, mapFn=identity) => [
		...castToArray(field).map(v => [v.name, quote(v['#text'])]),
		...castToArray(value).map(v => [mapFn(v.name), castArg(v)])
	];
	return function(block, offset=0){
		const opcode = block.type;
		if(opcode === 'math_number')return block.field['#text'];
		if(opcode === 'text')return quote(block.field['#text'] || '');
		if(opcode === 'logic_boolean')return block.field['#text'] === 'TRUE';
		const tab = '\t'.repeat(offset);
		if(opcode === 'controls_flow_statements'){
			return tab + block.field['#text'].toLowerCase();
		}
		if(opcode === 'logic_ternary'){
			const {IF, THEN, ELSE} = castToDict(block.value, castArg);
			return `((${IF || 0}) ? (${THEN || 0}) : (${ELSE || 0}))`;
		}
		if(opcode == 'control_wait'){
			return tab + `for(let end=performance.now()+1000*(${
				castArg(block.value)
			});performance.now()<end;)yield yieldOneTickFlag;`;
		}
		if(opcode === 'controls_if'){
			const elseifCount = block.mutation ? Number(block.mutation['elseif']) : 0;
			const elseCount   = block.mutation ? Number(block.mutation['else'])   : 0;
			const value = castToDict(block.value, castArg);
			const statement = castToDict(block.statement, v => castBlockList(v.block, offset+1));
			let result = `${tab}if(${value.IF0 || false}){\n${statement.DO0 || ''}${tab}}`;
			for(let i=1; i<=elseifCount; ++i){
				result += `else if(${value['IF'+i] || false}){\n${statement['DO'+i] || ''}${tab}}`;
			}
			if(elseCount > 0){
				result += `else{\n${statement.ELSE || ''}${tab}}`;
			}
			return result;
		}
		if(opcode === 'controls_repeat_ext'){
			const {value, statement} = block;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let i=${castArg(value)};i>0;--i)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_for'){
			const value = castToDict(block.value, castArg);
			let code = tab + variables_set(block.field['#text'], 'i');
			if(block.statement)code += castBlockList(block.statement.block, offset+1);
			return tab + `for(let i=${value.FROM}, n=${value.TO}, s=${value.BY};i<=n;i+=s)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_forEach'){
			const list = block.value ? castArg(block.value) : '[]';
			let code = tab + variables_set(block.field['#text'], 'i');
			if(block.statement)code += castBlockList(block.statement.block, offset+1);
			return tab + `for(let i of ${list})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_whileUntil'){
			const {value, statement} = block;
			const condition = block.field['#text'] === 'UNTIL' ? `!(${castArg(value)})` : castArg(value);
			let code = castBlockList(statement && statement.block, offset+1);
			return tab + `while(${condition})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'procedures_ifreturn'){
			if(!block.value){
				return tab + `if(false)return;`;
			}
			if(Array.isArray(block.value)){
				let condition = block.value.find(v => v.name == 'CONDITION');
				let value = block.value.find(v => v.name == 'VALUE');
				return tab + `if(${castArg(condition)})return ${castArg(value)};`;
			}
			if(block.value.name === 'CONDITION'){
				return tab + `if(${castArg(block.value)})return;`;
			}
			if(block.value.name === 'VALUE'){
				return tab + `if(false)return ${castArg(block.value)};`;
			}
		}
		if(funcDefBlockNames.includes(opcode)){
			const {mutation, statement, value} = block;
			const result = mutation ? castToArray(mutation.arg).map(v => variables_set(v.name, `args${generateKey(v.name)}`)) : [];
			if(statement)result.push(castBlockList(statement.block));
			if(value)result.push(`\treturn ${castArg(value)}\n`);
			return result.join('');
		}
		if(opcode === 'procedures_callnoreturn' || opcode === 'procedures_callreturn'){
			const prefix = opcode === 'procedures_callnoreturn' ? tab : '';
			let name = prefix + `yield* fn${generateKey(block.mutation.name)}`;
			if(!block.value)return name + '({})';
			const args = castToArray(block.mutation.arg);
			return name + '(' + generateObject(castArgList(block, v => args[v.slice(3)].name)) + ')';
		}
		const prefix = (block.data && block.data['#text'] == 'isAsyncFunc') ? 'yield ' : '';
		return tab + prefix + `$${generateKey(opcode)}(${generateObject(castArgList(block))})`;
	}
}();

function castBlockList(block, offset=1){
	let result = [];
	while(block){
		result.push(castBlock(block, offset));
		block = block.next && block.next.block;
	}
	return result.map(v => v + '\n').join('');
}

function genFunction(blocks, startBlockName){
	const fnDefBlocks = blocks.filter(v => funcDefBlockNames.includes(v.type));
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	let code = 'return $ => {\nlet fn = {';
	code += fnDefBlocks.map(v => generateFuncDef(v.field['#text'], castBlock(v), 'args'));
	code += '}\nreturn {';
	code += startBlocks.map(v => generateFuncDef(v.id, castBlockList(v.next && v.next.block)));
	code += '}\n}';
	console.log(code);
	return Function('yieldFlag', 'yieldOneTickFlag', code)(yieldFlag, yieldOneTickFlag);
}

function exec(blocks, startBlockName, context){
	if(blocks == null)return;
	if(!Array.isArray(blocks))blocks = [blocks];
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	if(startBlocks.length <= 0)return;
	const factory = genFunction(blocks, startBlockName)(context);
	threadList.push(...startBlocks.map(v => factory[v.id]()));
}

exports.exec = exec;
exports.stop = () => threadList.length = 0;
exports.onfinish = null;
