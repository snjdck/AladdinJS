'use strict';

const yieldFlag = Symbol();
const yieldOneTickFlag = Symbol();
const suspendFlag = Symbol();

const threadList = [];

requestAnimationFrame(function(){
	const finishThreads = [];
	const reviveThreads = [];
	return function loop(timestamp){
		requestAnimationFrame(loop);
		const timeEnd = timestamp + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				threadList.splice(threadList.indexOf(thread), 1);
				console.log('thread done!', thread.returnValue);
				if(threadList.length == 0){
					const {onfinish} = module.exports;
					if(onfinish)onfinish();
					return;
				}
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

const castBlockList = function(){
	const castToArray = v => v == null ? [] : Array.isArray(v) ? v : [v];
	const castToDict = v => castToArray(v).reduce((dict, v) => (dict[v.name] = v, dict), Object.create(null));
	const quote = (regExp => v => `'${v.replace(regExp, "\\'")}'`)(/'/g);
	const isVarName = (regExp => name => regExp.test(name))(/^[a-z_A-Z]\w*$/);
	const castVarName = v => '_' + v.replace(/\W/g, c => c.charCodeAt().toString(36));
	const insertYieldFlag = (tab, code='') => `{\n${tab+'\t'}yield yieldFlag\n${code}${tab}}`;
	function castArg({name, shadow, block}){
		return [name, castBlock(block || shadow)];
	}
	function castArgList({field, value}){
		if(!(field || value)){
			return [];
		}
		if(field){
			if(!Array.isArray(field))
				field = [field];
			field = field.map(v => [v.name, quote(v['#text'])]);
		}
		if(value){
			if(!Array.isArray(value))
				value = [value];
			value = value.map(castArg);
		}
		return (field && value) ? field.concat(value) : (field || value);
	}
	function castBlock(block, offset=0){
		const tab = '\t'.repeat(offset);
		let opcode = block.type;
		if(opcode === 'controls_flow_statements'){
			return tab + block.field['#text'].toLowerCase();
		}
		if(opcode === 'logic_ternary'){
			const {IF, THEN, ELSE} = castToDict(block.value);
			return `((${IF ? castArg(IF)[1] : 0}) ? (${THEN ? castArg(THEN)[1] : 0}) : (${ELSE ? castArg(ELSE)[1] : 0}))`;
		}
		if(opcode.startsWith('argument_reporter_')){
			return castVarName(block.field['#text']);
		}
		if(opcode == 'control_wait'){
			return tab + `for(const end=performance.now()+1000*(${
				castArg(block.value)[1]
			});performance.now()<end;)yield yieldOneTickFlag;`;
		}
		if(opcode === 'control_repeat'){
			if(!block.statement){
				return `${tab}void(${castArg(block.value)[1]})`;
			}
			let code = castBlockList(block.statement.block, offset+1);
			return tab + `for(let i=${castArg(block.value)[1]};i>0;--i)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'control_if_else'){
			if(!block.statement){
				opcode = 'control_if';
			}else{
				let condition = block.value ? castArg(block.value)[1] : false;
				if(Array.isArray(block.statement)){
					let statement = block.statement.reduce((prev, {name, block}) => {
						prev[name] = block;
						return prev;
					},{});
					let code1 = castBlockList(statement['SUBSTACK'], offset+1);
					let code2 = castBlockList(statement['SUBSTACK2'], offset+1);
					return `${tab}if(${condition}){\n${code1}${tab}}else{\n${code2}${tab}}`;
				}
				let code = castBlockList(block.statement.block, offset+1);
				if(block.statement.name === 'SUBSTACK'){
					return `${tab}if(${condition}){\n${code}${tab}}`;
				}
				return `${tab}if(${condition}){\n${tab}}else{\n${code}${tab}}`;
			}
		}
		if(opcode === 'control_if'){
			if(!block.value){
				return tab + '//pass control_if';
			}
			let condition = castArg(block.value)[1];
			if(block.statement){
				return `${tab}if(${condition}){\n${castBlockList(block.statement.block, offset+1)}${tab}}`;
			}
			return `${tab}void(${condition})`;
		}
		if(opcode === 'controls_if'){//Blockly
			let elseifCount = 0;
			let elseCount = 0;
			let {mutation, value, statement} = block;
			if(mutation){
				elseifCount = Number(mutation['elseif']);
				elseCount = Number(mutation['else']);
			}
			value = castToDict(value);
			statement = castToDict(statement);
			let result = `${tab}if(${value.IF0 ? castArg(value.IF0)[1] : false}){\n${castBlockList(statement.DO0 && statement.DO0.block, offset+1)}${tab}}`;
			for(let i=1; i<=elseifCount; ++i){
				result += `else if(${value['IF'+i] ? castArg(value['IF'+i])[1] : false}){\n${castBlockList(statement['DO'+i] && statement['DO'+i].block, offset+1)}${tab}}`;
			}
			if(elseCount > 0){
				result += `else{\n${castBlockList(statement.ELSE && statement.ELSE.block, offset+1)}${tab}}`;
			}
			return result;
		}
		if(opcode === 'controls_repeat_ext'){//Blockly
			const {value, statement} = block;
			const count = value ? castArg(value)[1] : 0;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let i=${count};i>0;--i)` + insertYieldFlag(tab, code);
		}
		/*
		if(opcode === 'controls_for'){
			const {value, statement} = block;
			const name = block.field['#text'];
			const count = value ? castBlock(value.block) : 0;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let ${name}=0, n=${count};${name}<;${name}+=${step})` + insertYieldFlag(tab, code);
		}*/
		if(opcode === 'controls_forEach'){
			const {value, statement} = block;
			const name = block.field['#text'];
			const list = value ? castBlock(value.block) : '[]';
			let code = tab + `\tcontext.variables_set({VAR:${quote(name)},VALUE:${name}})\n`;
			if(statement)code += castBlockList(statement.block, offset+1);
			return tab + `for(let ${name} of ${list})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_whileUntil'){//Blockly
			if(block.field['#text'] === 'WHILE'){
				const {value, statement} = block;
				let condition = value ? castBlock(value.block) : false;
				let code = castBlockList(statement && statement.block, offset+1);
				return tab + `while(${condition})` + insertYieldFlag(tab, code);
			}
			opcode = 'control_repeat_until';
		}
		if(opcode === 'control_repeat_until'){
			if(!block.statement){
				opcode = 'control_wait_until';
			}else if(!block.value){
				opcode = 'control_forever';
			}else{
				let condition = castArg(block.value)[1];
				let code = castBlockList(block.statement.block, offset+1);
				return tab + `while(!(${condition}))` + insertYieldFlag(tab, code);
			}
		}
		if(opcode === 'control_wait_until'){
			if(!block.value){
				return tab + 'yield suspendFlag';
			}
			let condition = castArg(block.value)[1];
			return tab + `while(!(${condition}))` + insertYieldFlag(tab);
		}
		if(opcode === 'control_forever'){
			if(!block.statement){
				return tab + 'yield suspendFlag';
			}
			return tab + 'for(;;)' + insertYieldFlag(tab, castBlockList(block.statement.block, offset+1));
		}
		if(opcode === 'procedures_call'){
			let {proccode, argumentids} = block.mutation;
			let args = JSON.parse(argumentids).map(function(v){
				let result = this.find(([k]) => v == k);
				return result ? result[1] : 0;
			}, castArgList(block));
			return tab + `yield* ${castVarName(proccode)}(${args})`;
		}
		if(opcode === 'procedures_definition'){
			let {mutation} = block.statement.shadow;
			return `function* ${castVarName(mutation.proccode)}(${
				JSON.parse(mutation.argumentnames).map(castVarName)
			}){`;
		}
		opcode = isVarName(opcode) ? '.' + opcode : `['${opcode}']`;
		const isAsyncFunc = block.data && block.data['#text'] == 'isAsyncFunc';
		return tab + (isAsyncFunc ? 'yield ' : '') + `$${opcode}({${
			castArgList(block).map(([k, v]) => (isVarName(k) ? k : quote(k)) + ':' + v)
		}})`;
	}
	return function(block, offset=1){
		let result = [];
		while(block){
			result.push(castBlock(block, offset));
			block = block.next && block.next.block;
		}
		return result.map(v => v + '\n').join('');
	}
}();

function genFunction(blocks, startBlockName){
	const fnDefBlocks = blocks.filter(v => v.type === 'procedures_definition');
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	let code = 'return $ => {\n';
	code += fnDefBlocks.map(v => castBlockList(v) + '}\n').join('');
	code += 'return {';
	code += startBlocks.map(v => `*['${v.id}'](){\n${castBlockList(v.next && v.next.block)}}`);
	code += '}\n}';
	console.log(code);
	//return console.log;
	return Function('yieldFlag', 'yieldOneTickFlag', 'suspendFlag', code)(yieldFlag, yieldOneTickFlag, suspendFlag);
}

function exec(blocks, startBlockName, context){
	if(blocks == null)return;
	if(!Array.isArray(blocks))blocks = [blocks];
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	if(startBlocks.length <= 0)return;
	const factory = genFunction(blocks, startBlockName)(context);
	threadList.push(...startBlocks.map(v => factory[v.id]()));
}

function stop(){
	threadList.length = 0;
}

exports.exec = exec;
exports.stop = stop;
exports.onfinish = null;
