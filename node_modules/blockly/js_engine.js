'use strict';

const yieldFlag = Symbol();
const yieldOneTickFlag = Symbol();
const suspendFlag = Symbol();

const threadList = [];

requestAnimationFrame(function(){
	const finishThreads = [];
	const reviveThreads = [];
	return function loop(timestamp){
		requestAnimationFrame(loop);
		const timeEnd = timestamp + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				threadList.splice(threadList.indexOf(thread), 1);
				console.log('thread done!', thread.returnValue);
				if(threadList.length == 0){
					const {onfinish} = module.exports;
					if(onfinish)onfinish();
					return;
				}
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

const funcDefBlockNames = ['procedures_defreturn', 'procedures_defnoreturn'];

const castBlockList = function(){
	const castToArray = v => v == null ? [] : Array.isArray(v) ? v : [v];
	const castToDict = v => castToArray(v).reduce((dict, v) => (dict[v.name] = v, dict), Object.create(null));
	const quote = JSON.stringify;
	const isVarName = (regExp => name => regExp.test(name))(/^[a-z_A-Z]\w*$/);
	//const castVarName = v => '_' + v.replace(/\W/g, c => c.charCodeAt().toString(36));
	const insertYieldFlag = (tab, code='') => `{\n${tab+'\t'}yield yieldFlag\n${code}${tab}}`;
	const castArg = ({block, shadow}) => castBlock(block || shadow);
	const castArgList = ({field, value}) => [
		...castToArray(field).map(v => [v.name, quote(v['#text'])]),
		...castToArray(value).map(v => [v.name, castArg(v)])
	];
	function castBlock(block, offset=0){
		const tab = '\t'.repeat(offset);
		let opcode = block.type;
		if(opcode === 'controls_flow_statements'){
			return tab + block.field['#text'].toLowerCase();
		}
		if(opcode === 'logic_ternary'){
			const {IF, THEN, ELSE} = castToDict(block.value);
			return `((${IF ? castArg(IF) : 0}) ? (${THEN ? castArg(THEN) : 0}) : (${ELSE ? castArg(ELSE) : 0}))`;
		}
		if(opcode == 'control_wait'){
			return tab + `for(const end=performance.now()+1000*(${
				castArg(block.value)
			});performance.now()<end;)yield yieldOneTickFlag;`;
		}
		if(opcode === 'control_repeat'){
			if(!block.statement){
				return `${tab}void(${castArg(block.value)})`;
			}
			let code = castBlockList(block.statement.block, offset+1);
			return tab + `for(let i=${castArg(block.value)};i>0;--i)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'control_if_else'){
			if(!block.statement){
				opcode = 'control_if';
			}else{
				let condition = block.value ? castArg(block.value) : false;
				if(Array.isArray(block.statement)){
					let statement = block.statement.reduce((prev, {name, block}) => {
						prev[name] = block;
						return prev;
					},{});
					let code1 = castBlockList(statement['SUBSTACK'], offset+1);
					let code2 = castBlockList(statement['SUBSTACK2'], offset+1);
					return `${tab}if(${condition}){\n${code1}${tab}}else{\n${code2}${tab}}`;
				}
				let code = castBlockList(block.statement.block, offset+1);
				if(block.statement.name === 'SUBSTACK'){
					return `${tab}if(${condition}){\n${code}${tab}}`;
				}
				return `${tab}if(${condition}){\n${tab}}else{\n${code}${tab}}`;
			}
		}
		if(opcode === 'control_if'){
			if(!block.value){
				return tab + '//pass control_if';
			}
			let condition = castArg(block.value);
			if(block.statement){
				return `${tab}if(${condition}){\n${castBlockList(block.statement.block, offset+1)}${tab}}`;
			}
			return `${tab}void(${condition})`;
		}
		if(opcode === 'controls_if'){//Blockly
			let elseifCount = 0;
			let elseCount = 0;
			let {mutation, value, statement} = block;
			if(mutation){
				elseifCount = Number(mutation['elseif']);
				elseCount = Number(mutation['else']);
			}
			value = castToDict(value);
			statement = castToDict(statement);
			let result = `${tab}if(${value.IF0 ? castArg(value.IF0) : false}){\n${castBlockList(statement.DO0 && statement.DO0.block, offset+1)}${tab}}`;
			for(let i=1; i<=elseifCount; ++i){
				result += `else if(${value['IF'+i] ? castArg(value['IF'+i]) : false}){\n${castBlockList(statement['DO'+i] && statement['DO'+i].block, offset+1)}${tab}}`;
			}
			if(elseCount > 0){
				result += `else{\n${castBlockList(statement.ELSE && statement.ELSE.block, offset+1)}${tab}}`;
			}
			return result;
		}
		if(opcode === 'controls_repeat_ext'){//Blockly
			const {value, statement} = block;
			const count = value ? castArg(value) : 0;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let i=${count};i>0;--i)` + insertYieldFlag(tab, code);
		}
		/*
		if(opcode === 'controls_for'){
			const {value, statement} = block;
			const name = block.field['#text'];
			const count = value ? castBlock(value.block) : 0;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let ${name}=0, n=${count};${name}<;${name}+=${step})` + insertYieldFlag(tab, code);
		}*/
		if(opcode === 'controls_forEach'){
			const {value, statement} = block;
			const name = block.field['#text'];
			const list = value ? castBlock(value.block) : '[]';
			let code = tab + `\tcontext.variables_set({VAR:${quote(name)},VALUE:${name}})\n`;
			if(statement)code += castBlockList(statement.block, offset+1);
			return tab + `for(let ${name} of ${list})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_whileUntil'){//Blockly
			const {value, statement} = block;
			let condition = castArg(value);
			if(block.field['#text'] === 'UNTIL'){
				condition = `!(${condition})`;
			}
			let code = castBlockList(statement && statement.block, offset+1);
			return tab + `while(${condition})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'procedures_ifreturn'){
			if(!block.value){
				return tab + `if(false)return;`;
			}
			if(Array.isArray(block.value)){
				let condition = block.value.find(v => v.name == 'CONDITION');
				let value = block.value.find(v => v.name == 'VALUE');
				return tab + `if(${castArg(condition)})return ${castArg(value)};`;
			}
			if(block.value.name === 'CONDITION'){
				return tab + `if(${castArg(block.value)})return;`;
			}
			if(block.value.name === 'VALUE'){
				return tab + `if(false)return ${castArg(block.value)};`;
			}
		}
		if(funcDefBlockNames.includes(opcode)){
			let result = `fn[${quote(block.field['#text'])}] = function*(args){\n`;
			if(block.mutation){
				let args = castToArray(block.mutation.arg);
				for(let arg of args){
					let key = quote(arg.name);
					result += `\t$.variables_set({VAR:${key}, VALUE:args[${key}]})\n`;
				}
			}
			if(block.statement){
				result += castBlockList(block.statement.block);
			}
			if(block.value){
				result += `\treturn ${castArg(block.value)};\n`;
			}
			return result + `}`;
		}
		if(opcode === 'procedures_callnoreturn' || opcode === 'procedures_callreturn'){
			const prefix = opcode === 'procedures_callnoreturn' ? tab : '';
			let name = prefix + `yield* fn[${quote(block.mutation.name)}]`;
			if(!block.value)return name + '({})';
			const value = castToArray(block.value);
			const args = castToArray(block.mutation.arg);
			return name + '(' + value.map(v => quote(args[v.name.slice(3)].name) + ':' + castBlock(v.block)) + ')';
		}
		opcode = isVarName(opcode) ? '.' + opcode : `['${opcode}']`;
		const isAsyncFunc = block.data && block.data['#text'] == 'isAsyncFunc';
		return tab + (isAsyncFunc ? 'yield ' : '') + `$${opcode}({${
			castArgList(block).map(([k, v]) => (isVarName(k) ? k : quote(k)) + ':' + v)
		}})`;
	}
	return function(block, offset=1){
		let result = [];
		while(block){
			result.push(castBlock(block, offset));
			block = block.next && block.next.block;
		}
		return result.map(v => v + '\n').join('');
	}
}();

function genFunction(blocks, startBlockName){
	const fnDefBlocks = blocks.filter(v => funcDefBlockNames.includes(v.type));
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	let code = 'return $ => {\n';
	if(fnDefBlocks.length > 0){
		code += 'const fn = Object.create(null);\n';
		code += fnDefBlocks.map(v => castBlockList(v)).join('');
	}
	code += 'return {';
	code += startBlocks.map(v => `*['${v.id}'](){\n${castBlockList(v.next && v.next.block)}}`);
	code += '}\n}';
	console.log(code);
	//return console.log;
	return Function('yieldFlag', 'yieldOneTickFlag', code)(yieldFlag, yieldOneTickFlag);
}

function exec(blocks, startBlockName, context){
	if(blocks == null)return;
	if(!Array.isArray(blocks))blocks = [blocks];
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	if(startBlocks.length <= 0)return;
	const factory = genFunction(blocks, startBlockName)(context);
	threadList.push(...startBlocks.map(v => factory[v.id]()));
}

function stop(){
	threadList.length = 0;
}

exports.exec = exec;
exports.stop = stop;
exports.onfinish = null;
