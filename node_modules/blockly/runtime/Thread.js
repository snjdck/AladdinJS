"use strict";

function apply(func){
	if(func == null)
		return;
	if(typeof func == "function")
		return func();
	return func[0](...func.slice(1));
}

class Signal
{
	constructor(){
		this.handlerMap = new Map();
	}

	add(handler, once=false){
		this.handlerMap.set(handler, once);
	}

	del(handler){
		this.handlerMap.delete(handler);
	}

	notify(...args){
		for(let handler in this.handlerMap){
			handler(...args);
			if(this.handlerMap[handler]){
				this.delete(handler);
			}
		}
	}
}

class Thread
{
	constructor(virtualMachine, codeList, globalContext){
		this.virtualMachine = virtualMachine;
		this.codeList = codeList;
		this.globalContext = globalContext;
		this.context = this.createContext();

		this.ip = 0;
		this.valueStack = [];
		this.sp = -1;

		this._isSuspend = false;
		this.suspendUpdater = null;

		this._finishSignal = new Signal();
		this._finishFlag = false;
		this._interruptFlag = false;
		this.runFlag = 0;
		this.userData = null;
	}
	
	createContext(){
		return this.globalContext != null ? this.globalContext.createChild() : new ScriptContext();
	}
	
	get finishSignal(){
		return this._finishSignal;
	}
	
	notifyFinish(){
		this._finishSignal.notify(this._interruptFlag);
	}
	
	interrupt(){
		this._interruptFlag = true;
		this._finishFlag = true;
	}
	
	isFinish(){
		return this._finishFlag;
	}
	
	start(){
		this.virtualMachine.startThread(this);
	}
	
	restart(){
		this.runFlag = 0;
		this._finishFlag = this._interruptFlag = false;
		this.valueStack.length = this.ip = 0;
		this.scope = null;
		this.sp = -1;
		this.context = this.createContext();
		this.resume();
		this.start();
	}
	
	execNextCode(){
		const {ip, codeList} = this;
		if(ip < codeList.length){
			InstructionExector.execute(codeList[ip], codeList[ip+1]);
		}else{
			this._finishFlag = true;
		}
	}
	
	yield(waitFlag=true){
		this.virtualMachine.yieldFlag = true;
		if(!this.virtualMachine.waitFlag && waitFlag){
			this.virtualMachine.waitFlag = true;
		}
	}
	
	suspend(){
		this._isSuspend = true;
	}
	
	resume(){
		this._isSuspend = false;
		this.suspendUpdater = null;
	}
	
	isSuspend(){
		return this._isSuspend;
	}
	
	push(value){
		this.valueStack[++this.sp] = value;
	}
	
	pop(){
		return this.valueStack[this.sp--];
	}
	
	updateSuspendState(){
		if(this.suspendUpdater != null)
			apply(this.suspendUpdater);
	}
	
	get resultValue(){
		if(this._interruptFlag)
			return;
		if(this._finishFlag && this.sp == 0)
			return this.valueStack[0];
	}
	
	requestRedraw(){
		if(Thread.REDRAW_FLAG){
			this.virtualMachine.redrawFlag = true;
		}
	}
	
	isRecursiveInvoke(funcRef){
		for(let scope = this.scope; scope; scope = scope.prev)
			if(scope.hasInvoked(funcRef))
				return true;
		return false;
	}
	
	peekScope(){
		return this.scope;
	}
	
	pushScope(scope){
		scope.prev = this.scope;
		this.scope = scope;
	}
	
	popScope(){
		let scope = this.scope;
		this.scope = scope.prev;
		return scope;
	}
	
	clone(){
		return new Thread(this.virtualMachine, this.codeList, this.globalContext);
	}
	
	newVar(varName, varValue){
		this.context.newKey(varName, varValue);
	}
	
	getVar(varName){
		return this.context.getValue(varName);
	}
	
	setVar(varName, value){
		this.context.setValue(varName, value);
	}
}

Thread.EXEC_TIME = 0;
Thread.REDRAW_FLAG = true;
Thread.Current = null;

module.exports = Thread;

const ScriptContext = require("./ScriptContext");
const InstructionExector = require("./InstructionExector");
