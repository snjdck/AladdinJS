"use strict";

const OpCode = require("../OpCode");
const OpFactory = require("../OpFactory");

var loopLayer = 0;

function append(target, list){
	target.push(...list);
}
	
function translate(blockList)
{
	console.assert(loopLayer == 0);
	return genStatementCode(blockList);
}

function genStatementCode(blockList)
{
	var result = [];
	var n = blockList != null ? blockList.length : 0;
	for(var i=0; i<n; ++i){
		var block = blockList[i];
		switch(block["type"]){
			case "break":
				if(loopLayer > 0){
					result.push([OpCode.BREAK]);
				}
				break;
			case "continue":
				if(loopLayer > 0){
					result.push([OpCode.CONTINUE]);
				}
				break;
			case "while":
			case "for":
				append(result, genForCode(block));
				break;
			case "until":
				append(result, genUntilCode(block));
				break;
			case "if":
				append(result, genIfCode(blockList, i));
				break;
			case "unless":
				append(result, genUnlessCode(block));
				break;
			case "loop":
				append(result, genLoopTimesCode(block));
				break;
			case "invoke":
				append(result, genInvokeCode(block));
				break;
			case "return":
				if(block["value"]){
					append(result, genExpressionCode(block["value"]));
					result.push(OpFactory.Return(1));
				}else{
					result.push(OpFactory.Return(0));
				}
				break;
			case "newVar":
				append(result, genExpressionCode(block["value"]));
				result.push([OpCode.NEW_VAR, block["name"]]);
				break;
			case "setVar":
				append(result, genExpressionCode(block["value"]));
				result.push(OpFactory.SetVar(block["name"]));
				break;
		}
	}
	return result;
}

function genExpressionCode(block)
{
	switch(block["type"]){
		case "string":
		case "number":
			return [OpFactory.Push(block["value"])];
		case "invoke":
			return genInvokeCode(block);
		case "getVar":
			return [OpFactory.GetVar(block["name"])];
		case "newFunction":
			return genNewFunctionCode(block);
		case "array":
			return [
				OpFactory.GetVar("__asm__newArray"),
				OpFactory.Invoke(0, 1),
				...block.value.map((v, i) => [
					OpFactory.Push(i),
					...genExpressionCode(v),
					OpFactory.GetVar("__asm__setKey"),
					OpFactory.Invoke(3, 1)
				]).reduce((a, b) => a.concat(b), [])
			];
		case "object":
			return [
				OpFactory.GetVar("__asm__newObject"),
				OpFactory.Invoke(0, 1),
				...block.value.map(([k, v]) => [
					...genExpressionCode(k),
					...genExpressionCode(v),
					OpFactory.GetVar("__asm__setKey"),
					OpFactory.Invoke(3, 1)
				]).reduce((a, b) => a.concat(b), [])
			];
	}
	return null;
}

function genArgListCode(argList)
{
	if(argList == null)
		return [];
	return argList.map(genExpressionCode).reduce((a, b) => a.concat(b), []);
}

function genForCode({init, condition, iter, code})
{
	return genForCodeImpl(
		genStatementCode(init),
		genExpressionCode(condition),
		genStatementCode(iter),
		code
	);
}

function genUntilCode({condition, code})
{
	return genForCodeImpl([], genExpressionCode(condition), [], code, true);
}

function genForCodeImpl(initCode, conditionCode, iterCode, loopBlock, invertCondition=false)
{
	++loopLayer;
	const loopCode = genStatementCode(loopBlock);
	--loopLayer;
	
	const result = initCode;
	
	const loopCount = loopCode.length + iterCode.length;
	const totalCount = loopCount + conditionCode.length;
	if(invertCondition){
		replaceBreakContinue(loopCode, loopCount + 1);
		append(result, conditionCode);
		result.push(OpFactory.JumpIf(loopCount + 2));
		append(result, loopCode);
		append(result, iterCode);
		result.push(OpFactory.Jump(-(totalCount + 1)));
	}else{
		replaceBreakContinue(loopCode, totalCount + 1);
		result.push(OpFactory.Jump(loopCount + 1));
		append(result, loopCode);
		append(result, iterCode);
		append(result, conditionCode);
		result.push(OpFactory.JumpIf(-totalCount));
	}
	return result;
}

function replaceBreakContinue(codeList, totalCodeLength)
{
	for(var i=0, n=codeList.length; i<n; ++i){
		switch(codeList[i][0]){
			case OpCode.BREAK:
				codeList[i] = OpFactory.Jump(totalCodeLength - i);
				break;
			case OpCode.CONTINUE:
				codeList[i] = OpFactory.Jump(n - i);
				break;
		}
	}
}

function genIfCodeImpl(condition, caseTrue, caseFalse)
{
	return [
		...genExpressionCode(condition),
		OpFactory.JumpIf(caseFalse.length + 2),
		...caseFalse,
		OpFactory.Jump(caseTrue.length + 1),
		...caseTrue
	];
}

function genIfCode(blockList, index)
{
	const {condition, code} = blockList[index];
	return genIfCodeImpl(condition, genStatementCode(code), genElseCode(blockList, index + 1));
}

function genElseCode(blockList, index)
{
	if(index < blockList.length){
		const {type, code} = blockList[index];
		switch(type){
			case "else if":
				return genIfCode(blockList, index);
			case "else":
				return genStatementCode(code);
		}
	}
	return [];
}

function genUnlessCode({condition, code})
{
	return genIfCodeImpl(condition, [], genStatementCode(code));
}

function genLoopTimesCode({count, code, key})
{
	let result;
	if(key){
		result = genForCodeImpl([
			OpFactory.Push(0),
			OpFactory.SetVar(key)
		], [
			[OpCode.DUPLICATE],
			OpFactory.GetVar(key),
			OpFactory.GetVar(">"),
			OpFactory.Invoke(2, 1)
		], [
			OpFactory.GetVar(key),
			OpFactory.GetVar("__asm__increase"),
			OpFactory.Invoke(1, 1),
			OpFactory.SetVar(key)
		], code);
	}else{
		result = genForCodeImpl([], [
			OpFactory.GetVar("__asm__decrease"),
			OpFactory.Invoke(1, 1),
			[OpCode.DUPLICATE],
			OpFactory.GetVar("__asm__isNotNegative"),
			OpFactory.Invoke(1, 1)
		], [], code);
	}
	return [...genExpressionCode(count), ...result, ...[OpFactory.GetVar("__asm__pop"), OpFactory.Invoke(1, 0)]];
}

function genInvokeCode({target, argList, retCount})
{
	return [
		...genArgListCode(argList),
		...genExpressionCode(target),
		OpFactory.Invoke(argList.length, retCount)
	];
}

function genNewFunctionCode({code, argList, userData})
{
	const result = genStatementCode(code);
	return [
		OpFactory.NewFunction(result.length+2, argList, userData),
		...result,
		OpFactory.Return(0)
	];
}

exports.translate = translate;