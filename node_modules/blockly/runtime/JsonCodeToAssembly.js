"use strict";

const OpCode = require("../OpCode");
const OpFactory = require("../OpFactory");
const Invoke = (name, argCount, retCount) => [OpFactory.GetVar(name), OpFactory.Invoke(argCount, retCount)];

let loopLayer = 0;
	
function translate(blockList)
{
	console.assert(loopLayer == 0);
	return genStatementCode(blockList);
}

function genStatementCode(blockList)
{
	let result = [];
	if(!blockList)return result;
	if(!Array.isArray(blockList))
		blockList = [blockList];
	let n = blockList != null ? blockList.length : 0;
	for(let i=0; i<n; ++i){
		let block = blockList[i];
		switch(block["type"]){
			case "break":
			case "continue":
				if(loopLayer > 0){
					result.push([block["type"]]);
				}
				break;
			case "while":
			case "for":
				result.push(...genForCode(block));
				break;
			case "until":
				result.push(...genUntilCode(block));
				break;
			case "if":
				result.push(...genIfCode(blockList, i));
				break;
			case "unless":
				result.push(...genUnlessCode(block));
				break;
			case "loop":
				result.push(...genLoopTimesCode(block));
				break;
			case "invoke":
				result.push(...genInvokeCode(block));
				break;
			case "return":
				if(block["value"]){
					result.push(...genExpressionCode(block["value"]));
					result.push(OpFactory.Return(1));
				}else{
					result.push(OpFactory.Return(0));
				}
				break;
			case "newVar":
				result.push(...genExpressionCode(block["value"]));
				result.push([OpCode.NEW_VAR, block["name"]]);
				break;
			case "setVar":
				result.push(...genExpressionCode(block["value"]));
				result.push(OpFactory.SetVar(block["name"]));
				break;
			case "arduino":
				result.push(...genStatementCode(block["setup"]));
				result.push(...genForCode({condition:{type:"number",value:1},code:block["loop"]}));
				break;
		}
	}
	return result;
}

function genExpressionCode(block)
{
	switch(block["type"]){
		case "string":
		case "number":
			return [OpFactory.Push(block["value"])];
		case "invoke":
			return genInvokeCode(block);
		case "get":
			return [OpFactory.GetVar(block["name"])];
		case "newFunction":
			return genNewFunctionCode(block);
		case "array":
			return [
				...Invoke("__asm__newArray", 0, 1),
				...block.value.map((v, i) => [
					OpFactory.Push(i),
					...genExpressionCode(v),
					...Invoke("__asm__setKey", 3, 1)
				]).reduce((a, b) => a.concat(b), [])
			];
		case "object":
			return [
				...Invoke("__asm__newObject", 0, 1),
				...block.value.map(([k, v]) => [
					...genExpressionCode(k),
					...genExpressionCode(v),
					...Invoke("__asm__setKey", 3, 1)
				]).reduce((a, b) => a.concat(b), [])
			];
	}
}

function genArgListCode(argList)
{
	if(argList == null)return [];
	return argList.map(genExpressionCode).reduce((a, b) => a.concat(b), []);
}

function genForCode({init, condition, iter, code})
{
	return genForCodeImpl(
		genStatementCode(init),
		genExpressionCode(condition),
		genStatementCode(iter),
		code);
}

function genUntilCode({condition, code})
{
	return genForCodeImpl([], genExpressionCode(condition), [], code, true);
}

function genForCodeImpl(initCode, conditionCode, iterCode, loopBlock, invertCondition=false)
{
	++loopLayer;
	const loopCode = genStatementCode(loopBlock);
	--loopLayer;
	
	const result = initCode;
	
	const loopCount = loopCode.length + iterCode.length;
	const totalCount = loopCount + conditionCode.length;
	if(invertCondition){
		replaceBreakContinue(loopCode, loopCount + 1);
		result.push(...conditionCode);
		result.push(OpFactory.JumpIf(loopCount + 2));
		result.push(...loopCode);
		result.push(...iterCode);
		result.push(OpFactory.Jump(-(totalCount + 1)));
	}else{
		replaceBreakContinue(loopCode, totalCount + 1);
		result.push(OpFactory.Jump(loopCount + 1));
		result.push(...loopCode);
		result.push(...iterCode);
		result.push(...conditionCode);
		result.push(OpFactory.JumpIf(-totalCount));
	}
	return result;
}

function replaceBreakContinue(codeList, totalCodeLength)
{
	for(let i=0, n=codeList.length; i<n; ++i){
		switch(codeList[i][0]){
			case "break":
				codeList[i] = OpFactory.Jump(totalCodeLength - i);
				break;
			case "continue":
				codeList[i] = OpFactory.Jump(n - i);
				break;
		}
	}
}

function genIfCodeImpl(condition, caseTrue, caseFalse)
{
	return [
		...genExpressionCode(condition),
		OpFactory.JumpIf(caseFalse.length + 2),
		...caseFalse,
		OpFactory.Jump(caseTrue.length + 1),
		...caseTrue
	];
}

function genIfCode(blockList, index)
{
	const {condition, code} = blockList[index];
	return genIfCodeImpl(condition, genStatementCode(code), genElseCode(blockList, index + 1));
}

function genElseCode(blockList, index)
{
	if(index < blockList.length){
		const {type, code} = blockList[index];
		switch(type){
			case "else if":
				return genIfCode(blockList, index);
			case "else":
				return genStatementCode(code);
		}
	}
	return [];
}

function genUnlessCode({condition, code})
{
	return genIfCodeImpl(condition, [], genStatementCode(code));
}

function genLoopTimesCode({count, code, key})
{
	let result;
	if(key){
		result = genForCodeImpl([
			OpFactory.Push(0),
			OpFactory.SetVar(key)
		], [
			...Invoke("__asm__duplicate", 1, 2),
			OpFactory.GetVar(key),
			...Invoke(">", 2, 1)
		], [
			OpFactory.GetVar(key),
			...Invoke("__asm__increase", 1, 1),
			OpFactory.SetVar(key)
		], code);
	}else{
		result = genForCodeImpl([], [
			...Invoke("__asm__decrease", 1, 1),
			...Invoke("__asm__duplicate", 1, 2),
			...Invoke("__asm__isNotNegative", 1, 1)
		], [], code);
	}
	return [...genExpressionCode(count), ...result, ...Invoke("__asm__pop", 1, 0)];
}

function genInvokeCode({target, argList, retCount})
{
	return [
		...genArgListCode(argList),
		...genExpressionCode(target),
		OpFactory.Invoke(argList.length, retCount)
	];
}

function genNewFunctionCode({code, argList, userData})
{
	const result = genStatementCode(code);
	return [
		OpFactory.NewFunction(result.length+2, argList, userData),
		...result,
		OpFactory.Return(0)
	];
}

exports.translate = translate;