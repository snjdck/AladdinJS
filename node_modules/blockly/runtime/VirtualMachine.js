'use strict';

if(typeof performance === "undefined"){
	var performance = Date;
}

class VirtualMachine
{
	constructor(){
		this.threadList = new Set();
		this.redrawFlag = false;
		this.yieldFlag = false;
		this.waitFlag = false;
		this.activeFlag = false;
	}
	
	getThreadCount(){
		return this.threadList.size;
	}
	
	getCopyOfThreadList(){
		return Array.from(this.threadList);
	}
	
	startThread(thread){
		this.threadList.add(thread);
	}
	
	stopAllThreads(){
		for(let thread of this.threadList){
			thread.interrupt();
		}
	}
	
	onTick(){
		if(this.getThreadCount() <= 0){
			return;
		}
		this.redrawFlag = false;
		let timeEnd = performance.now() + Thread.EXEC_TIME;
		while(this.updateThreads() && performance.now() < timeEnd);
	}
	
	updateThreads(){
		this.activeFlag = false;
		for(let thread of this.threadList)
			this.updateThread(thread);
		Thread.Current = null;
		this.removeFinishedThreads();
		return !this.redrawFlag && this.activeFlag;
	}
	
	updateThread(thread){
		Thread.Current = thread;
		this.yieldFlag = this.waitFlag = false;
		for(;;){
			if(thread.isFinish()){
				return;
			}
			if(thread.isSuspend()){
				thread.updateSuspendState();
				return;
			}
			thread.execNextCode();
			if(!this.yieldFlag){
				continue;
			}
			if(thread.runFlag > 0){
				this.yieldFlag = false;
			}else{
				break;
			}
		}
		if(!this.waitFlag){
			this.activeFlag = true;
		}
	}
	
	removeFinishedThreads(){
		for(let thread of this.threadList){
			if(thread.isFinish()){
				this.threadList.delete(thread);
				thread.notifyFinish();
			}
		}
	}
	
	execute(thread){
		let prevThread = Thread.Current;
		Thread.Current = thread;
		while(!thread.isFinish()){
			thread.execNextCode();
		}
		Thread.Current = prevThread;
	}
}

module.exports = VirtualMachine;

const Thread = require('./Thread');