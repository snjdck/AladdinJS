"use strict";

const ScriptContext = require("./ScriptContext");
/*
const isArray = value => Object.prototype.toString.apply(value) == "[object Array]";
const isAsync = value => value && (value.toString() == "[object Promise]") && (typeof value.then == "function");
*/
class FunctionProvider
{
	constructor(){
		this.context = new ScriptContext();
		this.init();
	}

	init(){
		this.register((a, b) => a + b, "+");
		this.register((a, b) => a - b, "-");
		this.register((a, b) => a * b, "*");
		this.register((a, b) => a / b, "/");
		this.register((a, b) => a % b, "%");
		this.register((a, b) => a > b, ">");
		this.register((a, b) => a < b, "<");
		this.register((a, b) => a >= b, ">=");
		this.register((a, b) => a <= b, "<=");
		this.register((a, b) => a == b, "==");
		this.register((a, b) => a != b, "!=");
		
		this.register((a) => a + 1,  "__asm__increase");
		this.register((a) => a - 1,  "__asm__decrease");
		this.register((a) => a >= 0, "__asm__isNotNegative");
		this.register(() => {}, "__asm__pop");

		this.register((a, b) => a[b], "__asm__getKey");
		this.register((a, b, c) => {
			a[b] = c;
			return a;
		}, "__asm__setKey");
		this.register(() => ({}), "__asm__newObject");
		this.register(() => []  , "__asm__newArray");
	}
	
	register(handler, name){
		this.context.newKey(name || handler.name, handler);
	}
	
	alias(name, newName){
		console.assert(this.context.hasKey(name, false));
		this.context.newKey(newName, this.context.getValue(name));
	}
	
	static async CallFunction(thread, handler, valueList, hasValue){
		const value = Array.isArray(valueList) ? handler.apply(thread, valueList) : handler.call(thread, valueList);
		if(value instanceof Promise){
			thread.suspend();
			let result = await value;
			if(hasValue)
				thread.push(result);
			thread.resume();
		}else if(hasValue){
			thread.push(value);
		}
	}
}

module.exports = FunctionProvider;