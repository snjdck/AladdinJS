
import ScriptContext from './ScriptContext';
/*
const isArray = value => Object.prototype.toString.apply(value) == "[object Array]";
const isAsync = value => value && (value.toString() == "[object Promise]") && (typeof value.then == "function");
*/
class FunctionProvider
{
	constructor(){
		this.context = new ScriptContext();
		this.init();
	}

	init(){
		this.register((a, b) => a + b, "+");
		this.register((a, b) => a - b, "-");
		this.register((a, b) => a * b, "*");
		this.register((a, b) => a / b, "/");
		this.register((a, b) => a % b, "%");
		this.register((a, b) => a > b, ">");
		this.register((a, b) => a < b, "<");
		this.register((a, b) => a >= b, ">=");
		this.register((a, b) => a <= b, "<=");
		this.register((a, b) => a == b, "==");
		this.register((a, b) => a != b, "!=");
		
		this.register((a) => a + 1,  "__asm__increase");
		this.register((a) => a - 1,  "__asm__decrease");
		this.register((a) => a >= 0, "__asm__isNotNegative");
		this.register((a) => [a, a], "__asm__duplicate");
		this.register(() => {}, "__asm__pop");
		this.register((a, b) => [b, a], "__asm__swap");

		this.register((a, b) => a[b], "__asm__getKey");
		this.register((a, b, c) => (a[b] = c, a), "__asm__setKey");
		this.register(() => ({}), "__asm__newObject");
		this.register((...args) => args, "__asm__newArray");
	}
	
	register(handler, name){
		this.context.newKey(name || handler.name, handler);
	}
	
	alias(name, newName){
		console.assert(this.context.hasKey(name, false));
		this.context.newKey(newName, this.context.getValue(name));
	}
	
	static async CallFunction(thread, handler, valueList, retCount){
		const value = handler.apply(thread, valueList);
		if(value instanceof Promise){
			thread.suspend();
			returnValue(thread, await value, retCount);
			thread.resume();
		}else{
			returnValue(thread, value, retCount);
		}
	}
}

function returnValue(thread, value, retCount){
	if(retCount <= 0){
		return;
	}
	if(retCount == 1){
		thread.push(value);
		return;
	}
	if(Array.isArray(value)){
		for(let i=0; i<retCount; ++i)
			thread.push(value[i]);
	}else{
		while(retCount--)
			thread.push(undefined);
	}
}

export default FunctionProvider;