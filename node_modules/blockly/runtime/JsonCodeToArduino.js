"use strict";

const {translate:translateCpp} = require("./JsonCodeToCpp");
const translateSubCode = (blockList, context) => translateCpp(blockList, context).map(v => "\t" + v);
const template = ["void setup{", "}", "void loop(){", "}"];
	
function translate(blockList, context={})
{
	if(blockList == null){
		return template.slice();
	}
	context = new FuncDict(context);
	if(!Array.isArray(blockList)){
		return context.translate(
			translateSubCode(blockList["setup"], context),
			translateSubCode(blockList["loop"], context)
		);
	}
	if(blockList.length <= 0){
		return template.slice();
	}
	const lastBlock = blockList[blockList.length-1];
	if(lastBlock["type"] == "while" && lastBlock["condition"]["type"] == "number" && lastBlock["condition"]["value"]){
		return context.translate(
			translateSubCode(blockList.slice(0, -1), context),
			translateSubCode(lastBlock.code, context)
		);
	}
	return context.translate(translateSubCode(blockList, context), []);
}

class FuncDict
{
	constructor(context){
		this.context = context;
		this.includeDict = Object.create(null);
		this.fieldDict = Object.create(null);
		this.funcDict = Object.create(null);
		this.initDict = Object.create(null);
		this.loopDict = Object.create(null);
	}

	generate(method, argList){
		let handler = this.context[method];
		if(handler){
			return handler.apply(this, argList);
		}
	}

	addInclude(path){
		this.includeDict[path] = `#include<${path}>`;
	}

	addField(field, key=field){
		this.fieldDict[key] = `${field};`;
	}

	addSetupCode(code, key=code){
		this.initDict[key] = `\t${code};`;
	}

	addLoopCode(code, key=code){
		this.loopDict[key] = `\t${code};`;
	}

	addFuncDef(sign, code){
		code = code.map(v => "\t" + v).join("\n");
		this.funcDict[sign+";"] = `${sign}{\n${code}\n}`;
	}

	translate(initCode, loopCode){
		initCode.unshift(...Object.values(this.initDict));
		loopCode.unshift(...Object.values(this.loopDict));
		const result = template.slice();
		result.splice(3, 0, ...loopCode);
		result.splice(1, 0, ...initCode);
		result.unshift(...Object.keys(this.funcDict), "");
		result.unshift(...Object.values(this.fieldDict), "");
		result.unshift(...Object.values(this.includeDict), "");
		result.push(...Object.values(this.funcDict));
		return result;
	}
}

exports.translate = translate;