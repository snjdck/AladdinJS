"use strict";

let stack = [];
	
function translate(blockList)
{
	return genStatementCode(blockList);
}

function genStatementCode(blockList)
{
	let result = [];
	let n = blockList != null ? blockList.length : 0;
	for(let i=0; i<n; ++i){
		let block = blockList[i];
		switch(block["type"]){
			case "break":
			case "continue":
				result.push(block["type"]);
				break;
			case "while":
				result.push(genWhileCode(block));
				break;
			case "for":
				result.push(genForCode(block));
				break;
			case "until":
				result.push(genUntilCode(block));
				break;
			case "if":
			case "else if":
			case "else":
				result.push(genIfCode(block));
				break;
			case "unless":
				result.push(genUnlessCode(block));
				break;
			case "loop":
				result.push(genLoopTimesCode(block));
				break;
			case "invoke":
				result.push(genInvokeCode(block));
				break;
			case "return":
				if(block["value"]){
					result.push(block["type"] + " " + genExpressionCode(block["value"]));
				}else{
					result.push(block["type"]);
				}
				break;
			case "newVar":
				result.push(`int ${block["name"]} = ${genExpressionCode(block["value"])};`);
				break;
			case "setVar":
				result.push(`${block["name"]} = ${genExpressionCode(block["value"])};`);
				break;
		}
	}
	return result;
}

function genExpressionCode(block)
{
	switch(block["type"]){
		case "string":
			return `"${block["value"]}"`;
		case "number":
			return block["value"];
		case "invoke":
			return genInvokeCode(block);
		case "getVar":
			return block["name"];
		case "newFunction":
			return genNewFunctionCode(block);
	}
}

function genArgListCode(argList)
{
	if(argList == null)return [];
	return argList.map(genExpressionCode);
}

function genForCode({init, condition, iter, code})
{
	return `for(${genStatementCode(init).join(",")};${genExpressionCode(condition)};${genStatementCode(iter).join(",")}){\n${genStatementCode(code).join("\n")}\n}`;
}

function genWhileCode({condition, code})
{
	return `while(${genExpressionCode(condition)}){\n${genStatementCode(code).join("\n")}\n}`;
}

function genUntilCode({condition, code})
{
	return `while(!(${genExpressionCode(condition)})){\n${genStatementCode(code).join("\n")}\n}`;
}

function genIfCode({type, condition, code})
{
	let result = `{\n${genStatementCode(code).join("\n")}\n}`;
	if(type == "else"){
		result = type + result;
	}else{
		result = `${type}(${genExpressionCode(condition)})` + result;
	}
	return result;
}

function genUnlessCode({condition, code})
{
	return `if(!(${genExpressionCode(condition)})){\n${genStatementCode(code).join("\n")}\n}`;
}

function genLoopTimesCode({count, code, key})
{
	let condition = key ? `int ${key}=0, n=${genExpressionCode(count)}; ${key}<n; ++${key}` : `int n=${genExpressionCode(count)}; n>0; --n`;
	return `for(${condition}){\n${genStatementCode(code).join("\n")}\n}`;
}

function genInvokeCode({target, argList, retCount})
{
	let result;
	argList = genArgListCode(argList);
	const method = genExpressionCode(target);
	if(["+", "-", "*", "/", ">", "<", ">=", "<=", "==", "!="].includes(method)){
		result = `(${argList[0]} ${method} ${argList[1]})`;
	}else{
		result = `${method}(${argList.join(", ")})`;
	}
	if(retCount == 0){
		result += ";";
	}
	return result;
}

function genNewFunctionCode({code, argList, userData})
{
	const result = genStatementCode(code);
	return [
		OpFactory.NewFunction(result.length+2, argList, userData),
		...result,
		OpFactory.Return(0)
	];
}

exports.translate = translate;