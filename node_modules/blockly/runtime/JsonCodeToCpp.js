"use strict";

const stack = [];
const genSubCode = block => [...genStatementCode(block.code, true), "}"];
const operators = ["+", "-", "*", "/", "%", ">", "<", ">=", "<=", "==", "!="];
let level = 0;
let layer = 0;
let funcDict;
	
function translate(blockList, context=null)
{
	try{
		funcDict = context;
		return genStatementCode(blockList);
	}finally{
		funcDict = null;
		stack.length = 0;
	}
}

function genStatementCode(blockList, useTab=false)
{
	let result = [];
	for(const block of blockList){
		switch(block["type"]){
			case "break":
			case "continue":
				result.push(block["type"]);
				break;
			case "while":
				result.push(`while(${genExpressionCode(block.condition)}){`);
				result.push(...genSubCode(block));
				break;
			case "for":
				result.push(`for(${genStatementCode(block.init).join(",")};${genExpressionCode(block.condition)};${genStatementCode(block.iter).join(",")}){`);
				result.push(...genSubCode(block));
				break;
			case "until":
				result.push(`while(!(${genExpressionCode(block.condition)})){`);
				result.push(...genSubCode(block));
				break;
			case "if":
				result.push(`if(${genExpressionCode(block.condition)}){`);
				result.push(...genSubCode(block));
				break;
			case "else if":
				result.pop();
				result.push(`}else if(${genExpressionCode(block.condition)}){`);
				result.push(...genSubCode(block));
				break;
			case "else":
				result.pop();
				result.push("}else{");
				result.push(...genSubCode(block));
				break;
			case "unless":
				result.push(`if(!(${genExpressionCode(block.condition)})){`)
				result.push(...genSubCode(block));
				break;
			case "loop":
				let {key, count} = block;
				let n = `_n_${layer}`;
				if(key){
					result.push(`for(int ${key}=0, ${n}=${genExpressionCode(count)}; ${key}<${n}; ++${key}){`);
				}else{
					result.push(`for(int ${n}=${genExpressionCode(count)}; ${n}>0; --${n}){`);
				}
				++layer;
				result.push(...genSubCode(block));
				--layer;
				break;
			case "invoke":
				result.push(genInvokeCode(block) + ";");
				break;
			case "return":
				if(block["value"]){
					result.push("return " + genExpressionCode(block["value"]));
				}else{
					result.push("return");
				}
				break;
			case "newVar":
				result.push(`int ${block["name"]} = ${genExpressionCode(block["value"])};`);
				break;
			case "setVar":
				let value = genExpressionCode(block["value"]);
				if(value == "function"){
					let funcBlock = stack.pop();
					result.push(`void ${block["name"]}(${funcBlock.argList.join(", ")}){`);
					result.push(...genSubCode(funcBlock));
				}else{
					result.push(`${block["name"]} = ${value};`);
				}
				break;
		}
	}
	return useTab ? result.map(v => "\t" + v) : result;
}

function genExpressionCode(block)
{
	switch(block["type"]){
		case "string":
			return `"${block["value"]}"`;
		case "number":
			return block["value"];
		case "invoke":
			return genInvokeCode(block);
		case "getVar":
			return block["name"];
		case "newFunction":
			stack.push(block);
			return "function";
	}
}

function genInvokeCode({target, argList, retCount})
{
	const method = genExpressionCode(target);
	const isOperator = operators.includes(method);
	const argCount = argList ? argList.length : 0;
	if(argCount > 0){
		level += isOperator;
		argList = argList.map(genExpressionCode);
		level -= isOperator;
	}
	if(isOperator){
		let result = `${argList[0]} ${method} ${argList[1]}`;
		return level > 0 ? `(${result})` : result;
	}
	if(method == "getKey"){
		return `${argList[0]}.${argList[1].slice(1, -1)}`;
	}
	if(method == "setKey" && retCount == 0){
		return `${argList[0]}.${argList[1].slice(1, -1)} = ${argList[2]}`;
	}
	if(funcDict){
		let result = funcDict.generate(method, argList);
		if(result != undefined){
			return result;
		}
	}
	if(argList){
		return `${method}(${argList.join(", ")})`;
	}
	return `${method}()`;
}

exports.translate = translate;