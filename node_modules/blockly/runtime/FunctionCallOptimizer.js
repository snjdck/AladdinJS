"use strict";

const OpCode = require("../OpCode");
const OpFactory = require("../OpFactory");

function optimize(codeList)
{
	for(var i=0, n=codeList.length; i<n; ++i){
		var code = codeList[i];
		if(code[0] != OpCode.INVOKE)
			continue;
		findArgs(codeList, i, code[1]);
	}
}

function findFuncDefIndex(codeList, fromIndex)
{
	for(let i=fromIndex-1; i>=0; --i){
		let code = codeList[i];
		if(code[0] != OpCode.NEW_FUNCTION)
			continue;
		if(code[1] == fromIndex - i)
			return i;
	}
	console.assert(false);
}

function findIndex(codeList, fromIndex, argCount)
{
	for(let i=fromIndex-1; i>=0; --i){
		let code = codeList[i];
		switch(code[0]){
			case OpCode.PUSH:
			case OpCode.GET_VAR:
				--argCount;
				break;
			case OpCode.INVOKE:
				argCount += code[1] - code[2];
				break;
			case OpCode.RETURN:
				--argCount;
				i = findFuncDefIndex(codeList, i + 1);
				break;
			case OpCode.JUMP:
				console.assert(code[1] == 1);
				break;
			default:
				console.assert(false, code[0]);
		}
		if(0 == argCount){
			return i;
		}
	}
	return -1;
}

function findArgs(codeList, fromIndex, argCount)
{
	var foundCount = 0;
	var indexList = [];
	var paramList = new Array(argCount);
	for(var i=fromIndex-1; i>=0; --i){
		if(0 == argCount){
			break;
		}
		var code = codeList[i];
		switch(code[0]){
			case OpCode.PUSH:
				--argCount;
				if(argCount >= 0){
					++foundCount;
					paramList[argCount] = code[1];
					codeList[i] = OpFactory.Jump(1);
				}
				break;
			case OpCode.JUMP:
				console.assert(code[1] == 1);
				break;
			case OpCode.INVOKE:
				if(code[1] > 0){
					i = findIndex(codeList, i, code[1]);
				}
				//fallthrough
			case OpCode.GET_VAR:
				--argCount;
				if(argCount >= 0){
					indexList.unshift(argCount);
				}
				break;
			case OpCode.RETURN:
				--argCount;
				if(argCount >= 0){
					indexList.unshift(argCount);
				}
				i = findFuncDefIndex(codeList, i + 1);
				break;
			default:
				console.assert(false, code[0]);
		}
	}
	if(foundCount <= 0){
		return;
	}
	code = codeList[fromIndex];
	code[1] -= foundCount;
	code[code.length] = [paramList, indexList];
}

exports.optimize = optimize;