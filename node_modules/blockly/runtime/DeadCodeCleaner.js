"use strict";

const OpCode = require("../OpCode");

const codeUsage = [];

function clean(codeList)
{
	codeUsage.length = codeList.length;
	codeUsage.fill(false);
	calcCodeUsage(codeList);
	forEachUsedCode(codeList, markJump1Codes);
	forEachUsedCode(codeList, adjustJumpCode);
	removeDeadCode(codeList);
}

function forEachUsedCode(codeList, callback){
	for(let i=codeList.length-1; i>=0; --i){
		if(codeUsage[i]){
			callback(codeList[i], i);
		}
	}
}

function calcCodeUsage(codeList, fromIndex=0)
{
	const totalCount = codeList.length;
	let index = fromIndex;
	while(index < totalCount && !codeUsage[index]){
		codeUsage[index] = true;
		let code = codeList[index];
		switch(code[0]){
			case OpCode.NEW_FUNCTION:
			case OpCode.JUMP_IF_FALSE:
			case OpCode.JUMP_IF_POSITIVE:
				calcCodeUsage(codeList, index+1);
				//fallthrough
			case OpCode.JUMP:
				index += code[1];
				break;
			case OpCode.RETURN:
				return;
			default:
				++index;
		}
	}
}

function markJump1Codes(code, i)
{
	if(code[0] != OpCode.JUMP || code[1] <= 0){
		return;
	}
	let jumpIndex = i + code[1];
	while(i < --jumpIndex){
		if(codeUsage[jumpIndex]){
			return;
		}
	}
	codeUsage[i] = false;
}

function removeDeadCode(codeList)
{
	let isInDeadCode = false;
	let index;
	for(let i=codeList.length-1; i>=0; --i){
		if(codeUsage[i] != isInDeadCode){
			continue;
		}
		isInDeadCode = !isInDeadCode;
		if(isInDeadCode){
			index = i;
		}else{
			codeList.splice(i + 1, index - i);
		}
	}
	if(isInDeadCode){
		codeList.splice(0, index + 1);
	}
}

function adjustJumpCode(code, i)
{
	switch(code[0]){
		case OpCode.JUMP:
		case OpCode.JUMP_IF_FALSE:
		case OpCode.JUMP_IF_POSITIVE:
		case OpCode.NEW_FUNCTION:
			break;
		default:
			return;
	}
	const jumpCount = code[1];
	if(jumpCount > 0){
		code[1] -= calcSpace(i, i+jumpCount);
	}else if(jumpCount < 0){
		code[1] += calcSpace(i+jumpCount, i);
	}
}

function calcSpace(fromIndex, toIndex)
{
	let result = 0;
	for(let i=fromIndex+1; i<toIndex; ++i)
		result += !codeUsage[i];
	return result;
}

exports.clean = clean;