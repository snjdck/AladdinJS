'use strict';

const OpCode = require('../OpCode');

const newOperator = handler => (_, ...args) => {
	let thread = Thread.Current;
	handler(thread, ...args);
	++thread.ip;
}

const newUnaryOperator = handler => () => {
	let thread = Thread.Current;
	thread.push(handler(thread.pop()));
	++thread.ip;
}

const newBinaryOperator = handler => () => {
	let thread = Thread.Current;
	let b = thread.pop();
	let a = thread.pop();
	thread.push(handler(a, b));
	++thread.ip;
}

const newAssignOperator = handler => () => {
	let thread = Thread.Current;
	let c = thread.pop();
	let b = thread.pop();
	let a = thread.pop();
	thread.push(handler(a, b, c));
	++thread.ip;
}

const collectArgList = (argList => (thread, argCount) => {
	argList.length = argCount;
	while(argCount-- > 0)
		argList[argCount] = thread.pop();
	return argList;
})([]);

const OpDict = {
	[OpCode.JUMP](_, count){
		let thread = Thread.Current;
		thread.ip += count;
		if(count < 0) thread.yield(false);
		else if(count == 0) thread.suspend();
	},
	[OpCode.JUMP_IF](_, count){
		let thread = Thread.Current;
		if(thread.pop()){
			if(count < 0){
				thread.yield(false);
			}
			thread.ip += count;
		}else{
			++thread.ip;
		}
	},
	[OpCode.INVOKE](_, argCount){
		const retCount = 1;
		const thread = Thread.Current;
		const argList = collectArgList(thread, argCount);
		const funcRef = thread.pop();
		if(funcRef instanceof Function){
			FunctionProvider.CallFunction(thread, funcRef, argList, retCount);
			++thread.ip;
		}else if(funcRef instanceof FunctionObject){
			let scope = new FunctionScope(funcRef);
			funcRef.initScope(scope, argList);
			scope.doInvoke(thread);
			if(thread.isRecursiveInvoke(funcRef)){
				thread.yield(false);
			}
			if(this && this[0] == OpCode.RETURN && this[1] == retCount){
				scope.join(thread.popScope());
			}
			thread.pushScope(scope);
			scope.retCount = retCount;
		}else{
			while(retCount-- > 0)
				thread.push(0);
			++thread.ip;
		}
	},
	[OpCode.RETURN](_, retCount){
		let thread = Thread.Current;
		let scope = thread.popScope();
		scope.onReturn(thread);
		if(retCount == scope.retCount){
			return;
		}
		if(retCount > scope.retCount){
			while(retCount-- != scope.retCount){
				thread.pop();
			}
		}else{
			while(retCount++ != scope.retCount){
				thread.push(null);
			}
		}
	},
	[OpCode.NEW_FUNCTION](_, offset, argList, userData){
		let thread = Thread.Current;
		let addressEnd = thread.ip + offset;
		thread.push(new FunctionObject(thread.codeList, thread.context, argList, thread.ip, addressEnd, userData));
		thread.ip = addressEnd;
	},
	push:newOperator((thread, value) => thread.push(value)),
	get: newOperator((thread, name) => thread.push(thread.getVar(name))),
	set: newOperator((thread, name) => thread.setVar(name, thread.pop())),
	pop: newOperator(thread => thread.pop()),
	swap: newOperator(thread => {
		let a = thread.pop();
		let b = thread.pop();
		thread.push(a);
		thread.push(b);
	}),
	duplicate: newOperator(thread => {
		let v = thread.pop();
		thread.push(v);
		thread.push(v);
	}),
	call: newOperator((thread, argCount) => {
		const argList = collectArgList(thread, argCount);
		const prop = thread.pop();
		const target = thread.pop();
		thread.push(target[prop](...argList));
	}),
	'+1':	newUnaryOperator(v => +v),
	'-1':	newUnaryOperator(v => -v),
	'!':	newUnaryOperator(v => !v),
	'~':	newUnaryOperator(v => ~v),
	'void':	newUnaryOperator(v => undefined),
	'typeof':	newUnaryOperator(v => typeof v),
	'delete':	newBinaryOperator((a, b) => delete a[b]),
	'+':	newBinaryOperator((a, b) => a + b),
	'-':	newBinaryOperator((a, b) => a - b),
	'*':	newBinaryOperator((a, b) => a * b),
	'/':	newBinaryOperator((a, b) => a / b),
	'%':	newBinaryOperator((a, b) => a % b),
	'&':	newBinaryOperator((a, b) => a & b),
	'|':	newBinaryOperator((a, b) => a | b),
	'^':	newBinaryOperator((a, b) => a ^ b),
	'<<':	newBinaryOperator((a, b) => a << b),
	'>>':	newBinaryOperator((a, b) => a >> b),
	'>>>':	newBinaryOperator((a, b) => a >>> b),
	'>':	newBinaryOperator((a, b) => a > b),
	'<':	newBinaryOperator((a, b) => a < b),
	'>=':	newBinaryOperator((a, b) => a >= b),
	'<=':	newBinaryOperator((a, b) => a <= b),
	'==':	newBinaryOperator((a, b) => a == b),
	'!=':	newBinaryOperator((a, b) => a != b),
	'===':	newBinaryOperator((a, b) => a === b),
	'!==':	newBinaryOperator((a, b) => a !== b),
	'in':	newBinaryOperator((a, b) => a in b),
	'instanceof':	newBinaryOperator((a, b) => a instanceof b),
	'++':	newUnaryOperator(v => ++v),
	'--':	newUnaryOperator(v => --v),
	'=':	newAssignOperator((a, b, c) => a[b] = c),
	'+=':	newAssignOperator((a, b, c) => a[b] += c),
	'-=':	newAssignOperator((a, b, c) => a[b] -= c),
	'*=':	newAssignOperator((a, b, c) => a[b] *= c),
	'/=':	newAssignOperator((a, b, c) => a[b] /= c),
	'%=':	newAssignOperator((a, b, c) => a[b] %= c),
	'&=':	newAssignOperator((a, b, c) => a[b] &= c),
	'|=':	newAssignOperator((a, b, c) => a[b] |= c),
	'^=':	newAssignOperator((a, b, c) => a[b] ^= c),
	'<<=':	newAssignOperator((a, b, c) => a[b] <<= c),
	'>>=':	newAssignOperator((a, b, c) => a[b] >>= c),
	'>>>=':	newAssignOperator((a, b, c) => a[b] >>>= c),
};

const execute = (instruction, nextInstruction) => OpDict[instruction[0]].apply(nextInstruction, instruction);

module.exports = execute;

const Thread = require('./Thread');
const FunctionProvider = require('./FunctionProvider');
const FunctionObject = require('./FunctionObject');
const FunctionScope = require('./FunctionScope');
