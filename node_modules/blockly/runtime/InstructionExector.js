
import OpCode from "../OpCode";
import Thread from "./Thread";
import FunctionProvider from "./FunctionProvider";
import FunctionObject from "./FunctionObject";
import FunctionScope from "./FunctionScope";

const collectArgList = (argList => (thread, argCount) => {
	argList.length = argCount;
	while(argCount-- > 0)
		argList[argCount] = thread.pop();
	return argList;
})([]);

const OpDict = {
	[OpCode.PUSH](_, value){
		let thread = Thread.Current;
		thread.push(value);
		++thread.ip;
	},
	[OpCode.JUMP](_, count){
		let thread = Thread.Current;
		thread.ip += count;
		if(count < 0) thread.yield(false);
		else if(count == 0) thread.suspend();
	},
	[OpCode.JUMP_IF](_, count){
		let thread = Thread.Current;
		if(thread.pop()){
			if(count < 0){
				thread.yield(false);
			}
			thread.ip += count;
		}else{
			++thread.ip;
		}
	},
	[OpCode.INVOKE](_, argCount, retCount){
		const thread = Thread.Current;
		const funcRef = thread.pop();
		const argList = collectArgList(thread, argCount);
		if(funcRef instanceof Function){
			FunctionProvider.CallFunction(thread, funcRef, argList, retCount);
			++thread.ip;
		}else if(funcRef instanceof FunctionObject){
			let scope = new FunctionScope(funcRef);
			funcRef.initScope(scope, argList);
			scope.doInvoke(thread);
			if(thread.isRecursiveInvoke(funcRef)){
				thread.yield(false);
			}
			if(this && this[0] == OpCode.RETURN && this[1] == retCount){
				scope.join(thread.popScope());
			}
			thread.pushScope(scope);
			scope.retCount = retCount;
		}else{
			throw new Error("function not exist!");
		}
	},
	[OpCode.RETURN](_, retCount){
		let thread = Thread.Current;
		let scope = thread.popScope();
		scope.onReturn(thread);
		if(retCount == scope.retCount){
			return;
		}
		if(retCount > scope.retCount){
			while(retCount-- != scope.retCount){
				thread.pop();
			}
		}else{
			while(retCount++ != scope.retCount){
				thread.push(null);
			}
		}
	},
	[OpCode.GET_VAR](_, name){
		let thread = Thread.Current;
		thread.push(thread.getVar(name));
		++thread.ip;
	},
	[OpCode.SET_VAR](_, name){
		let thread = Thread.Current;
		thread.setVar(name, thread.pop());
		++thread.ip;
	},
	[OpCode.NEW_FUNCTION](_, offset, argList, userData){
		let thread = Thread.Current;
		let addressEnd = thread.ip + offset;
		thread.push(new FunctionObject(thread.codeList, thread.context, argList, thread.ip, addressEnd, userData));
		thread.ip = addressEnd;
	}
};

const execute = (instruction, nextInstruction) => OpDict[instruction[0]].apply(nextInstruction, instruction);

export default execute;
