"use strict";

const OpCode = require("../OpCode");
const Thread = require("./Thread");
const FunctionProvider = require("./FunctionProvider");
const FunctionObject = require("./FunctionObject");
const FunctionScope = require("./FunctionScope");

class InstructionExector
{
	constructor(){
		this.opDict = {};

		this.regOpHandler(OpCode.PUSH, onPush);
		this.regOpHandler(OpCode.JUMP, onJump);
		this.regOpHandler(OpCode.JUMP_IF, onJumpIf);
		this.regOpHandler(OpCode.INVOKE, onInvoke);
		this.regOpHandler(OpCode.RETURN, onReturn);
		this.regOpHandler(OpCode.GET_VAR, onGetVar);
		this.regOpHandler(OpCode.SET_VAR, onSetVar);
		this.regOpHandler(OpCode.NEW_FUNCTION, onNewFunction);
	}
	
	regOpHandler(op, handler){
		this.opDict[op] = handler;
	}
	
	execute(instruction, nextInstruction){
		let handler = this.opDict[instruction[0]];
		handler.apply(nextInstruction, instruction);
	}
}

function onPush(_, value){
	let thread = Thread.Current;
	thread.push(value);
	++thread.ip;
}

function onJump(_, count){
	var thread = Thread.Current;
	thread.ip += count;
	if(count < 0) thread.yield(false);
	else if(count == 0) thread.suspend();
}

function onJumpIf(_, count){
	var thread = Thread.Current;
	if(thread.pop()){
		if(count < 0){
			thread.yield(false);
		}
		thread.ip += count;
	}else{
		++thread.ip;
	}
}

function onInvoke(_, argCount, retCount){
	const thread = Thread.Current;
	const funcRef = thread.pop();
	const argList = collectArgList(thread, argCount);
	if(funcRef instanceof Function){
		FunctionProvider.CallFunction(thread, funcRef, argList, retCount);
		++thread.ip;
	}else if(funcRef instanceof FunctionObject){
		let scope = new FunctionScope(funcRef);
		funcRef.initScope(scope, argList);
		scope.doInvoke(thread);
		if(thread.isRecursiveInvoke(funcRef)){
			thread.yield(false);
		}
		if(this && this[0] == OpCode.RETURN && this[1] == retCount){
			scope.join(thread.popScope());
		}
		thread.pushScope(scope);
		scope.retCount = retCount;
	}else{
		throw new Error("function not exist!");
	}
}

function onReturn(_, retCount){
	var thread = Thread.Current;
	var scope = thread.popScope();
	scope.onReturn(thread);
	if(retCount == scope.retCount){
		return;
	}
	if(retCount > scope.retCount){
		while(retCount-- != scope.retCount){
			thread.pop();
		}
	}else{
		while(retCount++ != scope.retCount){
			thread.push(null);
		}
	}
}

function onGetVar(_, name){
	var thread = Thread.Current;
	thread.push(thread.getVar(name));
	++thread.ip;
}

function onSetVar(_, name){
	var thread = Thread.Current;
	thread.setVar(name, thread.pop());
	++thread.ip;
}

function onNewFunction(_, offset, argList, userData){
	var thread = Thread.Current;
	var addressEnd = thread.ip + offset;
	thread.push(thread.newFunction(argList, addressEnd, userData));
	thread.ip = addressEnd;
}

const collectArgList = (argList => (thread, argCount) => {
	argList.length = argCount;
	while(argCount-- > 0)
		argList[argCount] = thread.pop();
	return argList;
})([]);

module.exports = InstructionExector;