'use strict';

const OpCode = require('../OpCode');

const collectArgList = (argList => (thread, argCount) => {
	argList.length = argCount;
	while(argCount-- > 0)
		argList[argCount] = thread.pop();
	return argList;
})([]);

const OpDict = {
	[OpCode.PUSH](_, value){
		let thread = Thread.Current;
		thread.push(value);
		++thread.ip;
	},
	[OpCode.JUMP](_, count){
		let thread = Thread.Current;
		thread.ip += count;
		if(count < 0) thread.yield(false);
		else if(count == 0) thread.suspend();
	},
	[OpCode.JUMP_IF](_, count){
		let thread = Thread.Current;
		if(thread.pop()){
			if(count < 0){
				thread.yield(false);
			}
			thread.ip += count;
		}else{
			++thread.ip;
		}
	},
	[OpCode.INVOKE](_, argCount, retCount){
		const thread = Thread.Current;
		const argList = collectArgList(thread, argCount);
		const funcRef = thread.pop();
		if(funcRef instanceof Function){
			FunctionProvider.CallFunction(thread, funcRef, argList, retCount);
			++thread.ip;
		}else if(funcRef instanceof FunctionObject){
			let scope = new FunctionScope(funcRef);
			funcRef.initScope(scope, argList);
			scope.doInvoke(thread);
			if(thread.isRecursiveInvoke(funcRef)){
				thread.yield(false);
			}
			if(this && this[0] == OpCode.RETURN && this[1] == retCount){
				scope.join(thread.popScope());
			}
			thread.pushScope(scope);
			scope.retCount = retCount;
		}else{
			while(retCount-- > 0)
				thread.push(0);
			++thread.ip;
		}
	},
	[OpCode.RETURN](_, retCount){
		let thread = Thread.Current;
		let scope = thread.popScope();
		scope.onReturn(thread);
		if(retCount == scope.retCount){
			return;
		}
		if(retCount > scope.retCount){
			while(retCount-- != scope.retCount){
				thread.pop();
			}
		}else{
			while(retCount++ != scope.retCount){
				thread.push(null);
			}
		}
	},
	[OpCode.GET_VAR](_, name){
		let thread = Thread.Current;
		thread.push(thread.getVar(name));
		++thread.ip;
	},
	[OpCode.SET_VAR](_, name){
		let thread = Thread.Current;
		thread.setVar(name, thread.pop());
		++thread.ip;
	},
	[OpCode.NEW_FUNCTION](_, offset, argList, userData){
		let thread = Thread.Current;
		let addressEnd = thread.ip + offset;
		thread.push(new FunctionObject(thread.codeList, thread.context, argList, thread.ip, addressEnd, userData));
		thread.ip = addressEnd;
	}
};

function addOperator(name, handler){
	OpDict[name] = function(_, ...args){
		let thread = Thread.Current;
		handler(thread, ...args);
		++thread.ip;
	}
}

function addBinOperator(name, handler){
	OpDict[name] = function(){
		let thread = Thread.Current;
		let b = thread.pop();
		let a = thread.pop();
		thread.push(handler(a, b));
		++thread.ip;
	}
}

addOperator('swap', thread => {
	let a = thread.pop();
	let b = thread.pop();
	thread.push(a);
	thread.push(b);
});

addOperator('duplicate', thread => {
	let v = thread.pop();
	thread.push(v);
	thread.push(v);
});

addOperator('call', (thread, argCount, retCount) => {
	const argList = collectArgList(thread, argCount);
	const prop = thread.pop();
	const target = thread.pop();
	const result = target[prop](...argList);
	if(retCount > 0)thread.push(result);
});

addBinOperator('+', (a, b) => a + b);
addBinOperator('>', (a, b) => a > b);
addBinOperator('===', (a, b) => a === b);
addBinOperator('==', (a, b) => a == b);

const execute = (instruction, nextInstruction) => OpDict[instruction[0]].apply(nextInstruction, instruction);

module.exports = execute;

const Thread = require('./Thread');
const FunctionProvider = require('./FunctionProvider');
const FunctionObject = require('./FunctionObject');
const FunctionScope = require('./FunctionScope');
