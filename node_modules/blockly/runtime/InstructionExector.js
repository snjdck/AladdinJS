'use strict';

const OpCode = require('../OpCode');

const newOperator = handler => (_, ...args) => {
	let thread = Thread.Current;
	++thread.ip;
	handler(thread, ...args);
}

const newUnaryOperator = handler => () => {
	let thread = Thread.Current;
	thread.push(handler(thread.pop()));
	++thread.ip;
}

const newBinaryOperator = handler => () => {
	let thread = Thread.Current;
	let b = thread.pop();
	let a = thread.pop();
	thread.push(handler(a, b));
	++thread.ip;
}

const newAssignOperator = handler => () => {
	let thread = Thread.Current;
	let c = thread.pop();
	let b = thread.pop();
	let a = thread.pop();
	thread.push(handler(a, b, c));
	++thread.ip;
}

const collectArgList = (argList => (thread, argCount) => {
	argList.length = argCount;
	while(argCount-- > 0)
		argList[argCount] = thread.pop();
	return argList;
})([]);

const OpDict = {
	[OpCode.JUMP](_, count){
		let thread = Thread.Current;
		thread.ip += count;
		if(count < 0) thread.yield(false);
		else if(count == 0) thread.suspend();
	},
	[OpCode.JUMP_IF](_, count){
		let thread = Thread.Current;
		if(thread.pop()){
			if(count < 0){
				thread.yield(false);
			}
			thread.ip += count;
		}else{
			++thread.ip;
		}
	},
	invoke: newOperator((thread, argCount) => {
		const argList = collectArgList(thread, argCount);
		const funcRef = thread.pop();
		const newIP = thread.ip;
		FunctionProvider.CallFunction(thread, funcRef, argList, 1);
		if(thread.ip != newIP)thread.pop();
	}),
	call: newOperator((thread, argCount) => {
		const argList = collectArgList(thread, argCount);
		const prop = thread.pop();
		const target = thread.pop();

		const newIP = thread.ip;
		const result = target[prop](...argList);
		if(thread.ip == newIP){
			thread.push(result);
		}
	}),
	[OpCode.RETURN](_, argCount){
		let thread = Thread.Current;
		let scope = thread.popScope();
		scope.onReturn(thread);
		scope.returnFlag = true;
		if(scope.generatorFlag){
			let value;
			if(argCount > 0){
				value = thread.pop();
			}
			thread.push({done: true, value});
		}else if(argCount == 0){
			thread.push(undefined);
		}
	},
	[OpCode.NEW_FUNCTION](_, offset, argList, userData){
		let thread = Thread.Current;
		let addressEnd = thread.ip + offset;
		const funcRef = new FunctionObject(thread.codeList, thread.context, argList, thread.ip, addressEnd, userData);
		thread.ip = addressEnd;
		if(userData[1]){//generator
			thread.push(function*(...args){
				let thread = this;
				let scope = new FunctionScope(funcRef);
				funcRef.initScope(scope, args);
				while(!scope.returnFlag){
					scope.doInvoke(thread);
					thread.pushScope(scope);
					thread.push(yield);
				}
				thread.pop();
			});
			return;
		}
		thread.push(function(...args){
			let thread = this;
			let scope = new FunctionScope(funcRef);
			funcRef.initScope(scope, args);
			scope.doInvoke(thread);
			thread.pushScope(scope);
		});
	},
	yield(_, argCount){
		let thread = Thread.Current;
		let scope = thread.popScope();
		scope.onReturn(thread);
		let value;
		if(argCount > 0){
			value = thread.pop();
		}
		thread.push({done: false, value});
	},
	push:newOperator((thread, value) => thread.push(value)),
	get: newOperator((thread, name) => thread.push(thread.getVar(name))),
	set: newOperator((thread, name) => thread.setVar(name, thread.pop())),
	pop: newOperator(thread => thread.pop()),
	swap: newOperator(thread => {
		let a = thread.pop();
		let b = thread.pop();
		thread.push(a);
		thread.push(b);
	}),
	duplicate: newOperator(thread => {
		let v = thread.pop();
		thread.push(v);
		thread.push(v);
	}),
	'+1':	newUnaryOperator(v => +v),
	'-1':	newUnaryOperator(v => -v),
	'!':	newUnaryOperator(v => !v),
	'~':	newUnaryOperator(v => ~v),
	'void':	newUnaryOperator(v => undefined),
	'typeof':	newUnaryOperator(v => typeof v),
	'delete':	newBinaryOperator((a, b) => delete a[b]),
	'+':	newBinaryOperator((a, b) => a + b),
	'-':	newBinaryOperator((a, b) => a - b),
	'*':	newBinaryOperator((a, b) => a * b),
	'/':	newBinaryOperator((a, b) => a / b),
	'%':	newBinaryOperator((a, b) => a % b),
	'&':	newBinaryOperator((a, b) => a & b),
	'|':	newBinaryOperator((a, b) => a | b),
	'^':	newBinaryOperator((a, b) => a ^ b),
	'<<':	newBinaryOperator((a, b) => a << b),
	'>>':	newBinaryOperator((a, b) => a >> b),
	'>>>':	newBinaryOperator((a, b) => a >>> b),
	'>':	newBinaryOperator((a, b) => a > b),
	'<':	newBinaryOperator((a, b) => a < b),
	'>=':	newBinaryOperator((a, b) => a >= b),
	'<=':	newBinaryOperator((a, b) => a <= b),
	'==':	newBinaryOperator((a, b) => a == b),
	'!=':	newBinaryOperator((a, b) => a != b),
	'===':	newBinaryOperator((a, b) => a === b),
	'!==':	newBinaryOperator((a, b) => a !== b),
	'in':	newBinaryOperator((a, b) => a in b),
	'instanceof':	newBinaryOperator((a, b) => a instanceof b),
	'++':	newUnaryOperator(v => ++v),
	'--':	newUnaryOperator(v => --v),
	'=':	newAssignOperator((a, b, c) => a[b] = c),
	'+=':	newAssignOperator((a, b, c) => a[b] += c),
	'-=':	newAssignOperator((a, b, c) => a[b] -= c),
	'*=':	newAssignOperator((a, b, c) => a[b] *= c),
	'/=':	newAssignOperator((a, b, c) => a[b] /= c),
	'%=':	newAssignOperator((a, b, c) => a[b] %= c),
	'&=':	newAssignOperator((a, b, c) => a[b] &= c),
	'|=':	newAssignOperator((a, b, c) => a[b] |= c),
	'^=':	newAssignOperator((a, b, c) => a[b] ^= c),
	'<<=':	newAssignOperator((a, b, c) => a[b] <<= c),
	'>>=':	newAssignOperator((a, b, c) => a[b] >>= c),
	'>>>=':	newAssignOperator((a, b, c) => a[b] >>>= c),
};

const execute = (instruction, nextInstruction) => OpDict[instruction[0]].apply(nextInstruction, instruction);

module.exports = execute;

const Thread = require('./Thread');
const FunctionProvider = require('./FunctionProvider');
const FunctionObject = require('./FunctionObject');
const FunctionScope = require('./FunctionScope');
