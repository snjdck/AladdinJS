"use strict";

const OpCode = require("../OpCode");
const Thread = require("./Thread");
const FunctionProvider = require("./FunctionProvider");
const FunctionObject = require("./FunctionObject");
const FunctionScope = require("./FunctionScope");

class InstructionExector
{
	constructor(){
		this.opDict = {};

		this.regOpHandler(OpCode.PUSH, onPush);
		this.regOpHandler(OpCode.POP, onPop);
		this.regOpHandler(OpCode.JUMP, onJump);
		this.regOpHandler(OpCode.JUMP_IF_FALSE, onJumpIfFalse);
		this.regOpHandler(OpCode.INVOKE, onInvoke);
		this.regOpHandler(OpCode.RETURN, onReturn);
		this.regOpHandler(OpCode.JUMP_IF_POSITIVE, onJumpIfPositive);
		this.regOpHandler(OpCode.GET_VAR, onGetVar);
		this.regOpHandler(OpCode.SET_VAR, onSetVar);
		this.regOpHandler(OpCode.NEW_FUNCTION, onNewFunction);
	}
	
	regOpHandler(op, handler){
		this.opDict[op] = handler;
	}
	
	execute(instruction, nextInstruction){
		this.nextOp = nextInstruction && nextInstruction[0];
		this.nextData = nextInstruction;
		let handler = this.opDict[instruction[0]];
		handler.apply(this, instruction);
	}
}

function onPush(op, value){
	var thread = Thread.Current;
	thread.push(value);
	++thread.ip;
}

function onPop(op){
	var thread = Thread.Current;
	thread.pop();
	++thread.ip;
}

function onJump(op, count){
	var thread = Thread.Current;
	thread.ip += count;
	if(count < 0) thread.yield(false);
	else if(count == 0) thread.suspend();
}

function onJumpIfFalse(op, count){
	var thread = Thread.Current;
	if(thread.pop()){
		++thread.ip;
		return;
	}
	if(count < 0){
		thread.yield(false);
	}
	thread.ip += count;
}

function onJumpIfPositive(op, count){
	var thread = Thread.Current;
	var value = thread.peek();
	if(value >= 1){
		thread.put(value - 1);
		thread.ip += count;
	}else{
		++thread.ip;
	}
}

function onInvoke(op, argCount, retCount, argNames, paramInfo){
	const thread = Thread.Current;
	const argList = collectArgList(thread, argCount, paramInfo);
	if(argNames != null){
		var argDict = {};
		for(let i=0, n=argList.length; i<n; ++i){
			argDict[argNames[i]] = argList[i];
		}
	}
	const funcRef = thread.pop();
	if(funcRef instanceof Function){
		FunctionProvider.CallFunction(thread, funcRef, argDict || argList, retCount > 0);
		++thread.ip;
	}else if(funcRef instanceof FunctionObject){
		let scope = new FunctionScope(funcRef);
		funcRef.initScope(scope, argList);
		scope.doInvoke(thread);
		if(thread.isRecursiveInvoke(funcRef)){
			thread.yield(false);
		}
		if(this.nextOp == OpCode.RETURN && retCount == nextData[1]){
			let prevScope = thread.peekScope();
			if(retCount == prevScope.retCount){
				scope.join(thread.popScope());
			}
		}
		thread.pushScope(scope);
		scope.retCount = retCount;
	}else{
		throw new Error("function not exist!");
	}
}

function onReturn(op, retCount){
	var thread = Thread.Current;
	var scope = thread.popScope();
	scope.onReturn(thread);
	if(retCount == scope.retCount){
		return;
	}
	if(retCount > scope.retCount){
		while(retCount-- != scope.retCount){
			thread.pop();
		}
	}else{
		while(retCount++ != scope.retCount){
			thread.push(null);
		}
	}
}

function onGetVar(op, varName){
	var thread = Thread.Current;
	thread.push(thread.getVar(varName));
	++thread.ip;
}

function onSetVar(op, varName){
	var thread = Thread.Current;
	thread.setVar(varName, thread.pop());
	++thread.ip;
}

function onNewFunction(op, offset, argList, userData){
	var thread = Thread.Current;
	var addressEnd = thread.ip + offset;
	thread.push(thread.newFunction(argList, addressEnd, userData));
	thread.ip = addressEnd;
}

const collectArgList = (argList => (thread, argCount, paramInfo) => {
	argList.length = argCount;
	while(argCount-- > 0)
		argList[argCount] = thread.pop();
	if(paramInfo == null)
		return argList;
	const [paramList, indexList] = paramInfo;
	for(let i=indexList.length-1; i>=0; --i)
		paramList[indexList[i]] = argList[i];
	return paramList;
})([]);

module.exports = InstructionExector;