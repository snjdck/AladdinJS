"use strict";

const Thread = require("./Thread");
const InstructionExector = require("./InstructionExector");
const VirtualMachine = require("./VirtualMachine");
const JsonCodeToAssembly = require("./JsonCodeToAssembly");
const ConditionCalculater = require("./ConditionCalculater");
const AssemblyOptimizer = require("./AssemblyOptimizer");
const FunctionCallOptimizer = require("./FunctionCallOptimizer");
const DeadCodeCleaner = require("./DeadCodeCleaner");
const CodeListPrinter = require("./CodeListPrinter");

class Interpreter
{
	constructor(functionProvider){
		this.functionProvider = functionProvider;
		this.instructionExector = new InstructionExector();
		this.virtualMachine = new VirtualMachine(this.instructionExector);
	}

	run(){
		if(typeof requestAnimationFrame != "function"){
			setInterval(()=>this.tick(), 1000/60);
			return;
		}
		const updater = timeElapsed => {
			requestAnimationFrame(updater);
			this.tick();
		};
		requestAnimationFrame(updater);
	}

	tick(){
		if(this.virtualMachine.getThreadCount() > 0){
			this.virtualMachine.onTick();
		}
	}
	
	compile(blockList){
		var codeList = JsonCodeToAssembly.translate(blockList);
		FunctionCallOptimizer.optimize(codeList);
		ConditionCalculater.calculate(codeList);
		AssemblyOptimizer.optimize(codeList);
		DeadCodeCleaner.clean(codeList);
		return codeList;
	}
	
	execute(blockList, globalContext=null){
		return this.executeAssembly(this.compile(blockList), globalContext);
	}
	
	executeAssembly(codeList, globalContext=null){
		if(globalContext){
			globalContext.parent = this.functionProvider.context;
		}else{
			globalContext = this.functionProvider.context;
		}
		var thread = new Thread(this.virtualMachine, codeList, globalContext);
		this.virtualMachine.startThread(thread);
		return thread;
	}
	
	executeAssemblySynchronously(codeList){
		var thread = new Thread(this.virtualMachine, codeList, null);
		this.virtualMachine.execute(thread);
		return thread.context;
	}
	
	executeSynchronously(blockList){
		return this.executeAssemblySynchronously(this.compile(blockList));
	}
	
	stopAllThreads(){
		this.virtualMachine.stopAllThreads();
	}
	
	getCopyOfThreadList(){
		return this.virtualMachine.getCopyOfThreadList();
	}
	
	getThreadCount(){
		return this.virtualMachine.getThreadCount();
	}
	
	castCodeListToString(codeList){
		return CodeListPrinter.castCodeListToString(codeList);
	}
}

module.exports = Interpreter;