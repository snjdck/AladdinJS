'use strict';

const yieldFlag = Symbol();
const yieldOneTickFlag = Symbol();
const suspendFlag = Symbol();

const threadList = [];
const eventTarget = new EventTarget();
const dispatchEvent = (type, detail) => eventTarget.dispatchEvent(new CustomEvent(type, {detail}));

requestAnimationFrame(function(){
	const finishThreads = [];
	const reviveThreads = [];
	const {scheduling} = navigator;
	const options = {includeContinuous: true};//include mousemove events?, or ['mousedown', 'mouseup', 'keydown', 'keyup']
	return function loop(timestamp){
		requestAnimationFrame(loop);
		const timeEnd = timestamp + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			if(scheduling.isInputPending(options))break;
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				threadList.splice(threadList.indexOf(thread), 1);
				dispatchEvent('thread_finish', thread);
				if(threadList.length == 0){
					finishThreads.length = 0;
					dispatchEvent('finish');
				}
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

exports.on = (type, handler) => eventTarget.addEventListener(type, handler);
exports.off = (type, handler) => eventTarget.removeEventListener(type, handler);

exports.wrap = code => Function('yieldFlag', 'yieldOneTickFlag', 'suspendFlag', code)(yieldFlag, yieldOneTickFlag, suspendFlag);
exports.exec = thread => threadList.push(thread);
exports.stop = () => threadList.length = 0;
