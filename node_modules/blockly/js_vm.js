'use strict';

const yieldFlag = Symbol();
const yieldOneTickFlag = Symbol();
const suspendFlag = Symbol();

const threadList = [];

//requestAnimationFrame will suspend when page invisible
setInterval(function(){
	const finishThreads = [];
	const reviveThreads = [];
	const {scheduling} = navigator;
	const options = {includeContinuous: true};//include mousemove events?, or ['mousedown', 'mouseup', 'keydown', 'keyup']
	return function(){
		const timeEnd = performance.now() + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			if(scheduling.isInputPending(options))break;
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.code.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				let index = threadList.indexOf(thread);
				if(index < 0)continue;
				threadList.splice(index, 1);
				thread.onFinish(threadList.length);
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

exports.wrap = code => Function('yieldFlag', 'yieldOneTickFlag', 'suspendFlag', code)(yieldFlag, yieldOneTickFlag, suspendFlag);
exports.exec = code => new Promise(resolve => threadList.push({code, onFinish:resolve}));
exports.stop = () => {
	while(threadList.length > 0){
		let thread = threadList.shift();
		thread.onFinish(threadList.length);
	}
};
