"use strict";

const OpCode = require("./OpCode");

function getValue(code){
	if(code[0] == OpCode.PUSH && typeof code[1] == "string"){
		return `"${code[1]}"`;
	}
	if(code[0] == OpCode.NEW_FUNCTION){
		return `function(${code[2].join(", ")}){\n${code[1].join("\n")}\n}`;
	}
	return code[1];
}

function findIndex(codeList, from, count=1){
	for(let i=from-1; i>=0; --i){
		let code = codeList[i];
		switch(code[0]){
			case OpCode.INVOKE:
				count += code[1] - code[2] + 1;
				break;
			case OpCode.GET_VAR:
			case OpCode.PUSH:
			case OpCode.DUPLICATE:
				count--;
				break;
			default:
				console.assert(false);
		}
		if(count == 0){
			return i;
		}
	}
	return -1;
}

function build(codeList, from=0, to=codeList.length){
	const result = [];
	const stack = [];
	for(let i=from; i<to; ++i){
		const code = codeList[i];
		switch(code[0]){
			case OpCode.PUSH:
			case OpCode.GET_VAR:
				stack.push(code);
				break;
			case OpCode.POP:
				stack.pop();
				break;
			case OpCode.DUPLICATE:
				result.push("_local_1_ = " + getValue(stack.pop()));
				stack.push([OpCode.GET_VAR, "_local_1_"]);
				break;
			case OpCode.INVOKE:
				let method = stack.pop()[1];
				let args = new Array(code[1]).fill(0).map(_ => getValue(stack.pop())).reverse().join(", ");
				let info = `${method}(${args})`;
				if(code[2] > 0){
					stack.push([OpCode.INVOKE, info]);
				}else{
					result.push(info);
				}
				break;
			case OpCode.SET_VAR:
				result.push(`${code[1]} = ${getValue(stack.pop())};`)
				break;
			case OpCode.RETURN:
				if(code[1] > 0){
					result.push(`return ${getValue(stack.pop())};`);
				}else{
					result.push("return;");
				}
				break;
			case OpCode.NEW_FUNCTION:
				stack.push([OpCode.NEW_FUNCTION, build(codeList, i+1, i+code[1]), code[2]]);
				i += code[1] - 1;
				break;
			case OpCode.JUMP:
				if(code[1] > 0){
					i += code[1] - 1;
				}else if(code[1] < 0){
					console.log("----------jump");
				}else{
					result.push("for(;;);");
					return result;
				}
				break;
			case OpCode.JUMP_IF:
				let condition = getValue(stack.pop());
				if(code[1] > 0){
					let branchCode = codeList[i+code[1]-1];
					if(branchCode[0] == OpCode.JUMP){
						if(branchCode[1] > 0){
							let falseCase = build(codeList, i+1, i+code[1]-1).join("\n");
							let trueCase = build(codeList, i+code[1], i+code[1]+branchCode[1]-1).join("\n");
							result.push(`if(${condition}){\n${trueCase}\n}else{\n${falseCase}\n}`);
							i += code[1]+branchCode[1]-2;
						}else if(branchCode[1] < 0){
							let iterCode = "";
							let loopCode = build(codeList, i+1, i+code[1]-1).join("\n");
							result.push(`for(;;){\nif(${condition})break;\n${loopCode}\n}`)
							console.log("until", codeList.slice(findIndex(codeList, i), i), condition);
						}else{
							console.assert(false);
						}
						
					}else{
						let falseCase = build(codeList, i+1, i+code[1]).join("\n")
						result.push(`if(!(${condition})){\n${falseCase}\n}`);
						i += code[1]-1;
					}
				}else{
					let loopCode = build(codeList, i + code[1], findIndex(codeList, i)).join("\n");
					result.push(`while(${condition}){\n${loopCode}\n}`);
				}
				
				break;
		}
	}
	console.assert(stack.length == 0)
	return result;
}

class SyntaxTreeBuilder
{
}

SyntaxTreeBuilder.prototype.build = build;

module.exports = SyntaxTreeBuilder;