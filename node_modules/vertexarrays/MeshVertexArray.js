"use strict";

const VertexArray = require("./VertexArray");

class MeshVertexArray extends VertexArray{
	constructor(subMesh, formatList){
		super();
		Object.assign(this, subMesh);
		this.formatList = formatList;
		this.indexCount = this.indexData.byteLength >> 1;
		this.indexMode = this.indexCount > 0;
	}

	onCreate(gl){
		this.vertexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);

		if(this.indexMode){
			this.indexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData, gl.STATIC_DRAW);
		}

		let {position, uv, boneIndex, boneWeight} = this.formatList;

		gl.vertexAttribPointer(0, 3, gl.FLOAT, false, this.byteSizePerVertex, position.offset);
		gl.vertexAttribPointer(1, 2, gl.FLOAT, false, this.byteSizePerVertex, uv.offset);
		gl.enableVertexAttribArray(0);
		gl.enableVertexAttribArray(1);

		if(boneIndex){
			let boneCount = parseInt(boneIndex.format.slice(-1));
			gl.vertexAttribIPointer(2, boneCount, gl.SHORT, this.byteSizePerVertex, boneIndex.offset);
			gl.enableVertexAttribArray(2);
		}else{
			gl.vertexAttribI4i(2, 0, 0, 0, 0);
			gl.disableVertexAttribArray(2);
		}
		
		if(boneWeight){
			let boneCount = parseInt(boneWeight.format.slice(-1));
			gl.vertexAttribPointer(3, boneCount, gl.FLOAT, false, this.byteSizePerVertex, boneWeight.offset);
			gl.enableVertexAttribArray(3);
		}else{
			gl.vertexAttrib4f(3, 1, 0, 0, 0);
			gl.disableVertexAttribArray(3);
		}
	}

	onDispose(gl){
		gl.deleteBuffer(this.vertexBuffer);
		this.vertexBuffer = null;
		if(this.indexMode){
			gl.deleteBuffer(this.indexBuffer);
			this.indexBuffer = null;
		}
	}

	draw(gl){
		if(this.indexMode){
			gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
		}else{
			gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
		}
	}
}

module.exports = MeshVertexArray;