"use strict";

const VertexArray = require("./VertexArray");

class MeshVertexArray extends VertexArray
{
	constructor(subMesh, formatList){
		super();
		Object.assign(this, subMesh);
		this.formatList = formatList;
		this.indexCount = this.indexData.byteLength >> 1;
		this.indexMode = this.indexCount > 0;
	}

	onCreate(gl){
		super.onCreate(gl, this.vertexData, this.indexMode && this.indexData);

		let {position, uv, boneIndex, boneWeight} = this.formatList;

		gl.vertexAttribPointer(0, 3, gl.FLOAT, false, this.byteSizePerVertex, position.offset);
		gl.vertexAttribPointer(1, 2, gl.FLOAT, false, this.byteSizePerVertex, uv.offset);
		gl.enableVertexAttribArray(0);
		gl.enableVertexAttribArray(1);

		if(boneIndex){
			let boneCount = parseInt(boneIndex.format.slice(-1));
			gl.vertexAttribIPointer(2, boneCount, gl.SHORT, this.byteSizePerVertex, boneIndex.offset);
			gl.enableVertexAttribArray(2);
		}else{
			gl.vertexAttribI4i(2, 0, 0, 0, 0);
			//gl.disableVertexAttribArray(2);
		}
		
		if(boneWeight){
			let boneCount = parseInt(boneWeight.format.slice(-1));
			gl.vertexAttribPointer(3, boneCount, gl.FLOAT, false, this.byteSizePerVertex, boneWeight.offset);
			gl.enableVertexAttribArray(3);
		}else{
			gl.vertexAttrib4f(3, 1, 0, 0, 0);
			//gl.disableVertexAttribArray(3);
		}
	}

	draw(gl){
		if(this.indexMode){
			gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
		}else{
			gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
		}
	}
}

module.exports = MeshVertexArray;