import ast
import json
import sys

def invoke(target, argList, retCount):
	return {"type":"invoke", "target":target, "argList":argList, "retCount":retCount}

def call(name, argList, retCount):
	return invoke(getVar(name), argList, retCount)

def getVar(name):
	return {"type":"getVar", "name":name}

def setVar(name, value):
	return {"type":"setVar", "name":name, "value":value}

def newNumber(value):
	return {"type":"number", "value":value}

def newString(value):
	return {"type":"string", "value":value}

def newFunction(argList, code):
	return {"type":"newFunction", "argList":argList, "code":code, "userData":[True]}

def getKey(target, key):
	return call("getKey", [target, key], 1)

def setKey(target, key, value):
	return call("setKey", [target, key, value], 0)

def castList(nodeList, retCount=0):
	result = []
	for node in nodeList:
		v = cast(node, retCount)
		if isinstance(v, list):
			result += v
		elif v is not None:
			result.append(v)
	return result

def cast(node, retCount=1):
	if isinstance(node, ast.Expr):
		node = node.value
	if isinstance(node, ast.Call):
		return invoke(cast(node.func), castList(node.args, 1), retCount)
	if isinstance(node, ast.Name):
		return getVar(node.id)
	if isinstance(node, ast.Attribute):
		return getKey(cast(node.value), newString(node.attr))
	if isinstance(node, ast.Num):
		return newNumber(node.n)
	if isinstance(node, ast.Str):
		return newString(node.s)
	if isinstance(node, (ast.Tuple, ast.List)):
		return {"type":"array",  "value":castList(node.elts, 1)}
	if isinstance(node, ast.Dict):
		return {"type":"object", "value":list(zip(castList(node.keys, 1), castList(node.values, 1)))}
	if isinstance(node, ast.Name):
		return getVar(node.id)
	if isinstance(node, ast.NameConstant):
		return newNumber(node.value)
	if isinstance(node, ast.Pass):
		return None
	if isinstance(node, ast.arguments):
		return [v.arg for v in node.args]
	if isinstance(node, ast.Continue):
		return {"type":"continue"}
	if isinstance(node, ast.Break):
		return {"type":"break"}
	if isinstance(node, ast.Return):
		if node.value is None:
			return {"type":"return"}
		return {"type":"return", "value":cast(node.value)}
	if isinstance(node, ast.Compare):
		if isinstance(node.ops[0], ast.Gt):
			method = ">"
		else: assert False, ast.dump(node)
		return call(method, [cast(node.left), cast(node.comparators[0])], 1)
	if isinstance(node, ast.BinOp):
		if isinstance(node.op, ast.Add):
			method = "+"
		else: assert False, ast.dump(node)
		return call(method, [cast(node.left), cast(node.right)], 1)
	if isinstance(node, ast.Assign):
		target = node.targets[0]
		if isinstance(target, ast.Attribute):
			return setKey(cast(target.value), newString(target.attr), cast(node.value))
		return setVar(target.id, cast(node.value))
	if isinstance(node, ast.If):
		result = [{"type":"if", "condition":cast(node.test), "code":castList(node.body)}]
		if len(node.orelse):
			result.append({"type":"else", "code":castList(node.orelse)})
		return result
	if isinstance(node, ast.While):
		return {"type":"while", "condition":cast(node.test), "code":castList(node.body)}
	if isinstance(node, ast.For):
		return {"type":"loop", "count":cast(node.iter.args[0]), "key":node.target.id, "code":castList(node.body)}
	if isinstance(node, ast.FunctionDef):
		return setVar(node.name, newFunction(cast(node.args), castList(node.body)))
	if isinstance(node, ast.ClassDef):
		result = [setVar(node.name, call("newObj", [], 1))]
		for item in node.body:
			if isinstance(item, ast.FunctionDef):
				result.append(setKey(getVar(node.name), newString(item.name), newFunction(cast(item.args), castList(item.body))))
			else:
				assert False, ast.dump(item)
		return result
	if isinstance(node, ast.Module):
		return castList(node.body)
	assert False, ast.dump(node)

with open(sys.argv[1]) as f:
	tree = ast.parse(f.read())
	info = {"desc":ast.dump(tree)}
	try:
		info["tree"] = cast(tree)
	except Exception as e:
		info["error"] = str(e)
	print(json.dumps(info))
	