function drawLine(g, from, to){
	g.moveTo(from.x, from.y);
	g.lineTo(to.x, to.y);
}

function lineTo(g, to){
	g.lineTo(to.x, to.y);
}

function curveTo(g, control, to){
	g.quadraticCurveTo(control.x, control.y, to.x, to.y);
}

function curveBy(g, from, cross, to){
	g.quadraticCurveTo(
		cross.x * 2 - 0.5 * (from.x + to.x),
		cross.y * 2 - 0.5 * (from.y + to.y),
		to.x,
		to.y
	);
}

function drawCurvePath(g, pointList){	
	if(pointList.length < 3)return;
	
	const centerPoints = calcCenterPoints(pointList);
	const n = centerPoints.length;
	
	drawLine(g, pointList[0], centerPoints[0]);
	for(var i=1; i < n; i++){
		curveTo(g, pointList[i], centerPoints[i]);
	}
	lineTo(g, pointList[n]);
}
		
function bezier(t, controlPts)
{
	const n = controlPts.length - 1;
	
	let x = 0;
	let y = 0;
	
	for(let i=0; i <= n; i++){
		const blend = combination(n, i) * Math.pow(t, i) * Math.pow(1-t, n-i);
		const pt = controlPts[i];
		x += blend * pt.x;
		y += blend * pt.y;
	}

	return {x, y}
}
		
function calcBezierPath(pointList, count){
	if(pointList.length < 3){
		return pointList;
	}
	
	const centerPoints = calcCenterPoints(pointList);
	const n = centerPoints.length;
	
	var result = [pointList[0], centerPoints[0]];
	for(var i=1; i < n; i++){
		bezierSpline([centerPoints[i-1], pointList[i], centerPoints[i]], count, result);
	}
	result.push(pointList[n]);
	return result;
}
		
function bezierSpline(controlPts, count, result){
	//不包含起点,包含终点
	for (let i=1; i <= count; i++){
		let pt = bezier(i / count, controlPts);
		result.push(pt);
	}
}

const calcCenterPoint = (a, b) => ({
	x: 0.5 * (a.x + b.x),
	y: 0.5 * (a.y + b.y),
});
		
function calcCenterPoints(pointList){
	return Array.from({length: pointList.length-1}, (_, i) => calcCenterPoint(pointList[i], pointList[i+1]));
}