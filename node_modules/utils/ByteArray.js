"use strict";

const assert = require("assert");

class ByteArray
{
	constructor(data=0){
		this.ba = (typeof data == "number") ? Buffer.alloc(data) : Buffer.isBuffer(data) ? data : Buffer.from(data);
		this.position = 0;
	}

	get length(){
		return this.ba.length;
	}

	get bytesAvailable(){
		return this.length - this.position;
	}

	readInt64LE(){
		let low = buffer.readUInt32LE();
		let high = buffer.readInt32LE();
		return low + high * INT64_BASE;
	}

	readUInt64LE(){
		let low = buffer.readUInt32LE();
		let high = buffer.readUInt32LE();
		return low + high * INT64_BASE;
	}

	readUInt32LE(){
		let value = this.ba.readUInt32LE(this.position);
		this.position += 4;
		return value;
	}

	readInt32LE(){
		let value = this.ba.readInt32LE(this.position);
		this.position += 4;
		return value;
	}

	readUInt16LE(){
		let value = this.ba.readUInt16LE(this.position);
		this.position += 2;
		return value;
	}

	readInt16LE(){
		let value = this.ba.readInt16LE(this.position);
		this.position += 2;
		return value;
	}

	readUInt8(){
		let value = this.ba.readUInt8(this.position);
		this.position += 1;
		return value;
	}

	readInt8(){
		let value = this.ba.readInt8(this.position);
		this.position += 1;
		return value;
	}

	readBoolean(){
		return this.readUInt8() > 0;
	}

	readCString(){
		let start = this.position;
		while(this.readUInt8());
		return this.ba.toString('utf8', start, this.position-1);
	}

	readUTFBytes(length){
		let start = this.position;
		this.position += length;
		return this.ba.toString('utf8', start, this.position);
	}

	readDouble(){
		let value = this.ba.readDoubleLE(this.position);
		this.position += 8;
		return value;
	}

	readBytes(length){
		let start = this.position;
		this.position += length;
		return this.ba.slice(start, this.position);
	}
}

const INT64_BASE = 0x100000000;

module.exports = ByteArray;