'use strict';
/*
MD5,SHA1,不可逆哈希验证,速度MD5快,长度MD5=16字节,SHA1=20字节,SHA256=32字节
DES,AES,对称加密,AES更难破解
RSA,非对称加密,速度慢,可用来加密DES的密钥
*/

const fs = require('fs');
const crypto = require('crypto');
const {scryptSync, randomFillSync} = crypto;

const file = process.argv[2];

const data = fs.readFileSync(file);
console.log('md5:',  crypto.createHash('md5').update(data).digest('hex'))
console.log('sha1:', crypto.createHash('sha1').update(data).digest('hex'))
console.log('sha256:', crypto.createHash('sha256').update(data).digest('hex'))
console.log('sha512:', crypto.createHash('sha512').update(data).digest('hex'))

function factory(algorithm, decrypt=false){
	const fn = crypto[decrypt ? 'createDecipheriv' : 'createCipheriv'];
	return function(value, key, iv){
		const codec = fn(algorithm, key, iv);
		codec.setAutoPadding(true);
		return Buffer.concat([codec.update(value), codec.final()]);
	}
}

let k = Buffer.from('12345670');
let test = '/upload/image/201602120012.jpg';

function run(algorithm, value, k, iv){
	const encrypt = factory(algorithm);
	const decrypt = factory(algorithm, true);
	const result = encrypt(Buffer.from(value), k, iv).toString('base64');
	console.log(result, decrypt(Buffer.from(result, 'base64'), k, iv).toString() == value)
}

run('des-cbc', test, k, Buffer.alloc(8))
run('des', test, k, Buffer.alloc(8))
console.log('----------')
run('des-ecb', test, k, Buffer.alloc(0))
console.log('----------')
run('aes128', test, scryptSync(k, 'salt', 16), Buffer.alloc(16))
run('aes-128-cbc', test, scryptSync(k, 'salt', 16), Buffer.alloc(16))
run('aes192', test, scryptSync(k, 'salt', 24), Buffer.alloc(16))
run('aes-192-cbc', test, scryptSync(k, 'salt', 24), Buffer.alloc(16))
run('aes256', test, scryptSync(k, 'salt', 32), Buffer.alloc(16))
run('aes-256-cbc', test, scryptSync(k, 'salt', 32), Buffer.alloc(16))


class AES {
	static encrypt(plain, publicKey){
		return crypto.publicEncrypt(publicKey, plain);
	}

	static decrypt(cipher, privateKey, passphrase=''){
		return crypto.privateDecrypt({key: privateKey, passphrase}, cipher);
	}

	static generateKeyPair(passphrase='', modulusLength=4096){
		return crypto.generateKeyPairSync('rsa', {
			modulusLength,
			publicKeyEncoding: {
				type: 'pkcs1',
				format: 'pem',
			},
			privateKeyEncoding: {
				type: 'pkcs1',
				format: 'pem',
				cipher: 'aes-256-cbc',
				passphrase,
			},
		});
	}
}

const {publicKey, privateKey} = AES.generateKeyPair('abc');
let en = AES.encrypt(Buffer.from('hello'), publicKey).toString('base64')
console.log(AES.decrypt(Buffer.from(en, 'base64'), privateKey, 'abc').toString())
//