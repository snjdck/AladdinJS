"use strict";

const TweenEase = require("./TweenEase");
const Range = require("./Range");

const tweenMap = new Map();

function runForever(callback){
	requestAnimationFrame(function(){
		let now = performance.now();
		return function fn(timestamp){
			requestAnimationFrame(fn);
			const timeElapsed = timestamp - now;
			now = timestamp;
			callback(timeElapsed);
		}
	}());
}

function TweenTicker(timeElapsed){
	for(let [target, tweenSet] of tweenMap){
		for(let tween of tweenSet){
			tween.update(timeElapsed);
		}
	}
}

runForever(TweenTicker);

class Tween{
	static KillTweensOf(target){
		let tweenSet = tweenMap.get(target);
		if(tweenSet){
			tweenSet.clear();
		}
	}

	constructor(target, duration, props=null, ease=null, onEnd=null, onUpdate=null){
		this.target = target;
		this._position = 0;
		this.duration = duration;
		this.ease = ease || TweenEase.Linear;
		this._props = props;
		this.onUpdate = onUpdate;
		this.onEnd = onEnd;
	}

	start(){
		const {target} = this;
		let tweenSet = tweenMap.get(target);
		if(!tweenSet){
			tweenSet = new Set([this]);
			tweenMap.set(target, tweenSet);
			this.createPropInfoDict();
			return;
		}
		if(tweenSet.has(this)){
			return;
		}
		this.createPropInfoDict();
		this.delConflictPropsOnOtherTweens(tweenSet);
		tweenSet.add(this);
	}

	stop(){
		let tweenSet = tweenMap.get(this.target);
		if(tweenSet){
			tweenSet.delete(this);
		}
	}

	update(timeElapsed){
		this.position += timeElapsed;
		this.onUpdate?.();
		if(this.position >= this.duration){
			this.stop();
			this.onEnd?.();
		}
	}

	get position(){
		return this._position;
	}

	set position(value){
		this._position = value;
		if(value >= this.duration){
			this.updateTargetPropValues(1);
		}else if(value > 0){
			this.updateTargetPropValues(this.ease(value / this.duration));
		}else{//value <= 0
			this.updateTargetPropValues(0);
		}
	}

	updateTargetPropValues(ratio){
		const {target, props} = this;
		for(let [key, range] of Object.entries(props)){
			target[key] = range.getValue(ratio);
		}
	}

	createPropInfoDict(){
		this.props = {};
		for(let [key, val] of Object.entries(this._props)){
			this.props[key] = this.calcRange(key, val);
		}
	}

	calcRange(key, value){
		const {target} = this;
		let endValue;
		if(Array.isArray(value)){
			endValue = this.calcValue(key, value[1]);
			target[key] = this.calcValue(key, value[0]);
		}else{
			endValue = this.calcValue(key, value);
		}
		return new Range(target[key], endValue);
	}

	calcValue(key, value){
		if(typeof value != "string"){
			return value;
		}
		return parseNumber(value) + this.target[key];
	}

	delConflictPropsOnOtherTweens(tweenSet){
		for(let tween of tweenSet){
			for(let key in this._props){
				delete tween.props[key];
			}
		}
	}
}



module.exports = Tween;