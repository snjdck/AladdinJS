'use strict';

const TweenEase = require('./TweenEase');
const Range = require('./Range');
const {tickByFrame} = require('webonly/timer');

const tweenMap = new WeakMap();

class Tween {
	static KillTweensOf(target){
		const tweenSet = tweenMap.get(target);
		if(!(tweenSet && tweenSet.size > 0))return;
		for(let tween of tweenSet){
			tween.interruptFlag = true;
		}
		tweenSet.clear();
	}

	constructor(target, duration, props, ease=null){
		this.target = target;
		this.duration = duration;
		this.ease = ease || TweenEase.Linear;
		this._props = props;
	}

	start(){
		const {target, _props} = this;
		let tweenSet = tweenMap.get(target);
		if(tweenSet?.has(this))return;
		this._position = 0;
		this.props = createProps(target, _props);
		if(tweenSet){
			delConflictPropsOnOtherTweens(_props, tweenSet);
			tweenSet.add(this);
		}else{
			tweenSet = new Set([this]);
			tweenMap.set(target, tweenSet);
		}
		return tickByFrame(
			timeElapsed => this.position += timeElapsed,
			() => this.interruptFlag || this.position >= this.duration
		).then(() => {
			tweenSet.delete(this);
			return this.interruptFlag;
		});
	}

	get position(){
		return this._position;
	}

	set position(value){
		this._position = value;
		if(value >= this.duration){
			this.updateTargetPropValues(1);
		}else if(value > 0){
			this.updateTargetPropValues(this.ease(value / this.duration));
		}else{//value <= 0
			this.updateTargetPropValues(0);
		}
	}

	updateTargetPropValues(ratio){
		const {target, props} = this;
		for(let [key, range] of Object.entries(props)){
			target[key] = range.getValue(ratio);
		}
	}
}

function createProps(target, props){
	return Object.fromEntries(Object.entries(props).map(([k, v]) => [k, calcRange(target, k, v)]));
}

function calcRange(target, key, value){
	let endValue;
	if(Array.isArray(value)){
		endValue = calcValue(target, key, value[1]);
		target[key] = calcValue(target, key, value[0]);
	}else{
		endValue = calcValue(target, key, value);
	}
	return new Range(target[key], endValue);
}

function calcValue(target, key, value){
	return typeof value !== 'string' ? value : Number(value) + target[key];
}

function delConflictPropsOnOtherTweens(props, tweenSet){
	loop:
	for(let tween of tweenSet){
		for(let key in props){
			delete tween.props[key];
		}
		for(let key in tween.props){
			continue loop;
		}
		tween.interruptFlag = true;
	}
}

module.exports = Tween;
