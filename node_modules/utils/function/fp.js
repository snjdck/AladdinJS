
const identity = v => v;
const constant = v => () => v;
const spreadArgs = fn => v => fn(...v);
const gatherArgs = fn => (...v) => fn(v);
const compose = (...funcs) => funcs.length ? funcs.reduce((a, b) => (...args) => a(b(...args))) : identity;
const partial = (fn, ...presets) => (...args) => fn(...presets, ...args);
const partialRight = (fn, ...presets) => (...args) => fn(...args, ...presets);
const curry = (fn, arity=fn.length) => (...args) => args.length >= arity ? fn(...args) : curry(partial(fn, ...args), arity - args.length);
const curryRight = (fn, arity=fn.length) => (...args) => args.length >= arity ? fn(...args) : curryRight(partialRight(fn, ...args), arity - args.length);
const partialProps = (fn, ...presets) => (...args) => fn(Object.assign({}, ...presets, ...args));
const reverseArgs = fn => (...args) => fn(...args.reverse());
const not = fn => (...args) => !fn(...args);
const uncurry = fn => (...args) => args.reduce((f, v) => f(v), fn);
const uncurryRight = compose(reverseArgs, uncurry);
const when = (predicate, fn) => (...args) => predicate(...args) && fn(...args);
const pipe = reverseArgs(compose);
const rememberData = (...args) => fn => fn(...args);
const unique = list => list.filter((v, idx) => list.indexOf(v) == idx);
const flatten = (list, result=[]) => (list.forEach(value => Array.isArray(value) ? flatten(value, result) : result.push(value)), result);
const before = (n, fn) => () => --n > 0 && fn();
const after = (n, fn) => () => --n <= 0 && fn();
const ary = (fn, n=fn.length) => (...args) => fn(...args.slice(0, n));
const unary = fn => v => fn(v);
const binary = fn => (a, b) => fn(a, b);

const once = fn => () => fn && (fn(), fn=null);
const overArgs = (fn, transforms) => (...args) => fn(...args.map(
	Array.isArray(transforms) ? (v, i) => (transforms[i] || identity)(v) : transforms || identity
));
const repeat = (n, fn) => {
	for(let i=0; i<n; ++i)fn(i);
};
const array = (n, fill=0) => Array(n).fill(fill);
const rearg = (fn, indexes) => indexes ? (...args) => fn(...indexes.map(i => args[i])) : fn;
const rest = (fn, start=fn.length-1) => (...args) => {
	let offset = start + args.length - fn.length + 1;
	fn(...args.slice(0, start), args.slice(start, offset), ...args.slice(offset));
}

const tap = curry((fn, v) => (fn(v), v));
const pick = curry((keys, dict) => keys.reduce((result, key) => (result[key] = dict[key], result), {}));
//const pick = curry((keys, dict) => Object.fromEntries(keys.map(k => [k, dict[k]])));
const get = curry((key, dict) => dict[key]);
const map = curry((fn, list) => list.map(fn));
const filter = curry((fn, list) => list.filter(fn));
const reject = curry((fn, list) => list.filter(not(fn)));
const sortBy = curry((fn, list) => list.sort(overArgs(sign, fn)));
const reduce = curry((fn, init, list) => list.reduce(fn, init));
const all = curry((fn, list) => list.every(fn));
const any = curry((fn, list) => list.some(fn));
const propEq = curry((key, value, dict) => dict[key] === value);
const filterReducer = curry((predicate, fn) => (acc, cur) => predicate(cur) ? fn(acc, cur) : acc);
const eq = curry((a, b) => a === b);
const method = curry((f, a, b) => a[f](b));

const parallel = (...funcs) => (...args) => funcs.map(fn => fn(...args));

const zip = gatherArgs(compose(
	map(binary(uncurryRight(compose(map, get)))),
	spreadArgs(array),
	parallel(
		compose(
			spreadArgs(Math.min),
			map(get('length'))
		),
		identity
	)
));

const mergeList = gatherArgs(compose(
	filter(not(eq(undefined))),
	reduce(method('concat'), []),
	map(binary(uncurryRight(compose(map, get)))),
	spreadArgs(array),
	parallel(
		compose(
			spreadArgs(Math.max),
			map(get('length'))
		),
		identity
	)
));


//console.log(mergeList( [1,3,5,7,9], [2,4,6,8,10,11] ))
//console.log(zip( [1,3,5,7,9], [2,4,6,8,10,11] ))

const double = v => v * 2;
const square = v => v * v;
const isOdd = v => v % 2 == 1;
const add = (a, b) => a + b;
const sum = reduce(add, 0);
const sign = (a, b) => a < b ? -1 : a > b ? 1 : 0;
const gte = curry((v, n) => n >= v);
const lte = curry((v, n) => n <= v);

const keyCount = dict => Object.keys(dict).length;
const totalKeyCount = compose(sum, map(keyCount));
//const mergeDict = (...args) => Object.assign({}, ...args);
const curryProps = (fn, arity=1) => (...args) => {
	let n = totalKeyCount(args);
	return n >= arity ? fn(Object.assign({}, ...args)) : curryProps(partialProps(fn, ...args), arity - n);
};


var objects = [{ id: 1 }, { id: 2 }, { id: 3 }];
console.log(map(get('id'))(objects));

//var add = function(a, b) {return a + b;};
var numbers = [1, 2, 3, 4, 5];
//var sum = reduce(add, 0); //=> 15
console.log(sum(numbers));

var data = {
    result: "SUCCESS",
    interfaceVersion: "1.0.3",
    requested: "10/17/2013 15:31:20",
    lastUpdated: "10/16/2013 10:52:39",
    tasks: [
        {id: 104, complete: false,            priority: "high",
                  dueDate: "2013-11-29",      username: "Scott",
                  title: "Do something",      created: "9/22/2013"},
        {id: 105, complete: false,            priority: "medium",
                  dueDate: "2013-11-22",      username: "Lena",
                  title: "Do something else", created: "9/22/2013"},
        {id: 107, complete: true,             priority: "high",
                  dueDate: "2013-11-22",      username: "Mike",
                  title: "Fix the foo",       created: "9/22/2013"},
        {id: 108, complete: false,            priority: "low",
                  dueDate: "2013-11-15",      username: "Punam",
                  title: "Adjust the bar",    created: "9/25/2013"},
        {id: 110, complete: false,            priority: "medium",
                  dueDate: "2013-11-15",      username: "Scott",
                  title: "Rename everything", created: "10/2/2013"},
        {id: 112, complete: true,             priority: "high",
                  dueDate: "2013-11-27",      username: "Lena",
                  title: "Alter all quuxes",  created: "10/5/2013"}
        // , ...
    ]
};

const getIncompleteTaskSummaries = membername => pipe(
	get('tasks'),
	filter(propEq('username', membername)),
	reject(propEq('complete', true)),
	//tap(v => console.log(v)),
	map(pick(['id', 'dueDate', 'title', 'priority'])),
	sortBy(get('dueDate'))
);


console.log(getIncompleteTaskSummaries('Scott')(data));
void function(){
function sum(x,y) { return x + y; }
function constructMsg(v) { return `The magic number is: ${v}`; }
var sumOnlyFavorites = compose(
    filterReducer( gte( 10 ) ),
    filterReducer( lte( 20 ) )
)( sum );

var printMagicNumber = pipe(
 // filter(gte( 10 )),
 // tap(v => console.log(v)),
 // filter(lte( 20 )),
    reduce( sumOnlyFavorites, 0 ),
    constructMsg,
    console.log
);

var numbers = [4,10,0,27,42,17,15,-6,58];

printMagicNumber( numbers );        // The magic number is: 42

// ***************
}();

