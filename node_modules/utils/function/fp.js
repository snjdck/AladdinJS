
const unary = fn => v => fn(v);
const unary_n = (fn, n=1) => (...args) => fn(...args.slice(0, n));

const identity = v => v;
const constant = v => () => v;
const spreadArgs = fn => v => fn(...v);
const gatherArgs = fn => (...v) => fn(v);
const partial = (fn, ...presets) => (...args) => fn(...presets, ...args);
const partialRight = (fn, ...presets) => (...args) => fn(...args, ...presets);
const reverseArgs = fn => (...args) => fn(...args.reverse());
const not = fn => (...args) => !fn(...args);
const uncurry = fn => (...args) => args.reduce((f, v) => f(v), fn);
const when = (predicate, fn) => (...args) => predicate(...args) && fn(...args);
const compose = (...funcs) => funcs.length ? funcs.reduce((a, b) => (...args) => a(b(...args))) : identity;
const pipe = reverseArgs(compose);
const rememberData = (...args) => fn => fn(...args);
const unique = list => list.filter((v, idx) => list.indexOf(v) == idx);
const flatten = (list, result=[]) => (list.forEach(value => Array.isArray(value) ? flatten(value, result) : result.push(value)), result);

