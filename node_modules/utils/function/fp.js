
const unary = fn => v => fn(v);
const unary_2 = fn => (a, b) => fn(a, b);
const unary_3 = fn => (a, b, c) => fn(a, b, c);
const unary_n = (fn, n=1) => (...args) => fn(...args.slice(0, n));

const identity = v => v;
const constant = v => () => v;
const spreadArgs = fn => v => fn(...v);
const gatherArgs = fn => (...v) => fn(v);
const partial = (fn, ...presets) => (...args) => fn(...presets, ...args);
const partialRight = (fn, ...presets) => (...args) => fn(...args, ...presets);
const reverseArgs = fn => (...args) => fn(...args.reverse());
const not = fn => (...args) => !fn(...args);
const uncurry = fn => (...args) => args.reduce((f, v) => f(v), fn);
const when = (predicate, fn) => (...args) => predicate(...args) && fn(...args);
const compose = (...funcs) => funcs.length ? funcs.reduce((a, b) => (...args) => a(b(...args))) : identity;
const pipe = reverseArgs(compose);
const rememberData = (...args) => fn => fn(...args);
const unique = list => list.filter((v, idx) => list.indexOf(v) == idx);
const flatten = (list, result=[]) => (list.forEach(value => Array.isArray(value) ? flatten(value, result) : result.push(value)), result);

const filter = fn => v => v.filter(fn);
const map = fn => v => v.map(fn);
const double = v => v * 2;
const isOdd = v => v % 2 == 1;

console.log(compose(map(double), filter(isOdd))([1,2,3]))


