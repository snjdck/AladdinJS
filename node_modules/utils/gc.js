const {timeline} = document;//performance.now();

function mainLoop(handler){
	let zero = timeline.currentTime;
	let prev = zero;//timeElapsed
	requestAnimationFrame(function f(timestamp){
		handler(timestamp - prev, timestamp - zero);
		requestAnimationFrame(f);
		prev = timestamp;
	});
}

function newTimer(lifetime){
	const getMap = ((map1, map2) => key => typeof key === 'string' ? map1 : map2)(new Map(), new WeakMap());
	return {
		update(key){
			getMap(key).set(key, timeline.currentTime);
		},
		timeout(key){
			return getMap(key).get(key) + lifetime < timeline.currentTime;
		}
	}
}

function* newGC(fn){
	for(;;){
		yield* fn();
		yield;//fn may not yield
	}
}

function ObjectPool(newFn, queryFnMap, lifetime=1000){
	const timer = newTimer(lifetime);
	const getCache = [];
	const outCache = [];
	const gc = newGC(function*(){
		for(let i=0; i<getCache.length; ++i){
			const index = -(i + 1);
			if(timer.timeout(getCache.at(index))){
				getCache.splice(index, 1)[0].destroy();
				--i;
			}
			yield;
		}
	});
	function onReset(){
		gc.next();
		getCache.unshift(...outCache);
		outCache.length = 0;
	}
	return (query, strategy) => {
		const index = getCache.findIndex(queryFnMap[strategy], query);
		const object = index >= 0 ? getCache.splice(index, 1)[0] : newFn(query, strategy);
		timer.update(object);
		if(outCache.length == 0)requestAnimationFrame(onReset);
		outCache.push(object);
		return object;
	}
}

function OneFrameMap(){
	const map = new Map();
	const reset = () => map.clear();
	return {
		get size(){return map.size},
		has:k => map.has(k),
		get:k => map.get(k),
		set(key, value){
			if(map.size == 0)requestAnimationFrame(reset);
			map.set(key, value);
		}
	}
}

function LRUCache(lifetime=1000){
	const map = new Map();
	const timer = newTimer(lifetime);
	const gc = newGC(function*(){
		for(let key of map.keys()){
			if(timer.timeout(key)){
				map.get(key).destroy?.();
				map.delete(key);
			}
			yield;
		}
	});
	return {
		get(key){
			timer.update(key);
			gc.next();
			return map.get(key);
		},
		set(key, value){
			timer.update(key);
			map.set(key, value);
		},
		has(key){
			return map.has(key);
		}
	}
}

exports.mainLoop = mainLoop;
exports.OneFrameMap = OneFrameMap;
exports.ObjectPool = ObjectPool;
exports.LRUCache = LRUCache;
