
function* newGC(fn){
	for(;;){
		yield* fn();
		yield;//fn may not yield
	}
}

function newTimer(lifetime){
	const {timeline} = document;//performance.now();
	const map = new WeakMap();
	return {
		update(key){
			map.set(key, timeline.currentTime);
		},
		timeout(key){
			return map.get(key) + lifetime < timeline.currentTime;
		}
	}
}

function ObjectPool(newFn, queryFn, lifetime=1000){
	const timer = newTimer(lifetime);
	const getCache = [];
	const outCache = [];
	const gc = newGC(function*(){
		for(let i=0; i<getCache.length; ++i){
			const index = -(i + 1);
			if(timer.timeout(getCache.at(index))){
				getCache.splice(index, 1)[0].destroy();
				--i;
			}
			yield;
		}
	});
	function onReset(){
		gc.next();
		getCache.unshift(...outCache);
		outCache.length = 0;
	}
	return (query, ...args) => {
		const index = getCache.findIndex(queryFn, query);
		const object = index >= 0 ? getCache.splice(index, 1)[0] : newFn(query, ...args);
		timer.update(object);
		if(outCache.length == 0)requestAnimationFrame(onReset);
		outCache.push(object);
		return object;
	}
}

function LRUCache(lifetime=1000){
	const map = new Map();
	const timer = newTimer(lifetime);
	const gc = newGC(function*(){
		for(let key of map.keys()){
			if(timer.timeout(key)){
				map.get(key).destroy?.();
				map.delete(key);
			}
			yield;
		}
	});
	return {
		get(key){
			gc.next();
			timer.update(key);
			return map.get(key);
		},
		set(key, value){
			timer.update(key);
			map.set(key, value);
		},
		has(key){
			return map.has(key);
		},
		delete(key){
			map.delete(key);
		}
	}
}

exports.ObjectPool = ObjectPool;
exports.LRUCache = LRUCache;
