
function* newGC(fn){
	for(;;){
		yield* fn();
		yield;//fn may not yield
	}
}

function newTimer(lifetime){
	const {timeline} = document;//performance.now();
	const getMap = ((map1, map2) => key => typeof key === 'string' ? map1 : map2)(new Map(), new WeakMap());
	return {
		update(key){
			getMap(key).set(key, timeline.currentTime);
		},
		timeout(key){
			return getMap(key).get(key) + lifetime < timeline.currentTime;
		}
	}
}

function ObjectPool(newFn, queryFnMap, lifetime=1000){
	const timer = newTimer(lifetime);
	const getCache = [];
	const outCache = [];
	const gc = newGC(function*(){
		for(let i=0; i<getCache.length; ++i){
			const index = -(i + 1);
			if(timer.timeout(getCache.at(index))){
				getCache.splice(index, 1)[0].destroy();
				--i;
			}
			yield;
		}
	});
	function onReset(){
		gc.next();
		getCache.unshift(...outCache);
		outCache.length = 0;
	}
	return (query, findKey, newKey) => {
		const index = getCache.findIndex(queryFnMap[findKey], query);
		const object = index >= 0 ? getCache.splice(index, 1)[0] : newFn(query, newKey);
		timer.update(object);
		if(outCache.length == 0)requestAnimationFrame(onReset);
		outCache.push(object);
		return object;
	}
}

function LRUCache(lifetime=1000){
	const map = new Map();
	const timer = newTimer(lifetime);
	const gc = newGC(function*(){
		for(let key of map.keys()){
			if(timer.timeout(key)){
				map.get(key).destroy?.();
				map.delete(key);
			}
			yield;
		}
	});
	return {
		get(key){
			timer.update(key);
			gc.next();
			return map.get(key);
		},
		set(key, value){
			timer.update(key);
			map.set(key, value);
		},
		has(key){
			return map.has(key);
		}
	}
}

exports.ObjectPool = ObjectPool;
exports.LRUCache = LRUCache;
