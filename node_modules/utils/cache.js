
function delayNew(newFn){
	let v;
	return function(){
		if(newFn){
			v = newFn.call(this);
			newFn = null;
		}
		return v;
	}
}

function createGetter(newFn, keyFn){
	let hit = Object.create(null);
	return function(...args){
		let k = keyFn ? keyFn(...args) : args[0];
		return (k in hit) ? hit[k] : (hit[k] = newFn.apply(this, args));
	}
}

function createListGetter(newFn){
	const list = [];
	return i => list[i] ?? (list[i] = newFn(i));
}

function createGetSet(newFn, setFlag=true, value=undefined){
	return [function(){
		if(setFlag){
			value = newFn.call(this);
			setFlag = false;
		}
		return value;
	}, () => setFlag = true];
}

function defineMainSubPropNow(mainProp, subPropMap, valueCheckFlag=true){
	function mainPropFn(value){
		return {
			get: () => value,
			set(newValue){
				if(valueCheckFlag && value == newValue)return;
				value = newValue;
				for(const name in subPropMap){
					this[name] = subPropMap[name].call(this);
				}
			}
		};
	}
	return function(target, value){
		Object.defineProperty(target, mainProp, mainPropFn(value));
	}
}

function defineMainSubPropDelay(mainProp, subPropMap, valueCheckFlag=true){
	const keyList = Object.keys(subPropMap);
	function mainPropFn(subPropList, value){
		return {
			get: () => value,
			set(newValue){
				if(valueCheckFlag && value == newValue)return;
				value = newValue;
				for(const [getFn, setFn] of subPropList)setFn();
			}
		};
	}
	return function(target, value){
		const subPropList = keyList.map(k => createGetSet(subPropMap[k], false));
		Object.defineProperty(target, mainProp, mainPropFn(subPropList, value));
		for(let i=0, n=keyList.length; i<n; ++i){
			Object.defineProperty(target, keyList[i], {get: subPropList[i][0]});
		}
	}
}

//const createSingleValueWrapper = value => newValue => (newValue === undefined) ? value : (value = newValue);

function createFetch(loader){
	const cache = new Map();
	return function(key, callback){
		if(cache.has(key)){
			const {value, waitList} = cache.get(key);
			if(callback){
				if(waitList){
					waitList.push(callback);
				}else{
					callback(value);
				}
			}
			return value;
		}
		const waitList = callback ? [callback] : [];
		const info = {waitList};
		cache.set(key, info);
		loader.call(this, key, value => {
			info.value = value;
			info.waitList = null;
			waitList.forEach(f => f(value));
		});
	}
}

module.exports = {
	delayNew,
	createGetter,
	createFetch,
	createListGetter,
	createGetSet,
	defineMainSubPropNow,
	defineMainSubPropDelay,
	//createSingleValueWrapper,
};