
function delayNew(newFn){
	let v;
	return function(){
		if(newFn){
			v = newFn.call(this);
			newFn = null;
		}
		return v;
	}
}

function createGetter(newFn, keyFn){
	let hit = Object.create(null);
	return function(...args){
		let k = keyFn ? keyFn(...args) : args[0];
		return (k in hit) ? hit[k] : (hit[k] = newFn.apply(this, args));
	}
}

const createListGetter = (newFn, list=[]) => i => list[i] ?? (list[i] = newFn(i, list));
const createDictGetter = (newFn, dict={}) => k => dict[k] ?? (dict[k] = newFn(k, dict));
const createMapGetter = (newFn, map=new Map()) => k => {
	if(map.has(k))return map.get(k);
	const v = newFn(k, map);
	map.set(k, v);
	return v;
}

function createGetSet(newFn, setFlag=true, value, onSet){
	return [function(){
		if(setFlag){
			setFlag = false;
			value = newFn.call(this);
		}
		return value;
	}, function(){
		const oldFlag = setFlag;
		setFlag = true;
		onSet?.call(this, oldFlag);
	}];
}

function defineProperty(target, key, get, set){
	Object.defineProperty(target, key, {get, set, enumerable: true});
}

const defineMainSubProp = function(){
	const mainPropFn = (subPropList, value) => [() => value, function(newValue){
		if(value === newValue)return;
		value = newValue;
		for(const [getFn, setFn] of subPropList)setFn.call(this);
	}];
	return function(mainProp, subPropMap){
		const keyList = Object.keys(subPropMap);
		return function(target, value){
			const subPropList = keyList.map(k => createGetSet(subPropMap[k], false));
			defineProperty(target, mainProp, ...mainPropFn(subPropList, value));
			for(let i=0, n=keyList.length; i<n; ++i){
				defineProperty(target, keyList[i], subPropList[i][0]);
			}
		}
	}
}();

const defineSubMainProp = function(){
	function subPropFn(setFn, defaultValue){
		const needCheck = typeof defaultValue !== 'function';
		let value = needCheck ? defaultValue : defaultValue();
		return [() => value, function(newValue){
			if(needCheck && value === newValue)return;
			value = newValue;
			setFn.call(this);
		}];
	}
	return (mainProp, mainPropFn, subPropMap) => (target, value, onSet) => {
		const [getFn, setFn] = createGetSet(mainPropFn, false, value, onSet);
		defineProperty(target, mainProp, getFn);
		for(const name in subPropMap){
			defineProperty(target, name, ...subPropFn(setFn, subPropMap[name]));
		}
	}
}();

const createSingleValueWrapper = oldValue => newValue => (newValue === undefined) ? oldValue : (oldValue = newValue);

function createFetch(loadFn){
	const cache = new Map();
	return function(key, callback){
		if(cache.has(key)){
			const {value, waitList} = cache.get(key);
			if(callback){
				if(waitList){
					waitList.push(callback);
				}else{
					queueMicrotask(() => callback(value));
				}
			}
			return value;
		}
		const waitList = callback ? [callback] : [];
		const info = {waitList};
		cache.set(key, info);
		loadFn(key).then(value => {
			info.value = value;
			info.waitList = null;
			waitList.forEach(f => f(value));
		});
	}
}

module.exports = {
	delayNew,
	createGetter,
	createFetch,
	createListGetter,
	createDictGetter,
	createMapGetter,
	createGetSet,
	defineMainSubProp,
	defineSubMainProp,
	createSingleValueWrapper,
};