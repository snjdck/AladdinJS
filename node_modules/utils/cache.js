
const delayNew = (newFn, v) => function(...args){
	if(newFn){
		v = newFn.apply(this, args);
		newFn = null;
	}
	return v;
}

const createGetter = (newFn, keyFn, hit=Object.create(null)) => function(...args){
	const k = keyFn?.(...args) ?? args[0];
	if(k in hit)return hit[k];
	const v = newFn.apply(this, args);
	hit[k] = v;
	return v;
}

const createMapGetter = (newFn, keyFn, hit=new Map()) => function(...args){
	const k = keyFn?.(...args) ?? args[0];
	if(hit.has(k))return hit.get(k);
	const v = newFn.apply(this, args);
	hit.set(k, v);
	return v;
}

const createSingleValueWrapper = oldValue => newValue => (newValue === undefined) ? oldValue : (oldValue = newValue);

function createFetch(loadFn, cache=new Map()){
	const loadCache = new Map();
	return function(key, promiseFlag=true){
		if(cache.has(key)){
			const value = cache.get(key);
			return promiseFlag ? Promise.resolve(value) : value;
		}
		if(!loadCache.has(key)){
			const waitList = [];
			loadCache.set(key, waitList);
			loadFn.call(this, key).then(value => {
				cache.set(key, value);
				waitList.forEach(f => f[0](value));
				loadCache.delete(key)
			}, value => {
				waitList.forEach(f => f[1](value));
				loadCache.delete(key)
			});
		}
		return promiseFlag ? new Promise((...args) => loadCache.get(key).push(args)) : undefined;
	}
}

module.exports = {
	delayNew,
	createGetter,
	createMapGetter,
	createFetch,
	createSingleValueWrapper,
	createListGetter: (newFn, list=[]) => createGetter(newFn, null, list),
	createWeakMapGetter: (newFn, keyFn) => createMapGetter(newFn, keyFn, new WeakMap()),
};