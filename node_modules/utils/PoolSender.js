
if(typeof performance === 'undefined')
	var performance = Date;
if(typeof setImmediate === 'undefined')
	var setImmediate = v => setTimeout(v, 0);

class PoolSender
{
	constructor(maxPoolSize, maxSendSize, sendInterval, sender){
		this.maxPoolSize = maxPoolSize;
		this.maxSendSize = Math.min(maxSendSize, maxPoolSize);
		this.sendInterval = sendInterval;
		this.timestamp = 0;
		this.sender = sender;
		this.sendQueue = [];
		this.recvQueue = [];
		this.onSend = this.onSend.bind(this);
		this.clear();
	}

	clear(){
		this.sendQueue.length = 0;
		this.recvQueue.length = 0;
		this.poolSize = this.maxPoolSize;
		this.mustWaitFlag = false;
	}

	send(data, callback, mustWaitFlag=false){
		this.sendQueue.push([data.length, callback, data, mustWaitFlag]);
		this.deferSend();
	}

	deferSend(){
		if(this.timer != null)return;
		this.timer = setImmediate(this.onSend);
	}

	onSend(){
		this.timer = null;
		if(this.mustWaitFlag)return;
		let now = performance.now();
		if(now - this.timestamp < this.sendInterval){
			this.deferSend();
			return;
		}
		let bufferList = [];
		let bufferSize = this.maxSendSize;
		while(this.sendQueue.length && this.poolSize && bufferSize){
			const maxSize = Math.min(this.poolSize, bufferSize);
			const item = this.sendQueue[0];
			const data = item[2];
			if(data.length <= maxSize){
				bufferList.push(data);
				item.splice(2, 1);
				this.poolSize -= data.length;
				bufferSize -= data.length;
				this.recvQueue.push(this.sendQueue.shift());
				this.mustWaitFlag = item[2];
				if(this.mustWaitFlag)break;
			}else{
				bufferList.push(data.slice(0, maxSize));
				item[2] = data.slice(maxSize);
				this.poolSize -= maxSize;
				bufferSize -= maxSize;
			}
		}
		if(bufferList.length <= 0)return;
		this.sender(Buffer.concat(bufferList));
		this.timestamp = now;
		this.deferSend();
	}

	onRecv(data){
		if(this.recvQueue.length <= 0){
			return;
		}
		let [dataSize, callback, mustWaitFlag] = this.recvQueue.shift();
		if(callback)callback(data);
		this.poolSize += dataSize;
		this.deferSend();
		if(mustWaitFlag){
			this.mustWaitFlag = false;
		}
	}
}

export default PoolSender;