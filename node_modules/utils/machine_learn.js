const sum = v => v.reduce((a, b) => a + b);
const zip = (a, b) => a.map((v, i) => [v, b[i]]);
const mul = ([a, b]) => a * b;
const sub = ([a, b]) => a - b;
const zipmul = (a, b) => zip(a, b).map(mul);
const zipsub = (a, b) => zip(a, b).map(sub);
const sigmoid = z => 1 / (1 + Math.E ** -z);
const sigmoid$ = z => z * (1 - z);
const relu = v => Math.max(0, v);
const isNumber = v => typeof v === 'number';
const calc = (a, b, bias) => a.reduce((sum, v, i) => sum + v * b[i], bias);
//const calcNet = (net, input) => net.reduce((input, layer) => layer.map(v => sigmoid(calc(input, v))), input);
const createNet = (...shape) => shape.slice(1).map((n, i) => Array(n).fill().map(_ => Array(shape[i]).fill(0)));
//*
function calcNet(net, bias, input){
	let result = [input];
	result.push(...net.map((layer, i) => input = layer.map(v => sigmoid(calc(input, v, bias[i])))));
	return result;
}
//*/
function setData(net, values){
	for(let i=0; i<net.length; ++i){
		for(let j=0; j<net[i].length; ++j){
			let a = net[i][j];
			let b = values[i][j];
			if(a.length !== b.length){
				console.error('shape size error!');
				continue;
			}
			if(!(a.every(isNumber) && b.every(isNumber))){
				console.error('value must be number!');
				continue;
			}
			for(let k=a.length-1; k>=0; --k){
				a[k] = b[k];
			}
		}
	}
}

const calcError = (result, output) => result.reduce((sum, v, i) => sum + 0.5 * (v - output[i]) ** 2, 0);
const calcTimes = (fn, count=10000) => {
	for(let i=1; i<=count; ++i)fn(i==count);
}

function calcErrorList(net, bias, input, output){
	let result = calcNet(net, bias, input);
	let errorList = [];
	let layer = result[result.length-1];
	errorList.push(zipmul(layer.map(sigmoid$), zipsub(layer, output)));
	for(let index=result.length-2; index>0; --index){
		let lastError = errorList[errorList.length-1];
		let layer = result[index];
		let weight = net[index];
		errorList.push(zipmul(layer.map(sigmoid$), layer.map((_, i) => sum(lastError.map((v, j) => v * weight[j][i])))));
	}
	return errorList.reverse().map((error, i) => error.map(v => result[i].map(t => t * v)));
}

const mapNet = (net, fn) => net.map((layer, i) => layer.map((node, j) => node.map((value, k) => fn(value, i, j, k))));

const runData = (net, bias, sampleList) => calcTimes(endFlag => {
	let errorList = sampleList.map(sample => calcErrorList(net, bias, ...sample));
	let error = errorList.reduce((a, b) => mapNet(net, (_, i, j, k) => a[i][j][k] + b[i][j][k]));
	if(errorList.length > 1){
		let factor = 1 / errorList.length;
		error = mapNet(error, v => v * factor);
	}
	net = mapNet(net, (v, i, j, k) => v - 0.5 * error[i][j][k]);
	if(endFlag)console.log(net)
});


void function(){
	let testA = createNet(2, 2, 2);
	const bias = [0.35, 0.6];
	//let inputA = [0.05, 0.1];
	//let outputA = [0.01, 0.99];

	let sampleList = [
		[[0.05, 0.1], [0.01, 0.99]]
	];
	//console.log(testA);
	setData(testA, [[[0.15, 0.2],[0.25,0.3]],[[0.4,0.45],[0.5,0.55]]]);
	runData(testA, bias, sampleList);
}()


/*
这里介绍的是计算完一条记录，就马上更新权重，以后每计算完一条都即时更新权重。
实际上批量更新的效果会更好，方法是在不更新权重的情况下，把记录集的每条记录都算过一遍，
把要更新的增值全部累加起来求平均值，然后利用这个平均值来更新一次权重，
然后利用更新后的权重进行下一轮的计算，这种方法叫批量梯度下降(Batch Gradient Descent)。
*/




return;

let sample = [
	[[0, 0], [0]],
	[[0, 1], [1]],
	[[1, 0], [1]],
	[[1, 1], [0]],
];

const runSample = net => console.log(sample.map(v => calcNet(net, v[0])));

//cost = T.sum((y-y_hat)**2) #采用的是平方损失函数
//cost = - (y_hat*T.log(y)+(1-y_hat)*T.log(1-y)).sum() #采用交叉熵损失函数

function testRun(net){
	const target = sample.map(v => v[1]);
	let result = sample.map(v => calcNet(net, v[0]));
	let error = 0.5 * target.reduce((acc, v, i) => acc + (v - result[i]) ** 2, 0);
	console.log(target, result, error)
}

let and = [-3, 2, 2];
let or = [-1, 2, 2];
let not_or = [1, -2, -2];

/*
let testA = createNet(2,1);
setData(testA, [[and]])
//console.log('testA',testA)
runSample(testA);
setData(testA, [[or]])
runSample(testA);
setData(testA, [[not_or]])
runSample(testA);
*/
let testB = createNet(2, 2, 1);
setData(testB, [[and, not_or],[or]])
runSample(testB);

//testRun(testB);