const sum = v => v.reduce((a, b) => a + b);
const zip = (a, b) => a.map((v, i) => [v, b[i]]);
const mul = ([a, b]) => a * b;
const sub = ([a, b]) => a - b;
const zipmul = (a, b) => zip(a, b).map(mul);
const zipsub = (a, b) => zip(a, b).map(sub);
const sigmoid = z => 1 / (1 + Math.E ** -z);
const sigmoid$ = z => z * (1 - z);
const relu = v => Math.max(0, v);
const isNumber = v => typeof v === 'number';
const calc = (a, b, bias) => a.reduce((sum, v, i) => sum + v * b[i], bias);
const calcNet = (net, bias, input) => net.map((layer, i) => input = layer.map(v => sigmoid(calc(input, v, bias[i]))));
const createNet = (...shape) => shape.slice(1).map((n, i) => Array(n).fill().map(_ => Array(shape[i]).fill(0)));

function setData(net, values){
	for(let i=0; i<net.length; ++i){
		for(let j=0; j<net[i].length; ++j){
			let a = net[i][j];
			let b = values[i][j];
			if(a.length !== b.length){
				console.error('shape size error!');
				continue;
			}
			if(!(a.every(isNumber) && b.every(isNumber))){
				console.error('value must be number!');
				continue;
			}
			for(let k=a.length-1; k>=0; --k){
				a[k] = b[k];
			}
		}
	}
}

const calcError = (result, output) => result.reduce((sum, v, i) => sum + (v - output[i]) ** 2, 0) * 0.5;
const calcTimes = (fn, count) => {
	for(let i=1; i<=count; ++i)fn(i==count);
}

function calcErrorList(net, bias, input, output){
	let result = calcNet(net, bias, input).reverse();
	let lastError;
	let errorList = result.map((layer, index) => {
		if(index == 0){
			lastError = zipsub(layer, output);
		}else{
			let weight = net[net.length-index];
			lastError = layer.map((_, i) => sum(lastError.map((v, j) => v * weight[j][i])));
		}
		return lastError = zipmul(layer.map(sigmoid$), lastError);
	});
	result.push(input);
	return errorList.map((error, i) => error.map(v => result[i+1].map(t => t * v))).reverse();
}

const mapNet = (net, fn) => net.map((layer, i) => layer.map((node, j) => node.map((value, k) => fn(value, i, j, k))));

const runData = (net, bias, sampleList, times=10000) => calcTimes(endFlag => {
	let errorList = sampleList.map(sample => calcErrorList(net, bias, ...sample));
	let error = errorList.reduce((a, b) => mapNet(net, (_, i, j, k) => a[i][j][k] + b[i][j][k]));
	if(errorList.length > 1){
		let factor = 1 / errorList.length;
		error = mapNet(error, v => v * factor);
	}
	net = mapNet(net, (v, i, j, k) => v - 0.5 * error[i][j][k]);
	if(endFlag)console.log('net', net, 'sample', sampleList.map(sample => calcNet(net, bias, ...sample).pop()));
}, times);


void function(){
	let test = createNet(2, 2, 2);
	const bias = [0.35, 0.6];
	let sampleList = [
		[[0.05, 0.1], [0.01, 0.99]]
	];
	setData(test, [[[0.15, 0.2],[0.25,0.3]],[[0.4,0.45],[0.5,0.55]]]);
	runData(test, bias, sampleList);
}();

void function(){
	let test = createNet(2, 2, 1);
	const bias = [0.35, 0.6];
	let sampleList = [
		[[0.1, 0.1], [0.0002]],
		[[0.1, 1], [1]],
		[[1, 0.1], [1]],
		[[1, 1], [0.00002]],
	];
	setData(test, [[[0.2, 0.8],[-0.5,-0.2]],[[0.23,0.26]]]);
	runData(test, bias, sampleList, 1000000);
}();


/*
这里介绍的是计算完一条记录，就马上更新权重，以后每计算完一条都即时更新权重。
实际上批量更新的效果会更好，方法是在不更新权重的情况下，把记录集的每条记录都算过一遍，
把要更新的增值全部累加起来求平均值，然后利用这个平均值来更新一次权重，
然后利用更新后的权重进行下一轮的计算，这种方法叫批量梯度下降(Batch Gradient Descent)。
*/




return;

let sample = [
	[[0, 0], [0]],
	[[0, 1], [1]],
	[[1, 0], [1]],
	[[1, 1], [0]],
];

const runSample = net => console.log(sample.map(v => calcNet(net, v[0])));

//cost = T.sum((y-y_hat)**2) #采用的是平方损失函数
//cost = - (y_hat*T.log(y)+(1-y_hat)*T.log(1-y)).sum() #采用交叉熵损失函数

function testRun(net){
	const target = sample.map(v => v[1]);
	let result = sample.map(v => calcNet(net, v[0]));
	let error = 0.5 * target.reduce((acc, v, i) => acc + (v - result[i]) ** 2, 0);
	console.log(target, result, error)
}

let and = [-3, 2, 2];
let or = [-1, 2, 2];
let not_or = [1, -2, -2];

/*
let testA = createNet(2,1);
setData(testA, [[and]])
//console.log('testA',testA)
runSample(testA);
setData(testA, [[or]])
runSample(testA);
setData(testA, [[not_or]])
runSample(testA);
*/
let testB = createNet(2, 2, 1);
setData(testB, [[and, not_or],[or]])
runSample(testB);

//testRun(testB);

void function(){


	

	const none = v => v;
	const sigmod = v => 1 / (1 + Math.exp(-v));

	const sum = v => v.reduce((a, b) => a + b, 0);
	const last = (v, i=1) => v[v.length-i];

	function calcLayer(input, layer, bias, func=none){
		return layer.map(node => calcNode(input, node) + bias).map(func);
	}

	function calcNode(input, node){
		return sum(node.map((v, i) => v * input[i]));
	}

	function calcNet(input, layerList){
		return layerList.reduce((r, v) => {
			r.push(calcLayer(last(r), ...v));
			return r;
		}, [input]);
	}

	function calcTotalError(actual, expect){
		return sum(expect.map((v, i) => 0.5 * Math.pow(v - actual[i], 2)));
	}

	function calcOutputLayerDelta(value, expect){
		return value.map((v, i) => (v - expect[i]) * v * (1 - v));
	}

	function calcHiddenLayerDelta(value, prevDelta, layer){
		let fn = index => sum(prevDelta.map((v, i) => v * layer[i][index]))
		return value.map((v, i) => fn(i) * v * (1 - v));
	}

	function updateLayerList(layerList, adjust, studyRate=0.5){
		layerList[0] = layerList[0].map((list, i) => list.map(v => v - studyRate * adjust[i]));
	}

	function calcWeight(delta, result){
		return delta.map((v, i) => v * result[i]);
	}

	function* reverseCalcNet(output, layerList, result){
		let value = calcOutputLayerDelta(last(result), output);
		yield value;
		for(let i=layerList.length-1; i>0; --i){
			value = calcHiddenLayerDelta(result[i], value, layerList[i][0]);
			yield value;
		}
	}

	void function(){
		let layerList = [
			[[[0.15, 0.2],[0.25, 0.3]], 0.35, sigmod],
			[[[0.4, 0.45],[0.5, 0.55]], 0.6 , sigmod]
		];

		let input = [0.05, 0.1];
		let output = [0.01, 0.99];

		let actual;

		//9999 [ 0.016003651858419662, 0.9840749495728799 ] 0.00003557502910051099
		for(let i=0; i<10000; ++i){
			let result = calcNet(input, layerList);
			actual = last(result);
			
			let layerDeltaList = Array.from(reverseCalcNet(output, layerList, result))
			layerDeltaList = layerDeltaList.reverse().map((v, i) => calcWeight(v, result[i]));
			layerList.forEach((v, i) => updateLayerList(v, layerDeltaList[i]));
		}

		console.log(actual, calcTotalError(actual, output));
		
	}();


}