
const sigmod = z => 1 / (1 + Math.E ** -z);
const isNumber = v => typeof v === 'number';
const calc = (a, b) => b[0] + a.reduce((sum, v, i) => sum + v * b[i+1], 0);
//const calcNet = (net, input) => net.reduce((input, layer) => layer.map(v => sigmod(calc(input, v))), input);
const createNet = (...shape) => shape.slice(1).map((n, i) => Array(n).fill().map(_ => Array(shape[i]+1).fill(0)));

function calcNet(net, input){
	let result = [input];
	for(let layer of net){
		input = layer.map(v => calc(input, v));
		result.push(input);
		input = input.map(sigmod);
	}
	return input;
}

function setData(net, values){
	for(let i=0; i<net.length; ++i){
		for(let j=0; j<net[i].length; ++j){
			let a = net[i][j];
			let b = values[i][j];
			if(a.length !== b.length){
				console.error('shape size error!');
				continue;
			}
			if(!(a.every(isNumber) && b.every(isNumber))){
				console.error('value must be number!');
				continue;
			}
			for(let k=a.length-1; k>=0; --k){
				a[k] = b[k];
			}
		}
	}
}



let sample = [
	[[0, 0], [0]],
	[[0, 1], [1]],
	[[1, 0], [1]],
	[[1, 1], [0]],
];

const runSample = net => console.log(sample.map(v => calcNet(net, v[0])));

//cost = T.sum((y-y_hat)**2) #采用的是平方损失函数
//cost = - (y_hat*T.log(y)+(1-y_hat)*T.log(1-y)).sum() #采用交叉熵损失函数

function testRun(net){
	const target = sample.map(v => v[1]);
	let result = sample.map(v => calcNet(net, v[0]));
	let error = 0.5 * target.reduce((acc, v, i) => acc + (v - result[i]) ** 2, 0);
	console.log(target, result, error)
}

let and = [-3, 2, 2];
let or = [-1, 2, 2];
let not_or = [1, -2, -2];

/*
let testA = createNet(2,1);
setData(testA, [[and]])
//console.log('testA',testA)
runSample(testA);
setData(testA, [[or]])
runSample(testA);
setData(testA, [[not_or]])
runSample(testA);
*/
let testB = createNet(2, 2, 1);
setData(testB, [[and, not_or],[or]])
runSample(testB);

//testRun(testB);