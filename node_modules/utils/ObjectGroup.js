"use strict";

const assert = require("assert");
const ObjectCache = require("./ObjectCache");

const arrayCache = new ObjectCache(Array, v => v.length = 0);
const mapCache = new ObjectCache(Map, v => v.clear());

class ObjectGroup
{
	constructor(groupFnList, updateFnList){
		this.groupFnList = groupFnList;
		this.updateFnList = updateFnList;
		this.deferFnList = [];
		this.context = Object.create(null);
	}

	group(objectList){
		arrayCache.putAllIn();
		mapCache.putAllIn();
		this.root = this._group(objectList);
	}

	update(...args){
		this._update(this.root, 0, args);
	}

	_group(objectList, fnIndex=0){
		let fn = this.groupFnList[fnIndex++];
		let dict = mapCache.getOut();
		for(let object of objectList){
			let key = fn(object);
			if(!dict.has(key)){
				dict.set(key, arrayCache.getOut());
			}
			dict.get(key).push(object);
		}
		if(fnIndex < this.groupFnList.length){
			for(let [k, v] of dict){
				dict.set(k, this._group(v, fnIndex));
			}
		}
		return dict;
	}

	_update(dict, fnIndex, args){
		let {deferFnList} = this;
		let fn = this.updateFnList[fnIndex];
		if(fnIndex < this.groupFnList.length){
			for(let [k, v] of dict){
				deferFnList.push(fn);
				this._update(v, fnIndex+1, args);
			}
		}else{
			let {context} = this;
			let v = dict[0];
			while(deferFnList.length > 0)
				deferFnList.shift().call(context, v, ...args);
			fn.call(context, dict, ...args);
		}
	}
}

module.exports = ObjectGroup;