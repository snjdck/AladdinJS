"use strict";

const assert = require("assert");
const ObjectCache = require("./ObjectCache");

const arrayCache = new ObjectCache(() => [], v => v.length = 0);
const mapCache = new ObjectCache(() => new Map(), v => v.clear());

class ObjectGroup
{
	constructor(){
		this.groupRuleList = [];
		this.deferCallList = [];
	}

	addGroupRule(groupRule){
		this.groupRuleList.push(groupRule);
	}

	group(objectList){
		arrayCache.putAllIn();
		mapCache.putAllIn();
		this.root = this._group(objectList);
	}

	update(handler){
		this._update(this.root, 0, handler);
	}

	_group(objectList, level=0){
		let {groupRuleList} = this;
		let groupRule = groupRuleList[level++];
		let dict = mapCache.getOut();
		for(let object of objectList){
			let key = groupRule.calcKey(object);
			if(!dict.has(key)){
				dict.set(key, arrayCache.getOut());
			}
			dict.get(key).push(object);
		}
		if(level < groupRuleList.length){
			for(let [k, v] of dict){
				dict.set(k, this._group(v, level));
			}
		}
		return dict;
	}

	_update(dict, level, handler){
		let {groupRuleList, deferCallList} = this;
		if(level < groupRuleList.length){
			let groupRule = groupRuleList[level++];
			let values = groupRule.sort ? groupRule.sort(Array.from(dict.keys())).map(dict.get, dict) : dict.values();
			for(let v of values){
				deferCallList.push(groupRule);
				this._update(v, level, handler);
			}
		}else{
			let v = dict[0];
			while(deferCallList.length > 0)
				deferCallList.shift().active(v);
			handler(dict);
		}
	}
}

module.exports = ObjectGroup;