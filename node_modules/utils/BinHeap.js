"use strict";

const defaultCompareFn = (p, c) => p > c;

class BinHeap{
	constructor(compareFn){
		this.compareFn = compareFn || defaultCompareFn;
		this.list = [];
	}

	push(item){
		const {list} = this;
		let index = list.length;
		list[index] = item;
		this.bubbleUp(index);
	}

	shift(){
		const {list} = this;
		if(list.length <= 2){
			return list.shift();
		}
		let item = list[0];
		list[0] = list.pop();
		this.bubbleDown(0);
		return item;
	}

	update(item){
		const {list} = this;
		let index = list.indexOf(item);
		if(index >= 0){
			this.bubbleDown(index);
			this.bubbleUp(index);
		}
	}

	bubbleUp(fromIndex){
		let childIndex = fromIndex;
		while(childIndex > 0){
			let parentIndex = (childIndex - 1) >> 1;
			if(!this.needSwap(parentIndex, childIndex)){
				break;
			}
			this.swapAt(childIndex, parentIndex);
			childIndex = parentIndex;
		}
	}

	bubbleDown(fromIndex){
		const maxLength = this.list.length;
		let parentIndex = fromIndex;
		for(;;){
			let leftChildIndex = (parentIndex << 1) + 1;
			if(leftChildIndex >= maxLength){
				break;
			}
			let rightChildIndex = leftChildIndex + 1;
			let childIndex = ((rightChildIndex < maxLength) && this.needSwap(leftChildIndex, rightChildIndex)) ? rightChildIndex : leftChildIndex;
			if(!this.needSwap(parentIndex, childIndex)){
				break;
			}
			this.swapAt(parentIndex, childIndex);
			parentIndex = childIndex;
		}
	}

	needSwap(parentIndex, childIndex){
		const {list} = this;
		return this.compareFn(list[parentIndex], list[childIndex]);
	}

	swapAt(index1, index2){
		const {list} = this;
		let value = list[index1];
		list[index1] = list[index2];
		list[index2] = value;
	}

	clear(){
		this.list.length = 0;
	}

	isEmpty(){
		return this.list.length == 0;
	}

	has(item){
		return this.list.includes(item);
	}

	toString(){
		return this.list.toString();
	}
}

module.exports = BinHeap;