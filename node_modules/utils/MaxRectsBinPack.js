'use strict';

class MaxRectsBinPack
{
	constructor(width, height){
		this.defaultRect = new Rect(width, height);
		this.freeRectList = [this.defaultRect];
	}

	clear(){
		this.freeRectList.length = 1;
		this.freeRectList[0] = this.defaultRect;
	}

	insert(width, height){
		const freeRect = findBestFreeRect(this.freeRectList, width, height);
		if(!freeRect)return;
		const rect = freeRect.clone();
		rect.width = width;
		rect.height = height;
		splitFreeRects(this.freeRectList, rect);
		pruneFreeList(this.freeRectList);
		return rect;
	}
}

function findBestFreeRect(freeRectList, width, height){
	let bestAreaFit = Infinity;
	let bestShortSideFit;
	let bestFreeRect;

	for(let freeRect of freeRectList){
		if(freeRect.width < width || freeRect.height < height)continue;
		const areaFit = freeRect.width * freeRect.height;
		const shortSideFit = Math.min(freeRect.width - width, freeRect.height - height);
		if(areaFit < bestAreaFit || areaFit == bestAreaFit && shortSideFit < bestShortSideFit){
			bestAreaFit = areaFit;
			bestShortSideFit = shortSideFit;
			bestFreeRect = freeRect;
		}
	}

	return bestFreeRect;
}

function splitFreeRects(freeRectList, usedRect){
	for(let i=freeRectList.length-1; i>=0; --i){
		const freeRect = freeRectList[i];
		if(freeRect.notIntersect(usedRect))continue;
		
		freeRectList.splice(i, 1);
		
		if(usedRect.y > freeRect.y){
			let newNode = freeRect.clone();
			newNode.bottom = usedRect.y;
			freeRectList.push(newNode);
		}

		if(usedRect.x > freeRect.x){
			let newNode = freeRect.clone();
			newNode.right = usedRect.x;
			freeRectList.push(newNode);
		}
		
		if(usedRect.bottom < freeRect.bottom){
			let newNode = freeRect.clone();
			newNode.y = usedRect.bottom;
			newNode.bottom = freeRect.bottom;
			freeRectList.push(newNode);
		}
		
		if(usedRect.right < freeRect.right){
			let newNode = freeRect.clone();
			newNode.x = usedRect.right;
			newNode.right = freeRect.right;
			freeRectList.push(newNode);
		}
	}
}

/** 修剪自由列表 */
function pruneFreeList(rectList){
	for(let i=rectList.length-1; i>0; --i){
		const a = rectList[i];
		for(let j=i-1; j>=0; --j){
			const b = rectList[j];
			if(b.contains(a)){
				rectList.splice(i, 1);
				break;
			}
			if(a.contains(b)){
				rectList.splice(j, 1);
				--i;
			}
		}
	}
}

class Rect
{
	static Merge(rectList){
		if(rectList.length <= 0)return null;
		const result = rectList[0].clone();
		for(let i=1, n=rectList.length; i<n; ++i)
			result.merge(rectList[i]);
		return result;
	}

	constructor(width, height, x=0, y=0){
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}

	clone(){
		return new Rect(this.width, this.height, this.x, this.y);
	}

	get left(){
		return this.x;
	}

	set left(value){
		this.width += this.x - value;
		this.x = value;
	}

	get right(){
		return this.x + this.width;
	}

	set right(value){
		this.width = value - this.x;
	}

	get top(){
		return this.y;
	}

	set top(value){
		this.height += this.y - value;
		this.y = value;
	}

	get bottom(){
		return this.y + this.height;
	}

	set bottom(value){
		this.height = value - this.y;
	}

	contains(other){
		return other.x >= this.x && other.right <= this.right
			&& other.y >= this.y && other.bottom <= this.bottom;
	}

	notIntersect(other){
		return other.x >= this.right || other.y >= this.bottom
			|| other.right <= this.x || other.bottom <= this.y;
	}

	merge(other){
		const x = Math.min(this.x, other.x);
		const y = Math.min(this.y, other.y);
		const right = Math.max(this.right, other.right);
		const bottom = Math.max(this.bottom, other.bottom);
		this.x = x;
		this.y = y;
		this.width = right - x;
		this.height = bottom - y;
		return this;
	}

	intersect(other){
		const x = Math.max(this.x, other.x);
		const y = Math.max(this.y, other.y);
		const right = Math.min(this.right, other.right);
		const bottom = Math.min(this.bottom, other.bottom);
		if(right <= x || bottom <= y)return null;
		this.x = x;
		this.y = y;
		this.width = right - x;
		this.height = bottom - y;
		return this;
	}
}

exports.MaxRectsBinPack = MaxRectsBinPack;
exports.Rect = Rect;
