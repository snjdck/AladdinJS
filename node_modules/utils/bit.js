
function cast2(byteList, bitCountPerByte, bitOffset=0){
	const threshold = 1 << bitCountPerByte;
	const binList = byteList.map(v => {
		if(v >= threshold)
			return v.toString(2).slice(-bitCountPerByte);
		return v.toString(2).padStart(bitCountPerByte, '0');
	});
	let string = binList.join('');
	if(bitOffset > 0){
		string = '0'.repeat(bitOffset) + string;
	}
	const count = Math.ceil(string.length / 8);
	string = string.padEnd(count << 3, '0');
	let data = Array(count);
	for(let i=0; i<count; ++i){
		data[i] = parseInt(string.substr(i << 3, 8), 2);
	}
	return data;
}

function cast(byteList, bitCountPerByte, bitOffset=0){
	const w = byteList.length;
	const h = bitCountPerByte;
	const mask = (1 << h) - 1;

	const data = new Uint8Array(Math.ceil((w * h + bitOffset) / 8));

	for(let i=0, offset=bitOffset; i<w; ++i, offset+=h){
		const size = 8 - offset % 8;
		const index = Math.floor(offset / 8);
		const value = byteList[i] & mask;
		const diff = size - h;
		if(diff >= 0){
			data[index] |= value << diff;
		}else{
			data[index] |= value >> -diff;
			data[index+1] = value << diff + 8;
		}
	}
	
	return data;
}
/*
function* gen(){
	for(let i=0; i< 100; ++i){
		yield [[Math.round(Math.random() * 1000),Math.round(Math.random() * 1000),Math.round(Math.random() * 1000),Math.round(Math.random() * 1000),Math.round(Math.random() * 1000)], Math.floor(Math.random() * 7) + 1]
	}
}

for(let [a, b] of [
	[[1,2,3,4], 2],
	[[1,2,3,4], 3],
	[[89,2,4,78,9,2], 6],
	...gen()
]){
	//console.log('-----', cast(a, b), cast2(a, b))
	if(cast(a, b, 3).join('#') != cast2(a, b, 3).join('#')){
		console.log('error', a, b, cast(a, b, 3), cast2(a, b, 3))
	}
}
//*/


exports.cast = cast;