
function cast2(byteList, bitCountPerByte, bitOffset=0){
	const threshold = 1 << bitCountPerByte;
	const binList = byteList.map(v => {
		if(v >= threshold)
			return v.toString(2).slice(-bitCountPerByte);
		return v.toString(2).padStart(bitCountPerByte, '0');
	});
	let string = binList.join('');
	console.log(binList.join('-'))
	if(bitOffset > 0){
		string = '0'.repeat(bitOffset) + string;
	}
	const count = Math.ceil(string.length / 8);
	string = string.padEnd(count << 3, '0');
	let data = Array(count);
	for(let i=0; i<count; ++i){
		data[i] = parseInt(string.substr(i << 3, 8), 2);
	}
	return data;
}

function compress(byteList, bitCountPerByte, bitOffset=0){
	const w = byteList.length;
	const h = bitCountPerByte;
	const mask = (1 << h) - 1;

	const data = new Uint8Array(calcSize(w, h, bitOffset));

	for(let i=0, offset=bitOffset; i<w; ++i, offset+=h){
		const size = 8 - offset % 8;
		const index = Math.floor(offset / 8);
		const diff = size - h;
		const value = byteList[i] & mask;
		console.assert(
			byteList[i] <= mask,
			'%d at %d is greater than %d, bit width: %d',
			byteList[i], i, mask, bitCountPerByte
		);
		if(diff >= 0){
			data[index] |= value << diff;
		}else{
			data[index] |= value >> -diff;
			data[index+1] = value << diff + 8;
		}
	}
	
	return data;
}

function uncompress(byteList, bitCountPerByte, bitOffset=0){
	const w = Math.floor((byteList.length * 8 - bitOffset) / bitCountPerByte);
	const h = bitCountPerByte;
	const mask = (1 << h) - 1;

	const data = new Uint8Array(w);

	for(let i=0, offset=bitOffset; i<w; ++i, offset+=h){
		const size = 8 - offset % 8;
		const index = Math.floor(offset / 8);
		const diff = size - h;
		let value;
		if(diff >= 0){
			value = byteList[index] >> diff;
		}else{
			value = byteList[index] << -diff | byteList[index+1] >> diff + 8;
		}
		data[i] = value & mask;
	}
	
	return data;
}

/**
0 -> 0
1    1
2    2
3    3
4    4
5    5
6    6
7    7
*/
function calcArea(byteList){
	const len = byteList.length;
	let x=0, y=0, w=len, h=8;
	for(let i=0; i<len; ++i){
		if(byteList[i])break;
		++x;
		--w;
	}
	for(let i=len-1; i>=0; --i){
		if(byteList[i])break;
		--w;
	}
	for(let i=0; i<8; ++i){
		const mask = 1 << i;
		if(byteList.some(v => v & mask))break;
		++y;
		--h;
	}
	for(let i=7; i>=0; --i){
		const mask = 1 << i;
		if(byteList.some(v => v & mask))break;
		--h;
	}
	return {x, y, w, h};
}

const calcSize = (w, h, offset=0) => Math.ceil((w * h + offset) / 8);
const cutMargin = (byteList, area) => byteList.slice(area.x, area.x + area.w).map(v => v >> area.y);

exports.compress = compress;
exports.uncompress = uncompress;
exports.cutMargin = cutMargin;
exports.calcArea = calcArea;
exports.calcSize = calcSize;
