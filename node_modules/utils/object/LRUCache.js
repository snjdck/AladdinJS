/*
const LRUCache = (capacity, onDelete) => {
	const map = new Map();
	return (k, v) => {
		if(v === undefined){//get
			if(!map.has(k))return;
			v = map.get(k);
			map.delete(k);
			map.set(k, v);
			return v;
		}else{//set
			if(map.has(k)){
				map.delete(k);
			}else if(map.size >= capacity){
				const t = map.keys().next().value;
				onDelete?.(t, map.get(t));
				map.delete(t);
			}
			map.set(k, v);
		}
	};
}

const LRUCache = (lifetime, newFn) => {
	const map = new Map();
	return key => {
		const now = performance.now();
		let value;
		if(map.has(key)){
			value = map.get(key);
			map.delete(key);
		}else{
			value = newFn(key);
		}
		for(let k of map.keys()){
			let v = map.get(k);
			if(v.timestamp > now)break;
			map.delete(k);
			v.onDestroy?.();
		}
		map.set(key, value);
		value.timestamp = now + lifetime;
		return value;
	};
}
*/
const LRUCache = (lifetime, newFn) => {
	const {timeline} = document;
	const map = new Map();
	const timeMap = new WeakMap();
	let timestamp = 0;
	return (key, ...args) => {
		const now = timeline.currentTime;
		if(now > timestamp){
			timestamp = now + lifetime;
			const threshold = now - lifetime;
			for(let k of map.keys()){
				let v = map.get(k);
				if(timeMap.get(v) > threshold)continue;
				map.delete(k);
				v.destroy();
			}
		}
		let value;
		if(map.has(key)){
			value = map.get(key);
		}else{
			value = newFn(key, ...args);
			map.set(key, value);
		}
		timeMap.set(value, now);
		return value;
	};
}

exports.LRUCache = LRUCache;
