/*
const LRUCache = (capacity, onDelete) => {
	const map = new Map();
	return (k, v) => {
		if(v === undefined){//get
			if(!map.has(k))return;
			v = map.get(k);
			map.delete(k);
			map.set(k, v);
			return v;
		}else{//set
			if(map.has(k)){
				map.delete(k);
			}else if(map.size >= capacity){
				const t = map.keys().next().value;
				onDelete?.(t, map.get(t));
				map.delete(t);
			}
			map.set(k, v);
		}
	};
}

const LRUCache = (lifetime, newFn) => {
	const map = new Map();
	return key => {
		const now = performance.now();
		let value;
		if(map.has(key)){
			value = map.get(key);
			map.delete(key);
		}else{
			value = newFn(key);
		}
		for(let k of map.keys()){
			let v = map.get(k);
			if(v.timestamp > now)break;
			map.delete(k);
			v.onDestroy?.();
		}
		map.set(key, value);
		value.timestamp = now + lifetime;
		return value;
	};
}
*/

const {intervalCall} = require('../function/intervalCall');

const LRUCache = (lifetime, newFn) => {
	const {timeline} = document;
	const map = new Map();
	const timeMap = new WeakMap();
	const gc = intervalCall(function(){
		const threshold = timeline.currentTime - lifetime;
		for(let k of map.keys()){
			let v = map.get(k);
			if(timeMap.get(v) > threshold)continue;
			map.delete(k);
			v.destroy();
		}
	}, lifetime);
	return (key, ...args) => {
		gc();
		let value;
		if(map.has(key)){
			value = map.get(key);
		}else{
			value = newFn(key, ...args);
			map.set(key, value);
		}
		timeMap.set(value, timeline.currentTime);
		return value;
	};
}

exports.LRUCache = LRUCache;
