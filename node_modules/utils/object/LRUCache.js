/*
const LRUCache = (capacity, onDelete) => {
	const map = new Map();
	return (k, v) => {
		if(v === undefined){//get
			if(!map.has(k))return;
			v = map.get(k);
			map.delete(k);
			map.set(k, v);
			return v;
		}else{//set
			if(map.has(k)){
				map.delete(k);
			}else if(map.size >= capacity){
				const t = map.keys().next().value;
				onDelete?.(t, map.get(t));
				map.delete(t);
			}
			map.set(k, v);
		}
	};
}
*/
const LRUCache = (lifetime, newFn) => {
	const map = new Map();
	return key => {
		const now = performance.now();
		let value;
		if(map.has(key)){
			value = map.get(key);
			map.delete(key);
		}else{
			value = newFn(key);
		}
		for(let k of map.keys()){
			let v = map.get(k);
			if(v.timestamp > now)break;
			map.delete(k);
			v.onDestroy?.();
		}
		map.set(key, value);
		value.timestamp = now + lifetime;
		return value;
	};
}

exports.LRUCache = LRUCache;
