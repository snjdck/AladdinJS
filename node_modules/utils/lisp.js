

const exec = function(){
	const parseString = function(){
		const pattern = /[^\s'()]+/g;
		return function(input, result=[]){
			for(let i=0; i<input.length; ++i){
				let char = input.charAt(i);
				switch(char){
					case '(':
					case ')':
					case "'":
						result.push(char);
					case ' ':
					case '\t':
					case '\r':
					case '\n':
						break;
					default:
						let info = pattern.exec(input);
						result.push(info[0]);
						i = info.index + info[0].length - 1;
				}
			}
			return result;
		}
	}();
	const expandQuote = function(){
		function findQuoteIndex(list, offset){
			let count = 0;
			for(let j=offset; j<list.length; ++j){
				switch(list[j]){
					case '(': ++count; break;
					case ')': --count; break;
				}
				if(count === 0) return j + 1;
			}
			return -1;
		}
		return function(list){
			for(let i=0; i<list.length; ++i){
				if(list[i] !== "'")continue;
				list.splice(findQuoteIndex(list, i + 1), 0, ')');
				list.splice(i, 1, '(', 'quote');
			}
			return list;
		}
	}();
	const buildTree = function(list, result=[]){
		let stack = [];
		let cursor = result;
		for(let i=0; i<list.length; ++i){
			switch(list[i]){
				case '(':
					stack.push(cursor);
					cursor = [];
					break;
				case ')':
					let parent = stack.pop();
					parent.push(cursor);
					cursor = parent;
					break;
				default:
					cursor.push(list[i]);
			}
		}
		return result;
	};
	return function(input, context={}){
		let list = buildTree(expandQuote(parseString(input)));
		list.forEach(v => _exec(v, context));
	};
}();

const _exec = function(tree, context){
	if(!Array.isArray(tree)){
		const num = Number(tree);
		return isNaN(num) ? context[tree] : num;
	}
	let name = tree[0];
	let fn = context[name] || builtins[name];
	if(fn instanceof Function){
		return fn.apply(context, tree.slice(1));
	}
};

const builtins = Object.create(null);
builtins.quote = v => v;
builtins.atom = function(v){
	let value = _exec(v, this);
	return (Array.isArray(value) && value.length > 0) ? [] : 't';
}
builtins.eq = function(a, b){
	let value1 = _exec(a, this);
	let value2 = _exec(b, this);
	if(Array.isArray(value1) != Array.isArray(value2))
		return [];
	if(!Array.isArray(value1))
		return value1 === value2 ? 't' : [];
	return value1.length === 0 && value2.length === 0 ? 't' : [];
}
builtins.car = function(v){
	return _exec(v, this)[0];
}
builtins.cdr = function(v){
	return _exec(v, this).slice(1);
}
builtins.cons = function(a, b){
	return [_exec(a, this), ..._exec(b, this)];
}
builtins.cond = function(...args){
	for(let [test, data] of args){
		if(_exec(test, this) === 't'){
			return _exec(data, this);
		}
	}
	return [];
}
builtins.defun = function(fnName, argNames, fnBody){
	let context = this;
	context[fnName] = function(...args){
		let newContext = Object.create(context);
		argNames.forEach((k, i) => newContext[k] = _exec(args[i], this));
		return _exec(fnBody, newContext);
	}
}

module.exports = {exec, _exec};
