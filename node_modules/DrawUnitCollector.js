"use strict";

class DrawUnitCollector
{
	constructor(){
		this.shaderDict = {};
		this.shaderDict["shader3d&normal"] = new Shader();
		this.shaderDict["shader3d&pick"] = new PickShader();
	}

	clear(){
		for(let shader in this.shaderDict){
			let drawer = this.shaderDict[shader];
			drawer.clear();
		}
	}

	addDrawUnit(drawUnit, mode){
		this.shaderDict[drawUnit.shader].addDrawUnit(drawUnit);
	}

	draw(gl, camera){
		for(let shader in this.shaderDict){
			let drawer = this.shaderDict[shader];
			drawer.render(camera, gl, shader);
		}
	}
}

class Drawer{
	constructor(){
		this.drawUnitList = [];
	}

	clear(){
		this.drawUnitList.length = 0;
	}

	addDrawUnit(drawUnit){
		this.drawUnitList.push(drawUnit);
	}

	render(camera, gl, shader){
		if(this.drawUnitList.length <= 0){
			return;
		}
		this.active(camera, gl, shader);
		for(let drawUnit of this.drawUnitList){
			this.draw(gl, drawUnit);
		}
	}
}

class Shader extends Drawer{
	state(gl, program){
		gl.enable(gl.DEPTH_TEST);
		gl.depthMask(true);
		gl.depthFunc(gl.LEQUAL);
		gl.enable(gl.BLEND);
	}

	active(camera, gl, shader){
		let program = gl.__program__[shader];
		gl.useProgram(program);

		let screenAddress = gl.getUniformLocation(program, "screenMatrix");
		gl.uniform3f(screenAddress, 2 / gl.drawingBufferWidth, 2 / gl.drawingBufferHeight, 2 / camera.zRange);

		let cameraAddress = gl.getUniformLocation(program, "cameraMatrix");
		gl.uniformMatrix4fv(cameraAddress, false, camera.worldTransformInvert);

		this.worldMatrixAddress = gl.getUniformLocation(program, "worldMatrix");
		gl.activeTexture(gl.TEXTURE0);
		gl.uniform1i(gl.getUniformLocation(program, "sampler0"), 0);

		this.state(gl, program);
	}

	draw(gl, {worldMatrix, vao, texture, indexCount, vertexCount}){
		const {worldMatrixAddress} = this;
		gl.uniformMatrix4fv(worldMatrixAddress, false, worldMatrix);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.bindVertexArray(vao);
		if(indexCount > 0){
			gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
		}else{
			gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
		}
	}
}

class PickShader extends Shader{
	state(gl, program){
		gl.enable(gl.DEPTH_TEST);
		gl.depthMask(true);
		gl.depthFunc(gl.LEQUAL);
		gl.disable(gl.BLEND);
		
		this.uidLocation = gl.getUniformLocation(program, "uid");
	}

	draw(gl, drawUnit){
		gl.uniform1i(this.uidLocation, drawUnit.uid);
		super.draw(gl, drawUnit);
	}
}

module.exports = DrawUnitCollector;