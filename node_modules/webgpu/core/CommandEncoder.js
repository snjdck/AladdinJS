/*
const submit = function(){
	const commandBufferList = [];
	function onSubmit(){
		this.submit(commandBufferList);
		commandBufferList.length = 0;
	}
	return (device, commandBuffer) => {
		if(commandBufferList.length == 0)queueMicrotask(onSubmit.bind(device.queue));
		commandBufferList.push(commandBuffer);
	}
}();
*/
const {GPUContext} = require('./GPUContext');

class CommandEncoderContext
{
	constructor(commandEncoder){
		this.commandEncoder = commandEncoder;
	}

	clearBuffer(buffer, offset, size){
		this.commandEncoder.clearBuffer(buffer, offset, size);
	}

	copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size){
		this.commandEncoder.copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size);
	}

	copyBufferToTexture(source, destination, copySize){
		this.commandEncoder.copyBufferToTexture(source, destination, copySize);
	}

	copyTextureToBuffer(source, destination, copySize){
		this.commandEncoder.copyTextureToBuffer(source, destination, copySize);
	}

	copyTextureToTexture(source, destination, copySize){
		this.commandEncoder.copyTextureToTexture(source, destination, copySize);
	}

	*beginComputePass(){
		const encoder = this.commandEncoder.beginComputePass();
		yield encoder;
		encoder.end();
	}

	*beginRenderPass(descText, ...textureViews){
		const desc = descCache(descText);
		const n = desc.colorAttachments.length;
		for(let i=0; i<n; ++i){
			desc.colorAttachments[i].view = textureViews[i];
		}
		if(desc.depthStencilAttachment){
			desc.depthStencilAttachment.view = textureViews[n];
		}
		const encoder = this.commandEncoder.beginRenderPass(desc);
		yield new GPUContext(encoder);
		encoder.end();
	}
}

const CommandEncoder = function*(device){
	const encoder = device.createCommandEncoder();
	yield new CommandEncoderContext(encoder);
	device.queue.submit([encoder.finish()]);
}

const createGetter = (newFn, hit=Object.create(null)) => k => k in hit ? hit[k] : (hit[k] = newFn(k));

const descCache = function(){
	const parseOp = v => {
		const [loadOp, storeOp] = v.split('+');
		return {
			loadOp: loadOp == 'load' ? 'load' : 'clear',
			clearValue: loadOp == 'load' ? undefined : JSON.parse(loadOp),
			storeOp,
		}
	}
	function parseDesc(desc){
		let colorAttachments, depthStencilAttachment;
		const [colors, depth, stencil] = desc.split(';');
		colorAttachments = colors ? colors.split(':').map(parseOp) : [];
		if(depth || stencil){
			depthStencilAttachment = {};
			if(depth == '+'){
				depthStencilAttachment.depthReadOnly = true;
			}else if(depth){
				let {loadOp, storeOp, clearValue} = parseOp(depth);
				depthStencilAttachment.depthLoadOp = loadOp;
				depthStencilAttachment.depthClearValue = clearValue;
				depthStencilAttachment.depthStoreOp = storeOp;
			}
			if(stencil == '+'){
				depthStencilAttachment.stencilReadOnly = true;
			}else if(stencil){
				let {loadOp, storeOp, clearValue} = parseOp(stencil);
				depthStencilAttachment.stencilLoadOp = loadOp;
				depthStencilAttachment.stencilClearValue = clearValue;
				depthStencilAttachment.stencilStoreOp = storeOp;
			}
		}
		return {colorAttachments, depthStencilAttachment};
	}
	return createGetter(parseDesc);
}();

exports.CommandEncoder = CommandEncoder;
