
const {fetchArrayBuffer, loadImage} = require('webonly/utils');
const {createMapGetter, createFetch} = require('utils/cache');
const {LRUCache, ObjectPool} = require('utils/gc');
const {nextPowerOf2} = require('utils/math');

class EncoderEx
{
	constructor(device, canvas){
		this.device = device;
		this.canvas = canvas;
	}

	importExternalTexture(desc){
		return this.device.importExternalTexture(desc);
	}

	createCommandEncoder(){
		return CommandEncoder(this.device, this.canvas);
	}

	copyExternalImageToTexture(source, destination, copySize){
		this.device.queue.copyExternalImageToTexture(source, destination, copySize);
	}

	writeTexture(destination, data, dataLayout, size){
		this.device.queue.writeTexture(destination, data, dataLayout, size);
	}

	writeBuffer(buffer, bufferOffset, data, dataOffset, size){
		this.device.queue.writeBuffer(buffer, bufferOffset, data, dataOffset, size);
	}

	async readBuffer(buffer, callback, offset, size){
		await buffer.mapAsync(GPUMapMode.READ, offset, size);
		callback(buffer.getMappedRange());
		buffer.unmap();
	}

	get width(){
		return this.canvas.width;
	}

	get height(){
		return this.canvas.height;
	}

	getCurrentTexture(){
		if(!swapChain){
			swapChain = this.canvas.getContext('webgpu');
			swapChain.configure({
				device: this.device,
				format: 'bgra8unorm',
				usage: GPUTextureUsage.COPY_DST,
				alphaMode: 'opaque',//premultiplied
				colorSpace: 'srgb',//display-p3
			});
		}
		return swapChain.getCurrentTexture();
	}
}

let swapChain;

EncoderEx.prototype.fetchTempTypedArray = function(){
	const newFn = type => {
		let value = new type(1024);
		return length => {
			if(value.length < length){
				value = new type(nextPowerOf2(length));
			}
			return value;
		}
	};
	const map = new Map();
	return (length, type=Float32Array) => {
		if(!map.has(type)){
			map.set(type, newFn(type));
		}
		return map.get(type)(length);
	};
}();

EncoderEx.prototype.fetchTempTexture = function(){
	const map = new Map();
	const queryFnMap = {
		'>=':function(v){return v.width >= this.width && v.height >= this.height;},
		'==':function(v){return v.width == this.width && v.height == this.height;},
	};
	return function(size, descText, findKey='==', newKey='=='){
		if(!map.has(descText)){
			map.set(descText, ObjectPool((size, newKey) => {
				const desc = TextureDescCache(descText);
				if(newKey != '>='){
					desc.size = size;
				}else if(Array.isArray(size)){
					desc.size = [nextPowerOf2(size[0]), nextPowerOf2(size[1] ?? 1), size[2]];
				}else{
					desc.size = {width: nextPowerOf2(size.width), height: nextPowerOf2(size.height ?? 1), depthOrArrayLayers: size.depthOrArrayLayers};
				}
				return this.device.createTexture(desc);
			}, queryFnMap));
		}
		return map.get(descText)(size, findKey, newKey);
	}
}();

EncoderEx.prototype.fetchTextureView = function(){
	const map = new WeakMap();
	return function(texture, descText){
		if(!map.has(texture)){
			map.set(texture, createGetter(text => texture.createView(TextureViewDescCache(text))));
		}
		return map.get(texture)(descText);
	}
}();

EncoderEx.prototype.fetchTempBuffer = function(){
	const map = new Map();
	const queryFnMap = {'>=':function(v){return v.size >= this;}}
	return function(size, usage){
		if(!map.has(usage)){
			map.set(usage, ObjectPool(size => this.device.createBuffer({usage, size:nextPowerOf2(size)}), queryFnMap));
		}
		return map.get(usage)(size, '>=');
	}
}();

EncoderEx.prototype.fetchBufferBy = createMapGetter(function(data, usage){
	const buffer = this.device.createBuffer({usage, size:data.byteLength, mappedAtCreation:true});
	const mapping = buffer.getMappedRange();
	new data.constructor(mapping).set(data);
	buffer.unmap();
	return buffer;
}, null, LRUCache(1000));

EncoderEx.prototype.fetchAnimationTexture = createMapGetter(function(mesh){
	const width = Math.max(...mesh.animationList.map(v => v.keyFrameTimes.length)) * 2;
	const height = mesh.boneList.at(-1).id + 1;
	const depthOrArrayLayers = mesh.animationList.length;
	const data = new Float32Array(width * height * depthOrArrayLayers * 4);
	for(let k=0; k<depthOrArrayLayers; ++k){
		const animation = mesh.animationList[k];
		for(let j=0; j<height; ++j){
			const matrixList = animation.trackDict[j];
			if(!matrixList)continue;
			const parentBoneID = mesh.boneList.find(v => v.id == j).parent?.id ?? -1;
			for(let i=0; i<width; i+=2){
				const matrix = matrixList[i >> 1];
				if(!matrix)continue;
				const {rotation, translation} = matrix;
				const offset = (width * (height * k + j) + i) * 4;
				data[offset  ] = rotation.x;
				data[offset+1] = rotation.y;
				data[offset+2] = rotation.z;
				data[offset+3] = rotation.w;
				data[offset+4] = translation.x;
				data[offset+5] = translation.y;
				data[offset+6] = translation.z;
				data[offset+7] = parentBoneID;
			}
		}
	}
	const texture = this.device.createTexture({size: [width, height, depthOrArrayLayers], format: 'rgba32float', usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST});
	this.writeTexture({texture}, data, {bytesPerRow:width*16, rowsPerImage:height}, texture);
	return {
		textureView: texture.createView({dimension:'2d-array'}),
		destroy(){texture.destroy();}
	};
}, null, LRUCache(1000));

EncoderEx.prototype.loadTexture = function(){
	function loadTexture(device, image){
		const texture = device.createTexture({
			format: 'bgra8unorm',
			size: [image.width, image.height],
			usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
		});
		device.queue.copyExternalImageToTexture(
			{source:image, origin:[0,0], flipY:false},
			{texture, origin:[0,0,0], mipLevel:0, aspect:'all', colorSpace:'srgb', premultipliedAlpha:false},
			[image.width, image.height, 1]
		);
		return texture;
	}
	function loadTextureTga(device, arrayBuffer){
		const ba = new Uint8Array(arrayBuffer);
		/*--head begin--*/
		const imageInfoSize = ba.readUInt8(0);
		const hasColorTable = ba.readUInt8(1);
		const imageType = ba.readUInt8(2);
		//const colorTableStart = ba.readUInt16LE(3);
		//const colorTableLength = ba.readUInt16LE(5);
		//const colorTableDepth = ba.readUInt8(7);
		const px = ba.readUInt16LE(8);
		const py = ba.readUInt16LE(10);
		const width = ba.readUInt16LE(12);
		const height = ba.readUInt16LE(14);
		const bitPerPixel = ba.readUInt8(16);//8, 16, 24, 32
		const flags = ba.readUInt8(17);
		/*--head end--*/
		
		const right2left = ((flags >> 4) & 1) == 1;
		const bottom2top = ((flags >> 5) & 1) == 0;

		console.assert(!right2left && bottom2top && !hasColorTable && bitPerPixel == 32 && imageType == 2 && px == 0 && py == 0);
		console.assert(18 + imageInfoSize + width * height * 4 + 26 == ba.length);

		const imageOffset = 18 + imageInfoSize;
		const bytesPerRow = width << 2;
		const imageData = new Uint8Array(bytesPerRow * height);
		for(let i=0; i<height; ++i){
			imageData.set(ba.subarray(imageOffset + bytesPerRow * i, imageOffset + bytesPerRow * (i + 1)), bytesPerRow * (height - 1 - i));
		}
		const texture = device.createTexture({
			format: 'bgra8unorm',
			size: [width, height],
			usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
		});
		device.queue.writeTexture(
			{texture, origin:[0,0,0], mipLevel:0, aspect:'all'},
			imageData,
			{offset:0, bytesPerRow, rowsPerImage:undefined},
			[width, height, 1]
		);
		return texture;
	}
	function createColorTexture(device, color){
		if(color.length == 3)color.push(0xFF);
		const texture = device.createTexture({format: 'bgra8unorm', size: [1, 1], usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST});
		device.queue.writeTexture({texture}, new Uint8Array(color), {}, texture);
		return texture;
	}
	const colorPattern = 'color://';
	return createFetch(async function(path){
		if(path.startsWith(colorPattern)){
			return createColorTexture(this.device, JSON.parse(path.slice(colorPattern.length)));
		}
		if(path.toLowerCase().endsWith('.tga')){
			return loadTextureTga(this.device, await fetchArrayBuffer(path));
		}
		return loadTexture(this.device, await loadImage(path));
	}, LRUCache(30 * 1000));
}();

class RenderPassEncoderEx extends EncoderEx
{
	constructor(encoder, device, canvas){
		super(device, canvas);
		this.encoder = encoder;
		this.pipeline = null;
		this.resourcesQueue = [];
		this.index = null;
	}

	setPipeline(pipeline){
		if(this.pipeline == pipeline)return;
		this.encoder.setPipeline(pipeline.getRawValue(this.device));
		if(this.pipeline == null){
			for(let resources of this.resourcesQueue){
				pipeline.setResources(this, resources);
			}
		}
		this.pipeline = pipeline;
	}

	setResources(resources){
		const {pipeline} = this;
		if(pipeline){
			pipeline.setResources(this, resources);
		}else{
			this.resourcesQueue.push(resources);
		}
		this.index = resources.index ?? this.index;
	}

	setViewportWH(width, height){
		this.encoder.setViewport(0, 0, width, height, 0, 1);
	}

	setViewportToCanvas(){
		const {width, height} = this.canvas;
		this.encoder.setViewport(0, 0, width, height, 0, 1);
	}

	drawIndexedAuto(instanceCount=1, firstInstance=0){
		this.encoder.drawIndexed(this.index.length, instanceCount, 0, 0, firstInstance);
	}

	draw(vertexCount, instanceCount=1, firstVertex=0, firstInstance=0){
		this.encoder.draw(vertexCount, instanceCount, firstVertex, firstInstance);
	}

	setVertexBuffer(slot, buffer, offset, size){
		this.encoder.setVertexBuffer(slot, buffer, offset, size);
	}

	setIndexBuffer(buffer, indexFormat, offset, size){
		this.encoder.setIndexBuffer(buffer, indexFormat, offset, size);
	}

	setBindGroup(index, bindGroup){
		this.encoder.setBindGroup(index, bindGroup);
	}

	drawQuad(){
		this.encoder.draw(4);
	}

	drawQuadWith(pipeline, resources){
		this.setPipeline(pipeline);
		this.setResources(resources);
		this.encoder.draw(4);
	}
/*
	drawIndexed(indexCount, instanceCount=1, firstIndex=0, baseVertex=0, firstInstance=0){
		this.encoder.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
	}

	setViewport(x, y, width, height, minDepth=0, maxDepth=1){
		this.encoder.setViewport(x, y, width, height, minDepth, maxDepth);
	}

	setBlendConstant(color){
		this.encoder.setBlendConstant(color);
	}

	setScissorRect(x, y, width, height){
		this.encoder.setScissorRect(x, y, width, height);
	}

	setStencilReference(reference){
		this.encoder.setStencilReference(reference);
	}
*/
}

class CommandEncoderEx extends EncoderEx
{
	constructor(encoder, device, canvas){
		super(device, canvas);
		this.encoder = encoder;
	}

	clearBuffer(buffer, offset, size){
		this.encoder.clearBuffer(buffer, offset, size);
	}

	copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size){
		this.encoder.copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size);
	}

	copyBufferToTexture(source, destination, copySize){
		this.encoder.copyBufferToTexture(source, destination, copySize);
	}

	copyTextureToBuffer(source, destination, copySize){
		this.encoder.copyTextureToBuffer(source, destination, copySize);
	}

	copyTextureToTexture(source, destination, copySize){
		this.encoder.copyTextureToTexture(source, destination, copySize);
	}

	*beginComputePass(){
		const encoder = this.encoder.beginComputePass();
		yield encoder;
		encoder.end();
	}

	*beginRenderPass(descText, ...textureViews){
		const desc = RenderPassDescCache(descText);
		const n = desc.colorAttachments.length;
		for(let i=0; i<n; ++i){
			desc.colorAttachments[i].view = textureViews[i];
		}
		if(desc.depthStencilAttachment){
			desc.depthStencilAttachment.view = textureViews[n];
		}
		const encoder = this.encoder.beginRenderPass(desc);
		yield new RenderPassEncoderEx(encoder, this.device, this.canvas);
		encoder.end();
	}
}

function* CommandEncoder(device, canvas){
	const encoder = device.createCommandEncoder();
	yield new CommandEncoderEx(encoder, device, canvas);
	device.queue.submit([encoder.finish()]);
}

const createGetter = (newFn, hit=Object.create(null)) => k => k in hit ? hit[k] : (hit[k] = newFn(k));

const RenderPassDescCache = function(){
	const parseOp = v => {
		const [loadOp, storeOp] = v.split('+');
		return {
			loadOp: loadOp == 'load' ? 'load' : 'clear',
			clearValue: loadOp == 'load' ? undefined : JSON.parse(loadOp),
			storeOp,
		}
	}
	function parseDesc(desc){
		let colorAttachments, depthStencilAttachment;
		const [colors, depth, stencil] = desc.split(';');
		colorAttachments = colors ? colors.split(':').map(parseOp) : [];
		if(depth || stencil){
			depthStencilAttachment = {};
			if(depth == '+'){
				depthStencilAttachment.depthReadOnly = true;
			}else if(depth){
				let {loadOp, storeOp, clearValue} = parseOp(depth);
				depthStencilAttachment.depthLoadOp = loadOp;
				depthStencilAttachment.depthClearValue = clearValue;
				depthStencilAttachment.depthStoreOp = storeOp;
			}
			if(stencil == '+'){
				depthStencilAttachment.stencilReadOnly = true;
			}else if(stencil){
				let {loadOp, storeOp, clearValue} = parseOp(stencil);
				depthStencilAttachment.stencilLoadOp = loadOp;
				depthStencilAttachment.stencilClearValue = clearValue;
				depthStencilAttachment.stencilStoreOp = storeOp;
			}
		}
		return {colorAttachments, depthStencilAttachment};
	}
	return createGetter(parseDesc);
}();

const TextureViewDescCache = function(){
	function parseDesc(desc){
		const [dimension, aspect, baseArrayLayer, arrayLayerCount, baseMipLevel, mipLevelCount] = desc.split(',');
		return {
			dimension: dimension || undefined,
			aspect: aspect || undefined,
			baseArrayLayer: parseInt(baseArrayLayer || 0),
			arrayLayerCount: arrayLayerCount ? parseInt(arrayLayerCount) : undefined,
			baseMipLevel: parseInt(baseMipLevel || 0),
			mipLevelCount: mipLevelCount ? parseInt(mipLevelCount) : undefined,
		}
	}
	return createGetter(parseDesc);
}();

const TextureDescCache = function(){
	function parseDesc(desc){
		const [dimension, format, usage, mipLevelCount] = desc.split(',');
		return {dimension, format, usage: parseInt(usage), mipLevelCount: parseInt(mipLevelCount)};
	}
	return createGetter(parseDesc);
}();

exports.CommandEncoder = CommandEncoder;
