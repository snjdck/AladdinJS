
class EncoderEx
{
	constructor(device){
		this.device = device;
	}

	importExternalTexture(desc){
		return this.device.importExternalTexture(desc);
	}

	createCommandEncoder(){
		return CommandEncoder(this.device);
	}

	copyExternalImageToTexture(source, destination, copySize){
		this.device.queue.copyExternalImageToTexture(source, destination, copySize);
	}

	writeTexture(destination, data, dataLayout, size){
		this.device.queue.writeTexture(destination, data, dataLayout, size);
	}

	writeBuffer(buffer, bufferOffset, data, dataOffset, size){
		this.device.queue.writeBuffer(buffer, bufferOffset, data, dataOffset, size);
	}

	async readBuffer(buffer, callback, offset, size){
		await buffer.mapAsync(GPUMapMode.READ, offset, size);
		callback(buffer.getMappedRange());
		buffer.unmap();
	}
}

class RenderPassEncoderEx extends EncoderEx
{
	constructor(encoder, device){
		super(device);
		this.encoder = encoder;
		this.pipeline = null;
		this.resourcesQueue = [];
		this.index = null;
	}

	setPipeline(pipeline){
		if(this.pipeline == pipeline)return;
		this.encoder.setPipeline(pipeline.getRawValue(this.device));
		if(this.pipeline == null){
			for(let resources of this.resourcesQueue){
				pipeline.setResources(this, resources);
			}
		}
		this.pipeline = pipeline;
	}

	setResources(resources){
		const {pipeline} = this;
		if(pipeline){
			pipeline.setResources(this, resources);
		}else{
			this.resourcesQueue.push(resources);
		}
		this.index = resources.index ?? this.index;
	}

	setViewportWH(width, height){
		this.encoder.setViewport(0, 0, width, height, 0, 1);
	}

	drawIndexedAuto(instanceCount=1, firstInstance=0){
		this.encoder.drawIndexed(this.index.length, instanceCount, 0, 0, firstInstance);
	}

	draw(vertexCount, instanceCount=1, firstVertex=0, firstInstance=0){
		this.encoder.draw(vertexCount, instanceCount, firstVertex, firstInstance);
	}

	drawQuad(){
		this.encoder.draw(4);
	}

	setVertexBuffer(slot, buffer, offset, size){
		this.encoder.setVertexBuffer(slot, buffer, offset, size);
	}

	setIndexBuffer(buffer, indexFormat, offset, size){
		this.encoder.setIndexBuffer(buffer, indexFormat, offset, size);
	}

	setBindGroup(index, bindGroup){
		this.encoder.setBindGroup(index, bindGroup);
	}
/*
	drawIndexed(indexCount, instanceCount=1, firstIndex=0, baseVertex=0, firstInstance=0){
		this.encoder.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
	}

	setViewport(x, y, width, height, minDepth=0, maxDepth=1){
		this.encoder.setViewport(x, y, width, height, minDepth, maxDepth);
	}

	setBlendConstant(color){
		this.encoder.setBlendConstant(color);
	}

	setScissorRect(x, y, width, height){
		this.encoder.setScissorRect(x, y, width, height);
	}

	setStencilReference(reference){
		this.encoder.setStencilReference(reference);
	}
*/
}

class CommandEncoderEx extends EncoderEx
{
	constructor(encoder, device){
		super(device);
		this.encoder = encoder;
	}

	clearBuffer(buffer, offset, size){
		this.encoder.clearBuffer(buffer, offset, size);
	}

	copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size){
		this.encoder.copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size);
	}

	copyBufferToTexture(source, destination, copySize){
		this.encoder.copyBufferToTexture(source, destination, copySize);
	}

	copyTextureToBuffer(source, destination, copySize){
		this.encoder.copyTextureToBuffer(source, destination, copySize);
	}

	copyTextureToTexture(source, destination, copySize){
		this.encoder.copyTextureToTexture(source, destination, copySize);
	}

	*beginComputePass(){
		const encoder = this.encoder.beginComputePass();
		yield encoder;
		encoder.end();
	}

	*beginRenderPass(descText, ...textureViews){
		const desc = descCache(descText);
		const n = desc.colorAttachments.length;
		for(let i=0; i<n; ++i){
			desc.colorAttachments[i].view = textureViews[i];
		}
		if(desc.depthStencilAttachment){
			desc.depthStencilAttachment.view = textureViews[n];
		}
		const encoder = this.encoder.beginRenderPass(desc);
		yield new RenderPassEncoderEx(encoder, this.device);
		encoder.end();
	}
}

function* CommandEncoder(device){
	const encoder = device.createCommandEncoder();
	yield new CommandEncoderEx(encoder, device);
	device.queue.submit([encoder.finish()]);
}

const createGetter = (newFn, hit=Object.create(null)) => k => k in hit ? hit[k] : (hit[k] = newFn(k));

const descCache = function(){
	const parseOp = v => {
		const [loadOp, storeOp] = v.split('+');
		return {
			loadOp: loadOp == 'load' ? 'load' : 'clear',
			clearValue: loadOp == 'load' ? undefined : JSON.parse(loadOp),
			storeOp,
		}
	}
	function parseDesc(desc){
		let colorAttachments, depthStencilAttachment;
		const [colors, depth, stencil] = desc.split(';');
		colorAttachments = colors ? colors.split(':').map(parseOp) : [];
		if(depth || stencil){
			depthStencilAttachment = {};
			if(depth == '+'){
				depthStencilAttachment.depthReadOnly = true;
			}else if(depth){
				let {loadOp, storeOp, clearValue} = parseOp(depth);
				depthStencilAttachment.depthLoadOp = loadOp;
				depthStencilAttachment.depthClearValue = clearValue;
				depthStencilAttachment.depthStoreOp = storeOp;
			}
			if(stencil == '+'){
				depthStencilAttachment.stencilReadOnly = true;
			}else if(stencil){
				let {loadOp, storeOp, clearValue} = parseOp(stencil);
				depthStencilAttachment.stencilLoadOp = loadOp;
				depthStencilAttachment.stencilClearValue = clearValue;
				depthStencilAttachment.stencilStoreOp = storeOp;
			}
		}
		return {colorAttachments, depthStencilAttachment};
	}
	return createGetter(parseDesc);
}();

exports.CommandEncoder = CommandEncoder;
