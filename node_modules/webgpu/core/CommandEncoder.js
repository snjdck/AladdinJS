
const {createMapGetter, createFetch} = require('utils/cache');
const {LRUCache, ObjectPool} = require('utils/gc');
const {nextPowerOf2} = require('utils/math');
const {initMesh} = require('../helper/MeshHelper');
const bmd = require('mu/bmd');
const obj = require('fileformats/models/obj');

class EncoderEx
{
	constructor(device, canvas, data){
		this.device = device;
		this.canvas = canvas;
		this.data = data;
	}

	importExternalTexture(desc){
		return this.device.importExternalTexture(desc);
	}

	*createCommandEncoder(){
		const {device, canvas, data} = this;
		const encoder = device.createCommandEncoder();
		yield new CommandEncoderEx(encoder, device, canvas, data);
		device.queue.submit([encoder.finish()]);
	}

	copyExternalImageToTexture(source, destination, copySize){
		this.device.queue.copyExternalImageToTexture(source, destination, copySize);
	}

	writeTexture(destination, data, dataLayout, size){
		this.device.queue.writeTexture(destination, data, dataLayout, size);
	}

	writeBuffer(buffer, bufferOffset, data, dataOffset, size){
		this.device.queue.writeBuffer(buffer, bufferOffset, data, dataOffset, size);
	}

	readBuffer(buffer, size, callback){
		buffer.mapAsync(GPUMapMode.READ, 0, size).then(() => {
			callback(buffer.getMappedRange(0, size));
			buffer.unmap();
		});
	}

	get width(){
		return this.canvas.width;
	}

	get height(){
		return this.canvas.height;
	}
}

EncoderEx.prototype.getCurrentTexture = function(){
	const cache = createMapGetter((canvas, device) => {
		const swapChain = canvas.getContext('webgpu');
		swapChain.configure({
			device: device,
			format: 'bgra8unorm',
			usage: GPUTextureUsage.COPY_DST,
			alphaMode: 'opaque',//premultiplied
			colorSpace: 'srgb',//display-p3
		});
		return swapChain;
	}, null, new WeakMap());
	return function(){
		return cache(this.canvas, this.device).getCurrentTexture();
	}
}();

EncoderEx.prototype.fetchTempTypedArray = function(){
	const cache = createMapGetter(type => {
		let value = new type(1024);
		return length => {
			if(value.length >= length)return value;
			return value = new type(nextPowerOf2(length));
		}
	});
	return (length, type=Float32Array) => cache(type)(length);
}();

EncoderEx.prototype.fetchTempTexture = function(){
	const queryFnMap = {
		'>=':function(v){return v.width >= this.width && v.height >= this.height && v.depthOrArrayLayers == (this.depthOrArrayLayers ?? 1);},
		'==':function(v){return v.width == this.width && v.height == this.height && v.depthOrArrayLayers == (this.depthOrArrayLayers ?? 1);},
	};
	const sizeFnMap = {
		'>=':function(v){return {width: nextPowerOf2(v.width), height: nextPowerOf2(v.height ?? 1), depthOrArrayLayers: v.depthOrArrayLayers ?? 1};},
		'==':function(v){return v;}
	};
	const cache = createMapGetter(function(descText){
		return ObjectPool((size, strategy) => {
			const desc = TextureDescCache(descText);
			desc.size = sizeFnMap[strategy](size);
			return this.device.createTexture(desc);
		}, queryFnMap);
	});
	return function(size, descText, strategy='=='){
		return cache.call(this, descText)(size, strategy);
	}
}();

EncoderEx.prototype.fetchTextureView = function(){
	const cache = createMapGetter(texture => createGetter(text => texture.createView(TextureViewDescCache(text))), null, new WeakMap());
	return (texture, descText='') => cache(texture)(descText);
}();

EncoderEx.prototype.fetchTempBuffer = function(){
	const queryFnMap = {'>=':function(v){return v.mapState == 'unmapped' && v.size >= this;}};
	const cache = createMapGetter(function(usage){
		return ObjectPool(size => this.device.createBuffer({usage, size:nextPowerOf2(size)}), queryFnMap);
	});
	return function(size, usage){
		return cache.call(this, usage)(size, '>=');
	}
}();

EncoderEx.prototype.fetchBufferBy = createMapGetter(function(data, usage){
	const buffer = this.device.createBuffer({usage, size:data.byteLength, mappedAtCreation:true});
	const mapping = buffer.getMappedRange();
	new data.constructor(mapping).set(data);
	buffer.unmap();
	return buffer;
}, null, LRUCache(1000));
/*
EncoderEx.prototype.fetchAnimationTexture = createMapGetter(function(mesh){
	const width = Math.max(...mesh.animationList.map(v => v.keyFrameTimes.length)) * 2;
	const height = mesh.boneList.at(-1).id + 1;
	const depthOrArrayLayers = mesh.animationList.length;
	const data = new Float32Array(width * height * depthOrArrayLayers * 4);
	for(let k=0; k<depthOrArrayLayers; ++k){
		const animation = mesh.animationList[k];
		for(let j=0; j<height; ++j){
			const matrixList = animation.trackDict[j];
			if(!matrixList)continue;
			const parentBoneID = mesh.boneList.find(v => v.id == j).parent?.id ?? -1;
			for(let i=0; i<width; i+=2){
				const matrix = matrixList[i >> 1];
				if(!matrix)continue;
				const {rotation, translation} = matrix;
				const offset = (width * (height * k + j) + i) * 4;
				data[offset  ] = rotation.x;
				data[offset+1] = rotation.y;
				data[offset+2] = rotation.z;
				data[offset+3] = rotation.w;
				data[offset+4] = translation.x;
				data[offset+5] = translation.y;
				data[offset+6] = translation.z;
				data[offset+7] = parentBoneID;
			}
		}
	}
	const texture = this.device.createTexture({size: [width, height, depthOrArrayLayers], format: 'rgba32float', usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST});
	this.writeTexture({texture}, data, {bytesPerRow:width*16, rowsPerImage:height}, texture);
	return {
		textureView: texture.createView({dimension:'2d-array'}),
		destroy(){texture.destroy();}
	};
}, null, LRUCache(1000));
*/
const calcDir = v => v.includes('/') ? v.slice(0, v.lastIndexOf('/')+1) : '';

EncoderEx.prototype.loadData = createFetch(async function(path){
	const response = await fetch(path);
	if(path.endsWith('.bmd'))return initMesh(bmd.parse(await response.arrayBuffer()));
	if(path.endsWith('.obj'))return await obj.parseObj(await response.text(), calcDir(path), this.loadData);
	if(path.endsWith('.mtl'))return obj.parseMtl(await response.text(), calcDir(path));
	return await response.arrayBuffer();
}, LRUCache(60 * 1000));

EncoderEx.prototype.loadImage = function(){
	function loadMap(arrayBuffer){
		const ba = new Uint8Array(arrayBuffer, 1);
		const width = 256;
		const height = 256;
		const depthOrArrayLayers = 3;
		const data = ba.slice();
		for(let j=0; j<3; ++j){
			const dataOffset = j * width * height;
			for(let i=0; i<height; ++i){
				data.set(ba.subarray(dataOffset + width * i, dataOffset + width * (i + 1)), dataOffset + width * (height - 1 - i));
			}
		}
		return {width, height, depthOrArrayLayers, data};
	}
	function loadBmp(arrayBuffer){
		const ba = new Uint8Array(arrayBuffer);
		let right2left = false;
		let bottom2top = false;

		const dataOffset = ba.readUInt32LE(10);

		console.assert(ba.readUInt32LE(14) == 40);

		let width = ba.readInt32LE(18);
		let height = ba.readInt32LE(22);

		if(height < 0){
			height = -height;
		}else{
			bottom2top = true;
		}

		const bitPerPixel = ba.readUInt16LE(28);//1,4,8,16,24,32
		const compression = ba.readUInt32LE(30);// 0(不压缩),1(BI_RLE8压缩类型)或2(BI_RLE4压缩类型)之一
		//let imageSize = ba.readUInt32LE(34);

		if(compression == 0){
			if(bitPerPixel == 8){
				if(bottom2top){
					const bytesPerRow = width;
					const data = new Uint8Array(width * height);
					for(let i=0; i<height; ++i){
						data.set(ba.subarray(dataOffset + bytesPerRow * i, dataOffset + bytesPerRow * (i + 1)), bytesPerRow * (height - 1 - i));
					}
					return {width, height, bitPerPixel, data};
				}
				return {width, height, bitPerPixel, data:ba.subarray(dataOffset, dataOffset + width * height)};
			}else if(bitPerPixel == 24){
				const data = new Uint8Array(width * height << 2);
				if(bottom2top){
					for(let i=0; i<height; ++i){
						for(let j=0; j<width; ++j){
							let offset = dataOffset + (width * i + j) * 3;
							let b = ba[offset];
							let g = ba[offset+1];
							let r = ba[offset+2];
							offset = (width * (height - 1 - i) + j) << 2;
							data[offset] = b;
							data[offset+1] = g;
							data[offset+2] = r;
							data[offset+3] = 255;
						}
					}
				}else{
					for(let i=0; i<height; ++i){
						for(let j=0; j<width; ++j){
							let offset = dataOffset + (width * i + j) * 3;
							let b = ba[offset];
							let g = ba[offset+1];
							let r = ba[offset+2];
							offset = (width * i + j) << 2;
							data[offset] = b;
							data[offset+1] = g;
							data[offset+2] = r;
							data[offset+3] = 255;
						}
					}
				}
				return {width, height, bitPerPixel, data};
			}else{
				console.error('bitPerPixel not 8', bitPerPixel);
			}
		}else{
			console.error('compression bmp');
		}
	}
	function loadTga(arrayBuffer){
		const ba = new Uint8Array(arrayBuffer);
		/*--head begin--*/
		const imageInfoSize = ba.readUInt8(0);
		const hasColorTable = ba.readUInt8(1);
		const imageType = ba.readUInt8(2);
		//const colorTableStart = ba.readUInt16LE(3);
		//const colorTableLength = ba.readUInt16LE(5);
		//const colorTableDepth = ba.readUInt8(7);
		const px = ba.readUInt16LE(8);
		const py = ba.readUInt16LE(10);
		const width = ba.readUInt16LE(12);
		const height = ba.readUInt16LE(14);
		const bitPerPixel = ba.readUInt8(16);//8, 16, 24, 32
		const flags = ba.readUInt8(17);
		/*--head end--*/
		
		const right2left = ((flags >> 4) & 1) == 1;
		const bottom2top = ((flags >> 5) & 1) == 0;

		console.assert(!right2left && bottom2top && !hasColorTable && bitPerPixel == 32 && imageType == 2 && px == 0 && py == 0);
		console.assert(18 + imageInfoSize + width * height * 4 + 26 == ba.length);

		const imageOffset = 18 + imageInfoSize;
		const bytesPerRow = width << 2;
		const data = new Uint8Array(bytesPerRow * height);
		for(let i=0; i<height; ++i){
			data.set(ba.subarray(imageOffset + bytesPerRow * i, imageOffset + bytesPerRow * (i + 1)), bytesPerRow * (height - 1 - i));
		}
		return {width, height, data};
	}
	return createFetch(async function(path){
		const pathLower = path.toLowerCase();
		let image;
		if(pathLower.endsWith('.tga')){
			image = loadTga(await(await fetch(path)).arrayBuffer());
		}else if(pathLower.endsWith('.bmp')){
			image = loadBmp(await(await fetch(path)).arrayBuffer());
		}else if(pathLower.endsWith('.map')){
			image = loadMap(await(await fetch(path)).arrayBuffer());
		}else{
			image = new Image();
			image.src = path;
			await image.decode();
		}
		image.title = path;
		return image;
	}, LRUCache(60 * 1000));
}();

EncoderEx.prototype.loadTexture = function(){
	function loadTexture(device, image){
		const texture = device.createTexture({
			format: 'bgra8unorm',
			size: [image.width, image.height],
			usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
		});
		device.queue.copyExternalImageToTexture(
			{source:image, origin:[0,0], flipY:false},
			{texture, origin:[0,0,0], mipLevel:0, aspect:'all', colorSpace:'srgb', premultipliedAlpha:false},
			[image.width, image.height, 1]
		);
		return texture;
	}
	function loadTextureTga(device, info){
		const texture = device.createTexture({
			format: 'bgra8unorm',
			size: info,
			usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
		});
		device.queue.writeTexture(
			{texture, origin:[0,0,0], mipLevel:0, aspect:'all'},
			info.data,
			{offset:0, bytesPerRow:info.width << 2, rowsPerImage:undefined},
			info
		);
		return texture;
	}
	function loadTextureBmp(device, info){
		const format = info.bitPerPixel == 8 ? 'r8unorm' : 'bgra8unorm';
		const bytesPerRow = (info.bitPerPixel == 8 ? 1 : 4) * info.width;
		const texture = device.createTexture({format, size: info, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST});
		device.queue.writeTexture({texture}, info.data, {bytesPerRow}, info);
		return texture;
	}
	function loadTextureMap(device, info){
		const texture = device.createTexture({format:'r8uint', size: info, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST});
		device.queue.writeTexture({texture}, info.data, {bytesPerRow:info.width, rowsPerImage:info.height}, info);
		return texture;
	}
	function createColorTexture(device, color){
		if(color.length == 3)color.push(0xFF);
		const texture = device.createTexture({format: 'bgra8unorm', size: [1, 1], usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST});
		device.queue.writeTexture({texture}, new Uint8Array(color), {}, texture);
		return texture;
	}
	const colorPattern = 'color://';
	return createFetch(async function(path){
		const pathLower = path.toLowerCase();
		let texture;
		if(pathLower.startsWith(colorPattern)){
			texture = createColorTexture(this.device, JSON.parse(path.slice(colorPattern.length)));
		}else if(pathLower.endsWith('.tga')){
			texture = loadTextureTga(this.device, await this.loadImage(path));
		}else if(pathLower.endsWith('.bmp')){
			texture = loadTextureBmp(this.device, await this.loadImage(path));
		}else if(pathLower.endsWith('.map')){
			texture = loadTextureMap(this.device, await this.loadImage(path));
		}else{
			texture = loadTexture(this.device, await this.loadImage(path));
		}
		texture.label = path;
		return texture;
	}, LRUCache(30 * 1000));
}();

class RenderPassEncoderEx extends EncoderEx
{
	constructor(encoder, device, canvas, data){
		super(device, canvas, data);
		this.encoder = encoder;
		this.pipeline = null;
		this.resourcesQueue = [];
		this.index = null;
	}

	setPipeline(pipeline){
		if(this.pipeline == pipeline)return;
		if(pipeline){
			this.encoder.setPipeline(pipeline.getRawValue(this.device));
		}
		this.pipeline = pipeline;
	}

	setResources(resources){
		this.resourcesQueue.push(resources);
		this.index = resources.index ?? this.index;
	}

	onDrawBegin(){
		const {resourcesQueue} = this;
		if(resourcesQueue.length <= 0)return;
		this.pipeline.setResources(this, Object.assign({}, ...resourcesQueue));
		resourcesQueue.length = 0;
	}

	setViewportWH(width, height){
		this.encoder.setViewport(0, 0, width, height, 0, 1);
	}

	setViewportToCanvas(){
		const {width, height} = this.canvas;
		this.encoder.setViewport(0, 0, width, height, 0, 1);
	}

	drawIndexedAuto(instanceCount=1, firstInstance=0){
		this.drawIndexed(this.index.length, instanceCount, 0, 0, firstInstance);
	}

	draw(vertexCount, instanceCount=1, firstVertex=0, firstInstance=0){
		this.onDrawBegin();
		this.encoder.draw(vertexCount, instanceCount, firstVertex, firstInstance);
	}

	drawIndexed(indexCount, instanceCount=1, firstIndex=0, baseVertex=0, firstInstance=0){
		this.onDrawBegin();
		this.encoder.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
	}

	drawIndirect(indirectBuffer, indirectOffset=0){
		this.onDrawBegin();
		this.encoder.drawIndirect(indirectBuffer, indirectOffset);
	}

	drawIndexedIndirect(indirectBuffer, indirectOffset=0){
		this.onDrawBegin();
		this.encoder.drawIndexedIndirect(indirectBuffer, indirectOffset);
	}

	setVertexBuffer(slot, buffer, offset, size){
		this.encoder.setVertexBuffer(slot, buffer, offset, size);
	}

	setIndexBuffer(buffer, indexFormat, offset, size){
		this.encoder.setIndexBuffer(buffer, indexFormat, offset, size);
	}

	setBindGroup(index, bindGroup){
		this.encoder.setBindGroup(index, bindGroup);
	}

	drawQuad(){
		this.draw(4);
	}

	drawQuadWith(pipeline, resources, instanceCount=1){
		this.setPipeline(pipeline);
		this.setResources(resources);
		this.draw(4, instanceCount);
	}
/*
	drawIndexed(indexCount, instanceCount=1, firstIndex=0, baseVertex=0, firstInstance=0){
		this.encoder.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
	}

	setViewport(x, y, width, height, minDepth=0, maxDepth=1){
		this.encoder.setViewport(x, y, width, height, minDepth, maxDepth);
	}

	setBlendConstant(color){
		this.encoder.setBlendConstant(color);
	}

	setScissorRect(x, y, width, height){
		this.encoder.setScissorRect(x, y, width, height);
	}

	setStencilReference(reference){
		this.encoder.setStencilReference(reference);
	}
*/
}

class CommandEncoderEx extends EncoderEx
{
	constructor(encoder, device, canvas, data){
		super(device, canvas, data);
		this.encoder = encoder;
	}

	clearBuffer(buffer, offset, size){
		this.encoder.clearBuffer(buffer, offset, size);
	}

	copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size){
		this.encoder.copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size);
	}

	copyBufferToTexture(source, destination, copySize){
		this.encoder.copyBufferToTexture(source, destination, copySize);
	}

	copyTextureToBuffer(source, destination, copySize){
		this.encoder.copyTextureToBuffer(source, destination, copySize);
	}

	copyTextureToTexture(source, destination, copySize){
		this.encoder.copyTextureToTexture(source, destination, copySize);
	}

	*beginComputePass(){
		const encoder = this.encoder.beginComputePass();
		yield encoder;
		encoder.end();
	}

	*beginRenderPass(descText, ...textureViews){
		const desc = RenderPassDescCache(descText);
		const n = desc.colorAttachments.length;
		for(let i=0; i<n; ++i){
			desc.colorAttachments[i].view = textureViews[i];
		}
		if(desc.depthStencilAttachment){
			desc.depthStencilAttachment.view = textureViews[n];
		}
		const {device, canvas, data} = this;
		const encoder = this.encoder.beginRenderPass(desc);
		yield new RenderPassEncoderEx(encoder, device, canvas, data);
		encoder.end();
	}
}

const createGetter = (newFn, hit=Object.create(null)) => k => k in hit ? hit[k] : (hit[k] = newFn(k));

const RenderPassDescCache = function(){
	const parseOp = v => {
		const [loadOp, storeOp] = v.split('+');
		return {
			loadOp: loadOp == 'load' ? 'load' : 'clear',
			clearValue: loadOp == 'load' ? undefined : JSON.parse(loadOp),
			storeOp,
		}
	}
	function parseDesc(desc){
		let colorAttachments, depthStencilAttachment;
		const [colors, depth, stencil] = desc.split(';');
		colorAttachments = colors ? colors.split(':').map(parseOp) : [];
		if(depth || stencil){
			depthStencilAttachment = {};
			if(depth == '+'){
				depthStencilAttachment.depthReadOnly = true;
			}else if(depth){
				let {loadOp, storeOp, clearValue} = parseOp(depth);
				depthStencilAttachment.depthLoadOp = loadOp;
				depthStencilAttachment.depthClearValue = clearValue;
				depthStencilAttachment.depthStoreOp = storeOp;
			}
			if(stencil == '+'){
				depthStencilAttachment.stencilReadOnly = true;
			}else if(stencil){
				let {loadOp, storeOp, clearValue} = parseOp(stencil);
				depthStencilAttachment.stencilLoadOp = loadOp;
				depthStencilAttachment.stencilClearValue = clearValue;
				depthStencilAttachment.stencilStoreOp = storeOp;
			}
		}
		return {colorAttachments, depthStencilAttachment};
	}
	return createGetter(parseDesc);
}();

const TextureViewDescCache = function(){
	function parseDesc(desc){
		const [dimension, aspect, baseArrayLayer, arrayLayerCount, baseMipLevel, mipLevelCount] = desc.split(',');
		return {
			dimension: dimension || undefined,
			aspect: aspect || 'all',
			baseArrayLayer: baseArrayLayer ? parseInt(baseArrayLayer) : 0,
			arrayLayerCount: arrayLayerCount ? parseInt(arrayLayerCount) : undefined,
			baseMipLevel: baseMipLevel ? parseInt(baseMipLevel) : 0,
			mipLevelCount: mipLevelCount ? parseInt(mipLevelCount) : undefined,
		}
	}
	return createGetter(parseDesc);
}();

const TextureDescCache = function(){
	function parseDesc(desc){
		const [format, usage, dimension, mipLevelCount] = desc.split(',');
		return {
			format,
			usage: parseInt(usage),
			dimension: dimension || '2d',
			mipLevelCount: mipLevelCount ? parseInt(mipLevelCount) : 1,
		};
	}
	return createGetter(parseDesc);
}();

exports.EncoderEx = EncoderEx;
