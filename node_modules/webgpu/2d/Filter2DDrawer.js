'use strict';

const RenderPass = require('../helper/RenderPass');
const {fetchView2D} = require('../Vulkan/resource');
const {intersect} = require('../math/rectangle');

const renderPass2D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}]
});

const drawFilter2D = (commandEncoder, item, camera) => {
	const areaRect = item.getBoundingRect();
	const {texture} = item.filter;
	if(!areaRect)return texture.rawTexture = null;
	const {width, height, view0, view1, copyTexture} = fetchView2D(areaRect);
	const drawRect = {width:areaRect.width, height:areaRect.height, x:0, y:0};
	const frameRect = {width, height};

	camera.setLens(frameRect);
	camera.worldTransformInvert.copyFrom(item.worldTransformInvert);
	camera.worldTransformInvert.translate(-areaRect.x, -areaRect.y);
	camera.collectDrawUnits(item, true);

	texture.rawTexture = view1;
	for(let _ of renderPass2D(commandEncoder, view0))camera.draw();
	if(item.filter.justCopyFlag){
		const clipRect = intersect(areaRect, item.filter.clipRect);
		if(!clipRect)return;
		copyTexture(commandEncoder, clipRect.x - areaRect.x, clipRect.y - areaRect.y, clipRect.width, clipRect.height);
		texture.setUV(width, height, {x: 0, y: 0, width:clipRect.width, height:clipRect.height}, false);
		const {adjustX, adjustY} = item.filter;
		texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
		texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
	}else{
		texture.setUV(width, height, drawRect, false);
		texture.xyuvAdd[0] = areaRect.x;
		texture.xyuvAdd[1] = areaRect.y;
		for(let _ of renderPass2D(commandEncoder, view1)){
			const materialType = item.filter.constructor;
			materialType.setBindGroup(0, [{binding:0, resource:view0}]);
			materialType.draw([{frameRect, drawRect, material: item.filter}]);
		}
	}
}

module.exports = drawFilter2D;
