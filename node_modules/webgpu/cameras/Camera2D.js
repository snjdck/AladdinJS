'use strict';

const Material2D = require('../materials/Material2D');
const Matrix2D = require('../math/Matrix2D');
const {walkTree} = require('utils/traverseTree');
const DrawUnitCollector2D = require('./DrawUnitCollector2D');
const {intersect} = require('../math/rectangle');
const {createWeakMapGetter} = require('utils/cache');

class Camera2D
{
	constructor(lens){
		this.worldTransformInvert = new Matrix2D();
		this.lens = [0, 0, -1, 1];
		//this.layerFlagFilter = 0xFFFFFFFF;
		//this.viewportRect = new Float32Array([0, 0, 1, 1]);
		//this.projectionMatrix = new Array(16);
		this.drawUnitCollector = new DrawUnitCollector2D();

		if(lens)this.setLens(lens);
	}

	setLens(value){
		const {width, height} = value;
		const {lens} = this;
		lens[0] = 2 / width;
		lens[1] = -2 / height;
	}
}

Camera2D.prototype.collectDrawUnits = function(){
	const fn = walkTree(function(item, root, forceDrawFlag, drawUnitCollector){
		if(!item.visible)return true;
		if(item.filter && !(item == root && forceDrawFlag)){
			const {texture} = item.filter;
			const drawUnit = Object.create(item);
			drawUnit.texture = texture;
			drawUnit.width = texture.width;
			drawUnit.height = texture.height;
			drawUnitCollector.addBitmap(drawUnit);
			drawUnitCollector.addFilter(item);
			return true;
		}else if(item.texture){
			drawUnitCollector.addBitmap(item);
			if(item.type == 'bitmap3d'){
				drawUnitCollector.addBitmap3D(item);
			}
		}
	});
	return function(root, forceDrawFlag=false){
		fn(root, true, root, forceDrawFlag, this.drawUnitCollector);
	}
}();

Camera2D.prototype.draw = function(){
	const tempBuffer = new Float32Array(12);
	return function(renderPassEncoder){
		const {bitmap3DList, filterList, bitmapList} = this.drawUnitCollector;
		if(bitmap3DList.length > 0 || filterList.length > 0){
			for(let commandEncoder of renderPassEncoder.createCommandEncoder()){
				for(let item of bitmap3DList)drawBitmap3D(commandEncoder, item);
				for(let item of filterList)drawFilter2D(commandEncoder, item);
			}
		}
		if(bitmapList.length > 0){
			tempBuffer.set(this.lens);
			this.worldTransformInvert.copyToArray(tempBuffer, 4);
			renderPassEncoder.setResources({'vpMatrix': {buffer:tempBuffer}});
			Material2D.draw(bitmapList, renderPassEncoder);
			this.drawUnitCollector.clear();
		}
	};
}();

Camera2D.prototype.drawPick = function(){
	const viewport = new Float32Array(12);
	const fn = walkTree(function(item, result, picking){
		if(!item.visible)return true;
		if(item.mouseEnabled){
			result.push(item);
			picking.register(item);
		}
	});
	const pickList = [];
	return function(renderPassEncoder, root, rect, picking){
		pickList.length = 0;
		fn(root, false, pickList, picking);
		if(pickList.length <= 0)return;
		const {width, height} = renderPassEncoder;
		viewport.set([2/rect.width, -2/rect.height, -(2*rect.x/rect.width+1), 2*rect.y/rect.height+1]);
		this.worldTransformInvert.copyToArray(viewport, 4);
		renderPassEncoder.drawQuadWith(Material2D.Pick, {'vpMatrix': {buffer:viewport}, 'rectInfoList': pickList, 'meshId':pickList}, pickList.length);
	}
}();

const drawBitmap3D = function(){
	return (commandEncoder, item) => {
		const {width, height} = item;
		const colorTexture = commandEncoder.fetchTempTexture(item, 'bgra8unorm,0x14');
		const depthTexture = commandEncoder.fetchTempTexture(item, 'depth24plus-stencil8,0x10');
		const colorView = commandEncoder.fetchTextureView(colorTexture);
		const depthView = commandEncoder.fetchTextureView(depthTexture);
		item.texture.rawTexture = colorTexture;
		item.texture.setUV(width, height, {x:0,y:0,width:item.width,height:item.height}, false);
		item.camera.collectDrawUnits(item.root3d);
		for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store;1+discard;0+discard', colorView, depthView)){
			item.camera.draw(renderPassEncoder);
		}
	}
}();

const drawFilter2D = function(){
	const fetchCamera = createWeakMapGetter(() => new Camera2D());
	return (commandEncoder, item) => {
		const areaRect = item.getBoundingRect();
		const {texture} = item.filter;
		if(!areaRect)return texture.rawTexture = null;
		const colorTexture = commandEncoder.fetchTempTexture({...areaRect, depthOrArrayLayers:2}, 'bgra8unorm,0x17', '>=');
		const view0 = commandEncoder.fetchTextureView(colorTexture, '2d,all,0,1');
		const view1 = commandEncoder.fetchTextureView(colorTexture, '2d,all,1,1');
		const {width, height} = colorTexture;
		const drawRect = {width:areaRect.width, height:areaRect.height, x:0, y:0};
		const frameRect = {width, height};

		const camera = fetchCamera(item);
		camera.setLens(frameRect);
		camera.worldTransformInvert.copyFrom(item.worldTransformInvert);
		camera.worldTransformInvert.translate(-areaRect.x, -areaRect.y);
		camera.collectDrawUnits(item, true);

		texture.rawTexture = colorTexture;
		for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store', view1))camera.draw(renderPassEncoder);
		if(item.filter.justCopyFlag){
			const clipRect = intersect(areaRect, item.filter.clipRect);
			if(!clipRect)return;
			commandEncoder.copyTextureToTexture(
				{texture:colorTexture, origin: [clipRect.x - areaRect.x, clipRect.y - areaRect.y, 1]},
				{texture:colorTexture},
				clipRect
			);
			texture.setUV(width, height, {x: 0, y: 0, width:clipRect.width, height:clipRect.height}, false);
			const {adjustX, adjustY} = item.filter;
			texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
			texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
		}else{
			texture.setUV(width, height, drawRect, false);
			texture.xyuvAdd[0] = areaRect.x;
			texture.xyuvAdd[1] = areaRect.y;
			for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store', view0)){
				const materialType = item.filter.constructor;
				renderPassEncoder.setResources({'texture': view1});
				materialType.draw([{frameRect, drawRect, material: item.filter}], renderPassEncoder);
			}
		}
	}
}();

module.exports = Camera2D;
