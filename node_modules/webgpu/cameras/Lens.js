'use strict';

function Ortho(width, height, zNear, zFar){
	let matrix = new Float32Array(16);
	matrix[ 0] = 2 / width;
	matrix[ 5] = 2 / height;
	matrix[10] = 1 / (zFar - zNear);
	matrix[11] = zNear / (zNear - zFar);
	matrix[15] = 1;
	return matrix;
}

/**
 * @param fieldOfViewY 视野范围(弧度)
 * @param aspectRatio 高宽比(3/4, 9/16)
 */		
function PerspectiveFieldOfView(fieldOfViewY, aspectRatio, zNear, zFar, originZ=0){
	let yScale = 1 / Math.tan(fieldOfViewY * 0.5);
	let xScale = yScale * aspectRatio;

	let matrix = new Float32Array(16);
	matrix[ 0] = xScale;
	matrix[ 5] = yScale;
	matrix[10] = (zFar - originZ) / (zFar - zNear);
	matrix[11] = (zFar - originZ) * zNear / (zNear - zFar);
	matrix[14] = 1;
	matrix[15] = -originZ;
	return matrix;
}

function PerspectiveFieldOfViewWH(fieldOfViewY, aspectRatio, zNear, zFar, zNearHeight){
	let yScale = 1 / Math.tan(fieldOfViewY * 0.5);
	let xScale = yScale * aspectRatio;
	let originZ = zNear - yScale * zNearHeight * 0.5;

	let matrix = new Float32Array(16);
	matrix[ 0] = xScale;
	matrix[ 5] = yScale;
	matrix[10] = (zFar - originZ) / (zFar - zNear);
	matrix[11] = (zFar - originZ) * zNear / (zNear - zFar);
	matrix[14] = 1;
	matrix[15] = -originZ;
	return matrix;
}
/*
function calcZRange(fieldOfViewY, groundAngle, scale=1, offsetNear=0, offsetFar=0){
	fieldOfViewY *= 0.5;//half
	const tanFieldOfViewY = Math.tan(fieldOfViewY);
	const cosFieldOfViewY = Math.cos(fieldOfViewY);
	const zNear = 1 / (1 + tanFieldOfViewY / Math.tan(groundAngle));
	const zFar = (1 - tanFieldOfViewY / Math.tan(fieldOfViewY - groundAngle)) * cosFieldOfViewY * cosFieldOfViewY;
	return [zNear * scale - offsetNear, zFar * scale + offsetFar];
}
*/
exports.Ortho = Ortho;
exports.PerspectiveFieldOfView = PerspectiveFieldOfView;
exports.PerspectiveFieldOfViewWH = PerspectiveFieldOfViewWH;
