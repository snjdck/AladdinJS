'use strict';

const Vector3D = require('../math/Vector3D');
const Ray3D = require('../math/Ray3D');

class Ortho
{
	constructor(width, height, zNear, zFar){
		let matrix = new Float32Array(16);
		matrix[ 0] = 2 / width;
		matrix[ 5] = 2 / height;
		matrix[10] = 1 / (zFar - zNear);
		matrix[11] = zNear / (zNear - zFar);
		matrix[15] = 1;
		this.rawData = matrix;

		this.halfW = 0.5 * width;
		this.halfH = 0.5 * height;
		this.zNear = zNear;
		//this.zFar = zFar;

		let matrixInvert = new Float32Array(16);
		matrixInvert[ 0] = 1 / matrix[ 0];
		matrixInvert[ 5] = 1 / matrix[ 5];
		matrixInvert[10] = 1 / matrix[10];
		matrixInvert[11] = -matrix[11]/matrix[10];
		matrixInvert[15] = 1;
		this.matrixInvert = matrixInvert;
	}

	setWH(width, height){
		const {rawData} = this;
		rawData[0] = 2 / width;
		rawData[5] = 2 / height;
	}

	//x, y => [-1, 1]
	screenToCamera(x, y){
		const {halfW, halfH, zNear} = this;
		return new Ray3D(
			new Vector3D(x * halfW, y * halfH, zNear),
			new Vector3D(0, 0, 1)
		);
	}
	/*
	screenToCameraRect(l, t, r, b){
		const {halfW, halfH, zNear, zFar} = this;
		return [
			[ 1, 0, 0, l * -halfW],
			[-1, 0, 0, r *  halfW],
			[0,  1, 0, b * -halfH],
			[0, -1, 0, t *  halfH],
			[0, 0,  1, -zNear],
			[0, 0, -1,  zFar]
		];
	}
	*/
}

/*
a * x / (z-originZ) = x'
b * y / (z-originZ) = y'
(c * z + d) / (z-originZ) = z'

x = (c * originZ + d) / a * x'
y = (c * originZ + d) / b * y'
z = originZ * z' + d
w = z' - c

a' = (c * originZ + d) / a
b' = (c * originZ + d) / b
c' = originZ
d' = d

c * originZ + d == (originZ - zNear) * (zFar - originZ) / (zFar - zNear)
*/
/**
 * @param fieldOfViewY 视野范围(弧度)
 * @param aspectRatio 高宽比(3/4, 9/16)
 */
class Perspective
{
	constructor(fieldOfViewY, aspectRatio, zNear, zFar, originZ=0){
		let yScale = 1 / Math.tan(fieldOfViewY * 0.5);
		let xScale = yScale * aspectRatio;

		let matrix = new Float32Array(16);
		matrix[ 0] = xScale;
		matrix[ 5] = yScale;
		matrix[10] = (zFar - originZ) / (zFar - zNear);
		matrix[11] = (zFar - originZ) * zNear / (zNear - zFar);
		matrix[14] = 1;
		matrix[15] = -originZ;
		this.rawData = matrix;

		this.originZ = originZ;
		//this.zNear = zNear;
		//this.zFar = zFar;
		this.sizeZ = zNear - originZ;
		this.sizeX = this.sizeZ / xScale;
		this.sizeY = this.sizeZ / yScale;

		let matrixInvert = new Float32Array(16);
		matrixInvert[ 0] = (originZ * matrix[10] + matrix[11]) / xScale;
		matrixInvert[ 5] = (originZ * matrix[10] + matrix[11]) / yScale;
		matrixInvert[10] = originZ;
		matrixInvert[11] = matrix[11];
		matrixInvert[14] = 1;
		matrixInvert[15] = -matrix[10];
		this.matrixInvert = matrixInvert;

		this.temp = new Float32Array(16);
	}

	//x, y => [-1, 1]
	screenToCamera(x, y){
		const {originZ, sizeX, sizeY, sizeZ} = this;
		return new Ray3D(
			new Vector3D(0, 0, originZ),
			new Vector3D(sizeX * x, sizeY * y, sizeZ)
		);
	}

	offset(bw, bh, x, y, w, h){
		const {temp, rawData, originZ} = this;
		temp.set(rawData);
		const a = (bw - 2 * x) / w - 1;
		const b = (bh - 2 * y) / h - 1;
		temp[ 0] = rawData[0] * bw / w;
		temp[ 2] = a;
		temp[ 3] = a * -originZ;
		temp[ 5] = rawData[5] * bh / h;
		temp[ 6] = b;
		temp[ 7] = b * -originZ;
		return temp;
		//x1 => a * x / (z - zo)
		//x2 = ((x1 + 1) * 0.5 * bw - x) / w * 2 - 1;
		//x2 = x1 * bw / w + (bw - 2 * x) / w - 1;
		//x2 = (a * bw / w) * x + ((bw - 2 * x) / w - 1) * (z - z0)
	}
	/*
	screenToCameraRect(l, t, r, b){
		const {originZ, zNear, zFar, sizeX, sizeY, sizeZ} = this;
		return [
			[ sizeZ, 0, l * -sizeX,  l * sizeX * originZ],
			[-sizeZ, 0, r *  sizeX, -r * sizeX * originZ],
			[0,  sizeZ, b * -sizeY,  b * sizeY * originZ],
			[0, -sizeZ, t *  sizeY, -t * sizeY * originZ],
			[0, 0,  1, -zNear],
			[0, 0, -1,  zFar]
		];
	}
	*/
}

exports.Ortho = Ortho;
exports.Perspective = Perspective;
/*
A=x'/w'
B=y'/w'
C=z'/w'

x' = x * xscale
y' = y * yscale
z' = a * z + b;
w' = z - originZ

求x,y,z关于A,B,C的函数

z = (b + C * originZ) / (C - a)
z - originZ = (b + a * originZ) / (C - a)
x = A / xscale * (b + a * originZ) / (C - a)
y = B / yscale * (b + a * originZ) / (C - a)

*/
