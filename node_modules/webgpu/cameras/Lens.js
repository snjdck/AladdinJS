'use strict';

const Vector3D = require('opengl/math/Vector3D');
const Ray3D = require('../math/Ray3D');

/*
function calcZRange(fieldOfViewY, groundAngle, scale=1, offsetNear=0, offsetFar=0){
	fieldOfViewY *= 0.5;//half
	const tanFieldOfViewY = Math.tan(fieldOfViewY);
	const cosFieldOfViewY = Math.cos(fieldOfViewY);
	const zNear = 1 / (1 + tanFieldOfViewY / Math.tan(groundAngle));
	const zFar = (1 - tanFieldOfViewY / Math.tan(fieldOfViewY - groundAngle)) * cosFieldOfViewY * cosFieldOfViewY;
	return [zNear * scale - offsetNear, zFar * scale + offsetFar];
}
*/

class Ortho
{
	constructor(width, height, zNear, zFar){
		let matrix = new Float32Array(16);
		matrix[ 0] = 2 / width;
		matrix[ 5] = 2 / height;
		matrix[10] = 1 / (zFar - zNear);
		matrix[11] = zNear / (zNear - zFar);
		matrix[15] = 1;
		this.rawData = matrix;

		this.halfW = 0.5 * width;
		this.halfH = 0.5 * height;
		this.zNear = zNear;
		//this.zFar = zFar;
	}

	//x, y => [-1, 1]
	screenToCamera(x, y){
		const {halfW, halfH, zNear} = this;
		return new Ray3D(
			new Vector3D(x * halfW, y * halfH, zNear),
			new Vector3D(0, 0, 1)
		);
	}
	/*
	screenToCameraRect(l, t, r, b){
		const {halfW, halfH, zNear, zFar} = this;
		return [
			[ 1, 0, 0, l * -halfW],
			[-1, 0, 0, r *  halfW],
			[0,  1, 0, b * -halfH],
			[0, -1, 0, t *  halfH],
			[0, 0,  1, -zNear],
			[0, 0, -1,  zFar]
		];
	}
	*/
}

/*
a * x / (z-originZ) = x'
b * y / (z-originZ) = y'
(c * z + d) / (z-originZ) = z'

x = (c * originZ + d) / a * x'
y = (c * originZ + d) / b * y'
z = originZ * z' + d
w = z' - c

a' = (c * originZ + d) / a
b' = (c * originZ + d) / b
c' = originZ
d' = d

c * originZ + d == (originZ - zNear) * (zFar - originZ) / (zFar - zNear)
*/
/**
 * @param fieldOfViewY 视野范围(弧度)
 * @param aspectRatio 高宽比(3/4, 9/16)
 */
class Perspective
{
	constructor(fieldOfViewY, aspectRatio, zNear, zFar, originZ=0){
		let yScale = 1 / Math.tan(fieldOfViewY * 0.5);
		let xScale = yScale * aspectRatio;

		let matrix = new Float32Array(16);
		matrix[ 0] = xScale;
		matrix[ 5] = yScale;
		matrix[10] = (zFar - originZ) / (zFar - zNear);
		matrix[11] = (zFar - originZ) * zNear / (zNear - zFar);
		matrix[14] = 1;
		matrix[15] = -originZ;
		this.rawData = matrix;

		this.originZ = originZ;
		//this.zNear = zNear;
		//this.zFar = zFar;
		this.sizeZ = zNear - originZ;
		this.sizeX = this.sizeZ / xScale;
		this.sizeY = this.sizeZ / yScale;
	}

	//x, y => [-1, 1]
	screenToCamera(x, y){
		const {originZ, sizeX, sizeY, sizeZ} = this;
		return new Ray3D(
			new Vector3D(0, 0, originZ),
			new Vector3D(sizeX * x, sizeY * y, sizeZ)
		);
	}
	/*
	screenToCameraRect(l, t, r, b){
		const {originZ, zNear, zFar, sizeX, sizeY, sizeZ} = this;
		return [
			[ sizeZ, 0, l * -sizeX,  l * sizeX * originZ],
			[-sizeZ, 0, r *  sizeX, -r * sizeX * originZ],
			[0,  sizeZ, b * -sizeY,  b * sizeY * originZ],
			[0, -sizeZ, t *  sizeY, -t * sizeY * originZ],
			[0, 0,  1, -zNear],
			[0, 0, -1,  zFar]
		];
	}
	*/
}

exports.Ortho = Ortho;
exports.Perspective = Perspective;
