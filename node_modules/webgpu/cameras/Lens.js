'use strict';

const Vector3D = require('opengl/math/Vector3D');
const Ray3D = require('../math/Ray3D');

/*
function calcZRange(fieldOfViewY, groundAngle, scale=1, offsetNear=0, offsetFar=0){
	fieldOfViewY *= 0.5;//half
	const tanFieldOfViewY = Math.tan(fieldOfViewY);
	const cosFieldOfViewY = Math.cos(fieldOfViewY);
	const zNear = 1 / (1 + tanFieldOfViewY / Math.tan(groundAngle));
	const zFar = (1 - tanFieldOfViewY / Math.tan(fieldOfViewY - groundAngle)) * cosFieldOfViewY * cosFieldOfViewY;
	return [zNear * scale - offsetNear, zFar * scale + offsetFar];
}
*/

class Ortho
{
	constructor(rawData){
		this.rawData = rawData;
	}

	//x, y => [-1, 1]
	screenToCamera(x, y){
		const {rawData} = this;
		return new Ray3D(
			new Vector3D(x / rawData[0], y / rawData[5], -rawData[11] / rawData[10]),
			new Vector3D(0, 0, 1)
		);
	}
}

/*
a * x / (z-originZ) = x'
b * y / (z-originZ) = y'
(c * z + d) / (z-originZ) = z'

x = (c * originZ + d) / a * x'
y = (c * originZ + d) / b * y'
z = originZ * z' + d
w = z' - c

a' = (c * originZ + d) / a
b' = (c * originZ + d) / b
c' = originZ
d' = d

c * originZ + d == (originZ - zNear) * (zFar - originZ) / (zFar - zNear)
*/
class Perspective
{
	constructor(rawData){
		this.rawData = rawData;
	}

	//x, y => [-1, 1]
	screenToCamera(x, y){
		const {rawData} = this;
		const factor = rawData[15] - rawData[11] / rawData[10];
		return new Ray3D(
			new Vector3D(0, 0, -rawData[15]),
			new Vector3D(factor * x / rawData[0], factor * y / rawData[5], factor)
		);
	}
}

exports.Ortho = function(width, height, zNear, zFar){
	let matrix = new Float32Array(16);
	matrix[ 0] = 2 / width;
	matrix[ 5] = 2 / height;
	matrix[10] = 1 / (zFar - zNear);
	matrix[11] = zNear / (zNear - zFar);
	matrix[15] = 1;
	return new Ortho(matrix);
}

/**
 * @param fieldOfViewY 视野范围(弧度)
 * @param aspectRatio 高宽比(3/4, 9/16)
 */
exports.PerspectiveFieldOfView = function(fieldOfViewY, aspectRatio, zNear, zFar, originZ=0){
	let yScale = 1 / Math.tan(fieldOfViewY * 0.5);
	let xScale = yScale * aspectRatio;

	let matrix = new Float32Array(16);
	matrix[ 0] = xScale;
	matrix[ 5] = yScale;
	matrix[10] = (zFar - originZ) / (zFar - zNear);
	matrix[11] = (zFar - originZ) * zNear / (zNear - zFar);
	matrix[14] = 1;
	matrix[15] = -originZ;
	return new Perspective(matrix);
}
