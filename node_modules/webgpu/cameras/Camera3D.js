'use strict';

const Vulkan = require('../Vulkan');
const DisplayObject3D = require('../DisplayObject3D');
const ViewFrustum = require('./ViewFrustum');
const TextureMaterial = require('../materials/TextureMaterial');
const DrawUnitCollector3D = require('./DrawUnitCollector3D');
const {CommandEncoder, RenderPass} = require('../helper/CommandEncoder');
const {walkTree} = require('utils/traverseTree');
const {fetchTextures} = require('../Vulkan/resource');

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.cullEnabled = false;
		this.viewFrustum = new ViewFrustum();
		this.lens = lens;
		this.layerFlagFilter = 0xFFFFFFFF;
		this.viewportRect = new Float32Array([0, 0, 1, 1]);
		this.projectionMatrix = new Array(16);
		this.drawUnitCollector = new DrawUnitCollector3D();
	}

	updateViewFrustum(){
		if(!this.cullEnabled)return;
		const {projectionMatrix} = this;
		const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23] = this.worldTransformInvert.rawData;
		const [b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23, b30, b31, b32, b33] = this.lens.rawData;

		projectionMatrix[ 0] = a00 * b00;
		projectionMatrix[ 1] = a01 * b00;
		projectionMatrix[ 2] = a02 * b00;
		projectionMatrix[ 3] = a03 * b00;

		projectionMatrix[ 4] = a10 * b11;
		projectionMatrix[ 5] = a11 * b11;
		projectionMatrix[ 6] = a12 * b11;
		projectionMatrix[ 7] = a13 * b11;

		projectionMatrix[ 8] = a20 * b22;
		projectionMatrix[ 9] = a21 * b22;
		projectionMatrix[10] = a22 * b22;
		projectionMatrix[11] = a23 * b22 + b23;

		projectionMatrix[12] = a20 * b32;
		projectionMatrix[13] = a21 * b32;
		projectionMatrix[14] = a22 * b32;
		projectionMatrix[15] = a23 * b32 + b33;

		this.viewFrustum.update(this);
	}
/*
	setViewport(frameRect, drawRect){
		const {viewportRect} = this;

		viewportRect[0] = (drawRect.width + 2 * drawRect.x) / frameRect.width - 1;
		viewportRect[1] = 1 - (drawRect.height + 2 * drawRect.y) / frameRect.height;
		viewportRect[2] = drawRect.width / frameRect.width;
		viewportRect[3] = drawRect.height / frameRect.height;
	}
*/
	canCull(element){
		if(!this.cullEnabled)return false;
		if(element.layerFlag && !(element.layerFlag & this.layerFlagFilter))return true;
		return element.bound && this.viewFrustum.canCull(element);
	}
/*
	collectDrawUnits(root){
		this.updateViewFrustum();
		for(const entity of root.collectEntities(this)){
			for(const material of entity.getMaterials()){
				this.drawUnitCollector.addEntity({entity, material});
			}
		}
	}
*/
}

Camera3D.prototype.collectDrawUnits = function(){
	const fn = walkTree(function(item){
		if(!item.visible)return true;
		if(this.canCull(item))return true;//need handle sub entitys
		if(item.constructor.name == 'MeshEntity'){
			if(item.castShadow){
				this.drawUnitCollector.addShadowCaster({entity:item});
			}
			for(const material of item.getMaterials()){
				this.drawUnitCollector.addEntity({entity:item, material});
			}
			if(!item.hasAttachment())return;
			const {boneState} = item.skeleton;
			for(const [attachment, boneID] of item.attachmentDict){
				boneState[boneID]
				.copyToMatrix(attachment.worldTransform)
				.prepend(attachment.transform)
				.append(item.worldTransform);
				fn.call(this, attachment, true);
			}
		}else if(item.constructor.name == 'DirectionLight3D'){
			this.drawUnitCollector.addLight(item);
		}
	});
	return function(root){
		this.updateViewFrustum();
		fn.call(this, root, true);
	}
}();

Camera3D.prototype.draw = function(){
	const tempBuffer = new Float32Array(32);
	const groupFn = drawUnit => drawUnit.material.constructor;
	const sortFn = ([a], [b]) => a.order - b.order;
	return function(renderPassEncoder, prevCtx){
		const {drawUnitCollector} = this;

		tempBuffer.set(this.lens.rawData);
		tempBuffer.set(this.worldTransformInvert.rawData, 16);
		//tempBuffer.set(this.viewportRect, 28);

		TextureMaterial.setBindGroup(renderPassEncoder, 0, [{binding:0, resource:{buffer:tempBuffer}}]);
		const groupList = Array.from(Map.groupBy(drawUnitCollector.entityList, groupFn)).sort(sortFn);
		const opaqueList = groupList.filter(v => v[0].opaque);
		const transparentList = groupList.filter(v => !v[0].opaque);
		if(opaqueList.length > 0){
			const {width, height} = Vulkan.canvas;
			const ctx = fetchTextures(Vulkan.canvas);//sub camera area should smaller
			for(let commandEncoder of CommandEncoder(Vulkan.device)){
				for(let renderPassEncoderDeferred of renderPass3D(commandEncoder, ctx.colorView, ctx.normalView, ctx.positionView, ctx.depthView)){
					renderPassEncoderDeferred.setViewport(0, 0, width, height, 0, 1);
					TextureMaterial.setBindGroup(renderPassEncoderDeferred, 0, [{binding:0, resource:{buffer:tempBuffer}}]);
					for(let [materialType, entityList] of opaqueList){
						materialType.draw(entityList, renderPassEncoderDeferred);
					}
				}
			}
			for(let light of drawUnitCollector.lightList){
				light.drawDepthMap(drawUnitCollector.shadowCasterList);
				light.drawDeferred(ctx);
				light.drawShadow(ctx);
			}
			for(let commandEncoder of CommandEncoder(Vulkan.device)){
				commandEncoder.copyTextureToTexture({texture:ctx.lightTexture}, {texture:prevCtx.colorTexture}, Vulkan.canvas);
				commandEncoder.copyTextureToTexture({texture:ctx.depthTexture}, {texture:prevCtx.depthTexture}, ctx);//The entire subresource must be copied when the format (TextureFormat::Depth24PlusStencil8) is a depth/stencil format or the sample count (1) is > 1.
			}
		}else if(prevCtx){
			for(let commandEncoder of CommandEncoder(Vulkan.device)){
				for(let _ of clearPass(commandEncoder, prevCtx.colorView, prevCtx.depthView));
			}
		}
		for(let [materialType, entityList] of transparentList){
			materialType.draw(entityList, renderPassEncoder);
		}
		for(let light of drawUnitCollector.lightList){
			light.drawForward();
		}
		drawUnitCollector.clear();
	};
}();

const renderPass3D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
	},{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
	},{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
	}],
	depthStencilAttachment:{
		depthLoadOp:'clear',//load
		depthClearValue:1,//[0,1],when depthLoadOp is clear
		depthStoreOp:'store',//store
		depthReadOnly:false,
		stencilLoadOp:'clear',//load
		stencilClearValue:0,
		stencilStoreOp:'store',//store
		stencilReadOnly:false,
	}
});

const clearPass = RenderPass({
	colorAttachments:[{loadOp:'clear', clearValue:[0,0,0,0], storeOp:'store'}],
	depthStencilAttachment:{depthLoadOp:'clear', depthClearValue:1, depthStoreOp:'store', stencilLoadOp:'clear', stencilClearValue:0, stencilStoreOp:'store'}
});

/*
x/w => [-1, 1]

x' = (x/w * 0.5 + 0.5) * frameRect.width => [0, frameRect.width]
x' = ((a * x + b)/w * 0.5 + 0.5) * frameRect.width => [drawRect.x, drawRect.x + drawRect.width]

(b/w - a) * 0.5 + 0.5 = drawRect.x / frameRect.width
(b/w + a) * 0.5 + 0.5 = (drawRect.x + drawRect.width) / frameRect.width

a = drawRect.width / frameRect.width
b = ((drawRect.width + 2 * drawRect.x) / frameRect.width - 1) * w;

y/w => [-1, 1]

y' = (y/w * -0.5 + 0.5) * frameRect.height => [frameRect.height, 0]
y' = ((a * y + b)/w * -0.5 + 0.5) * frameRect.height => [drawRect.y + drawRect.height, drawRect.y]

(b/w - a) * -0.5 + 0.5 = (drawRect.y + drawRect.height) / frameRect.height
(b/w + a) * -0.5 + 0.5 = drawRect.y / frameRect.height

a = drawRect.height / frameRect.height
b = (1 - (drawRect.height + 2 * drawRect.y) / frameRect.height) * w
*/

module.exports = Camera3D;
