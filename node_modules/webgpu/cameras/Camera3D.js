'use strict';

const DisplayObject3D = require('../DisplayObject3D');
const ViewFrustum = require('./ViewFrustum');
const Material = require('../materials/Material');
const DrawUnitCollector3D = require('./DrawUnitCollector3D');
const {walkTree} = require('utils/traverseTree');
const Light3D = require('../lights/Light3D');
const Plane = require('../math/Plane');
const Vector3D = require('../math/Vector3D');
const Pipeline = require('../materials/Pipeline');
const {drawBloom} = require('../helper/BloomDrawer');
const {drawMipmap} = require('../helper/MipmapDrawer');

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.cullEnabled = false;
		this.viewFrustum = new ViewFrustum();
		this.lens = lens;
		this.layerFlagFilter = 0xFFFFFFFF;
		this.viewportRect = new Float32Array([0, 0, 1, 1]);
		this.projectionMatrix = new Array(16);
		this.drawUnitCollector = new DrawUnitCollector3D();
	}

	updateViewFrustum(){
		if(!this.cullEnabled)return;
		const {projectionMatrix} = this;
		const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23] = this.worldTransformInvert.rawData;
		const [b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23, b30, b31, b32, b33] = this.lens.rawData;

		projectionMatrix[ 0] = a00 * b00;
		projectionMatrix[ 1] = a01 * b00;
		projectionMatrix[ 2] = a02 * b00;
		projectionMatrix[ 3] = a03 * b00;

		projectionMatrix[ 4] = a10 * b11;
		projectionMatrix[ 5] = a11 * b11;
		projectionMatrix[ 6] = a12 * b11;
		projectionMatrix[ 7] = a13 * b11;

		projectionMatrix[ 8] = a20 * b22;
		projectionMatrix[ 9] = a21 * b22;
		projectionMatrix[10] = a22 * b22;
		projectionMatrix[11] = a23 * b22 + b23;

		projectionMatrix[12] = a20 * b32;
		projectionMatrix[13] = a21 * b32;
		projectionMatrix[14] = a22 * b32;
		projectionMatrix[15] = a23 * b32 + b33;

		this.viewFrustum.update(this);
	}
/*
	setViewport(frameRect, drawRect){
		const {viewportRect} = this;

		viewportRect[0] = (drawRect.width + 2 * drawRect.x) / frameRect.width - 1;
		viewportRect[1] = 1 - (drawRect.height + 2 * drawRect.y) / frameRect.height;
		viewportRect[2] = drawRect.width / frameRect.width;
		viewportRect[3] = drawRect.height / frameRect.height;
	}
*/
	canCull(element){
		if(!this.cullEnabled)return false;
		if(element.layerFlag && !(element.layerFlag & this.layerFlagFilter))return true;
		return element.bound && this.viewFrustum.canCull(element);
	}
/*
	collectDrawUnits(root){
		this.updateViewFrustum();
		for(const entity of root.collectEntities(this)){
			for(const material of entity.getMaterials()){
				this.drawUnitCollector.addEntity({entity, material});
			}
		}
	}
*/
}

Camera3D.prototype.collectDrawUnits = function(){
	const fn = walkTree(function(item){
		if(!item.visible)return true;
		if(this.canCull(item))return true;//need handle sub entitys
		if(item.constructor.name == 'MeshEntity'){
			for(const material of item.getMaterials()){
				this.drawUnitCollector.addEntity({entity:item, material});
				if(item.castShadow){
					this.drawUnitCollector.addShadowCaster({entity:item, material});
				}
				if(material.constructor.name == 'MirrorMaterial'){
					this.drawUnitCollector.addMirror({entity:item, material});
				}
			}
		}else if(item instanceof Light3D){
			this.drawUnitCollector.addLight(item);
		}
	});
	return function(root){
		this.updateViewFrustum();
		fn.call(this, root, true);
	}
}();

Camera3D.prototype.draw = function(){
	const tempBuffer = new Float32Array(32);
	const groupFn = drawUnit => drawUnit.material.constructor;
	const sortFn = ([a], [b]) => a.order - b.order;
	const tempPlane = [0,0,0,0];
	const plane = new Plane();
	const tempPt1 = new Vector3D();
	const tempPt2 = new Vector3D();
	return function(renderPassEncoder, prevCtx){
		const {drawUnitCollector} = this;
		//const tempBuffer = new Float32Array(32);
		/*
		if(drawUnitCollector.mirrorList.length > 0){
			for(let commandEncoder of renderPassEncoder.createCommandEncoder()){
				for(let {entity, material} of drawUnitCollector.mirrorList){
					const [a, b, c, d] = entity.worldTransformInvert.transformPlane([0,1,0,0], tempPlane);
					plane.setTo(a, b, c, -d);
					tempPt1.setTo(this.x, this.y, this.z);
					plane.mirror(tempPt1, tempPt2);
					material.camera.moveTo(tempPt2.x, tempPt2.y, tempPt2.z);
					material.camera.drawUnitCollector = drawUnitCollector.clone();
					material.camera.drawUnitCollector.mirrorList.length = 0;
					material.camera.drawUnitCollector.entityList = material.camera.drawUnitCollector.entityList.filter(v => v.entity != entity);
					
					const ctx = fetchTextures(renderPassEncoder, renderPassEncoder.device);
					material.texture = ctx.colorView;
					for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store;load+discard;load+discard', ctx.colorView, ctx.depthStencilView)){
						renderPassEncoder.setViewportToCanvas();
						material.camera.draw(renderPassEncoder, ctx);
					}
				}
			}
		}
		*/
		tempBuffer.set(this.lens.rawData);
		tempBuffer.set(this.worldTransformInvert.rawData, 16);
		renderPassEncoder.setResources({
			'vpMatrix': {buffer:tempBuffer},
			'worldMatrixList': {buffer:renderPassEncoder.data.worldMatrixList},
			'boneStateTexture': renderPassEncoder.data.boneStateTexture
		});

		const groupList = Array.from(Map.groupBy(drawUnitCollector.entityList, groupFn)).sort(sortFn);
		const opaqueList = groupList.filter(v => v[0].opaque);
		const transparentList = groupList.filter(v => !v[0].opaque);

		if(opaqueList.length > 0){
			for(let commandEncoder of renderPassEncoder.createCommandEncoder()){
				const textureSize = commandEncoder;
				const colorTexture = commandEncoder.fetchTempTexture(textureSize, 'bgra8unorm,0x17');
				const lightTexture = commandEncoder.fetchTempTexture(textureSize, 'bgra8unorm,0x17');
				const normalTexture = commandEncoder.fetchTempTexture(textureSize, 'rgba16float,0x17');
				const emissiveTexture = commandEncoder.fetchTempTexture(textureSize, 'rgba16float,0x17');

				const colorView = commandEncoder.fetchTextureView(colorTexture);
				const normalView = commandEncoder.fetchTextureView(normalTexture);
				const emissiveView = commandEncoder.fetchTextureView(emissiveTexture);
				const depthStencilView = commandEncoder.fetchTextureView(prevCtx.depthTexture);
				const depthView = commandEncoder.fetchTextureView(prevCtx.depthTexture, '2d,depth-only');
				const lightView = commandEncoder.fetchTextureView(lightTexture);

				for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store:[0,0,0,0]+store:[0,0,0,0]+store;1+store;0+store', colorView, normalView, emissiveView, depthStencilView)){
					renderPassEncoder.setResources({
						'vpMatrix': {buffer:tempBuffer},
						'worldMatrixList': {buffer:renderPassEncoder.data.worldMatrixList},
						'boneStateTexture': renderPassEncoder.data.boneStateTexture
					});
					for(let [materialType, entityList] of opaqueList){
						materialType.draw(entityList, renderPassEncoder);
					}
				}
				for(let _ of commandEncoder.beginRenderPass('[0,0,0,0]+store', lightView));
				drawBloom(commandEncoder, emissiveTexture);
				for(let light of drawUnitCollector.lightList){
					light.drawDepthMap(commandEncoder, drawUnitCollector.shadowCasterList, this);
					light.drawDeferred(commandEncoder, lightView, depthView, normalView);
				}
				for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store', commandEncoder.fetchTextureView(prevCtx.colorTexture))){
					renderPassEncoder.drawQuadWith(mergeFn, {'baseTexture': colorView, 'lightTexture': lightView, 'emissiveTexture':emissiveView});
				}
			}
		}else if(prevCtx){
			for(let commandEncoder of renderPassEncoder.createCommandEncoder()){
				for(let _ of commandEncoder.beginRenderPass('[0,0,0,0]+store;1+store;0+store', commandEncoder.fetchTextureView(prevCtx.colorTexture), commandEncoder.fetchTextureView(prevCtx.depthTexture)));
			}
		}
		for(let [materialType, entityList] of transparentList){
			materialType.draw(entityList, renderPassEncoder);
		}
		for(let light of drawUnitCollector.lightList){
			light.drawForward();
		}
		drawUnitCollector.clear();
	};
}();

Camera3D.prototype.drawPick = function(){
	const vpMatrix = new Float32Array(32);
	const groupFn = drawUnit => drawUnit.material.constructor;
	const findFn = v => v.mouseChildren === false;
	const fn = walkTree(function(item, result, picking, stack){
		if(!item.visible)return true;
		stack.push(item);
		//if(this.canCull(item))return true;//need handle sub entitys
		picking.register(item);
		if(item.constructor.name == 'MeshEntity'){
			for(const material of item.getMaterials()){
				const {pick} = material;
				if(!pick)continue;
				const mouseTarget = stack.find(findFn);
				if(mouseTarget)item.pickID = mouseTarget.pickID;
				result.push({entity:item, material:pick});
			}
		}
	}, function(item, result, picking, stack){
		stack.pop();
	});
	const pickList = [];
	const stack = [];
	return function(renderPassEncoder, root, rect, picking){
		pickList.length = 0;
		fn(root, false, pickList, picking, stack);
		if(pickList.length <= 0)return;
		const {width, height} = renderPassEncoder;
		vpMatrix.set(this.lens.offset(width, height, rect.x, rect.y, rect.width, rect.height));
		vpMatrix.set(this.worldTransformInvert.rawData, 16);
		renderPassEncoder.setResources({
			'vpMatrix': {buffer:vpMatrix},
			'worldMatrixList': {buffer:renderPassEncoder.data.worldMatrixList},
			'boneStateTexture': renderPassEncoder.data.boneStateTexture
		});
		for(let [materialType, drawUnitList] of Map.groupBy(pickList, groupFn)){
			materialType.draw(drawUnitList, renderPassEncoder);
		}
	}
}();

const mergeFn = Pipeline.Blit([[
	{name:'baseTexture', texture:{}},
	{name:'lightTexture', texture:{}},
	{name:'emissiveTexture', texture:{}},
	{name:'g_sampler', sampler:{}, default:{minFilter:'linear',magFilter:'linear',mipmapFilter:'linear'}},
]], {format: 'bgra8unorm'}, `

	fn ACESToneMapping(color0:vec3<f32>, adapted_lum:vec3<f32>) -> vec3<f32> {
		const A = 2.51f;
		const B = 0.03f;
		const C = 2.43f;
		const D = 0.59f;
		const E = 0.14f;
		let color = color0 * adapted_lum;
		return (color * (A * color + B)) / (color * (C * color + D) + E);
	}

	@fragment{
		let uv = uvxy.xy;
		let emissive = textureSampleLevel(emissiveTexture, g_sampler, uv, 0);
		let baseColor = textureSample(baseTexture, g_sampler, uv);
		let lightColor = textureSample(lightTexture, g_sampler, uv);
		return vec4(/*baseColor.rgb */ lightColor.rgb + ACESToneMapping(emissive.rgb, vec3<f32>(1)), baseColor.a);
	}
/*
	@fragment
	fn mainFragment(@builtin(position) frag_coord: vec4<f32>) -> @location(0) vec4<f32> {
		let coords = vec2<u32>(frag_coord.xy);
		let baseColor = textureLoad(texture_color, coords, 0);
		let lightColor = textureLoad(texture_light, coords, 0);
		//return vec4<f32>(baseColor.rgb, baseColor.a);
		return vec4<f32>(/*baseColor.rgb */ lightColor.rgb, baseColor.a);
	}
	*/
`);

//const uv_scale = new Float32Array(2);



/*
x/w => [-1, 1]

x' = (x/w * 0.5 + 0.5) * frameRect.width => [0, frameRect.width]
x' = ((a * x + b)/w * 0.5 + 0.5) * frameRect.width => [drawRect.x, drawRect.x + drawRect.width]

(b/w - a) * 0.5 + 0.5 = drawRect.x / frameRect.width
(b/w + a) * 0.5 + 0.5 = (drawRect.x + drawRect.width) / frameRect.width

a = drawRect.width / frameRect.width
b = ((drawRect.width + 2 * drawRect.x) / frameRect.width - 1) * w;

y/w => [-1, 1]

y' = (y/w * -0.5 + 0.5) * frameRect.height => [frameRect.height, 0]
y' = ((a * y + b)/w * -0.5 + 0.5) * frameRect.height => [drawRect.y + drawRect.height, drawRect.y]

(b/w - a) * -0.5 + 0.5 = (drawRect.y + drawRect.height) / frameRect.height
(b/w + a) * -0.5 + 0.5 = drawRect.y / frameRect.height

a = drawRect.height / frameRect.height
b = (1 - (drawRect.height + 2 * drawRect.y) / frameRect.height) * w
*/

module.exports = Camera3D;
