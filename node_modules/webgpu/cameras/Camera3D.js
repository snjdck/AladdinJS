'use strict';

const DisplayObject3D = require('../DisplayObject3D');
const ViewFrustum = require('./ViewFrustum');

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.cullEnabled = false;
		this.viewFrustum = new ViewFrustum();
		this.lens = lens;
		this.layerFlagFilter = 0xFFFFFFFF;
		this.viewportRect = new Float32Array([0, 0, 1, 1]);
		this.projectionMatrix = new Array(16);
	}

	updateViewFrustum(){
		const {projectionMatrix} = this;
		const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23] = this.worldTransformInvert.rawData;
		const [b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23, b30, b31, b32, b33] = this.lens.rawData;

		projectionMatrix[ 0] = a00 * b00;
		projectionMatrix[ 1] = a01 * b00;
		projectionMatrix[ 2] = a02 * b00;
		projectionMatrix[ 3] = a03 * b00;

		projectionMatrix[ 4] = a10 * b11;
		projectionMatrix[ 5] = a11 * b11;
		projectionMatrix[ 6] = a12 * b11;
		projectionMatrix[ 7] = a13 * b11;

		projectionMatrix[ 8] = a20 * b22;
		projectionMatrix[ 9] = a21 * b22;
		projectionMatrix[10] = a22 * b22;
		projectionMatrix[11] = a23 * b22 + b23;

		projectionMatrix[12] = a20 * b32;
		projectionMatrix[13] = a21 * b32;
		projectionMatrix[14] = a22 * b32;
		projectionMatrix[15] = a23 * b32 + b33;

		if(!this.cullEnabled)return;
		this.viewFrustum.update(this);
	}

	setViewport(frameRect, drawRect){
		const {viewportRect} = this;

		viewportRect[0] = (drawRect.width + 2 * drawRect.x) / frameRect.width - 1;
		viewportRect[1] = 1 - (drawRect.height + 2 * drawRect.y) / frameRect.height;
		viewportRect[2] = drawRect.width / frameRect.width;
		viewportRect[3] = drawRect.height / frameRect.height;
	}

	canCull(element){
		if(!this.cullEnabled)return false;
		if(element.layerFlag && !(element.layerFlag & this.layerFlagFilter))return true;
		if(!element.bound)return false;
		return this.viewFrustum.canCull(element.bound);
	}
}

/*
x/w => [-1, 1]

x' = (x/w * 0.5 + 0.5) * frameRect.width => [0, frameRect.width]
x' = ((a * x + b)/w * 0.5 + 0.5) * frameRect.width => [drawRect.x, drawRect.x + drawRect.width]

(b/w - a) * 0.5 + 0.5 = drawRect.x / frameRect.width
(b/w + a) * 0.5 + 0.5 = (drawRect.x + drawRect.width) / frameRect.width

a = drawRect.width / frameRect.width
b = ((drawRect.width + 2 * drawRect.x) / frameRect.width - 1) * w;

y/w => [-1, 1]

y' = (y/w * -0.5 + 0.5) * frameRect.height => [frameRect.height, 0]
y' = ((a * y + b)/w * -0.5 + 0.5) * frameRect.height => [drawRect.y + drawRect.height, drawRect.y]

(b/w - a) * -0.5 + 0.5 = (drawRect.y + drawRect.height) / frameRect.height
(b/w + a) * -0.5 + 0.5 = drawRect.y / frameRect.height

a = drawRect.height / frameRect.height
b = (1 - (drawRect.height + 2 * drawRect.y) / frameRect.height) * w
*/

void function(){
	const Vulkan = require('../Vulkan');
	const BufferBindGroup = require('../helper/BufferBindGroup');
	const IndexDistributor = require('../helper/IndexDistributor');
	const renderDrawUnits = require('../helper/renderDrawUnits');
	const {deferBunchDo} = require('../../utils/function/deferDo');

	const bytePerInstance = 8 * 4 * 4;
	const maxCameraCount = 100;

	const bufferBindGroup = new BufferBindGroup([
		[GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, bytePerInstance * maxCameraCount],
	], buffer => [
		['0', {buffer}, Vulkan.getSampler('linear_repeat')],
		['2', {buffer}],
	]);

	const [addDrawTask, runDrawTask] = deferBunchDo(function(drawUnits){
		Vulkan.renderPassEncoder.setBindGroup(0, bufferBindGroup.getBindGroup());
		renderDrawUnits(drawUnits);
	});
	const indexDistributor = new IndexDistributor();

	Camera3D.collectDrawUnits = function(camera, root){
		const cameraIndex = indexDistributor.getIndex(camera);
		const uniformBuffer = bufferBindGroup.getBuffer();
		const offset = bytePerInstance * cameraIndex;

		Vulkan.copyDataToBuffer(uniformBuffer, camera.lens.rawData, offset);
		Vulkan.copyDataToBuffer(uniformBuffer, camera.worldTransformInvert.rawData, offset + 64);
		Vulkan.copyDataToBuffer(uniformBuffer, camera.viewportRect, offset + 112);

		camera.updateViewFrustum();
		for(const entity of root.collectEntities(camera)){
			for(const material of entity.getMaterials()){
				addDrawTask({entity, material, cameraIndex});
			}
		}
	}

	Camera3D.draw = function(){
		Vulkan.requestReset(indexDistributor);
		runDrawTask();
	}
}();

module.exports = Camera3D;
