'use strict';

const Vector3D = require('../math/Vector3D');

const newPlane = () => Array(4).fill(0);
const tempPlane = newPlane();

class ViewFrustum
{
	constructor(){
		this.planeList = Array.from({length:6}, newPlane);
	}

	update(camera, l=-1, b=-1, r=1, t=1){
		const {projectionMatrix} = camera;
		const {planeList} = this;
		for(let i=0; i<4; ++i){
			const x = projectionMatrix[i];
			const y = projectionMatrix[i+4];
			//const z = projectionMatrix[i+8];
			const w = projectionMatrix[i+12];
			planeList[0][i] = x - w * l;
			planeList[1][i] = r * w - x;
			planeList[2][i] = y - w * b;
			planeList[3][i] = t * w - y;
			//planeList[4][i] = z;
			//planeList[5][i] = w - z;
		}
	}

	canCull({bound, worldTransform}){
		const {minX, minY, minZ, maxX, maxY, maxZ} = bound;
		for(let i=0; i<4; ++i){
			const [a, b, c, d] = worldTransform.transformPlane(this.planeList[i], tempPlane);
			if(
				a * (a > 0 ? maxX : minX) + 
				b * (b > 0 ? maxY : minY) + 
				c * (c > 0 ? maxZ : minZ) + 
				d < 0
			)return true;
		}
		return false;
	}
/*
	canCull({bound, worldTransformInvert}){
		const {minX, minY, minZ, maxX, maxY, maxZ} = bound;
		for(let i=0; i<4; ++i){
			let [a, b, c, d] = this.planeList[i];
			direction.setTo(a, b, c);
			worldTransformInvert.transformCoordsDelta(direction);
			worldTransformInvert.getTranslation(translation);
			a = direction.x;
			b = direction.y;
			c = direction.z;
			d -= direction.dotProd(translation);
			if(
				a * (a > 0 ? maxX : minX) + 
				b * (b > 0 ? maxY : minY) + 
				c * (c > 0 ? maxZ : minZ) + 
				d < 0
			)return true;
		}
		return false;
	}
*/
}

module.exports = ViewFrustum;