'use strict';

const DisplayObject = require('./DisplayObject');
const Matrix2D = require('./math/Matrix2D');
const {Rect} = require('utils/MaxRectsBinPack');
const RADIAN = Math.PI / 180;
const {walkTree} = require('utils/traverseTree');
const Signal = require('mvc/node_modules/signal');

class DisplayObject2D extends DisplayObject
{
	constructor(){
		super(Matrix2D);
		this.mouseDownSignal = new Signal();
		this.mouseUpSignal = new Signal();
		this.mouseOverSignal = new Signal();
		this.mouseOutSignal = new Signal();

		this.$addAttributeNumber('x', 0);
		this.$addAttributeNumber('y', 0);
		this.$addAttributeNumber('rotation', 0);
		this.$addAttributeNumber('scaleX', 1);
		this.$addAttributeNumber('scaleY', 1);
		this.$addAttributeTransform(value => Matrix2D.compose(value, this.scaleX, this.scaleY, this.rotation * RADIAN, this.x, this.y));
	}

	set scale(value){
		this.scaleX = this.scaleY = value;
	}

	addChild(child, index=this.numChildren){
		console.assert(0 <= index && index <= this.numChildren);

		if(child.parent){
			if(child.parent === this){
				this.setChildIndex(child, Math.min(index, this.numChildren-1));
				return child;
			}
			child.parent.removeChild(child);
		}

		this.children.splice(index, 0, child);
		return super.addChild(child);
	}

	removeChild(child){
		if(!child)return;
		const index = this._children.indexOf(child);
		if(index < 0)return;
		this._children.splice(index, 1);
		return super.removeChild(child);
	}

	removeChildAt(index){
		return this.removeChild(this._children[index]);
	}

	getChildAt(index){
		console.assert(0 <= index && index < this.numChildren);
		return this._children[index];
	}

	getChildIndex(child){
		return this._children.indexOf(child);
	}

	setChildIndex(child, index){
		console.assert(0 <= index && index < this.numChildren);
		let prevIndex = this.getChildIndex(child);
		if(prevIndex < 0 || prevIndex === index)return;
		let {_children} = this;
		_children.splice(prevIndex, 1);
		_children.splice(index, 0, child);
	}

	swapChildren(child1, child2){
		this.swapChildrenAt(this.getChildIndex(child1), this.getChildIndex(child2));
	}

	swapChildrenAt(index1, index2){
		if(index1 === index2)return;
		let {_children} = this;
		let child1 = _children[index1];
		let child2 = _children[index2];
		if(child1 && child2){
			_children[index1] = child2;
			_children[index2] = child1;
		}
	}

	get bottomChild(){
		return this.getChildAt(0);
	}

	get topChild(){
		return this.getChildAt(this.numChildren-1);
	}

	swapChildToTop(child){
		let childIndex = getChildIndex(child);
		if(childIndex < 0)return;
		let lastIndex = this.numChildren - 1;
		if(childIndex < lastIndex){
			this.swapChildrenAt(childIndex, lastIndex);
		}
	}

	swapChildToBottom(child){
		let childIndex = this.getChildIndex(child);
		if(childIndex > 0){
			this.swapChildrenAt(childIndex, 0);
		}
	}
}

DisplayObject2D.prototype.getBoundingRect = function(){
	const matrix = new Matrix2D();
	const rectList = [];
	const collectRectList = walkTree(function(item){
		if(!item.visible)return true;
		switch(item.type){
			case 'bitmap': case 'bitmap3d': break;
			default: return;
		}
		item.calculateRelativeTransform(this, matrix);
		rectList.push(matrix.transformBound(new Rect(item.width, item.height)));
	});
	return function(){
		collectRectList.call(this, this);
		const rect = Rect.Merge(rectList);
		rectList.length = 0;
		return rect;
	};
}();

void function(proto, pt, setXY, dx, dy, dragController){
	proto.startDrag = function(x, y, positionFn=setXY){
		if(dragController)return;
		dragController = new AbortController();
		this.parent.worldTransformInvert.transformCoords(x, y, pt);
		dx = this.x - pt.x;
		dy = this.y - pt.y;
		window.addEventListener('mousemove', evt => {
			this.parent.worldTransformInvert.transformCoords(evt.x, evt.y, pt);
			positionFn.call(this, pt.x + dx, pt.y + dy);
		}, {signal: dragController.signal});
	}
	proto.stopDrag = function(x, y, positionFn=setXY){
		if(!dragController)return;
		dragController.abort();
		dragController = null;
		this.parent.worldTransformInvert.transformCoords(x, y, pt);
		positionFn.call(this, pt.x + dx, pt.y + dy);
	}
}(DisplayObject2D.prototype, {}, function(x, y){
	this.x = x;
	this.y = y;
});

module.exports = DisplayObject2D;
