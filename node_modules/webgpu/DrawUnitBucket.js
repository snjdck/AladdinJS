'use strict';

const ObjectCache = require('utils/ObjectCache');
const ObjectBucket = require('ds/ObjectBucket');

const mapObjCache = new ObjectCache(() => new Map(), v => v.clear());

const Vulkan = require('./Vulkan');

class DrawUnitBucket extends ObjectBucket
{
	constructor(){
		super();
		this.regKeyFn(getMaterialType, updateMaterialType, sortMaterialType);
		this.regKeyFn(getMesh, updateMesh);
	}

	newMap(){
		return mapObjCache.getOut();
	}

	add(element, override){
		if(!element.visible)return true;
		if(element.attachmentDict){
			for(const [attachment, boneName] of element.attachmentDict){
				this.add(attachment);
				const {worldTransform} = attachment;
				worldTransform.copyFrom(element.skeleton.rootBone.getBoneWorldMatrix(boneName));
				worldTransform.prepend(attachment.transform);
				worldTransform.append(element.worldTransform);
			}
		}
		if(!element.materialDict)return;
		for(const materialType of element.materialDict.keys()){
			super.add(element, materialType);
		}
	}

	clear(){
		super.clear();
		mapObjCache.putAllIn();
	}

	draw(){
		this.forEach(this.onMaterialDraw, this);
		return this;
	}

	onMaterialDraw(entityList){
		Vulkan.currentMaterial.draw(entityList);
	}
}

const sortMaterialType = (fn => list => list.sort(fn))((a, b) => a.order - b.order);

function getMaterialType(drawUnit, key){
	let material = drawUnit.getMaterial(key);
	//let material = key ? drawUnit[key] : drawUnit.material;
	return material.constructor;
}

function getMesh(drawUnit, key){
	return key.useMeshFlag ? drawUnit.mesh : null;
}

function updateMaterialType(materialType){
	const {renderPassEncoder} = Vulkan;
	Vulkan.currentMaterial = materialType;
	renderPassEncoder.setPipeline(materialType.pipeline);
}

function updateMesh(mesh){
	Vulkan.currentMesh = mesh;
	if(!mesh)return;
	const {currentMaterial} = Vulkan;
	currentMaterial.setVertexBuffer();
	currentMaterial.setIndexBuffer();
}

module.exports = DrawUnitBucket;
