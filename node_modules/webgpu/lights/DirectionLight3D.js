"use strict";

const Vulkan = require('../Vulkan');
const {createDepthDrawFn} = require('../helper/RectDrawer');
const {CommandEncoder, beginRenderPass} = require('../helper/CommandEncoder');
const {fetchViewForDepth} = require('../Vulkan/resource');
const {DepthMaterial} = require('../materials/DepthMaterial');
const Lens = require('../cameras/Lens');
const Camera3D = require('../cameras/Camera3D');
const Quaternion = require('../math/Quaternion');
const {RADIAN} = require('../math');
const Light3D = require('./Light3D');

const width = 4096;
const height = 4096;

class DirectionLight3D extends Light3D
{
	constructor(){
		super();

		this.camera = new Camera3D(new Lens.Ortho(width, height, -2000, 10000));
		this.camera.rotation = new Quaternion().fromEulerAngles(135 * RADIAN, 0, -90 * RADIAN);
	}

	drawForward(){

	}

	drawDeferred(ctx){
		const {width, height} = Vulkan.canvas;
		uv_scale[0] = width / ctx.width;
		uv_scale[1] = height / ctx.height;
		for(let commandEncoder of CommandEncoder(Vulkan.device)){
			for(let renderPassEncoder of beginRenderPass('load+store', commandEncoder, ctx.lightView)){
				renderPassEncoder.setViewport(0, 0, width, height, 0, 1);
				drawFn(renderPassEncoder, {
					'depthTexture': ctx.depthView,
					'normalTexture': ctx.normalView,
					'lightDepthTexture': this.depthView,
					'cameraMatrixList':{buffer:tempBuffer},
					'uvScale': {buffer:uv_scale}
				});
			}
		}
	}

	drawShadow(ctx){
		//tempBuffer.set(this.lens.rawData);
		//tempBuffer.set(this.worldTransformInvert.rawData, 16);
	}

	drawShadowMap(root){
		this.camera.render(root, collectShadowUnits);
	}

	drawDepthMap(shadowCasterList, viewCamera){
		this.camera.moveTo(viewCamera.x, viewCamera.y, viewCamera.z);

		tempBuffer.set(this.camera.lens.rawData, 0);
		tempBuffer.set(this.camera.worldTransformInvert.rawData, 16);

		tempBuffer.set(viewCamera.lens.matrixInvert, 32);
		tempBuffer.set(viewCamera.worldTransform.rawData, 32+16);

		const {depthView, depthStencilView} = fetchViewForDepth({width, height});
		this.depthView = depthView;

		for(let commandEncoder of CommandEncoder(Vulkan.device)){
			for(let renderPassEncoder of beginRenderPass(';1+store', commandEncoder, depthStencilView)){
				renderPassEncoder.setViewport(0, 0, width, height, 0, 1);
				DepthMaterial.setResources(renderPassEncoder, {'vpMatrix': {buffer:tempBuffer}});
				DepthMaterial.draw(shadowCasterList, renderPassEncoder);
			}
		}
	}
}

const tempBuffer = new Float32Array(64);
const uv_scale = new Float32Array(2);

const drawFn = createDepthDrawFn('2d', `
	var dir = vec3<f32>(1,0,1);
	dir = normalize(dir);
	let myDepth = textureSample(texture_position, sampler_non_filtering, uv);
	let tt = vec4<f32>(position, myDepth, 1) * light[1].screenMatrix;
	let worldPosition = vec4<f32>(tt.xyz / tt.w, 1) * light[1].cameraMatrix;
	
	let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1) * light[0].cameraMatrix;
	let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * light[0].screenMatrix;
	let depth_uv = (vec2(screenPosition.x, -screenPosition.y) / screenPosition.w + 1) * 0.5;

	//depth_ref <= the sampled depth
	let depth_value = textureSampleCompare(texture_depth, sampler_depth, depth_uv, screenPosition.z / screenPosition.w - 0.001);

	let normal = calcNormal(textureSample(texture_normal, sampler_non_filtering, uv).xy);
	let factor = dot(normal, dir);
	//let baseColor = textureSample(texture_color, sampler_filtering, uv);

	//return vec4<f32>(/*baseColor.rgb + */vec3(factor * depth_value), 1);
	return vec4<f32>(vec3<f32>(0.5) * factor * depth_value, 1);
`);

module.exports = DirectionLight3D;