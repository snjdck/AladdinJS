"use strict";

const Vulkan = require('../Vulkan');
const DisplayObject3D = require('../DisplayObject3D');
const {pipeline} = require('../materials/LightPass');
const {CommandEncoder, RenderPass} = require('../helper/CommandEncoder');
const {fetchTextures} = require('../Vulkan/resource');

class DirectionLight3D extends DisplayObject3D
{
	constructor(){
		super();
		this.type = 'light';

		let w = 2048;
		let h = 2048;
		this.direction = 0;
/*
		let lens = Lens.OrthoLH(w, h, -1000, 1000);
		let camera = new Camera3D(lens);
		let rotation = camera.transform.rotation;
		rotation.rotateAxisX(120 * Math.PI / 180);
		rotation.rotateAxisZ(-90 * Math.PI / 180);
		camera.rotation = rotation;
		camera.clearFlags = ClearFlags.Depth();
		camera.renderTarget = new DepthRenderTarget(w, h);
		this.camera = camera;
*/
	}

	drawForward(){

	}

	drawDeferred(ctx){
		const {width, height} = Vulkan.canvas;
		uv_scale[0] = width / ctx.width;
		uv_scale[1] = height / ctx.height;
		for(let commandEncoder of CommandEncoder(Vulkan.device)){
			for(let renderPassEncoder of renderPass3D(commandEncoder, ctx.lightView)){
				renderPassEncoder.setViewport(0, 0, width, height, 0, 1);
				pipeline.setPipeline(renderPassEncoder);
				pipeline.setBindGroup(renderPassEncoder, 0, [
					{binding:0, resource:ctx.positionView},
					{binding:1, resource:ctx.normalView},
					{binding:2, resource:ctx.colorView},
				]);
				pipeline.setVertexBuffer(renderPassEncoder, 0, uv_scale);
				renderPassEncoder.draw(4);//quad
			}
		}
	}

	drawShadow(ctx){

	}

	drawShadowMap(root){
		this.camera.render(root, collectShadowUnits);
	}
}

const uv_scale = new Float32Array(2);

const renderPass3D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
	}]
});

const clearPass = RenderPass({
	colorAttachments:[{loadOp:'clear', clearValue:[0,0,0,0], storeOp:'store'}],
	depthStencilAttachment:{depthLoadOp:'clear', depthClearValue:1, depthStoreOp:'store', stencilLoadOp:'clear', stencilClearValue:0, stencilStoreOp:'store'}
});

function collectShadowUnits(node){
	if(node.castShadow && node.drawUnitCache){
		let drawUnit = node.drawUnitCache.getOut();
		drawUnit.material = DepthMaterial.new();
		this.addDrawUnit(drawUnit);
	}
}

module.exports = DirectionLight3D;