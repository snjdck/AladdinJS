"use strict";

const {createDepthDrawFn} = require('../helper/RectDrawer');
const Material = require('../materials/Material');
const Lens = require('../cameras/Lens');
const Camera3D = require('../cameras/Camera3D');
const Quaternion = require('../math/Quaternion');
const Vector3D = require('../math/Vector3D');
const {RADIAN} = require('../math');
const Light3D = require('./Light3D');

const width = 4096;
const height = 4096;

class DirectionLight3D extends Light3D
{
	constructor(){
		super();

		this.camera = new Camera3D(new Lens.Ortho(width, height, -2000, 10000));
		this.camera.rotation = new Quaternion().fromEulerAngles(135 * RADIAN, 0, -90 * RADIAN);
		this.direction = new Vector3D(1, 0, 1).normalize();
		this.color = [0.5, 0.5, 0.5];
	}

	drawForward(){

	}

	drawDeferred(commandEncoder, lightView, depthView, normalView){
			for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store', lightView)){
				renderPassEncoder.drawQuadWith(drawFn, {
					'depthTexture': depthView,
					'normalTexture': normalView,
					'lightDepthTexture': this.depthView,
					'cameraMatrixList':{buffer:tempBuffer},
					//'uvScale': {buffer:uv_scale}
				});
			}
	}

	drawShadow(ctx){
		//tempBuffer.set(this.lens.rawData);
		//tempBuffer.set(this.worldTransformInvert.rawData, 16);
	}

	drawShadowMap(root){
		this.camera.render(root, collectShadowUnits);
	}

	drawDepthMap(commandEncoder, shadowCasterList, viewCamera){
		this.camera.moveTo(viewCamera.x, viewCamera.y, viewCamera.z);

		tempBuffer.set(this.camera.lens.rawData, 0);
		tempBuffer.set(this.camera.worldTransformInvert.rawData, 16);

		tempBuffer.set(viewCamera.lens.matrixInvert, 32);
		tempBuffer.set(viewCamera.worldTransform.rawData, 32+16);

		tempBuffer.set(this.color, 64);
		tempBuffer.set(this.direction.copyToArray(tempArray), 68);

		const depthTexture = commandEncoder.fetchTempTexture({width, height}, '2d,depth32float,0x14,1');
		const depthView = commandEncoder.fetchTextureView(depthTexture, '2d,depth-only');
		const depthStencilView = commandEncoder.fetchTextureView(depthTexture);

		this.depthView = depthView;

			for(let renderPassEncoder of commandEncoder.beginRenderPass(';1+store', depthStencilView)){
				renderPassEncoder.setResources({'vpMatrix': {buffer:tempBuffer}});
				Material.drawDepth(renderPassEncoder, shadowCasterList);
			}
	}
}

const tempBuffer = new Float32Array(64 + 8);
const tempArray = [];
//const uv_scale = new Float32Array(2);

const drawFn = createDepthDrawFn('2d', `
fn calcLight(normal_in_world:vec3<f32>, pos_in_light_camera:vec3<f32>, shadow_factor:f32) -> vec4<f32> {
	let viewDirection = vec3<f32>(0, 0, -1) * m34tom33(cameraMatrixList.viewCameraInv.cameraMatrix);
	let factor = vec4<f32>(0, 0, 1, 1);
	let emissive = 0.0;
	let ambient = 0.1;
	let gloss: f32 = 20;//shininess
	let diffuse = saturate(dot(normal_in_world, cameraMatrixList.lightDirection.xyz));
	let specular = pow(saturate(dot(
		reflect(-cameraMatrixList.lightDirection.xyz, normal_in_world),
		viewDirection
	)), gloss);
	let lightValue: f32 = dot(vec4<f32>(emissive, ambient, diffuse, specular), factor);
	return vec4(cameraMatrixList.lightColor.rgb * lightValue * shadow_factor, 1);
}
`);

module.exports = DirectionLight3D;
