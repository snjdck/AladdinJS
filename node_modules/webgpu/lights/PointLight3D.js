"use strict";

const {createDepthDrawFn} = require('../helper/RectDrawer');
const Material = require('../materials/Material');
const Lens = require('../cameras/Lens');
const Camera3D = require('../cameras/Camera3D');
const Light3D = require('./Light3D');
const {drawDepthMap} = require('../helper/CubeTextureDrawer');

const width = 4096;
const height = 4096;
const zNear = 100;
const zFar = 20000;

class PointLight3D extends Light3D
{
	constructor(){
		super();
		this.camera = new Camera3D(new Lens.Perspective(Math.PI / 2, 1, zNear, zFar));
	}

	drawForward(){

	}

	drawDeferred(commandEncoder, lightView, depthView, normalView){
			for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store', lightView)){
				renderPassEncoder.drawQuadWith(drawFn, {
					'depthTexture': depthView,
					'normalTexture': normalView,
					'lightDepthTexture': this.depthView,
					'cameraMatrixList':{buffer:tempBuffer},
				});
			}
	}

	drawShadow(ctx){
		//tempBuffer.set(this.lens.rawData);
		//tempBuffer.set(this.worldTransformInvert.rawData, 16);
	}

	drawShadowMap(root){
		this.camera.render(root, collectShadowUnits);
	}

	drawDepthMap(commandEncoder, shadowCasterList, viewCamera){
		//console.log('shadowCasterList');
		//return
		this.camera.moveTo(this.x, this.y, this.z);

		tempBuffer.set(this.camera.lens.rawData, 0);
		tempBuffer.set(this.camera.worldTransformInvert.rawData, 16);
		tempBuffer.set(viewCamera.lens.matrixInvert, 32);
		tempBuffer.set(viewCamera.worldTransform.rawData, 32+16);

		const depthTexture = commandEncoder.fetchTempTexture({width, height, depthOrArrayLayers:6}, '2d,depth32float,0x14,1');
		const depthView = commandEncoder.fetchTextureView(depthTexture, 'cube,depth-only');
		const depthStencilView = [
			commandEncoder.fetchTextureView(depthTexture, '2d,all,0,1'),
			commandEncoder.fetchTextureView(depthTexture, '2d,all,1,1'),
			commandEncoder.fetchTextureView(depthTexture, '2d,all,2,1'),
			commandEncoder.fetchTextureView(depthTexture, '2d,all,3,1'),
			commandEncoder.fetchTextureView(depthTexture, '2d,all,4,1'),
			commandEncoder.fetchTextureView(depthTexture, '2d,all,5,1')
		];

		this.depthView = depthView;

		for(let [renderPassEncoder, mvp] of drawDepthMap(commandEncoder, this, zNear, zFar, depthStencilView)){
			renderPassEncoder.setResources({'vpMatrix': {buffer:mvp}});
			Material.drawDepth(renderPassEncoder, shadowCasterList);
		}
	}
}

const tempBuffer = new Float32Array(64+8);
//const uv_scale = new Float32Array(2);

const drawFn = createDepthDrawFn('cube', `
fn calcLight(normal_in_world:vec3<f32>, pos_in_light_camera:vec3<f32>, shadow_factor:f32) -> vec4<f32> {
	let normal_factor = max(0, dot(normal_in_world, -normalize(pos_in_light_camera)));

	let lightPower = length(pos_in_light_camera);
	let lightRange = 200000.0;

	return vec4(vec3<f32>(1 - lightPower / lightRange) * normal_factor * shadow_factor * 0.5, 1);
}
`);

module.exports = PointLight3D;