"use strict";

const Vulkan = require('../Vulkan');
const {pipeline} = require('../materials/PointLightPass');
const {CommandEncoder, RenderPass} = require('../helper/CommandEncoder');
const {fetchCubeDepth} = require('../Vulkan/resource');
const {CubeDepthMaterial} = require('../materials/DepthMaterial');
const Lens = require('../cameras/Lens');
const Camera3D = require('../cameras/Camera3D');
const Quaternion = require('../math/Quaternion');
const {RADIAN} = require('../math');
const Light3D = require('./Light3D');

const width = 4096;
const height = 4096;

const rotationList = [
	new Quaternion().fromEulerAngles(0, 90 * RADIAN,  0),//+x
	new Quaternion().fromEulerAngles(0, -90 * RADIAN, 0),//-x
	new Quaternion().fromEulerAngles(-90 * RADIAN, 0, 0),//+y
	new Quaternion().fromEulerAngles(90 * RADIAN, 0, 0),//-y
	new Quaternion().fromEulerAngles(0 , 0,   0),//+z
	new Quaternion().fromEulerAngles(0, 180 * RADIAN, 0),//-z
];

class PointLight3D extends Light3D
{
	constructor(){
		super();
		this.camera = new Camera3D(new Lens.Perspective(Math.PI / 2, 1, 100, 20000));
	}

	drawForward(){

	}

	drawDeferred(ctx){
		//return
		const {width, height} = Vulkan.canvas;
		uv_scale[0] = width / ctx.width;
		uv_scale[1] = height / ctx.height;

		this.camera.rotation = rotationList[4];
		tempBuffer.set(this.camera.worldTransformInvert.rawData, 16);
		
		for(let commandEncoder of CommandEncoder(Vulkan.device)){
			for(let renderPassEncoder of renderPass3D(commandEncoder, ctx.lightView)){
				renderPassEncoder.setViewport(0, 0, width, height, 0, 1);
				pipeline.setPipeline(renderPassEncoder);
				pipeline.setBindGroup(renderPassEncoder, 0, [
					{binding:0, resource:ctx.depthView},
					{binding:1, resource:ctx.normalView},
					{binding:2, resource:ctx.colorView},
					{binding:3, resource:this.depthView},
					{binding:4, resource:{buffer:tempBuffer}},
				]);
				pipeline.setVertexBuffer(renderPassEncoder, 0, uv_scale);
				renderPassEncoder.draw(4);//quad
			}
		}
	}

	drawShadow(ctx){
		//tempBuffer.set(this.lens.rawData);
		//tempBuffer.set(this.worldTransformInvert.rawData, 16);
	}

	drawShadowMap(root){
		this.camera.render(root, collectShadowUnits);
	}

	drawDepthMap(shadowCasterList, viewCamera){
		//console.log('shadowCasterList');
		//return
		this.camera.moveTo(this.x, this.y, this.z);

		tempBuffer.set(this.camera.lens.rawData, 0);

		tempBuffer.set(viewCamera.lens.matrixInvert, 32);
		tempBuffer.set(viewCamera.worldTransform.rawData, 32+16);

		const {depthView, depthStencilView} = fetchCubeDepth({width, height});
		this.depthView = depthView;

		for(let commandEncoder of CommandEncoder(Vulkan.device)){
			for(let i=0; i<6; ++i){
				this.camera.rotation = rotationList[i];
				tempBuffer.set(this.camera.worldTransformInvert.rawData, 16);
				for(let renderPassEncoder of clearDepthPass(commandEncoder, depthStencilView[i])){
					renderPassEncoder.setViewport(0, 0, width, height, 0, 1);
					CubeDepthMaterial.setBindGroup(renderPassEncoder, 0, [{binding:0, resource:{buffer:tempBuffer}}]);
					CubeDepthMaterial.draw(shadowCasterList, renderPassEncoder);
				}
			}
		}
	}
}

const tempBuffer = new Float32Array(64);
const uv_scale = new Float32Array(2);

const renderPass3D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
	}]
});

const clearDepthPass = RenderPass({
	colorAttachments:[],//can't be undefined, will error
	//depthStencilAttachment:{depthLoadOp:'clear', depthClearValue:1, depthStoreOp:'store', stencilLoadOp:'clear', stencilClearValue:0, stencilStoreOp:'store'}
	depthStencilAttachment:{depthLoadOp:'clear', depthClearValue:1, depthStoreOp:'store'}
});


module.exports = PointLight3D;