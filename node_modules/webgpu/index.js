'use strict';

const vertexShaderGLSL = `#version 450
	const vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));
	void main() {
	  gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
	}
`;

const fragmentShaderGLSL = `#version 450
	layout(location = 0) out vec4 outColor;
	void main() {
	  outColor = vec4(1.0, 0.0, 0.0, 1.0);
	}
`;

async function init(){
	const glslangModule = await import('https://unpkg.com/@webgpu/glslang@0.0.7/web/glslang.js');
	const glslang = await glslangModule.default();
	
	const canvas = document.createElement('canvas');
	document.body.appendChild(canvas);
	
	if(!navigator.gpu)return;
	const adapter = await navigator.gpu.requestAdapter();
	const device = await adapter.requestDevice();
	const context = canvas.getContext('gpupresent');
	const swapChainFormat = await context.getSwapChainPreferredFormat(device);
	const swapChain = context.configureSwapChain({
		device,
		format: swapChainFormat,
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT
	});

	const pipelineLayout = device.createPipelineLayout({
		bindGroupLayouts: []
	});

	const pipeline = device.createRenderPipeline({
		layout: pipelineLayout,
		vertexStage: {
			module: device.createShaderModule({
				code: glslang.compileGLSL(vertexShaderGLSL, "vertex"),
			}),
			entryPoint: 'main'
		},
		fragmentStage: {
			module: device.createShaderModule({
				code: glslang.compileGLSL(fragmentShaderGLSL, "fragment"),
			}),
			entryPoint: 'main'
		},
		primitiveTopology: 'triangle-list',
		colorStates:[{
			format: swapChainFormat
		}]
	});

	function frame(){
		requestAnimationFrame(frame);
		const commandEncoder = device.createCommandEncoder();
		const renderPassEncoder = commandEncoder.beginRenderPass({
			colorAttachments: [{
				attachment: swapChain.getCurrentTexture().createView(),
				loadValue: [0, 0, 0, 1]
			}]
		});
		renderPassEncoder.setPipeline(pipeline);
		renderPassEncoder.draw(3, 1, 0, 0);
		renderPassEncoder.endPass();

		device.defaultQueue.submit([commandEncoder.finish()]);
	}
	requestAnimationFrame(frame);
/*
	let buffer = device.createBuffer({size: 4096, usage: GPUBufferUsage.VERTEX});

	let texture = device.createTexture({
		size:{
			width: 100,
			height: 100,
			depth: 1
		},
		//size: [100, 100, 1],
		//dimension: '2d',//1d,3d
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED
	});

	let textureView = texture.createView();

	let sampler = device.createSampler();

	let bindGroupLayout = device.createBindGroupLayout({
		bindings:[{
			binding: 0,
			visibility: 1,
			type: 'uniform-buffer',
			//hasDynamicOffset: false
		},{
			binding: 1,
			visibility: 2,
			type: 'sampled-texture'
		}]
	});

	let bindGroup = device.createBindGroup({
		layout: bindGroupLayout,
		bindings: [{
			binding: 0,
			resource: textureView,
		}]
	});

	let pipelineLayout = device.createPipelineLayout({
		bindGroupLayouts:[bindGroupLayout]
	});

	let shaderModule = device.createShaderModule({
		code: ''
	});

	let pipeline = device.createRenderPipeline({
		layout: pipelineLayout,
		vertexStage: {
			module: shaderModule,
			entryPoint: 'vertex_main'
		},
		fragmentStage:{
			module: shaderModule,
			entryPoint: 'fragment_main'
		},
		primitiveTopology: 'triangle-list',
		colorStates:[{
			format: 'rgba8unorm',
			colorBlend:{
				srcFactor: 'one',
				dstFactor: 'zero',
				operation: 'add'
			},
			writeMask: 0xF
		}],
		//depthStencilState:'',
		vertexState: {
			indexFormat: 'uint16',
			vertexBuffers:[{
				arrayStride: 32,
				stepMode: 'vertex',
				attributes:[{
					format: GPUVertexFormat.float4,
					offset: 0,
					shaderLocation: 1
				}]
			}]
		}

	});

	let commandEncoder = device.createCommandEncoder();
	let renderPassEncoder = commandEncoder.beginRenderPass({
		colorAttachments:[{
			attachment: textureView,
			resolveTarget: null,
			loadValue: 'load',//or clear by color, { r: 0.5, g: 1.0, b: 1.0, a: 1.0 } // GPUColor
			//storeOp:''//store, clear
		}],
		
		//depthStencilAttachment:{
		//	attachment: textureView,
		//	depthLoadValue: 'load',//or float
		//	depthStoreOp: 'store',
		//	stencilLoadValue: 'load',
		//	stencilStoreOp: 'store'
		//}*
	});

	let commandBuffer = commandEncoder.finish();

	device.defaultQueue.submit([commandBuffer]);

	let renderBundleEncoder = device.createRenderBundleEncoder({
		colorFormats:[GPUTextureFormat],
		depthStencilFormat: GPUTextureFormat,
	});
	*/
}

/*

https://gpuweb.github.io/gpuweb/
https://gpuweb.github.io/WSL/
https://github.com/gpuweb/gpuweb

interface GPUQueue {
	void submit(sequence<GPUCommandBuffer> commandBuffers);

	GPUFence createFence(optional GPUFenceDescriptor descriptor = {});
	void signal(GPUFence fence, unsigned long long signalValue);

	void copyImageBitmapToTexture(
		GPUImageBitmapCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);
};

interface GPUCommandEncoder {
	GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);

	void copyBufferToBuffer(
		GPUBuffer source,
		GPUBufferSize sourceOffset,
		GPUBuffer destination,
		GPUBufferSize destinationOffset,
		GPUBufferSize size);

	void copyBufferToTexture(
		GPUBufferCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);

	void copyTextureToBuffer(
		GPUTextureCopyView source,
		GPUBufferCopyView destination,
		GPUExtent3D copySize);

	void copyTextureToTexture(
		GPUTextureCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);

	GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};

interface RenderBase {
	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
					  optional sequence<unsigned long> dynamicOffsets = []);

	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
					  Uint32Array dynamicOffsetsData,
					  unsigned long long dynamicOffsetsDataStart,
					  unsigned long long dynamicOffsetsDataLength);

	void setPipeline(GPURenderPipeline pipeline);

	void setIndexBuffer(GPUBuffer buffer, optional GPUBufferSize offset = 0);
	void setVertexBuffer(unsigned long slot, GPUBuffer buffer, optional GPUBufferSize offset = 0);

	void draw(unsigned long vertexCount, unsigned long instanceCount,
			  unsigned long firstVertex, unsigned long firstInstance);
	void drawIndexed(unsigned long indexCount, unsigned long instanceCount,
					 unsigned long firstIndex, long baseVertex, unsigned long firstInstance);

	void drawIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
	void drawIndexedIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
};

interface GPURenderPassEncoder extends RenderBase {
	void setViewport(float x, float y,
					 float width, float height,
					 float minDepth, float maxDepth);

	void setScissorRect(unsigned long x, unsigned long y, unsigned long width, unsigned long height);

	void setBlendColor(GPUColor color);
	void setStencilReference(unsigned long reference);

	void executeBundles(sequence<GPURenderBundle> bundles);
	void endPass();
};

interface GPURenderBundleEncoder extends RenderBase {
	GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};

enum GPUVertexFormat {
	"uchar2",
	"uchar4",
	"char2",
	"char4",
	"uchar2norm",
	"uchar4norm",
	"char2norm",
	"char4norm",
	"ushort2",
	"ushort4",
	"short2",
	"short4",
	"ushort2norm",
	"ushort4norm",
	"short2norm",
	"short4norm",
	"half2",
	"half4",
	"float",
	"float2",
	"float3",
	"float4",
	"uint",
	"uint2",
	"uint3",
	"uint4",
	"int",
	"int2",
	"int3",
	"int4"
};

enum GPUIndexFormat {
	"uint16",
	"uint32"
};

enum GPUInputStepMode {
	"vertex",
	"instance"
};

enum GPUPrimitiveTopology {
	"point-list",
	"line-list",
	"line-strip",
	"triangle-list",
	"triangle-strip"
};

dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
	required GPUBindGroupLayout layout;
	required sequence<GPUBindGroupBinding> bindings;
};
typedef (GPUSampler or GPUTextureView or GPUBufferBinding) GPUBindingResource;

dictionary GPUBindGroupBinding {
	required unsigned long binding;
	required GPUBindingResource resource;
};
dictionary GPUBufferBinding {
	required GPUBuffer buffer;
	GPUBufferSize offset = 0;
	GPUBufferSize size;
};

enum GPUBindingType {
	"uniform-buffer",
	"storage-buffer",
	"readonly-storage-buffer",
	"sampler",
	"sampled-texture",
	"storage-texture"
	// TODO: other binding types
};

interface GPUShaderStage {
	const GPUShaderStageFlags VERTEX   = 0x1;
	const GPUShaderStageFlags FRAGMENT = 0x2;
	const GPUShaderStageFlags COMPUTE  = 0x4;
};

interface GPUBufferUsage {
	const GPUBufferUsageFlags MAP_READ  = 0x0001;
	const GPUBufferUsageFlags MAP_WRITE = 0x0002;
	const GPUBufferUsageFlags COPY_SRC  = 0x0004;
	const GPUBufferUsageFlags COPY_DST  = 0x0008;
	const GPUBufferUsageFlags INDEX     = 0x0010;
	const GPUBufferUsageFlags VERTEX    = 0x0020;
	const GPUBufferUsageFlags UNIFORM   = 0x0040;
	const GPUBufferUsageFlags STORAGE   = 0x0080;
	const GPUBufferUsageFlags INDIRECT  = 0x0100;
};

interface GPUTextureUsage {
	const GPUTextureUsageFlags COPY_SRC          = 0x01;
	const GPUTextureUsageFlags COPY_DST          = 0x02;
	const GPUTextureUsageFlags SAMPLED           = 0x04;
	const GPUTextureUsageFlags STORAGE           = 0x08;
	const GPUTextureUsageFlags OUTPUT_ATTACHMENT = 0x10;
};

enum GPUTextureFormat {
	// 8-bit formats
	"r8unorm",
	"r8snorm",
	"r8uint",
	"r8sint",

	// 16-bit formats
	"r16uint",
	"r16sint",
	"r16float",
	"rg8unorm",
	"rg8snorm",
	"rg8uint",
	"rg8sint",

	// 32-bit formats
	"r32uint",
	"r32sint",
	"r32float",
	"rg16uint",
	"rg16sint",
	"rg16float",
	"rgba8unorm",
	"rgba8unorm-srgb",
	"rgba8snorm",
	"rgba8uint",
	"rgba8sint",
	"bgra8unorm",
	"bgra8unorm-srgb",
	// Packed 32-bit formats
	"rgb10a2unorm",
	"rg11b10float",

	// 64-bit formats
	"rg32uint",
	"rg32sint",
	"rg32float",
	"rgba16uint",
	"rgba16sint",
	"rgba16float",

	// 128-bit formats
	"rgba32uint",
	"rgba32sint",
	"rgba32float",

	// Depth and stencil formats
	"depth32float",
	"depth24plus",
	"depth24plus-stencil8"
};

dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
	GPUAddressMode addressModeU = "clamp-to-edge";
	GPUAddressMode addressModeV = "clamp-to-edge";
	GPUAddressMode addressModeW = "clamp-to-edge";
	GPUFilterMode magFilter = "nearest";
	GPUFilterMode minFilter = "nearest";
	GPUFilterMode mipmapFilter = "nearest";
	float lodMinClamp = 0;
	float lodMaxClamp = 0xffffffff; // TODO: What should this be? Was Number.MAX_VALUE.
	GPUCompareFunction compare = "never";
};
enum GPUAddressMode {
	"clamp-to-edge",
	"repeat",
	"mirror-repeat"
};
enum GPUFilterMode {
	"nearest",
	"linear"
};
enum GPUCompareFunction {
	"never",
	"less",
	"equal",
	"less-equal",
	"greater",
	"not-equal",
	"greater-equal",
	"always"
};

*/