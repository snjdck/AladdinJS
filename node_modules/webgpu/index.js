'use strict';

const vertexShaderGLSL = `#version 450

layout(binding=0)
uniform _ {
	vec2 screenWH;
};

//layout(location=0)in mat2x3 worldMatrix;

layout(location=0)
in vec3 worldMatrixX;

layout(location=1)
in vec3 worldMatrixY;

layout(location=2)
in vec4 textureMul;

layout(location=3)
in vec4 textureAdd;

layout(location=4)
in vec4 rectSize;//w,rw,h,rh

layout(location=5)
in vec4 scale9grid;//lm,rm,tm,bm

layout(location = 0)
out vec2 uv;

void main() {
	mat2x3 worldMatrix = mat2x3(worldMatrixX, worldMatrixY);
	vec2 inputPosition = vec2(gl_VertexIndex >> 1 & 1, gl_VertexIndex >> 3);
	vec4 inputMargin = vec4(equal(
		ivec2(gl_VertexIndex & 3, gl_VertexIndex >> 2).xxyy,
		ivec2(1, 2).xyxy
	));
	inputMargin.yw = -inputMargin.yw;
	vec4 margin = inputMargin * scale9grid;
	margin = margin.xxzz + margin.yyww;

	vec4 xyuv = inputPosition.xxyy * rectSize + margin;
	xyuv.yw /= rectSize.yw;
	xyuv = xyuv.xzyw * textureMul + textureAdd;

	xyuv.xy = vec3(xyuv.xy, 1) * worldMatrix;
	xyuv.xy = screenWH * vec2(xyuv) + vec2(-1, 1);

	gl_Position = vec4(xyuv.xy, 0, 1);
	uv = xyuv.zw;
}
`;

const fragmentShaderGLSL = `#version 450
	layout(binding=1)uniform sampler mySampler;
	layout(binding=2)uniform texture2D myTexture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		vec4 temp = texture(sampler2D(myTexture, mySampler), uv);
		outColor = temp;
	}
`;

const filterVertexShaderGLSL = `#version 450
layout(location = 0)
out vec2 uv;
void main() {
	vec2 vertex = vec2(gl_VertexIndex >> 1, gl_VertexIndex & 1);
	gl_Position = vec4(vertex * 2.0 - 1.0, 0, 1);
	uv = vertex;
}
`;
const filterFragmentShaderGLSL = `#version 450
	layout(binding=1)uniform sampler mySampler;
	layout(binding=2)uniform texture2D myTexture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		vec4 temp = texture(sampler2D(myTexture, mySampler), uv);
		outColor = vec4(1.0, 0, 0, 0.5);
		temp.a = 0.5;
		outColor = temp;
	}
`;

async function loadImage(path){
	let image = new Image();
	image.src = path;
	await image.decode();
	return image;
}

const instanceFloatCount = 22;
const allZero = new Float32Array(4);
const allOne = new Float32Array(4).fill(1);

async function init(){
	const glslangModule = await import('https://unpkg.com/@webgpu/glslang@0.0.7/web/glslang.js');
	const glslang = await glslangModule.default();
	
	const canvas = document.createElement('canvas');
	canvas.width = 550;
	canvas.height = 400;
	document.body.appendChild(canvas);
	
	if(!navigator.gpu)return;
	const adapter = await navigator.gpu.requestAdapter();
	const device = await adapter.requestDevice();
	const context = canvas.getContext('gpupresent');
	//const swapChainFormat = await context.getSwapChainPreferredFormat(device);
	const swapChainFormat = 'bgra8unorm';
	const swapChain = context.configureSwapChain({
		device,
		format: swapChainFormat,
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT
	});

	const vertexData = new Float32Array(instanceFloatCount * 4);
	const vertexBuffer = device.createBuffer({
		size: vertexData.byteLength,
		usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
	});

	const [indexBuffer, indexData] = device.createBufferMapped({
		size: 54 * 2,
		usage: GPUBufferUsage.INDEX
	});
	new Uint16Array(indexData).set(createMeshIndices(4, 4));
	indexBuffer.unmap();

	const [uniformBuffer, uniformData] = device.createBufferMapped({
		size: 2 * 4,
		usage: GPUBufferUsage.UNIFORM
	});
	new Float32Array(uniformData).set([2 / canvas.width, -2 / canvas.height]);
	uniformBuffer.unmap();

	const imageBitmap = await createImageBitmap(await loadImage('./1.png'));
	const imageBitmap2 = await createImageBitmap(await loadImage('./2.jpg'));

	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
	});

	const texture2 = device.createTexture({
		size: [imageBitmap2.width, imageBitmap2.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
	});

	device.copyImageBitmapToTexture(
		{imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, arrayLayer: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);

	device.copyImageBitmapToTexture(
		{imageBitmap:imageBitmap2, origin:[0, 0]},
		{texture:texture2, mipLevel: 0, arrayLayer: 0, origin: [0, 0, 0]},
		[imageBitmap2.width, imageBitmap2.height, 1]
	);

	const sampler = device.createSampler({
		magFilter: 'linear',
		minFilter: 'linear',
	});

	const textureBindGroupLayout = device.createBindGroupLayout({
		bindings:[{
			binding: 1,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampler'
		},{
			binding: 2,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampled-texture'
		}]
	});

	const bindGroupLayout = device.createBindGroupLayout({
		bindings:[{
			binding: 0,
			visibility: GPUShaderStage.VERTEX,
			type: 'uniform-buffer',
		},{
			binding: 1,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampler'
		},{
			binding: 2,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampled-texture'
		}]
	});

	const bindGroupDesc = {
		layout: bindGroupLayout,
		bindings: [{
			binding: 0,
			resource: {
				buffer: uniformBuffer,
				offset: 0
			}
		},{
			binding: 1,
			resource: sampler
		},{
			binding: 2,
			resource: null//bind later
		}]
	};

	const pipeline = device.createRenderPipeline({
		layout: device.createPipelineLayout({
			bindGroupLayouts: [bindGroupLayout/*, textureBindGroupLayout*/]
		}),
		vertexStage: {
			module: device.createShaderModule({
				code: glslang.compileGLSL(vertexShaderGLSL, "vertex"),
			}),
			entryPoint: 'main'
		},
		fragmentStage: {
			module: device.createShaderModule({
				code: glslang.compileGLSL(fragmentShaderGLSL, "fragment"),
			}),
			entryPoint: 'main'
		},
		primitiveTopology: 'triangle-list',
		colorStates:[{
			format: swapChainFormat
		}],
		depthStencilState: {
			format: 'depth24plus-stencil8',
		},
		vertexState: {
			indexFormat: 'uint16',
			vertexBuffers:[{
				arrayStride: instanceFloatCount << 2,
				stepMode: 'instance',
				attributes:[{
					shaderLocation: 0,
					offset: 0,
					format: 'float3'
				},{
					shaderLocation: 1,
					offset: 3 << 2,
					format: 'float3'
				},{
					shaderLocation: 2,
					offset: 6 << 2,
					format: 'float4'
				},{
					shaderLocation: 3,
					offset: 10 << 2,
					format: 'float4'
				},{
					shaderLocation: 4,
					offset: 14 << 2,
					format: 'float4'
				},{
					shaderLocation: 5,
					offset: 18 << 2,
					format: 'float4'
				}]
			}]
		}
	});

	const filterPipeline = device.createRenderPipeline({
		layout: device.createPipelineLayout({
			bindGroupLayouts: [textureBindGroupLayout]
		}),
		vertexStage: {
			module: device.createShaderModule({
				code: glslang.compileGLSL(filterVertexShaderGLSL, "vertex"),
			}),
			entryPoint: 'main'
		},
		fragmentStage: {
			module: device.createShaderModule({
				code: glslang.compileGLSL(filterFragmentShaderGLSL, "fragment"),
			}),
			entryPoint: 'main'
		},
		primitiveTopology: 'triangle-strip',
		colorStates:[{
			format: swapChainFormat,
			colorBlend: {
				srcFactor: 'src-alpha',
				dstFactor: 'one-minus-src-alpha',
				operation: 'add'
			}
		}]
	});

	const filterFrameBuffer = device.createTexture({
		size: [canvas.width, canvas.height, 1],
		format: 'bgra8unorm',
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
	});

	const filterBindGroup = device.createBindGroup({
		layout: textureBindGroupLayout,
		bindings:[{
			binding: 1,
			resource: sampler
		},{
			binding: 2,
			resource: filterFrameBuffer.createView()
		}]
	})

	const depthTexture = device.createTexture({
		size: [canvas.width, canvas.height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
		dimension: '2d',//optional, default 2d(1d, 3d)
	});

	const depthStencilAttachmentDescriptor = {
		attachment: depthTexture.createView(),
		depthLoadValue: 1.0,
		depthStoreOp: 'store',
		stencilLoadValue: 0,
		stencilStoreOp: 'store'
	};

	bindGroupDesc.bindings[2].resource = texture.createView();
	let bindGroup1 = device.createBindGroup(bindGroupDesc);
	bindGroupDesc.bindings[2].resource = texture2.createView();
	let bindGroup2 = device.createBindGroup(bindGroupDesc);
	
	function frame(){
		requestAnimationFrame(frame);

		for(let i=0; i<4; ++i){
			let j = i * instanceFloatCount;
			vertexData.set([1,0,110 * i,0,1,Math.sin(performance.now() * 0.001 - i) * 100 + 100],j);
			vertexData.set(allOne, j+6);
			vertexData.set(allZero, j+10);
			vertexData.set(allZero, j+18);
			vertexData[j+14] = 100;
			vertexData[j+15] = 550;
			vertexData[j+16] = 100;
			vertexData[j+17] = 400;
		}
		vertexBuffer.setSubData(0, vertexData);
		
		const commandEncoder = device.createCommandEncoder();
		let renderPassEncoder = commandEncoder.beginRenderPass({
			colorAttachments: [{
				attachment: swapChain.getCurrentTexture().createView(),
				loadValue: [0, 0, 0, 1]
			}],
			depthStencilAttachment: depthStencilAttachmentDescriptor//when 2D, can omit
		});
		/*
		const renderBundleEncoder = device.createRenderBundleEncoder({
			colorFormats:[swapChainFormat],
			depthStencilFormat: 'depth24plus-stencil8'
		});
		renderPassEncoder.executeBundles([renderBundleEncoder.finish()]);
		//*/
		renderPassEncoder.setPipeline(pipeline);
		renderPassEncoder.setVertexBuffer(0, vertexBuffer);
		renderPassEncoder.setIndexBuffer(indexBuffer);

		renderPassEncoder.setBindGroup(0, bindGroup1);
		renderPassEncoder.drawIndexed(54, 2, 0, 0, 0);

		if(true){
			renderPassEncoder.endPass();
			renderPassEncoder = commandEncoder.beginRenderPass({
				colorAttachments: [{
					attachment: filterFrameBuffer.createView(),
					loadValue: [0, 0, 0, 0]
				}],
				depthStencilAttachment: depthStencilAttachmentDescriptor//when 2D, can omit
			});
			renderPassEncoder.setPipeline(pipeline);
			renderPassEncoder.setVertexBuffer(0, vertexBuffer);
			renderPassEncoder.setIndexBuffer(indexBuffer);
		}

		renderPassEncoder.setBindGroup(0, bindGroup2);
		renderPassEncoder.drawIndexed(54, 2, 0, 0, 2);

		renderPassEncoder.endPass();

		if(true){
			renderPassEncoder = commandEncoder.beginRenderPass({
				colorAttachments: [{
					attachment: swapChain.getCurrentTexture().createView(),
					loadValue: 'load'
				}]
			});

			renderPassEncoder.setPipeline(filterPipeline);
			renderPassEncoder.setBindGroup(0, filterBindGroup);
			renderPassEncoder.draw(4, 1, 0, 0);//rect

			renderPassEncoder.endPass();
		}

		device.defaultQueue.submit([commandEncoder.finish()]);
	}
	requestAnimationFrame(frame);
}

GPUDevice.prototype.copyImageBitmapToTexture = function(source, destination, copySize){
	const pitchSize = 64;
	const bytePerPixel = 4;

	const {imageBitmap} = source;
	const {width, height} = imageBitmap;

	const rowPitch = Math.ceil(width / pitchSize) * pitchSize * bytePerPixel;//mulitimes of 256

	const canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;

	const ctx = canvas.getContext('2d');
	ctx.drawImage(imageBitmap, 0, 0);
	const imageData = ctx.getImageData(0, 0, width, height);

	let bufferData;

	if(width % pitchSize == 0){
		bufferData = imageData.data;
	}else{
		bufferData = new Uint8Array(rowPitch * height);
		const data = imageData.data;
		for(let y=0; y<height; ++y){
			for(let x=0; x<width; ++x){
				let i = y * rowPitch + x * bytePerPixel;
				let j = (y * width + x) * bytePerPixel;
				bufferData[i  ] = data[j];
				bufferData[i+1] = data[j+1];
				bufferData[i+2] = data[j+2];
				bufferData[i+3] = data[j+3];
			}
		}
	}

	const buffer = this.createBuffer({
		size: bufferData.length,
		usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
	});
	buffer.setSubData(0, bufferData);

	const commandEncoder = this.createCommandEncoder();
	commandEncoder.copyBufferToTexture({
		buffer,
		rowPitch,
		imageHeight: height,
		offset: 0
	}, destination, copySize);
	this.defaultQueue.submit([commandEncoder.finish()]);

	buffer.destroy();
}

//flat mode use value of last vertex
function createMeshIndices(numVertexPerRow, numVertexPerCol, result=[])
{
	const numGridPerRow = numVertexPerRow - 1;
	const numGridPerCol = numVertexPerCol - 1;
	for(var row=0; row<numGridPerCol; ++row){
		for(var col=0; col<numGridPerRow; ++col){
			var a = col + numVertexPerRow * row;
			var b = col + numVertexPerRow * (row + 1);
			//三角形1, 三角形2
			result.push(b, b+1, a, b+1, a+1, a);//topLeft
			//result.push(a, b, b+1, a+1, a, b+1);//bottomRight
			//result.push(a, b, a+1, b, b+1, a+1);//topRight
			//result.push(a+1, a, b, b+1, a+1, b);//bottomLeft
		}
	}
	return result;
}
/*

https://gpuweb.github.io/gpuweb/
https://gpuweb.github.io/WSL/
https://github.com/gpuweb/gpuweb

interface GPUCommandEncoder {
	void copyBufferToBuffer(
		GPUBuffer source,
		GPUBufferSize sourceOffset,
		GPUBuffer destination,
		GPUBufferSize destinationOffset,
		GPUBufferSize size);

	void copyBufferToTexture(
		GPUBufferCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);

	void copyTextureToBuffer(
		GPUTextureCopyView source,
		GPUBufferCopyView destination,
		GPUExtent3D copySize);

	void copyTextureToTexture(
		GPUTextureCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);
};

interface RenderBase {
	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
					  optional sequence<unsigned long> dynamicOffsets = []);

	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
					  Uint32Array dynamicOffsetsData,
					  unsigned long long dynamicOffsetsDataStart,
					  unsigned long long dynamicOffsetsDataLength);

	void setPipeline(GPURenderPipeline pipeline);

	void setIndexBuffer(GPUBuffer buffer, optional GPUBufferSize offset = 0);
	void setVertexBuffer(unsigned long slot, GPUBuffer buffer, optional GPUBufferSize offset = 0);

	void draw(unsigned long vertexCount, unsigned long instanceCount,
			  unsigned long firstVertex, unsigned long firstInstance);
	void drawIndexed(unsigned long indexCount, unsigned long instanceCount,
					 unsigned long firstIndex, long baseVertex, unsigned long firstInstance);

	void drawIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
	void drawIndexedIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
};

interface GPURenderPassEncoder extends RenderBase {
	void setViewport(float x, float y,
					 float width, float height,
					 float minDepth, float maxDepth);

	void setScissorRect(unsigned long x, unsigned long y, unsigned long width, unsigned long height);

	void setBlendColor(GPUColor color);
	void setStencilReference(unsigned long reference);

	void executeBundles(sequence<GPURenderBundle> bundles);
	void endPass();
};

interface GPURenderBundleEncoder extends RenderBase {
	GPURenderBundle finish();
};

enum GPUVertexFormat {
	"uchar2",
	"uchar4",
	"char2",
	"char4",
	"uchar2norm",
	"uchar4norm",
	"char2norm",
	"char4norm",
	"ushort2",
	"ushort4",
	"short2",
	"short4",
	"ushort2norm",
	"ushort4norm",
	"short2norm",
	"short4norm",
	"half2",
	"half4",
	"float",
	"float2",
	"float3",
	"float4",
	"uint",
	"uint2",
	"uint3",
	"uint4",
	"int",
	"int2",
	"int3",
	"int4"
};

enum GPUIndexFormat {
	"uint16",
	"uint32"
};

enum GPUInputStepMode {
	"vertex",
	"instance"
};

enum GPUPrimitiveTopology {
	"point-list",
	"line-list",
	"line-strip",
	"triangle-list",
	"triangle-strip"
};

dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
	required GPUBindGroupLayout layout;
	required sequence<GPUBindGroupBinding> bindings;
};
typedef (GPUSampler or GPUTextureView or GPUBufferBinding) GPUBindingResource;

dictionary GPUBindGroupBinding {
	required unsigned long binding;
	required GPUBindingResource resource;
};
dictionary GPUBufferBinding {
	required GPUBuffer buffer;
	GPUBufferSize offset = 0;
	GPUBufferSize size;
};

enum GPUBindingType {
	"uniform-buffer",
	"storage-buffer",
	"readonly-storage-buffer",
	"sampler",
	"sampled-texture",
	"storage-texture"
	// TODO: other binding types
};

interface GPUShaderStage {
	const GPUShaderStageFlags VERTEX   = 0x1;
	const GPUShaderStageFlags FRAGMENT = 0x2;
	const GPUShaderStageFlags COMPUTE  = 0x4;
};

interface GPUBufferUsage {
	const GPUBufferUsageFlags MAP_READ  = 0x0001;
	const GPUBufferUsageFlags MAP_WRITE = 0x0002;
	const GPUBufferUsageFlags COPY_SRC  = 0x0004;
	const GPUBufferUsageFlags COPY_DST  = 0x0008;
	const GPUBufferUsageFlags INDEX     = 0x0010;
	const GPUBufferUsageFlags VERTEX    = 0x0020;
	const GPUBufferUsageFlags UNIFORM   = 0x0040;
	const GPUBufferUsageFlags STORAGE   = 0x0080;
	const GPUBufferUsageFlags INDIRECT  = 0x0100;
};

interface GPUTextureUsage {
	const GPUTextureUsageFlags COPY_SRC          = 0x01;
	const GPUTextureUsageFlags COPY_DST          = 0x02;
	const GPUTextureUsageFlags SAMPLED           = 0x04;
	const GPUTextureUsageFlags STORAGE           = 0x08;
	const GPUTextureUsageFlags OUTPUT_ATTACHMENT = 0x10;
};

enum GPUTextureFormat {
	// 8-bit formats
	"r8unorm",
	"r8snorm",
	"r8uint",
	"r8sint",

	// 16-bit formats
	"r16uint",
	"r16sint",
	"r16float",
	"rg8unorm",
	"rg8snorm",
	"rg8uint",
	"rg8sint",

	// 32-bit formats
	"r32uint",
	"r32sint",
	"r32float",
	"rg16uint",
	"rg16sint",
	"rg16float",
	"rgba8unorm",
	"rgba8unorm-srgb",
	"rgba8snorm",
	"rgba8uint",
	"rgba8sint",
	"bgra8unorm",
	"bgra8unorm-srgb",
	// Packed 32-bit formats
	"rgb10a2unorm",
	"rg11b10float",

	// 64-bit formats
	"rg32uint",
	"rg32sint",
	"rg32float",
	"rgba16uint",
	"rgba16sint",
	"rgba16float",

	// 128-bit formats
	"rgba32uint",
	"rgba32sint",
	"rgba32float",

	// Depth and stencil formats
	"depth32float",
	"depth24plus",
	"depth24plus-stencil8"
};

dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
	GPUAddressMode addressModeU = "clamp-to-edge";
	GPUAddressMode addressModeV = "clamp-to-edge";
	GPUAddressMode addressModeW = "clamp-to-edge";
	GPUFilterMode magFilter = "nearest";
	GPUFilterMode minFilter = "nearest";
	GPUFilterMode mipmapFilter = "nearest";
	float lodMinClamp = 0;
	float lodMaxClamp = 0xffffffff; // TODO: What should this be? Was Number.MAX_VALUE.
	GPUCompareFunction compare = "never";
};
enum GPUAddressMode {
	"clamp-to-edge",
	"repeat",
	"mirror-repeat"
};
enum GPUFilterMode {
	"nearest",
	"linear"
};
enum GPUCompareFunction {
	"never",
	"less",
	"equal",
	"less-equal",
	"greater",
	"not-equal",
	"greater-equal",
	"always"
};

*/