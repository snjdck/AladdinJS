'use strict';

const Vulkan = require('../Vulkan');
const Filter2D = require('./Filter2D');

const pipelineDesc = {
	layout: ['filter2D', 'filter_blur'],
	vertex:{
		module: 'vertex_filter',
	},
	fragment:{
		module: 'fragment_filter',
		targets:[{
			format: 'bgra8unorm',
			blend: ['transparent']
		}]
	},
	primitive: {
		topology: 'triangle-strip',
		stripIndexFormat: 'uint16',
	}
};

class BlurFilter extends Filter2D.Subclass(pipelineDesc)
{
	constructor(color=[1,0,1,1]){
		super();

		this.uniformBuffer = Vulkan.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, 8 * 4);

		this.uniformBuffer2 = Vulkan.createBufferMapped(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, new Float32Array(color));
		this.bindGroup = Vulkan.createBindGroup('filter_blur', {buffer: this.uniformBuffer}, {buffer: this.uniformBuffer2});
	}

	onDraw(frameRect, drawRect){
		const {device, renderPassEncoder} = Vulkan;
		const rect = drawRect;
		renderPassEncoder.setPipeline(this.pipeline);
		renderPassEncoder.setBindGroup(1, this.bindGroup);
		renderPassEncoder.draw(4, 1, 0, 0);//rect

		const MAX_W = frameRect.width;
		const MAX_H = frameRect.height;

		Vulkan.copyDataToBuffer(this.uniformBuffer, new Float32Array([
			rect.x / MAX_W, rect.y / MAX_H, rect.width / MAX_W, rect.height / MAX_H,
			rect.x / MAX_W - 1, rect.y / MAX_H + 1, 2 * rect.width / MAX_W, -2 * rect.height / MAX_H,

			//0,0,1,1,
			//-1, 1, 2, -2
		]));
	}
}

module.exports = BlurFilter;
