'use strict';

const Vulkan = require('../Vulkan');
const Filter2D = require('./Filter2D');
const BufferBindGroup = require('../helper/BufferBindGroup');

const pipelineDesc = {
	layout: ['filter2D', 'filter_blur'],
	vertex:{
		module: 'vertex_filter',
	},
	fragment:{
		module: 'fragment_filter',
		targets:[{
			format: 'bgra8unorm',
			blend: ['transparent']
		}]
	},
	primitive: {
		topology: 'triangle-strip',
		stripIndexFormat: 'uint16',
	}
};

class BlurFilter extends Filter2D.Subclass(pipelineDesc)
{
	constructor(color=[1,0,1,1]){
		super();

		this.group = new BufferBindGroup([
			[GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, 8 * 4],
			[GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, 4 * 4, true],
		], (buffer1, buffer2) => {
			new Float32Array(buffer2.getMappedRange()).set(color);
			buffer2.unmap();
			return [['filter_blur', {buffer: buffer1}, {buffer: buffer2}]];
		}, ['buffer'], ['bindGroup']);
	}

	onDraw(frameRect, drawRect){
		const {device, renderPassEncoder} = Vulkan;
		const rect = drawRect;
		renderPassEncoder.setPipeline(this.pipeline);
		renderPassEncoder.setBindGroup(1, this.group.bindGroup);
		renderPassEncoder.draw(4, 1, 0, 0);//rect

		const MAX_W = frameRect.width;
		const MAX_H = frameRect.height;

		Vulkan.copyDataToBuffer(this.group.buffer, new Float32Array([
			rect.x / MAX_W, rect.y / MAX_H, rect.width / MAX_W, rect.height / MAX_H,
			rect.x / MAX_W - 1, rect.y / MAX_H + 1, 2 * rect.width / MAX_W, -2 * rect.height / MAX_H,

			//0,0,1,1,
			//-1, 1, 2, -2
		]));
	}
}

module.exports = BlurFilter;
