'use strict';

const Vulkan = require('../Vulkan');

class FrameBufferBase
{
	constructor(){
		this.width = this.height = 0;
	}

	needResize({width, height}){
		return this.width < width || this.height < height;
	}

	resize(frameRect){
		if(this.needResize(frameRect)){
			this.width = frameRect.width;
			this.height = frameRect.height;
			this._resize(frameRect.width, frameRect.height);
		}else{
			frameRect.width = this.width;
			frameRect.height = this.height;
		}
	}
}

/*
this.depthReadOnly is true, this.depthLoadValue must be "load" and this.depthStoreOp must be "store".
this.stencilReadOnly is true, this.stencilLoadValue must be "load" and this.stencilStoreOp must be "store".

multi color buffer can share one depth buffer
*/

class FrameBuffer extends FrameBufferBase
{
	constructor(depthStencilAttachment=null, loadValue=[0,0,0,0], storeOp='store'){
		super();
		this.renderPassDesc = {colorAttachments: [{loadValue, storeOp}]};
		if(!depthStencilAttachment)return;
		this.useSharedDepthStencilBuffer = depthStencilAttachment.useSharedDepthStencilBuffer ?? false;
		const {
			depthLoadValue = 1.0,//or load
			depthStoreOp = 'clear',//or store
			stencilLoadValue = 0,//or load
			stencilStoreOp = 'clear',//or store
		} = depthStencilAttachment;
		this.renderPassDesc.depthStencilAttachment = {depthLoadValue, depthStoreOp, stencilLoadValue, stencilStoreOp};
	}

	get colorView(){
		return this.colorBuffer.createView();
	}

	get depthView(){
		return this.depthBuffer.createView();
	}

	_resize(width, height){
		Vulkan.requestDestroy(this.colorBuffer);
		Vulkan.requestDestroy(this.depthBuffer);

		this.colorBuffer = Vulkan.device.createTexture({
			size: [width, height, 1],
			format: Vulkan.swapChainFormat,
			//usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.SAMPLED
			usage: 0x17
		});
		this.setColorAttachment(this.colorView);

		if(this.useSharedDepthStencilBuffer === false){
			this.depthBuffer = Vulkan.createDepthTexture(width, height);
			this.setDepthStencilAttachment(this.depthView);
		}
	}

	setColorAttachment(attachment){
		this.renderPassDesc.colorAttachments[0].attachment = attachment;
	}

	setDepthStencilAttachment(attachment){
		if(this.useSharedDepthStencilBuffer === undefined)return;
		this.renderPassDesc.depthStencilAttachment.attachment = attachment;
	}

	beginRenderPass(){
		Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass(this.renderPassDesc);
	}

	render(handler, self){
		this.beginRenderPass();
		handler.call(self);
		Vulkan.renderPassEncoder.endPass();
	}
}

class FrameBufferList extends FrameBufferBase
{
	constructor(){
		super();
		this.frameBufferList = new Array(2).fill().map(() => new FrameBuffer());
	}

	getFrameBuffer(index=0){
		return this.frameBufferList[index];
	}

	_resize(width, height){
		for(const frameBuffer of this.frameBufferList){
			frameBuffer._resize(width, height);
		}
	}

	render(handler){
		for(const frameBuffer of this.frameBufferList){
			frameBuffer.beginRenderPass();
			handler.next();
			Vulkan.renderPassEncoder.endPass();
		}
		handler.next();
	}
}

exports.FrameBuffer = FrameBuffer;
exports.FrameBufferList = FrameBufferList;
