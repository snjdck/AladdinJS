'use strict';

const Vulkan = require('../Vulkan');
const {defineMainSubProp} = require('utils/cache');

class FrameBufferBase
{
	constructor(depthStencilAttachment=null, loadValue=[0,0,0,0], storeOp='store'){
		this.renderPassDesc = {colorAttachments: [{loadValue, storeOp}]};
		if(!depthStencilAttachment)return;
		this.useSharedDepthStencilBuffer = depthStencilAttachment.useSharedDepthStencilBuffer ?? false;
		const {
			depthLoadValue = 1.0,//or load
			depthStoreOp = 'discard',//or store
			stencilLoadValue = 0,//or load
			stencilStoreOp = 'discard',//or store
		} = depthStencilAttachment;
		this.renderPassDesc.depthStencilAttachment = {depthLoadValue, depthStoreOp, stencilLoadValue, stencilStoreOp};
	}

	setColorAttachment(attachment){
		this.renderPassDesc.colorAttachments[0].view = attachment;
	}

	setDepthStencilAttachment(attachment){
		if(this.useSharedDepthStencilBuffer === undefined)return;
		this.renderPassDesc.depthStencilAttachment.view = attachment;
	}

	beginRenderPass(){
		Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass(this.renderPassDesc);
	}

	render(handler, self){
		this.beginRenderPass();
		handler.call(self);
		Vulkan.renderPassEncoder.endPass();
	}
}

/*
this.depthReadOnly is true, this.depthLoadValue must be "load" and this.depthStoreOp must be "store".
this.stencilReadOnly is true, this.stencilLoadValue must be "load" and this.stencilStoreOp must be "store".

multi color buffer can share one depth buffer
*/

class FrameBuffer extends FrameBufferBase
{
	constructor(depthStencilAttachment, loadValue, storeOp){
		super(depthStencilAttachment, loadValue, storeOp);
		this.width = this.height = 0;
		this.depthOrArrayLayers = 1;
		addPropColorBuffer(this);
		addPropDepthBuffer(this);
	}

	getColorView(index=0){
		return this._colorViewList[index];
	}

	get colorView(){
		return this._colorViewList[0];
	}

	resize(frameRect){
		if(this.width < frameRect.width || this.height < frameRect.height){
			this.width = frameRect.width;
			this.height = frameRect.height;
			this._resize(this.width, this.height);
		}else{
			frameRect.width = this.width;
			frameRect.height = this.height;
		}
	}

	_resize(width, height){
		Vulkan.requestDestroy(this.colorBuffer);
		Vulkan.requestDestroy(this.depthBuffer);

		this.colorBuffer = Vulkan.device.createTexture({
			size: [width, height, this.depthOrArrayLayers],
			format: Vulkan.swapChainFormat,
			//usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.SAMPLED
			usage: 0x17
		});

		if(this.depthOrArrayLayers == 1){
			this.setColorAttachment(this.colorView);
		}

		if(this.useSharedDepthStencilBuffer === false){
			this.depthBuffer = Vulkan.createDepthTexture(width, height);
			this.setDepthStencilAttachment(this.depthView);
		}
	}
}

const addPropColorBuffer = defineMainSubProp('colorBuffer', {
	_colorViewList(){
		const {depthOrArrayLayers, colorBuffer} = this;
		const result = [];
		for(let i=depthOrArrayLayers-1; i>=0; --i){
			result[i] = colorBuffer.createView({baseArrayLayer: i, arrayLayerCount: 1});
		}
		return result;
	}
});

const addPropDepthBuffer = defineMainSubProp('depthBuffer', {
	depthView(){
		return this.depthBuffer.createView();
	}
});

class FrameBufferList extends FrameBuffer
{
	constructor(depthOrArrayLayers=2){
		super();
		this.depthOrArrayLayers = depthOrArrayLayers;
	}

	render(handler){
		for(let i=0, n=this.depthOrArrayLayers; i<n; ++i){
			this.setColorAttachment(this.getColorView(i));
			this.beginRenderPass();
			handler.next();
			Vulkan.renderPassEncoder.endPass();
		}
		handler.next();
	}
}

exports.FrameBuffer = FrameBuffer;
exports.FrameBufferBase = FrameBufferBase;
exports.FrameBufferList = FrameBufferList;
