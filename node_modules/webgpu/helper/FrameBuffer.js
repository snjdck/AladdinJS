'use strict';

const Vulkan = require('../Vulkan');
const {defineMainSubProp} = require('utils/cache');

class FrameBufferBase
{
	constructor(depthStencilAttachment=null, {loadOp='clear', storeOp='store', clearValue}={}){
		this.renderPassDesc = {colorAttachments: [{loadOp, storeOp, clearValue}]};
		if(!depthStencilAttachment)return;
		this.useSharedDepthStencilBuffer = depthStencilAttachment.useSharedDepthStencilBuffer ?? false;
		let {
			depthClearValue = 1.0,
			depthLoadOp = 'clear',
			depthStoreOp = 'discard',
			depthReadOnly = false,
			stencilClearValue = 0,
			stencilLoadOp = 'clear',
			stencilStoreOp = 'discard',
			stencilReadOnly = false,
		} = depthStencilAttachment;
		if(depthReadOnly){
			depthLoadOp = 'load';
			depthStoreOp = 'store';
		}
		if(stencilReadOnly){
			stencilLoadOp = 'load';
			stencilStoreOp = 'store';
		}
		this.renderPassDesc.depthStencilAttachment = {depthClearValue, depthLoadOp, depthStoreOp, depthReadOnly, stencilClearValue, stencilLoadOp, stencilStoreOp, stencilReadOnly};
	}

	setColorAttachment(attachment){
		this.renderPassDesc.colorAttachments[0].view = attachment;
	}

	setDepthStencilAttachment(attachment){
		if(this.useSharedDepthStencilBuffer === undefined)return;
		this.renderPassDesc.depthStencilAttachment.view = attachment;
	}

	beginRenderPass(){
		Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass(this.renderPassDesc);
	}

	render(handler, self){
		this.beginRenderPass();
		handler.call(self);
		Vulkan.renderPassEncoder.endPass();
	}
}

class FrameBuffer extends FrameBufferBase
{
	constructor(depthStencilAttachment, loadValue, storeOp){
		super(depthStencilAttachment, loadValue, storeOp);
		this.width = this.height = 0;
		this.depthOrArrayLayers = 1;
		addPropColorBuffer(this);
		addPropDepthBuffer(this);
	}

	getColorView(index=0){
		return this._colorViewList[index];
	}

	get colorView(){
		return this._colorViewList[0];
	}

	resize(frameRect){
		if(this.width < frameRect.width || this.height < frameRect.height){
			this.width = frameRect.width;
			this.height = frameRect.height;
			this._resize(this.width, this.height);
		}else{
			frameRect.width = this.width;
			frameRect.height = this.height;
		}
	}

	_resize(width, height){
		Vulkan.requestDestroy(this.colorBuffer);
		Vulkan.requestDestroy(this.depthBuffer);

		const usage = this.depthOrArrayLayers > 1 ? 0x17 : 0x14;

		this.colorBuffer = Vulkan.device.createTexture({
			size: [width, height, this.depthOrArrayLayers],
			format: Vulkan.swapChainFormat,
			usage
		});

		if(this.depthOrArrayLayers == 1){
			this.setColorAttachment(this.colorView);
		}

		if(this.useSharedDepthStencilBuffer === false){
			this.depthBuffer = Vulkan.createDepthTexture(width, height);
			this.setDepthStencilAttachment(this.depthView);
		}
	}
}

const addPropColorBuffer = defineMainSubProp('colorBuffer', {
	_colorViewList(){
		const {depthOrArrayLayers, colorBuffer} = this;
		const result = [];
		for(let i=depthOrArrayLayers-1; i>=0; --i){
			result[i] = colorBuffer.createView({baseArrayLayer: i, arrayLayerCount: 1});
		}
		return result;
	}
});

const addPropDepthBuffer = defineMainSubProp('depthBuffer', {
	depthView(){
		return this.depthBuffer.createView();
	}
});

class FrameBufferList extends FrameBuffer
{
	constructor(depthOrArrayLayers=2){
		super();
		this.depthOrArrayLayers = depthOrArrayLayers;
	}

	render(handler, self=this){
		for(let i=0, n=this.depthOrArrayLayers; i<n; ++i){
			this.setColorAttachment(this.getColorView(i));
			this.beginRenderPass();
			handler.call(self, i);
			Vulkan.renderPassEncoder.endPass();
		}
	}
}

exports.FrameBuffer = FrameBuffer;
exports.FrameBufferBase = FrameBufferBase;
exports.FrameBufferList = FrameBufferList;
