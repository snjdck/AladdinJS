'use strict';

const Vulkan = require('../Vulkan');
const {createTexture} = require('webonly/utils_gpu');

class FrameBufferBase
{
	constructor(depthStencilAttachment=null, {loadOp='clear', storeOp='store', clearValue}={}){
		this.renderPassDesc = {colorAttachments: [{loadOp, storeOp, clearValue}]};
		if(!depthStencilAttachment)return;
		this.useSharedDepthStencilBuffer = depthStencilAttachment.useSharedDepthStencilBuffer ?? false;
		let {
			depthClearValue = 1.0,
			depthLoadOp = 'clear',
			depthStoreOp = 'discard',
			depthReadOnly = false,
			stencilClearValue = 0,
			stencilLoadOp = 'clear',
			stencilStoreOp = 'discard',
			stencilReadOnly = false,
		} = depthStencilAttachment;
		if(depthReadOnly){
			depthLoadOp = 'load';
			depthStoreOp = 'store';
		}
		if(stencilReadOnly){
			stencilLoadOp = 'load';
			stencilStoreOp = 'store';
		}
		this.renderPassDesc.depthStencilAttachment = {depthClearValue, depthLoadOp, depthStoreOp, depthReadOnly, stencilClearValue, stencilLoadOp, stencilStoreOp, stencilReadOnly};
	}

	setColorAttachment(attachment){
		this.renderPassDesc.colorAttachments[0].view = attachment;
	}

	setDepthStencilAttachment(attachment){
		if(this.useSharedDepthStencilBuffer === undefined)return;
		this.renderPassDesc.depthStencilAttachment.view = attachment;
	}

	beginRenderPass(){
		Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass(this.renderPassDesc);
	}

	render(handler, self){
		this.beginRenderPass();
		handler.call(self);
		Vulkan.renderPassEncoder.end();
	}
}

class FrameBuffer extends FrameBufferBase
{
	constructor(depthStencilAttachment, loadValue, storeOp){
		super(depthStencilAttachment, loadValue, storeOp);
		this.width = this.height = 0;
		this.depthOrArrayLayers = 1;
		this.colorBuffer = null;
		this.depthBuffer = null;
	}

	getColorView(index=0){
		return this._colorViewList[index];
	}

	get colorView(){
		return this._colorViewList[0];
	}

	resize(frameRect){
		if(this.width < frameRect.width || this.height < frameRect.height){
			this.width = frameRect.width;
			this.height = frameRect.height;
			this._resize(this.width, this.height);
		}else{
			frameRect.width = this.width;
			frameRect.height = this.height;
		}
	}

	_resize(width, height){
		Vulkan.requestDestroy(this.colorBuffer);
		Vulkan.requestDestroy(this.depthBuffer);

		const {depthOrArrayLayers} = this;

		this.colorBuffer = createTexture(Vulkan.device, width, height, depthOrArrayLayers, depthOrArrayLayers > 1 ? 0x17 : 0x14);
		this._colorViewList = Array.from({length:depthOrArrayLayers}, (_, i) => this.colorBuffer.createView({dimension: '2d', baseArrayLayer: i, arrayLayerCount: 1}));

		if(this.depthOrArrayLayers == 1){
			this.setColorAttachment(this.colorView);
		}

		if(this.useSharedDepthStencilBuffer === false){
			this.depthBuffer = Vulkan.createDepthTexture(width, height);
			this.depthView = this.depthBuffer.createView();
			this.setDepthStencilAttachment(this.depthView);
		}
	}
}

class FrameBufferList extends FrameBuffer
{
	constructor(){
		super();
		this.depthOrArrayLayers = 2;
	}
/*
	render(handler, self=this){
		for(let i=0, n=this.depthOrArrayLayers; i<n; ++i){
			this.setColorAttachment(this.getColorView(i));
			this.beginRenderPass();
			handler.call(self, i);
			Vulkan.renderPassEncoder.end();
		}
	}
*/
}

exports.FrameBuffer = FrameBuffer;
exports.FrameBufferBase = FrameBufferBase;
exports.FrameBufferList = FrameBufferList;
