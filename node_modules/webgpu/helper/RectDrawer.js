'use strict';

const Pipeline = require('../materials/Pipeline');

const createDepthDrawFn = (viewDimension, code) => Pipeline.Blit([[
		{name:'depthTexture', texture:{sampleType:'depth'}},//depth, sint, uint, unfilterable-float
		{name:'normalTexture', texture:{sampleType:'unfilterable-float'}},//depth, sint, uint, unfilterable-float
		{name:'lightDepthTexture', texture:{sampleType:'depth',viewDimension}},
		{name:'cameraMatrixList', type:'Info', buffer:{}},
		{name:'sampler_depth', sampler:{type:'comparison'}, default:{compare:'less-equal'}},//greater, less-equal
	]], {format: 'bgra8unorm', blend: 'one add one'}, `

		#include<cast>
		#include<constant>

		struct Info {
			lightCamera: MVP,
			viewCameraInv: MVP,
			lightColor: vec4<f32>,
			lightDirection: vec4<f32>,
		}

		struct PbrInfo {
			tColor:vec3<f32>,
			l:vec3<f32>,
			n:vec3<f32>,
			v:vec3<f32>,
			h:vec3<f32>,
			roughness:f32,
			metalness:f32,
			NdotH: f32,
			NdotL: f32,
			NdotV: f32,
		}

		fn microface_distribution(info:PbrInfo) -> f32 {
			let roughnessSq = info.roughness * info.roughness;
			let f:f32 = info.NdotH * info.NdotH * (roughnessSq - 1) + 1;
			return roughnessSq / (PI * f * f);
		}

		fn geometric_occlusion(info:PbrInfo) -> f32 {
			let k:f32 = (info.roughness + 1) * (info.roughness + 1) / 8.0;
			let attenuationL = info.NdotL + sqrt(mix(info.NdotL * info.NdotL, 1, k));
			let attenuationV = info.NdotV + sqrt(mix(info.NdotV * info.NdotV, 1, k));
			return 1 / max(0.01, attenuationL * attenuationV);
		}

		fn specluar_reflection(info:PbrInfo) -> vec3<f32> {
			let HdotV = saturate(dot(info.h, info.v));
			let f0 = mix(vec3<f32>(0.04), info.tColor, info.metalness);
			//return f0;
			return mix(f0, vec3<f32>(1), pow(1 - HdotV, 1));
		}

		fn test(
			l:vec3<f32>,
			n:vec3<f32>,
			v:vec3<f32>,
			lColor:vec3<f32>,
			tColor:vec3<f32>,
			roughness:f32,
			metalness:f32,
		) -> vec3<f32> {
			var info:PbrInfo;
			info.l = l;
			info.n = n;
			info.v = v;
			info.tColor = tColor;
			info.roughness = 0.1;
			info.metalness = 1;
			info.h = normalize(info.l + info.v);
			info.NdotH = saturate(dot(info.n, info.h));
			info.NdotL = saturate(dot(info.n, info.l));
			info.NdotV = saturate(dot(info.n, info.v));
			
			let ks: f32 = 0.5;//need input

			let diffuse = tColor;// / pi;
			let specular = microface_distribution(info) * geometric_occlusion(info) * specluar_reflection(info);
			return specluar_reflection(info) * lColor;
			//return (diffuse + specular) * lColor * info.NdotL;
		}

		struct MVP {
			screenMatrix: mat4x4<f32>,
			@size(64) cameraMatrix: mat3x4<f32>,
		}

		fn calcWorldPt(position:vec2<f32>, depth:f32, pvm: MVP) -> vec3<f32> {
			let cameraPt = vec4<f32>(position, depth, 1) * pvm.screenMatrix;
			return vec4<f32>(cameraPt.xyz / cameraPt.w, 1) * pvm.cameraMatrix;
		}

		fn calc_shadow_2d(texture: texture_depth_2d, pos_in_light_camera: vec3<f32>, lightScreenMatrix: mat4x4<f32>) -> f32 {
			let pos_in_light_screen = vec4<f32>(pos_in_light_camera, 1) * lightScreenMatrix;
			let uv = (vec2(pos_in_light_screen.x, -pos_in_light_screen.y) / pos_in_light_screen.w + 1) * 0.5;
			let depth = pos_in_light_screen.z / pos_in_light_screen.w;
			return textureSampleCompare(texture, sampler_depth, uv, depth - shadow_bias);//depth_ref <= the sampled depth
		}

		fn calc_shadow_cube(texture: texture_depth_cube, pos_in_light_camera: vec3<f32>, lightScreenMatrix: mat4x4<f32>) -> f32 {
			let absv = abs(pos_in_light_camera);
			let maxComp = max(absv.x, max(absv.y, absv.z));
			let pos_in_light_screen = vec4<f32>(0, 0, maxComp, 1) * lightScreenMatrix;
			let depth = pos_in_light_screen.z / pos_in_light_screen.w;
			return textureSampleCompare(texture, sampler_depth, pos_in_light_camera, depth - shadow_bias);//depth_ref <= the sampled depth
		}

		@fragment{
			let position = uvxy.zw;
			let coords = vec2<u32>(FragCoord.xy);
			//let normal_in_world = calcNormal(textureLoad(texture_normal, coords, 0).xy);
			let normal_in_world = textureLoad(normalTexture, coords, 0).xyz;
			let pos_in_world = calcWorldPt(position, textureLoad(depthTexture, coords, 0), cameraMatrixList.viewCameraInv);
			let pos_in_light_camera: vec3<f32> = vec4<f32>(pos_in_world, 1) * cameraMatrixList.lightCamera.cameraMatrix;
			let shadow_factor = calc_shadow_${viewDimension}(lightDepthTexture, pos_in_light_camera, cameraMatrixList.lightCamera.screenMatrix);
			${code}
		}
`);

exports.createDepthDrawFn = createDepthDrawFn;
exports.blit = Pipeline.Blit;
