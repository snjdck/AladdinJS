'use strict';

const Pipeline = require('../materials/Pipeline');
/*
(0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5)
0-2-4
|/|/|
1-3-5
*/
const defaultTarget = {
	blend: {
		color:{srcFactor: 'one', dstFactor: 'one', operation: 'add'},
		alpha:{srcFactor: 'one', dstFactor: 'one', operation: 'add'},
	}
};

const createDrawFn = (groups, code, target=defaultTarget) => {
	const pipeline = new Pipeline({
		groups,
		vertex: {entryPoint: 'mainVertex', code},
		fragment: {entryPoint: 'mainFragment', code, targets:[{format: 'bgra8unorm', ...target}]},
		primitive: {topology: 'triangle-strip'}
	});
	return (renderPassEncoder, resources) => {
		pipeline.setPipeline(renderPassEncoder);
		pipeline.setResources(renderPassEncoder, resources);
		renderPassEncoder.draw(4);//quad
	};
}

const createDepthDrawFn = (viewDimension, code) => createDrawFn([[
		{name:'depthTexture', binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{sampleType:'depth'}},//depth, sint, uint, unfilterable-float
		{name:'normalTexture', binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{sampleType:'unfilterable-float'}},//depth, sint, uint, unfilterable-float
		{name:'uvScale', binding:2, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{name:'lightDepthTexture', binding:3, visibility:GPUShaderStage.FRAGMENT, texture:{sampleType:'depth',viewDimension}},
		{name:'cameraMatrixList', binding:4, visibility:GPUShaderStage.FRAGMENT, buffer:{}},
		{binding:5, visibility:GPUShaderStage.FRAGMENT, sampler:{type:'filtering'}, default:{}},
		{binding:6, visibility:GPUShaderStage.FRAGMENT, sampler:{type:'non-filtering'}, default:{}},
		{binding:7, visibility:GPUShaderStage.FRAGMENT, sampler:{type:'comparison'}, default:{compare:'less-equal'}},//greater, less-equal
	]], `
		const shadow_bias:f32 = 0.001;

		@group(0) @binding(0) var texture_position: texture_depth_2d;
		@group(0) @binding(1) var texture_normal: texture_2d<f32>;
		@group(0) @binding(2) var<uniform> uv_scale: vec2<f32>;
		@group(0) @binding(3) var texture_depth: texture_depth_${viewDimension};
		@group(0) @binding(4) var<uniform> light: array<MVP, 2>;
		@group(0) @binding(5) var sampler_filtering: sampler;
		@group(0) @binding(6) var sampler_non_filtering: sampler;
		@group(0) @binding(7) var sampler_depth: sampler_comparison;

		struct Output {
			@builtin(position) position: vec4<f32>,
			@location(0) uv: vec2<f32>,
			@location(1) xy: vec2<f32>,
		}

		fn calcNormal(v: vec2<f32>) -> vec3<f32> {
			let t = v * v;
			return vec3(v, sqrt(1 - t.x - t.y));
		}

		struct MVP {
			screenMatrix: mat4x4<f32>,
			@size(64) cameraMatrix: mat3x4<f32>,
		}

		@vertex
		fn mainVertex(@builtin(vertex_index) vertex_index: u32) -> Output {
			var vertex: vec2<f32>;
			vertex.x = f32(vertex_index >> 1);
			vertex.y = f32(vertex_index & 1);

			var position = vertex * 2 - 1;
			position.y = -position.y;

			var output: Output;
			output.position = vec4<f32>(position, 0, 1);
			output.uv = vertex * uv_scale;
			output.xy = position;
			return output;
		}

		fn calcWorldPt(position:vec2<f32>, uv:vec2<f32>, pvm: MVP) -> vec3<f32> {
			let depth = textureSample(texture_position, sampler_non_filtering, uv);
			let cameraPt = vec4<f32>(position, depth, 1) * pvm.screenMatrix;
			let worldPt = vec4<f32>(cameraPt.xyz / cameraPt.w, 1) * pvm.cameraMatrix;
			return worldPt;
		}

		fn calc_shadow_2d(texture: texture_depth_2d, pos_in_light_camera: vec3<f32>, lightScreenMatrix: mat4x4<f32>) -> f32 {
			let pos_in_light_screen = vec4<f32>(pos_in_light_camera, 1) * lightScreenMatrix;
			let uv = (vec2(pos_in_light_screen.x, -pos_in_light_screen.y) / pos_in_light_screen.w + 1) * 0.5;
			return textureSampleCompare(texture, sampler_depth, uv, pos_in_light_screen.z / pos_in_light_screen.w - shadow_bias);//depth_ref <= the sampled depth
		}

		fn calc_shadow_cube(texture: texture_depth_cube, pos_in_light_camera: vec3<f32>, lightScreenMatrix: mat4x4<f32>) -> f32 {
			let depth = dot(vec4(vec3(1), 1 / length(pos_in_light_camera)), lightScreenMatrix[2]);
			return textureSampleCompare(texture, sampler_depth, pos_in_light_camera, depth - shadow_bias);//depth_ref <= the sampled depth
		}

		@fragment
		fn mainFragment(
			@location(0) uv: vec2<f32>,
			@location(1) position: vec2<f32>,
		) -> @location(0) vec4<f32> {
			let normal_in_world = calcNormal(textureSample(texture_normal, sampler_non_filtering, uv).xy);
			let pos_in_world = calcWorldPt(position, uv, light[1]);
			let pos_in_light_camera: vec3<f32> = vec4<f32>(pos_in_world, 1) * light[0].cameraMatrix;
			let shadow_factor = calc_shadow_${viewDimension}(texture_depth, pos_in_light_camera, light[0].screenMatrix);
			${code}
		}
`);

exports.createDrawFn = createDrawFn;
exports.createDepthDrawFn = createDepthDrawFn;
