'use strict';

const Pipeline = require('../materials/Pipeline');
const {CommandEncoder, beginRenderPass} = require('./CommandEncoder');
/*
(0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5)
0-2-4
|/|/|
1-3-5
*/

const createDrawFn = (groups, code) => {
	const pipeline = new Pipeline({
		groups,
		vertex: {entryPoint: 'mainVertex', code},
		fragment: {entryPoint: 'mainFragment', code, targets:[{format: 'bgra8unorm'}]},
		primitive: {topology: 'triangle-strip'}
	});
	return (device, texture) => {
		for(let commandEncoder of CommandEncoder(device)){
			for(let i=1, n=texture.mipLevelCount; i<n; ++i){
				for(let renderPassEncoder of beginRenderPass('[0,0,0,0]+store', commandEncoder, texture.createView({baseMipLevel:i,mipLevelCount:1}))){
					pipeline.setPipeline(renderPassEncoder);
					pipeline.setResources(renderPassEncoder, {texture: texture.createView({baseMipLevel:i-1,mipLevelCount:1})});
					renderPassEncoder.draw(4);
				}
			}
		}
	}
}

const drawMipmap = createDrawFn([[
		{name:'g_sampler', binding:0, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{minFilter:'linear'}},
		{name:'texture', binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{}},
	]], `
		struct Output {
			@builtin(position) position: vec4<f32>,
			@location(0) uv: vec2<f32>,
		}

		@vertex
		fn mainVertex(@builtin(vertex_index) vertex_index: u32) -> Output {
			let vertex = vec2<f32>(vec2(vertex_index >> 1, vertex_index & 1));
			let position = vertex * 2 - 1;
			return Output(vec4<f32>(position.x, -position.y, 0, 1), vertex);
		}

		@fragment
		fn mainFragment(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
			return textureSample(texture, g_sampler, uv);
		}
`);

exports.drawMipmap = drawMipmap;
