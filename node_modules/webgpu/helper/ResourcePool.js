const {timeline} = document;//performance.now();

function* newGC(fn){
	for(;;){
		yield* fn();
		yield;//fn may not yield
	}
}

function nextPowerOf2(x){
	let value = 1;
	while(value < x)value <<= 1;
	return value;
}

const ObjectPool = function(){
	const timeMap = new WeakMap();
	const updateTimeMap = function(v){timeMap.set(v, this);}
	return (newFn, queryFn, lifetime=1000) => {
		const getCache = [];
		const outCache = [];
		const gc = newGC(function*(){
			for(let i=0; i<getCache.length; ++i){
				const index = -(i + 1);
				if(timeMap.get(getCache.at(index)) + lifetime < timeline.currentTime){
					getCache.splice(index, 1)[0].destroy();
					--i;
				}
				yield;
			}
		});
		return {
			fetch(query){
				const index = getCache.findIndex(queryFn, query);
				const object = index >= 0 ? getCache.splice(index, 1)[0] : newFn(query);
				outCache.push(object);
				return object;
			},
			reset(){
				gc.next();
				outCache.forEach(updateTimeMap, timeline.currentTime + lifetime);
				getCache.unshift(...outCache);
				outCache.length = 0;
			}
		};
	}
}();

const TexturePool = function(){
	const queryFn = function(v){return v.width >= this.width && v.height >= this.height;}
	const wrapNewFn = newFn => ({width, height}) => {
		width = nextPowerOf2(width);
		height = nextPowerOf2(height);
		const result = newFn(width, height);
		result.width = width;
		result.height = height;
		return result;
	}
	return newFn => ObjectPool(wrapNewFn(newFn), queryFn);
}();

const BufferPool = function(){
	const queryFn = function(v){return v.size >= this;}
	return newFn => ObjectPool(size => newFn(nextPowerOf2(size)), queryFn);
}();

const LRUCache = (newFn, lifetime=1000) => {
	const map = new Map();
	const timeMap = new WeakMap();
	const gc = newGC(function*(){
		for(let k of map.keys()){
			if(timeMap.get(k) + lifetime < timeline.currentTime){
				map.get(k).destroy();
				map.delete(k);
			}
			yield;
		}
	});
	return (key, ...args) => {
		gc.next();
		timeMap.set(key, timeline.currentTime);
		if(!map.has(key)){
			map.set(key, newFn(key, ...args));
		}
		return map.get(key);
	};
}

exports.TexturePool = TexturePool;
exports.BufferPool = BufferPool;
exports.LRUCache = LRUCache;
