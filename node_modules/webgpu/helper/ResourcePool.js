const {timeline} = document;//performance.now();
const {ObjectPool, LRUCache} = require('utils/gc');
const {createMapGetter} = require('utils/cache');

function nextPowerOf2(x){
	let value = 1;
	while(value < x)value <<= 1;
	return value;
}

const TexturePool = function(){
	const queryFn1 = function(v){return v.width >= this.width && v.height >= this.height;}
	const queryFn2 = function(v){return v.width == this.width && v.height == this.height;}
	const wrapNewFn = newFn => (query, device) => newFn({...query, width:nextPowerOf2(query.width), height:nextPowerOf2(query.height)}, device);
	return (newFn, adjustFlag=true) => adjustFlag ? ObjectPool(wrapNewFn(newFn), queryFn1) : ObjectPool(newFn, queryFn2);
}();

const BufferPool = function(){
	const queryFn = function(v){return v.size >= this;}
	return newFn => ObjectPool(size => newFn(nextPowerOf2(size)), queryFn);
}();

const TypedArrayCache = function(){
	const newFn = type => {
		let value = new type(1024);
		return length => {
			if(value.length < length){
				value = new type(nextPowerOf2(length));
			}
			return value;
		}
	};
	const map = new Map();
	return (type, length) => {
		if(!map.has(type)){
			map.set(type, newFn(type));
		}
		return map.get(type)(length);
	};
}();

function mainLoop(handler){
	let zero = timeline.currentTime;
	let prev = zero;//timeElapsed
	requestAnimationFrame(function f(timestamp){
		handler(timestamp - prev, timestamp - zero);
		requestAnimationFrame(f);
		prev = timestamp;
	});
}

exports.mainLoop = mainLoop;
exports.TexturePool = TexturePool;
exports.BufferPool = BufferPool;
exports.LRUCache = newFn => createMapGetter(newFn, null, LRUCache(1000));
exports.TypedArrayCache = TypedArrayCache;
