
function nextPowerOf2(x){
	let value = 1;
	while(value < x)value <<= 1;
	return value;
}

const ObjectPool = function(){
	const destroyFn = v => v.destroy();
	const timeoutFn = function(v){return this < v.timestamp;}
	return (newFn, queryFn, lifetime=1000) => {
		const getCache = [];
		const outCache = [];
		return {
			fetch(query){
				const index = queryFn(getCache, query);
				const object = index >= 0 ? getCache.splice(index, 1)[0] : newFn(query);
				outCache.push(object);
				return object;
			},
			reset(){
				const now = performance.now();
				const index = getCache.findIndex(timeoutFn, now);
				getCache.splice(0, index >= 0 ? index : Infinity).forEach(destroyFn);
				while(outCache.length > 0){
					const object = outCache.pop();
					getCache.push(object);
					object.timestamp = now + lifetime;
				}
			}
		};
	}
}();

const TexturePool = function(){
	function queryFn(rectList, {width, height}){
		let bestAreaFit = Infinity;
		let bestShortSideFit;
		let bestRectIndex = -1;
		for(let i=rectList.length-1; i>=0; --i){
			const rect = rectList[i];
			if(rect.width < width || rect.height < height)continue;
			const areaFit = rect.width * rect.height;
			const shortSideFit = Math.min(rect.width - width, rect.height - height);
			if(areaFit < bestAreaFit || areaFit == bestAreaFit && shortSideFit < bestShortSideFit){
				bestAreaFit = areaFit;
				bestShortSideFit = shortSideFit;
				bestRectIndex = i;
			}
		}
		return bestRectIndex;
	}
	const wrapNewFn = newFn => ({width, height}) => {
		width = nextPowerOf2(width);
		height = nextPowerOf2(height);
		const result = newFn(width, height);
		result.width = width;
		result.height = height;
		return result;
	}
	return (newFn, lifetime) => ObjectPool(wrapNewFn(newFn), queryFn, lifetime);
}();

const BufferPool = function(){
	function queryFn(valueList, size){
		size = nextPowerOf2(size);
		let minValue = Infinity;
		let minIndex = -1;
		for(let i=valueList.length-1; i>=0; --i){
			const test = valueList[i].size;
			if(test == size)return i;
			if(test < size)continue;
			if(test < minValue){
				minValue = test;
				minIndex = i;
			}
		}
		return minIndex;
	}
	return (newFn, lifetime) => ObjectPool(size => newFn(nextPowerOf2(size)), queryFn, lifetime);
}();

const LRUCache = (newFn, lifetime=1000) => {
	const {timeline} = document;
	const map = new Map();
	const timeMap = new WeakMap();
	const gc = (function*(){
		for(;;){
			for(let k of map.keys()){
				if(timeMap.get(k) + lifetime < timeline.currentTime){
					map.get(k).destroy();
					map.delete(k);
				}
				yield;
			}
			yield;//map size maybe 0
		}
	})();
	return (key, ...args) => {
		gc.next();
		timeMap.set(key, timeline.currentTime);
		if(!map.has(key)){
			map.set(key, newFn(key, ...args));
		}
		return map.get(key);
	};
}

exports.TexturePool = TexturePool;
exports.BufferPool = BufferPool;
exports.LRUCache = LRUCache;
