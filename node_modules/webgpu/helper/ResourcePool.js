const {timeline} = document;//performance.now();

function nextPowerOf2(x){
	let value = 1;
	while(value < x)value <<= 1;
	return value;
}

const ObjectPool = function(){
	const timeoutFn = function(v){return v.timestamp < this;}
	const updateTimestamp = function(v){v.timestamp = this;}
	return (newFn, queryFn, lifetime=1000) => {
		const getCache = [];
		const outCache = [];
		return {
			fetch(query){
				const index = getCache.findIndex(queryFn, query);
				const object = index >= 0 ? getCache.splice(index, 1)[0] : newFn(query);
				outCache.push(object);
				return object;
			},
			reset(){
				const index = getCache.findIndex(timeoutFn, timeline.currentTime);
				if(index >= 0)while(getCache.length > index)getCache.pop().destroy();
				outCache.forEach(updateTimestamp, timeline.currentTime + lifetime);
				getCache.unshift(...outCache);
				outCache.length = 0;
			}
		};
	}
}();

const TexturePool = function(){
	const queryFn = function(v){return v.width >= this.width && v.height >= this.height;}
	const wrapNewFn = newFn => ({width, height}) => {
		width = nextPowerOf2(width);
		height = nextPowerOf2(height);
		const result = newFn(width, height);
		result.width = width;
		result.height = height;
		return result;
	}
	return newFn => ObjectPool(wrapNewFn(newFn), queryFn);
}();

const BufferPool = function(){
	const queryFn = function(v){return v.size >= this;}
	return newFn => ObjectPool(size => newFn(nextPowerOf2(size)), queryFn);
}();

const LRUCache = (newFn, lifetime=1000) => {
	const map = new Map();
	const timeMap = new WeakMap();
	const gc = (function*(){
		for(;;){
			for(let k of map.keys()){
				if(timeMap.get(k) + lifetime < timeline.currentTime){
					map.get(k).destroy();
					map.delete(k);
				}
				yield;
			}
			yield;//map size maybe 0
		}
	})();
	return (key, ...args) => {
		gc.next();
		timeMap.set(key, timeline.currentTime);
		if(!map.has(key)){
			map.set(key, newFn(key, ...args));
		}
		return map.get(key);
	};
}

exports.TexturePool = TexturePool;
exports.BufferPool = BufferPool;
exports.LRUCache = LRUCache;
