const {timeline} = document;//performance.now();

function* newGC(fn){
	for(;;){
		yield* fn();
		yield;//fn may not yield
	}
}

function nextPowerOf2(x){
	let value = 1;
	while(value < x)value <<= 1;
	return value;
}

const ObjectPool = function(){
	const timeMap = new WeakMap();
	return (newFn, queryFn, lifetime=1000) => {
		const getCache = [];
		const outCache = [];
		const gc = newGC(function*(){
			for(let i=0; i<getCache.length; ++i){
				const index = -(i + 1);
				if(timeMap.get(getCache.at(index)) + lifetime < timeline.currentTime){
					getCache.splice(index, 1)[0].destroy();
					--i;
				}
				yield;
			}
		});
		function onReset(){
			gc.next();
			getCache.unshift(...outCache);
			outCache.length = 0;
		}
		return (query, device) => {
			const index = getCache.findIndex(queryFn, query);
			const object = index >= 0 ? getCache.splice(index, 1)[0] : newFn(query, device);
			timeMap.set(object, timeline.currentTime);
			if(outCache.length == 0)requestAnimationFrame(onReset);
			outCache.push(object);
			return object;
		}
	}
}();

const TexturePool = function(){
	const queryFn1 = function(v){return v.width >= this.width && v.height >= this.height;}
	const queryFn2 = function(v){return v.width == this.width && v.height == this.height;}
	const wrapNewFn = newFn => query => newFn({...query, width:nextPowerOf2(query.width), height:nextPowerOf2(query.height)});
	return (newFn, adjustFlag=true) => adjustFlag ? ObjectPool(wrapNewFn(newFn), queryFn1) : ObjectPool(newFn, queryFn2);
}();

const BufferPool = function(){
	const queryFn = function(v){return v.size >= this;}
	return newFn => ObjectPool(size => newFn(nextPowerOf2(size)), queryFn);
}();

const LRUCache = (newFn, lifetime=1000) => {
	const map = new Map();
	const timeMap = new WeakMap();
	const gc = newGC(function*(){
		for(let k of map.keys()){
			if(timeMap.get(k) + lifetime < timeline.currentTime){
				map.get(k).destroy();
				map.delete(k);
			}
			yield;
		}
	});
	return (key, ...args) => {
		gc.next();
		timeMap.set(key, timeline.currentTime);
		if(!map.has(key)){
			map.set(key, newFn(key, ...args));
		}
		return map.get(key);
	};
}

const TypedArrayCache = function(){
	const newFn = type => {
		let value = new type(1024);
		return length => {
			if(value.length < length){
				value = new type(nextPowerOf2(length));
			}
			return value;
		}
	};
	const map = new Map();
	return (type, length) => {
		if(!map.has(type)){
			map.set(type, newFn(type));
		}
		return map.get(type)(length);
	};
}();

function mainLoop(handler){
	let zero = timeline.currentTime;
	let prev = zero;//timeElapsed
	requestAnimationFrame(function f(timestamp){
		handler(timestamp - prev, timestamp - zero);
		requestAnimationFrame(f);
		prev = timestamp;
	});
}

exports.mainLoop = mainLoop;
exports.TexturePool = TexturePool;
exports.BufferPool = BufferPool;
exports.LRUCache = LRUCache;
exports.TypedArrayCache = TypedArrayCache;
