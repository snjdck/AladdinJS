
const ObjectPool = function(){
	const destroyFn = v => v.onDestroy();
	const timeoutFn = function(v){return this < v.timestamp;}
	return (lifetime, newFn, queryFn) => {
		const getCache = [];
		const outCache = [];
		return query => {
			if(query !== undefined){
				const index = queryFn(getCache, query);
				const object = index >= 0 ? getCache.splice(index, 1)[0] : newFn(query);
				outCache.push(object);
				return object;
			}
			const now = performance.now();
			const index = getCache.findIndex(timeoutFn, now);
			getCache.splice(0, index >= 0 ? index : Infinity).forEach(destroyFn);
			while(outCache.length > 0){
				const object = outCache.pop();
				getCache.push(object);
				object.timestamp = now + lifetime;
			}
		}
	}
}();

const TexturePool = function(){
	function nextPowerOf2(x){
		let value = 1;
		while(value < x)value <<= 1;
		return value;
	}
	function queryFn(rectList, {width, height}){
		let bestAreaFit = Infinity;
		let bestShortSideFit;
		let bestRectIndex = -1;
		for(let i=rectList.length-1; i>=0; --i){
			const rect = rectList[i];
			if(rect.width < width || rect.height < height)continue;
			const areaFit = rect.width * rect.height;
			const shortSideFit = Math.min(rect.width - width, rect.height - height);
			if(areaFit < bestAreaFit || areaFit == bestAreaFit && shortSideFit < bestShortSideFit){
				bestAreaFit = areaFit;
				bestShortSideFit = shortSideFit;
				bestRectIndex = i;
			}
		}
		return bestRectIndex;
	}
	const wrapNewFn = newFn => ({width, height}) => {
		width = nextPowerOf2(width);
		height = nextPowerOf2(height);
		const result = newFn(width, height);
		result.width = width;
		result.height = height;
		return result;
	}
	return (lifetime, newFn) => ObjectPool(lifetime, wrapNewFn(newFn), queryFn);
}();

exports.TexturePool = TexturePool;
