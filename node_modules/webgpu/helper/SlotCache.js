'use strict';

const Vulkan = require('../Vulkan');
const Slot = require('./Slot');

class SlotCache
{
	constructor(bindGroupLayout, bytePerInstance, uniformValueFn){
		const maxCount = Math.floor(0x4000 / bytePerInstance);
		this.uniformCache = createUniformBufferListCache(bindGroupLayout, 0x8000 - bytePerInstance);
		this.slot = new Slot(maxCount);
		this.bytePerInstance = bytePerInstance;
		this.uniformValueFn = uniformValueFn;
	}

	clear(){
		this.slot.clear();
	}

	setBindGroup(bindIndex, batchIndex, bufferOffset){
		const {uniformCache, bytePerInstance} = this;
		const {renderPassEncoder} = Vulkan;
		renderPassEncoder.setBindGroup(bindIndex, uniformCache(batchIndex), [bufferOffset * bytePerInstance]);
	}

	add(instanceList){
		const {uniformCache, slot, bytePerInstance, uniformValueFn} = this;
		const infoList = Array.from(slot.add(instanceList.length));
		let offset = 0;
		for(const info of infoList){
			const instanceCount = info[2];
			for(let i=0; i<instanceCount; ++i){
				const instance = instanceList[offset+i];
				uniformCache(info[0], (info[1] + i) * bytePerInstance, uniformValueFn(instance));
			}
			offset += instanceCount;
		}
		return infoList;
	}
}

function createUniformBufferListCache(layout, size){
	const bufferList = [];
	const bindGroupList = [];
	return function(batchIndex, offset, value){
		const {device} = Vulkan;
		let uniformBuffer = bufferList[batchIndex];
		if(uniformBuffer == null){
			uniformBuffer = bufferList[batchIndex] = device.createBuffer({
				size,
				usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
			});
			bindGroupList[batchIndex] = device.createBindGroup({
				layout,
				entries: [{
					binding: 0,
					resource: {buffer: uniformBuffer, size: 0x4000}
				}]
			});
		}
		if(!value)return bindGroupList[batchIndex];
		Vulkan.copyDataToBuffer(uniformBuffer, value, offset);
	}
}

module.exports = SlotCache;
