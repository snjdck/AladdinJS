'use strict';

const Vulkan = require('../Vulkan');
const BufferBindGroup = require('./BufferBindGroup');
const {createListGetter} = require('utils/cache');

function* split(slotUsage, maxCount, totalCount){
	if(totalCount <= 0)return;
	const extra = totalCount % maxCount;
	for(let i=extra; i<totalCount; i+=maxCount){
		yield [slotUsage.push(0)-1, 0, maxCount];
	}
	if(extra <= 0)return;
	const n = slotUsage.length;
	let minIndex = n;
	let minValue = maxCount;
	for(let i=0; i<n; ++i){
		const v = slotUsage[i];
		if(v < extra || v >= minValue)continue;
		minIndex = i;
		minValue = v;
	}
	if(minIndex == n){
		slotUsage.push(maxCount);
	}
	slotUsage[minIndex] -= extra;
	yield [minIndex, maxCount - minValue, extra];
}

const createAddFn = (maxCountPerSlot, cacheFn) => (slotUsage, entityList) => {
	const infoList = Array.from(split(slotUsage, maxCountPerSlot, entityList.length));
	let index = 0;
	for(const [batchIndex, instanceOffset, instanceCount] of infoList){
		for(let i=0; i<instanceCount; ++i){
			cacheFn(batchIndex, instanceOffset+i, entityList[index++]);
		}
	}
	return infoList;
}

const VertexBufferSlot = function(){
	function createVertexBufferListCache(maxCountPerSlot, bytePerInstance, valueFn){
		const getBuffer = createListGetter(() => Vulkan.createBuffer(GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, maxCountPerSlot * bytePerInstance));
		return (batchIndex, offset, value) => {
			const buffer = getBuffer(batchIndex);
			if(value === undefined)return buffer;
			Vulkan.device.queue.writeBuffer(buffer, offset * bytePerInstance, valueFn(value));
		}
	}
	return function(maxCountPerSlot, bytePerInstance, valueFn){
		const cacheFn = createVertexBufferListCache(maxCountPerSlot, bytePerInstance, valueFn);
		const add = createAddFn(maxCountPerSlot, cacheFn);
		const usage = [];
		return bindIndex => ({
			reset(){
				usage.length = 0;
			},
			add(entityList){
				return add(usage, entityList);
			},
			active(batchIndex, bufferOffset){
				Vulkan.renderPassEncoder.setVertexBuffer(bindIndex, cacheFn(batchIndex), bufferOffset * bytePerInstance);
			}
		});
	}
}();

const UniformBufferSlot = function(){
	function createUniformBufferListCache(layout, bytePerInstance, valueFn){
		const getGroup = createListGetter(() => new BufferBindGroup(
			[[GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, 0x8000 - bytePerInstance]],
			buffer => [[layout, {buffer, size: 0x4000}]],
		));
		return function(batchIndex, offset, value){
			const group = getGroup(batchIndex);
			if(value === undefined)return group.getBindGroup();
			Vulkan.device.queue.writeBuffer(group.getBuffer(), offset * bytePerInstance, valueFn(value));
		}
	}
	return function(bindGroupLayout, bytePerInstance, valueFn){
		const maxCountPerSlot = Math.floor(0x4000 / bytePerInstance);
		const cacheFn = createUniformBufferListCache(bindGroupLayout, bytePerInstance, valueFn);
		const add = createAddFn(maxCountPerSlot, cacheFn);
		const usage = [];
		return bindIndex => ({
			reset(){
				usage.length = 0;
			},
			add(entityList){
				return add(usage, entityList);
			},
			active(batchIndex, bufferOffset){
				Vulkan.renderPassEncoder.setBindGroup(bindIndex, cacheFn(batchIndex), [bufferOffset * bytePerInstance]);
			}
		});
	}
}();

/*
class Slot
{
	constructor(maxCount){
		Object.defineProperty(this, 'maxCount', {value: Math.max(1, maxCount)});
		Object.defineProperty(this, 'remainList', {value: new RemainList()});
		this.nextIndex = 0;
	}

	clear(){
		this.remainList.clear();
		this.nextIndex = 0;
	}

	*add(totalCount){
		if(totalCount <= 0)return;
		const {remainList, maxCount} = this;
		const extra = totalCount % maxCount;
		for(let i=extra; i<totalCount; i+=maxCount){
			yield [this.nextIndex++, 0, maxCount];
		}
		if(extra <= 0)return;
		const index = remainList.find(extra);
		if(index < 0){
			remainList.add(this.nextIndex, maxCount - extra);
			yield [this.nextIndex++, 0, extra];
		}else{
			const [batchIndex, remainCount] = remainList.get(index);
			remainList.reduce(index, extra);
			yield [batchIndex, maxCount - remainCount, extra];
		}
	}
}

class RemainList
{
	constructor(){
		this.list = [];
	}

	clear(){
		this.list.length = 0;
	}

	get(index){
		return this.list[index];
	}

	find(count, n=this.list.length){
		const {list} = this;
		for(let i=0; i<n; ++i){
			if(count <= list[i][1]){
				return i;
			}
		}
		return -1;
	}

	add(batchIndex, remainCount){
		const {list} = this;
		const value = [batchIndex, remainCount];
		const index = list.push(value) - 1;
		for(let i=index-1; i>=0; --i){
			if(remainCount >= list[i][1])break;
			list[i+1] = list[i];
			list[i] = value;
		}
	}

	reduce(index, count){
		const {list} = this;
		const value = list[index];
		const remainCount = value[1] = value[1] - count;
		if(remainCount <= 0){
			list.splice(index, 1);
			return;
		}
		for(let i=index-1; i>=0; --i){
			if(remainCount >= list[i][1])break;
			list[i+1] = list[i];
			list[i] = value;
		}
	}
}
*/
/*
function assert(valueList, result){
	let slot = new Slot(10);
	let list = valueList.map(v => Array.from(slot.add(v))).reduce((a, b) => a.concat(b), []);
	let value = JSON.stringify(list);
	console.assert(value == result, value, result);
}

assert([0], '[]')
assert([6,7,3,4], '[[0,0,6],[1,0,7],[1,7,3],[0,6,4]]')
assert([5,7,4,1,1,2], '[[0,0,5],[1,0,7],[0,5,4],[0,9,1],[1,7,1],[1,8,2]]')
assert([7,3], '[[0,0,7],[0,7,3]]')
assert([7,4], '[[0,0,7],[1,0,4]]')
assert([7,4,3], '[[0,0,7],[1,0,4],[0,7,3]]')
assert([17,13], '[[0,0,10],[1,0,7],[2,0,10],[1,7,3]]')
assert([50, 50], '[[0,0,10],[1,0,10],[2,0,10],[3,0,10],[4,0,10],[5,0,10],[6,0,10],[7,0,10],[8,0,10],[9,0,10]]')

let remainList = new RemainList();
remainList.add(0, 10);
remainList.add(3, 10);
remainList.add(4, 10);
remainList.add(5, 11);
remainList.add(1, 9);
remainList.add(2, 8);
console.log(remainList);
remainList.reduce(5, 2);
console.log(remainList);
//*/

exports.VertexBufferSlot = VertexBufferSlot;
exports.UniformBufferSlot = UniformBufferSlot;
