'use strict';

const Vulkan = require('../Vulkan');
const {createListGetter} = require('utils/cache');

function* split(slotUsage, maxCountPerSlot, totalCount){
	if(totalCount <= 0)return;
	const extra = totalCount % maxCountPerSlot;
	for(let i=extra; i<totalCount; i+=maxCountPerSlot){
		yield {
			batchIndex: slotUsage.push(0)-1,
			instanceOffset: 0,
			instanceCount: maxCountPerSlot,
			instanceOffsetGlobal: i - extra,
		};
	}
	if(extra <= 0)return;
	const n = slotUsage.length;
	let minIndex = n;
	let minValue = maxCountPerSlot;
	for(let i=0; i<n; ++i){
		const v = slotUsage[i];
		if(v < extra || v >= minValue)continue;
		minIndex = i;
		minValue = v;
	}
	if(minIndex == n)slotUsage.push(maxCountPerSlot);
	slotUsage[minIndex] -= extra;
	yield {
		batchIndex: minIndex,
		instanceOffset: maxCountPerSlot - minValue,
		instanceCount: extra,
		instanceOffsetGlobal: totalCount - extra,
	};
}

function createSlot(maxCountPerSlot, bytePerInstance, valueFn, activeFn, cacheFn){
	const slotUsage = [];
	function add(entityList){
		const infoList = Array.from(split(slotUsage, maxCountPerSlot, entityList.length));
		for(const {batchIndex, instanceOffset, instanceCount, instanceOffsetGlobal} of infoList){
			for(let i=0; i<instanceCount; ++i){
				cacheFn(batchIndex, (instanceOffset + i) * bytePerInstance, valueFn(entityList[instanceOffsetGlobal + i]));
			}
		}
		return infoList;
	}
	return {
		reset: () => slotUsage.length = 0,
		bind(material, bindIndex){
			return {
				name: this.name, material, add,
				active(batchIndex, instanceOffset){
					activeFn.call(this, bindIndex, cacheFn(batchIndex), instanceOffset * bytePerInstance);
				}
			};
		}
	};
}

function createCache(usage, size){
	const getBuffer = createListGetter(() => Vulkan.device.createBuffer({usage: usage | GPUBufferUsage.COPY_DST, size}));
	return function(batchIndex, offset, value){
		if(value === undefined)return getBuffer(batchIndex);
		Vulkan.device.queue.writeBuffer(getBuffer(batchIndex), offset, value);
	}
}

const BufferSlot = (usage, size, activeFn) => (maxCountPerSlot, bytePerInstance, valueFn) => createSlot(maxCountPerSlot, bytePerInstance, valueFn, activeFn, createCache(usage, maxCountPerSlot * bytePerInstance * size));

const VertexBufferSlot = BufferSlot(GPUBufferUsage.VERTEX, 1, function(bindIndex, buffer, bufferOffset){
	Vulkan.renderPassEncoder.setVertexBuffer(bindIndex, buffer, bufferOffset);
});

const UniformBufferSlot = BufferSlot(GPUBufferUsage.UNIFORM, 2, function(bindIndex, buffer, bufferOffset){
	const {name, material} = this;
	Vulkan.renderPassEncoder.setBindGroup(bindIndex, material.createBindGroupWith({buffer,offset:0,size:0x4000}, name), [bufferOffset]);
});

/*
function assert(valueList, result){
	let usage = [];
	let list = valueList.map(v => Array.from(split(usage, 10, v))).reduce((a, b) => a.concat(b), []);
	let value = JSON.stringify(list);
	console.assert(value == result, value, result);
}

assert([0], '[]')
assert([6,7,3,4], '[[0,0,6],[1,0,7],[1,7,3],[0,6,4]]')
assert([5,7,4,1,1,2], '[[0,0,5],[1,0,7],[0,5,4],[0,9,1],[1,7,1],[1,8,2]]')
assert([7,3], '[[0,0,7],[0,7,3]]')
assert([7,4], '[[0,0,7],[1,0,4]]')
assert([7,4,3], '[[0,0,7],[1,0,4],[0,7,3]]')
assert([17,13], '[[0,0,10],[1,0,7],[2,0,10],[1,7,3]]')
assert([50, 50], '[[0,0,10],[1,0,10],[2,0,10],[3,0,10],[4,0,10],[5,0,10],[6,0,10],[7,0,10],[8,0,10],[9,0,10]]')
//*/

const activeBindGroup = function(){
	function forEachFn(slot){slot.infoList = slot.add(this)}
	function findFn(v){return this >= v.instanceOffsetGlobal}
	return function*(slotList, entityList){
		if(slotList.length <= 0)return;
		slotList.forEach(forEachFn, entityList);
		for(let i=0, n=entityList.length; i<n;){
			let j=Infinity;
			for(let slot of slotList){
				const {batchIndex, instanceOffset, instanceCount, instanceOffsetGlobal} = slot.infoList.findLast(findFn, i);
				slot.active(batchIndex, instanceOffset + i - instanceOffsetGlobal);
				j = Math.min(j, instanceOffsetGlobal + instanceCount);
			}
			yield j - i;
			i = j;
		}
	}
}();


/*
console.log(Array.from(activeBindGroup([], [])))
console.log(Array.from(activeBindGroup([{active(...args){
	console.log('active 1:', ...args)
}},{active(...args){
	console.log('active 2:', ...args)
}}], [[[0,0,3],[1,0,3]],[[0,0,2],[1,0,2],[2,0,2]]])))
//*/

//exports.calcBindGroupInfoList = calcBindGroupInfoList;
exports.activeBindGroup = activeBindGroup;
exports.VertexBufferSlot = VertexBufferSlot;
exports.UniformBufferSlot = UniformBufferSlot;
