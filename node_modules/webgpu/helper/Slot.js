'use strict';

const Vulkan = require('../Vulkan');
const {createListGetter} = require('utils/cache');

function* split(slotUsage, maxCount, totalCount){
	if(totalCount <= 0)return;
	const extra = totalCount % maxCount;
	for(let i=extra; i<totalCount; i+=maxCount){
		yield [slotUsage.push(0)-1, 0, maxCount];
	}
	if(extra <= 0)return;
	const n = slotUsage.length;
	let minIndex = n;
	let minValue = maxCount;
	for(let i=0; i<n; ++i){
		const v = slotUsage[i];
		if(v < extra || v >= minValue)continue;
		minIndex = i;
		minValue = v;
	}
	if(minIndex == n){
		slotUsage.push(maxCount);
	}
	slotUsage[minIndex] -= extra;
	yield [minIndex, maxCount - minValue, extra];
}

const createAddFn = (maxCountPerSlot, bytePerInstance, cacheFn, valueFn, slotUsage) => entityList => {
	const infoList = Array.from(split(slotUsage, maxCountPerSlot, entityList.length));
	let index = 0;
	for(const [batchIndex, instanceOffset, instanceCount] of infoList){
		for(let i=0; i<instanceCount; ++i){
			cacheFn(batchIndex, (instanceOffset + i) * bytePerInstance, valueFn(entityList[index++]));
		}
	}
	return infoList;
}

function createSlot(maxCountPerSlot, bytePerInstance, valueFn, activeFn, cacheFn){
	const slotUsage = [];
	const add = createAddFn(maxCountPerSlot, bytePerInstance, cacheFn, valueFn, slotUsage);
	return {
		reset: () => slotUsage.length = 0,
		bind: (materialClass, bindIndex) => ({add, active: (batchIndex, bufferOffset) => activeFn(materialClass, bindIndex, cacheFn(batchIndex), bufferOffset * bytePerInstance)})
	};
}

const VertexBufferSlot = function(){
	function createCache(size){
		const getBuffer = createListGetter(() => Vulkan.createBuffer(GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, size));
		return (batchIndex, offset, value) => {
			if(value === undefined)return getBuffer(batchIndex);
			Vulkan.device.queue.writeBuffer(getBuffer(batchIndex), offset, value);
		}
	}
	const activeFn = (materialClass, bindIndex, value, bufferOffset) => Vulkan.renderPassEncoder.setVertexBuffer(bindIndex, value, bufferOffset);
	return (maxCountPerSlot, bytePerInstance, valueFn) => createSlot(maxCountPerSlot, bytePerInstance, valueFn, activeFn, createCache(maxCountPerSlot * bytePerInstance));
}();

const UniformBufferSlot = function(){
	function createCache(){
		const getBuffer = createListGetter(() => Vulkan.device.createBuffer({usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, size: 0x8000}));
		return function(batchIndex, offset, value){
			if(value === undefined)return getBuffer(batchIndex);
			Vulkan.device.queue.writeBuffer(getBuffer(batchIndex), offset, value);
		}
	}
	const activeFn = (materialClass, bindIndex, value, bufferOffset) => Vulkan.renderPassEncoder.setBindGroup(bindIndex, materialClass.createBindGroup(bindIndex, [{binding:0,resource:{buffer:value, size: 0x4000}}]), [bufferOffset]);
	return (bytePerInstance, valueFn) => createSlot(Math.floor(0x4000 / bytePerInstance), bytePerInstance, valueFn, activeFn, createCache());
}();

/*
function assert(valueList, result){
	let usage = [];
	let list = valueList.map(v => Array.from(split(usage, 10, v))).reduce((a, b) => a.concat(b), []);
	let value = JSON.stringify(list);
	console.assert(value == result, value, result);
}

assert([0], '[]')
assert([6,7,3,4], '[[0,0,6],[1,0,7],[1,7,3],[0,6,4]]')
assert([5,7,4,1,1,2], '[[0,0,5],[1,0,7],[0,5,4],[0,9,1],[1,7,1],[1,8,2]]')
assert([7,3], '[[0,0,7],[0,7,3]]')
assert([7,4], '[[0,0,7],[1,0,4]]')
assert([7,4,3], '[[0,0,7],[1,0,4],[0,7,3]]')
assert([17,13], '[[0,0,10],[1,0,7],[2,0,10],[1,7,3]]')
assert([50, 50], '[[0,0,10],[1,0,10],[2,0,10],[3,0,10],[4,0,10],[5,0,10],[6,0,10],[7,0,10],[8,0,10],[9,0,10]]')
//*/

const calcBindGroupInfoList = function(){
	function mapFn(slot){return slot.add(this)}
	return (slotList, entityList) => slotList.map(mapFn, entityList);
}();

function* activeBindGroup(slotList, entityList){
	if(slotList.length <= 0)return;
	const dataList = slotList.map(slot => [slot, slot.add(entityList), 0, 0]);
	for(let i=0;;){
		let offsetEnd = Number.MAX_SAFE_INTEGER;
		for(let data of dataList){
			const [slot, info, index, offset] = data;
			if(i < offset){
				const [batchIndex, bufferOffset, instanceCount] = info[index-1];
				slot.active(batchIndex, bufferOffset + i - (offset - instanceCount));
			}else{
				if(index >= info.length)return;
				const [batchIndex, bufferOffset, instanceCount] = info[index];
				slot.active(batchIndex, bufferOffset);
				data[2] = index + 1;
				data[3] = offset + instanceCount;
			}
			offsetEnd = Math.min(offsetEnd, data[3]);
		}
		yield offsetEnd - i;
		i = offsetEnd;
	}
}

/*
console.log(Array.from(activeBindGroup([], [])))
console.log(Array.from(activeBindGroup([{active(...args){
	console.log('active 1:', ...args)
}},{active(...args){
	console.log('active 2:', ...args)
}}], [[[0,0,3],[1,0,3]],[[0,0,2],[1,0,2],[2,0,2]]])))
//*/

//exports.calcBindGroupInfoList = calcBindGroupInfoList;
exports.activeBindGroup = activeBindGroup;
exports.VertexBufferSlot = VertexBufferSlot;
exports.UniformBufferSlot = UniformBufferSlot;
