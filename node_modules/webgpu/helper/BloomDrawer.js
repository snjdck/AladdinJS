'use strict';

const Pipeline = require('../materials/Pipeline');
const {CommandEncoder, beginRenderPass} = require('./CommandEncoder');
const {fetchBloomTexture} = require('../Vulkan/resource');
/*
(0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5)
0-2-4
|/|/|
1-3-5
*/

const createView = (texture, baseMipLevel=0) => texture.createView({baseMipLevel, mipLevelCount:1});

const createDrawFn = (code) => {
	const code1 = code + `
		@fragment
		fn mainFragment(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
			let stride = 1 / vec2<f32>(textureDimensions(g_texture));
			return vec4<f32>(GaussNxN(g_texture, uv, 5, stride, 1), 1);
		}
`;
const code2 = code + `
		@group(0) @binding(2) var g_texture2: texture_2d<f32>;
		@fragment
		fn mainFragment(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
			let curr_stride = 1 / vec2<f32>(textureDimensions(g_texture));
			let prev_stride = 1 / vec2<f32>(textureDimensions(g_texture2));
			let curr_mip = GaussNxN(g_texture, uv, 5, curr_stride, 1);
			let prev_mip = GaussNxN(g_texture2, uv, 5, prev_stride, 1);
			return vec4<f32>(curr_mip + prev_mip, 1);
		}
`;
	const pipeline1 = new Pipeline({
		groups:[[
			{binding:0, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
			{name:'texture' , binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{}},
		]],
		vertex: {entryPoint: 'mainVertex', code:code1},
		fragment: {entryPoint: 'mainFragment', code:code1, targets:[{format: 'bgra8unorm'}]},
		primitive: {topology: 'triangle-strip'}
	});
	const pipeline2 = new Pipeline({
		groups:[[
			{binding:0, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
			{name:'texture' , binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{}},
			{name:'texture2', binding:2, visibility:GPUShaderStage.FRAGMENT, texture:{}}
		]],
		vertex: {entryPoint: 'mainVertex', code:code2},
		fragment: {entryPoint: 'mainFragment', code:code2, targets:[{format: 'bgra8unorm'}]},
		primitive: {topology: 'triangle-strip'}
	});
	const pipeline3 = pipeline2.clone({
		fragment:{code:code + `
		@group(0) @binding(2) var g_texture2: texture_2d<f32>;
		@fragment
		fn mainFragment(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
			let a = textureSample(g_texture , g_sampler, uv);
			let b = textureSample(g_texture2, g_sampler, uv);
			return select(b, vec4<f32>(), a.a > 0);
		}
`}
	})
	return (device, texture) => {
		const {texture0, texture1, texture2} = fetchBloomTexture({width:texture.width, height:texture.height});
		const n = 7;//texture0.mipLevelCount;
		for(let commandEncoder of CommandEncoder(device)){
			for(let i=0; i<n; ++i){
				for(let renderPassEncoder of beginRenderPass('[0,0,0,0]+store', commandEncoder, createView(texture0, i))){
					pipeline1.setPipeline(renderPassEncoder);
					pipeline1.setResources(renderPassEncoder, {texture: i==0 ? createView(texture, 0) : createView(texture0, i-1)});
					renderPassEncoder.draw(4);
				}
			}
			for(let i=n-2; i>=0; --i){
				for(let renderPassEncoder of beginRenderPass('[0,0,0,0]+store', commandEncoder, createView(texture1, i))){
					pipeline2.setPipeline(renderPassEncoder);
					pipeline2.setResources(renderPassEncoder, {
						texture: createView(texture0, i),
						texture2:createView(i == n-2 ? texture0 : texture1, i+1)
					});
					renderPassEncoder.draw(4);
				}
			}
			//*
			commandEncoder.copyTextureToTexture({texture}, {texture:texture2}, texture2);
			for(let renderPassEncoder of beginRenderPass('[0,0,0,0]+store', commandEncoder, createView(texture))){
				pipeline3.setPipeline(renderPassEncoder);
				pipeline3.setResources(renderPassEncoder, {
					texture: createView(texture2),
					texture2:createView(texture1)
				});
				renderPassEncoder.draw(4);
			}
			//commandEncoder.copyTextureToTexture({texture:texture1}, {texture,mipLevel:1}, [texture1.width, texture1.height]);
		}
	}
}

const drawBloom = createDrawFn(`
		struct Output {
			@builtin(position) position: vec4<f32>,
			@location(0) uv: vec2<f32>,
		}

		@vertex
		fn mainVertex(@builtin(vertex_index) vertex_index: u32) -> Output {
			let vertex = vec2<f32>(vec2(vertex_index >> 1, vertex_index & 1));
			let position = vertex * 2 - 1;
			return Output(vec4<f32>(position.x, -position.y, 0, 1), vertex);
		}

		@group(0) @binding(0) var g_sampler: sampler;
		@group(0) @binding(1) var g_texture: texture_2d<f32>;

		const PI:f32 = 3.14159265358;
		const E :f32 = 2.71828182846;

		fn GaussWeight2D(x:f32, y:f32, sigma:f32) -> f32 {
			let sigma_2 = 2 * sigma * sigma;
			return exp(-(x*x + y*y) / sigma_2) / (PI * sigma_2);
		}

		fn GaussNxN(tex:texture_2d<f32>, uv:vec2<f32>, n:i32, stride:vec2<f32>, sigma:f32) -> vec3<f32> {
			let r:i32 = n >> 1;
			var color:vec3<f32>;
			var weight:f32;

			for(var i:i32=-r; i<=r; i++){
				for(var j:i32=-r; j<=r; j++){
					let w = GaussWeight2D(f32(i), f32(j), sigma);
					let coord = uv + vec2<f32>(vec2(i, j)) * stride;
					color += textureSample(tex, g_sampler, coord).rgb * w;
					weight += w;
				}
			}

			return color / weight;
		}
`);

exports.drawBloom = drawBloom;
