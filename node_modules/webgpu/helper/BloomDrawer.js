'use strict';

const {CommandEncoder, beginRenderPass} = require('./CommandEncoder');
const {blit} = require('./RectDrawer');
const {fetchBloomTexture} = require('../Vulkan/resource');

const createView = (texture, baseMipLevel=0) => texture.createView({baseMipLevel, mipLevelCount:1});

const drawBloom = function(){
	const blit1 = blit([[
		{name:'g_sampler', binding:0, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
		{name:'texture' , binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{}},
	]], {format: 'rgba16float'}, `
		#include<gauss_blur>
		@fragment
		fn main(@location(0) uvxy: vec4<f32>) -> @location(0) vec4<f32> {
			let stride = 1 / vec2<f32>(textureDimensions(texture));
			return vec4<f32>(GaussNxN(texture, g_sampler, uvxy.xy, 5, stride, 1), 1);
		}
	`);
	const blit2 = blit([[
		{name:'g_sampler', binding:0, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
		{name:'texture' , binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{}},
		{name:'texture2', binding:2, visibility:GPUShaderStage.FRAGMENT, texture:{}}
	]], {format: 'rgba16float'}, `
		#include<gauss_blur>
		@fragment
		fn main(@location(0) uvxy: vec4<f32>) -> @location(0) vec4<f32> {
			let curr_stride = 1 / vec2<f32>(textureDimensions(texture));
			let prev_stride = 1 / vec2<f32>(textureDimensions(texture2));
			let curr_mip = GaussNxN(texture, g_sampler, uvxy.xy, 5, curr_stride, 1);
			let prev_mip = GaussNxN(texture2, g_sampler, uvxy.xy, 5, prev_stride, 1);
			return vec4<f32>(curr_mip + prev_mip, 1);
		}
	`);

	const blit3 = blit([[
		{name:'g_sampler', binding:0, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
		{name:'texture' , binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{}},
	]], {format: 'rgba16float'}, `
		@fragment
		fn main(@location(0) uvxy: vec4<f32>) -> @location(0) vec4<f32> {
			return textureSample(texture, g_sampler, uvxy.xy) * 5;
		}
	`);

	return (device, texture) => {
		const {texture0, texture1} = fetchBloomTexture({width:texture.width, height:texture.height});
		const n = texture0.mipLevelCount;
		for(let commandEncoder of CommandEncoder(device)){
			for(let i=0; i<n; ++i){
				for(let renderPassEncoder of beginRenderPass('[0,0,0,0]+store', commandEncoder, createView(texture0, i))){
					blit1(renderPassEncoder, {texture: i==0 ? createView(texture, 0) : createView(texture0, i-1)});
				}
			}
			for(let i=n-2; i>=0; --i){
				for(let renderPassEncoder of beginRenderPass('[0,0,0,0]+store', commandEncoder, createView(texture1, i))){
					blit2(renderPassEncoder, {
						texture: createView(texture0, i),
						texture2:createView(i == n-2 ? texture0 : texture1, i+1)
					});
				}
			}
			//*
			//commandEncoder.copyTextureToTexture({texture}, {texture:texture2}, texture2);
			for(let renderPassEncoder of beginRenderPass('[0,0,0,0]+store', commandEncoder, createView(texture))){
				blit3(renderPassEncoder, {texture: createView(texture1)});
			}
			//commandEncoder.copyTextureToTexture({texture:texture1}, {texture,mipLevel:1}, [texture1.width, texture1.height]);
		}
	}
}();

exports.drawBloom = drawBloom;
