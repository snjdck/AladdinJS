'use strict';

const Pipeline = require('../materials/Pipeline');

const createView = (texture, baseArrayLayer=0, baseMipLevel=0) => texture.createView({dimension: '2d', baseArrayLayer, arrayLayerCount:1, baseMipLevel, mipLevelCount:1});

const drawBloom = function(){
	const blit1 = Pipeline.Blit([[
		{name:'g_sampler', sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
		{name:'texture'  , texture:{}},
	]], {format: 'rgba16float'}, `
		#include<gauss_blur>
		@fragment{
			let stride = 1 / vec2<f32>(textureDimensions(texture));
			return vec4(GaussNxN(texture, g_sampler, uvxy.xy, 5, stride, 1), 1);
		}
	`);
	const blit2 = Pipeline.Blit([[
		{name:'g_sampler', sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
		{name:'texture' , texture:{}},
		{name:'texture2', texture:{}}
	]], {format: 'rgba16float'}, `
		#include<gauss_blur>
		@fragment{
			let curr_stride = 1 / vec2<f32>(textureDimensions(texture));
			let prev_stride = 1 / vec2<f32>(textureDimensions(texture2));
			let curr_mip = GaussNxN(texture, g_sampler, uvxy.xy, 5, curr_stride, 1);
			let prev_mip = GaussNxN(texture2, g_sampler, uvxy.xy, 5, prev_stride, 1);
			return vec4(curr_mip + prev_mip, 1);
		}
	`);

	const blit3 = Pipeline.Blit([[
		{name:'g_sampler', sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
		{name:'texture' , texture:{}},
	]], {format: 'rgba16float'}, `
		@fragment{
			return textureSample(texture, g_sampler, uvxy.xy) * 5;
		}
	`);

	return (commandEncoder, texture) => {
		const textureSize = {width:texture.width>>1, height:texture.height>>1, depthOrArrayLayers:2};
		const mipLevelCount = Math.floor(Math.log2(Math.max(textureSize.width, textureSize.height))) + 1;
		const textureTemp = commandEncoder.fetchTempTexture(textureSize, 'rgba16float,0x14,2d,'+mipLevelCount);
		
		const n = textureTemp.mipLevelCount;

			for(let i=0; i<n; ++i){
				for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store', createView(textureTemp, 0, i))){
					renderPassEncoder.drawQuadWith(blit1, {texture: i==0 ? createView(texture) : createView(textureTemp, 0, i-1)});
				}
			}
			for(let i=n-2; i>=0; --i){
				for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store', createView(textureTemp, 1, i))){
					renderPassEncoder.drawQuadWith(blit2, {
						texture: createView(textureTemp, 0, i),
						texture2:createView(textureTemp, i == n-2 ? 0 : 1, i+1)
					});
				}
			}
			//*
			//commandEncoder.copyTextureToTexture({texture}, {texture:texture2}, texture2);
			for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store', createView(texture))){
				renderPassEncoder.drawQuadWith(blit3, {texture: createView(textureTemp, 1)});
			}
			//commandEncoder.copyTextureToTexture({texture:texture1}, {texture,mipLevel:1}, [texture1.width, texture1.height]);
		}
}();

exports.drawBloom = drawBloom;
