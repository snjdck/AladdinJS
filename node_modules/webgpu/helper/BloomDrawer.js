'use strict';

const Pipeline = require('../materials/Pipeline');
const {CommandEncoder, beginRenderPass} = require('./CommandEncoder');
/*
(0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5)
0-2-4
|/|/|
1-3-5
*/

const createDrawFn = (groups, code) => {
	const pipeline = new Pipeline({
		groups,
		vertex: {entryPoint: 'mainVertex', code},
		fragment: {entryPoint: 'mainFragment', code, targets:[{format: 'bgra8unorm'}]},
		primitive: {topology: 'triangle-strip'}
	});
	return (device, texture) => {
		for(let commandEncoder of CommandEncoder(device)){
			for(let i=1, n=texture.mipLevelCount; i<n; ++i){
				for(let renderPassEncoder of beginRenderPass('[0,0,0,0]+store', commandEncoder, texture.createView({baseMipLevel:i,mipLevelCount:1}))){
					pipeline.setPipeline(renderPassEncoder);
					pipeline.setResources(renderPassEncoder, {texture: texture.createView({baseMipLevel:i-1,mipLevelCount:1})});
					renderPassEncoder.draw(4);
				}
			}
		}
	}
}

const drawBloom = createDrawFn([[
		{binding:0, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{minFilter:'linear',magFilter:'linear'}},
		{name:'texture', binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{}},
	]], `
		@group(0) @binding(0) var g_sampler: sampler;
		@group(0) @binding(1) var g_texture: texture_2d<f32>;

		struct Output {
			@builtin(position) position: vec4<f32>,
			@location(0) uv: vec2<f32>,
		}

		@vertex
		fn mainVertex(@builtin(vertex_index) vertex_index: u32) -> Output {
			let vertex = vec2<f32>(vec2(vertex_index >> 1, vertex_index & 1));
			let position = vertex * 2 - 1;
			return Output(vec4<f32>(position.x, -position.y, 0, 1), vertex);
		}

		const PI:f32 = 3.14159265358;
		const E :f32 = 2.71828182846;

		fn GaussWeight2D(x:f32, y:f32, sigma:f32) -> f32 {
			let sigma_2 = 2 * sigma * sigma;
			return exp(-(x*x + y*y) / sigma_2) / (PI * sigma_2);
		}

		fn GaussNxN(uv:vec2<f32>, n:i32, stride:vec2<f32>, sigma:f32) -> vec3<f32> {
			let r:i32 = n >> 1;
			var color:vec3<f32>;
			var weight:f32;

			for(var i:i32=-r; i<=r; i++){
				for(var j:i32=-r; j<=r; j++){
					let w = GaussWeight2D(f32(i), f32(j), sigma);
					let coord = uv + vec2<f32>(vec2(i, j)) * stride;
					color += textureSample(g_texture, g_sampler, coord).rgb * w;
					weight += w;
				}
			}

			return color / weight;
		}

		@fragment
		fn mainFragment(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
			let stride = 1 / vec2<f32>(textureDimensions(g_texture));
			return vec4<f32>(GaussNxN(uv, 5, stride, 1), 1);
		}
`);

exports.drawBloom = drawBloom;
