'use strict';

const Vulkan = require('../Vulkan');

const DisplayObject = require('../DisplayObject');
const DisplayObject3D = require('../DisplayObject3D');

const BoneObject = require('opengl/3d/BoneObject');

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialDict = new Map();

		if(!(createSkeleton && mesh.boneList.length > 0))return;
		this.buildBoneTree();
		this.animationList = mesh.animationList;
		this.animation = this.animationList[20] || this.animationList[0];
		this.animationTime = 0;
	}

	addMaterial(material){
		this.materialDict.set(material.constructor, material);
		return this;
	}

	getMaterial(materialType){
		return this.materialDict.get(materialType);
	}

	onDraw(){}

	onUpdate(){
		const {animation, animationTime} = this;
		if(animation){
			let timeElapsed = 1000 / 60;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(this.attachmentDict){
			for(const [attachment] of this.attachmentDict){
				DisplayObject.updateWorldTransform(attachment);
				DisplayObject.updateTree(attachment);
			}
		}
		if(!this._skeleton){
			this.rootBone?.updateBone(this);
		}
	}

	buildBoneTree(){
		const boneDict = Object.create(null);
		const boneList = [];
		let rootBone;
		for(let {boneName, boneID, bonePID} of this.mesh.boneList){
			let boneParent = bonePID < 0 ? null : boneList[bonePID];
			let bone = new BoneObject(boneParent, boneID);

			boneDict[boneName] = bone;
			boneList[boneID] = bone;

			if(bonePID >= 0){
				boneParent.addChild(bone);
			}else if(rootBone){
				rootBone.addSibling(bone);
			}else{
				rootBone = bone;
			}
		}
		rootBone.boneDict = boneDict;
		this.rootBone = rootBone;
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton || this;
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		if(!this.attachmentDict){
			this.attachmentDict = new Map();
		}
		if(clearOtherObjects)this.unbindObjects(boneName);
		this.attachmentDict.set(target, boneName);
	}

	unbindObject(target){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		attachmentDict.delete(target);
	}

	unbindObjects(boneName){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		if(boneName == null){
			attachmentDict.clear();
			return;
		}
		for(const [attachment, name] of attachmentDict){
			if(name != boneName)continue;
			attachmentDict.delete(attachment);
		}
	}
}

module.exports = MeshEntity;
