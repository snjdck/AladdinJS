'use strict';

const Vulkan = require('../Vulkan');

const DisplayObject = require('../DisplayObject');
const DisplayObject3D = require('../DisplayObject3D');

const BoneObject = require('./BoneObject');
const MaterialDict = require('./MaterialDict');
const AttachmentMixin = require('./AttachmentMixin');

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialDict = new MaterialDict();

		if(!(createSkeleton && mesh.boneList.length > 0))return;
		this.animationList = mesh.animationList;
		this.animation = this.animationList[0];
		this.animationTime = 0;
		this.rootBone = BoneObject.buildBoneTree(this.mesh.boneList);
		this.rootBone?.updateBone(this);
	}

	addMaterial(material, subMeshFilter=0xFFFFFFFF){
		this.materialDict.addMaterial(material, subMeshFilter);
		return this;
	}

	onCollectDrawUnits(drawUnitBucket){
		this.materialDict.collectDrawUnits(this, drawUnitBucket);
		if(this.attachmentDict){
			for(const [attachment, boneName] of this.attachmentDict){
				const {worldTransform} = attachment;
				worldTransform.copyFrom(this.skeleton.rootBone.getBoneWorldMatrix(boneName));
				worldTransform.prepend(attachment.transform);
				worldTransform.append(this.worldTransform);
				attachment.onCollectDrawUnits?.(drawUnitBucket);
			}
		}
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton || this;
	}
}

AttachmentMixin(MeshEntity);

module.exports = MeshEntity;
