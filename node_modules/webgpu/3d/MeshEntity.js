'use strict';

const Vulkan = require('../Vulkan');

const DisplayObject3D = require('../DisplayObject3D');

const BoneObject = require('./BoneObject');
const AttachmentMixin = require('./AttachmentMixin');
const {runAction} = require('game/engine/action/Action');

const PlayAnimationAction = (name, reverseFlag, repeatFlag, rewindFlag) => function*(target){
	const animation = target.mesh.animationList.find(v => v.name == name);
	const count = repeatFlag ? Infinity : rewindFlag ? 2 : 1;
	for(let time=0;;){
		let aniTime;
		if(rewindFlag){
			if(Math.floor(time / animation.duration) % 2 == reverseFlag){
				aniTime = time % animation.duration;
			}else{
				aniTime = animation.duration - time % animation.duration;
			}
		}else if(reverseFlag){
			aniTime = animation.duration - time % animation.duration;
		}else{
			aniTime = time % animation.duration;
		}
		target.rootBone?.updateBone(animation, aniTime, target.boneState);
		if(time >= animation.duration * count)break;
		time = (yield) * target.timeScale;
	}
}

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialSet = new Set();

		if(!(createSkeleton && mesh.boneList?.length > 0))return;
		this.animationList = mesh.animationList;
		this.animation = this.animationList[0];
		this.rootBone = BoneObject.buildBoneTree(this.mesh.boneList);
		this.boneState = this.rootBone?.buildBoneState();
		this.rootBone?.updateBone(this.animation, 0, this.boneState);
		this.timeScale = 0.006;
	}

	playAnimationByIndex(index=0, mode='repeat'){
		mode = mode.split('-')
		const value = this.animationList[index];
		if(!value)return;
		if(this.animation == value)return;
		this.animation = value;
		this.playAction?.cancel();
		this.playAction = runAction(this, PlayAnimationAction(index, mode.includes('reverse'), mode.includes('repeat'), mode.includes('rewind')));
		return this.playAction;
	}

	setAnimationIndex(index=0){
		this.animation = this.animationList[index];
	}

	addMaterial(material){
		this.materialSet.add(material);
		return this;
	}

	removeMaterial(material){
		this.materialSet.delete(material);
	}

	getMaterials(){
		return this.materialSet;
	}

	*onCollectEntities(camera){
		if(this.materialSet.size > 0)yield this;
		yield* super.onCollectEntities(camera);
		if(!this.hasAttachment())return;
		const {boneState} = this.skeleton;
		for(const [attachment, boneName] of this.attachmentDict){
			boneState[boneName]
			.copyToWorldMatrix(attachment.worldTransform)
			.prepend(attachment.transform)
			.append(this.worldTransform);
			yield* attachment.collectEntities(camera);
		}
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton ?? this;
	}

	copyBoneStateToBuffer(buffer){
		const {boneState} = this.skeleton;
		for(const name in boneState){
			boneState[name].copyToBuffer(buffer);
		}
	}
}

MeshEntity.PlayAnimationAction = PlayAnimationAction;

AttachmentMixin(MeshEntity);

module.exports = MeshEntity;
