'use strict';

const Vulkan = require('../Vulkan');

const DisplayObject3D = require('../DisplayObject3D');

const BoneObject = require('./BoneObject');
const AttachmentMixin = require('./AttachmentMixin');

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialSet = new Set();

		if(!(createSkeleton && mesh.boneList.length > 0))return;
		this.animationList = mesh.animationList;
		this.animation = this.animationList[0];
		this.animationTime = 0;
		this.animationTimestamp = Vulkan.now();
		this.rootBone = BoneObject.buildBoneTree(this.mesh.boneList);
		this.boneState = this.rootBone?.buildBoneState();
		this.rootBone?.updateBone(this);
	}

	addMaterial(material){
		this.materialSet.add(material);
		return this;
	}

	removeMaterial(material){
		this.materialSet.delete(material);
	}

	getMaterials(){
		return this.materialSet;
	}

	*onCollectEntities(camera){
		if(this.materialSet.size > 0)yield this;
		yield* super.onCollectEntities(camera);
		if(!this.hasAttachment())return;
		const {boneState} = this.skeleton;
		for(const [attachment, boneName] of this.attachmentDict){
			boneState[boneName]
			.copyToWorldMatrix(attachment.worldTransform)
			.prepend(attachment.transform)
			.append(this.worldTransform);
			yield* attachment.collectEntities(camera);
		}
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		const skeleton = this._skeleton || this;
		skeleton.updateBoneState();
		return skeleton;
	}

	updateBoneState(){
		if(!this.animation || this.animation.keyFrameCount <= 1)return;
		const timestamp = Vulkan.now();
		if(timestamp - this.animationTimestamp < 10)return;
		const lastAnimationTime = this.animationTime;
		this.animationTime += (timestamp - this.animationTimestamp) * 0.005;
		this.animationTimestamp = timestamp;
		if(this.animationTime > this.animation.duration){
			this.animationTime = 0;
		}
		if(this.animationTime == lastAnimationTime)return;
		this.rootBone?.updateBone(this);
	}

	copyBoneStateToBuffer(buffer){
		const {boneState} = this.skeleton;
		for(const name in boneState){
			boneState[name].copyToBuffer(buffer);
		}
	}
}

AttachmentMixin(MeshEntity);

module.exports = MeshEntity;
