'use strict';

const Vulkan = require('../Vulkan');

const DisplayObject3D = require('../DisplayObject3D');

const BoneObject = require('./BoneObject');
const AttachmentMixin = require('./AttachmentMixin');
const {runAction, ActionBuilder, Sequence, Spawn, Delay, Repeat, CallFunc, nearestRotation} = require('game/engine/action/Action');
const calcTime = require('animation/calcTime');
const {interpolateKeyFrames} = require('animation/interpolate');
const Vector3D = require('webgpu/math/Vector3D');
const {calcAniIndex} = require('mu/calcAniIndex');

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialSet = new Set();

		if(!(createSkeleton && mesh.boneList?.length > 0))return;
		this.animationList = mesh.animationList;
		this.animation = this.animationList[0];
		this.rootBone = BoneObject.buildBoneTree(this.mesh.boneList);
		this.boneState = this.rootBone?.buildBoneState();
		this.rootBone?.updateBone(this.animation, 0, this.boneState);

		this.info = {role:'sorcerer'};
		this.timeScale = 0.006;
	}

	addMaterial(material){
		this.materialSet.add(material);
		return this;
	}

	removeMaterial(material){
		this.materialSet.delete(material);
	}

	getMaterials(){
		return this.materialSet;
	}

	*onCollectEntities(camera){
		if(this.materialSet.size > 0)yield this;
		yield* super.onCollectEntities(camera);
		if(!this.hasAttachment())return;
		const {boneState} = this.skeleton;
		for(const [attachment, boneName] of this.attachmentDict){
			boneState[boneName]
			.copyToWorldMatrix(attachment.worldTransform)
			.prepend(attachment.transform)
			.append(this.worldTransform);
			yield* attachment.collectEntities(camera);
		}
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton ?? this;
	}

	copyBoneStateToBuffer(buffer){
		const {boneState} = this.skeleton;
		for(const name in boneState){
			boneState[name].copyToBuffer(buffer);
		}
	}
}

AttachmentMixin(MeshEntity);

const MoveAction = ActionBuilder(
	(target, value) => [[target.x, value.x ?? target.x + (value.dx ?? 0)], [target.y, value.y ?? target.y + (value.dy ?? 0)]],
	(target, [x, y]) => {target.x=x; target.y=y;}
);

const MoveToAction = ({x, y, speed}) => CallFunc(({animation}) => animation.offsetData.length ? OffsetMoveAction({x, y, animation}) : MoveAction({x, y, speed}));

const PlayAnimationAction = (animation, flags) => function*(target){
	const count = flags.repeat ? Infinity : flags.rewind ? 2 : 1;
	for(let time=0;;){
		target.rootBone?.updateBone(animation, calcTime(time, animation.duration, flags), target.boneState);
		if(time >= animation.duration * count)break;
		time = (yield) * target.timeScale;
	}
};

const OffsetMoveAction = ({x, y, animation}) => function*(target){
	const oldX = target.x;
	const oldY = target.y;
	let time = 0;
	while(Math.hypot(x - target.x, y - target.y) > 10){
		let b = animation.offsetData.at(-1).scaleBy(time / animation.duration >> 0, {});
		let a = interpolateKeyFrames(animation.keyFrameTimes, animation.offsetData, time % animation.duration, new Vector3D());
		target.rotation.rotateVector(a.add(b));
		target.x = oldX + a.x;
		target.y = oldY + a.y;
		time = (yield) * target.timeScale;
	}
};

const FaceToAction = ActionBuilder(
	(target, value) => {
		const currR = target.rotation.toEulerAngles({}).z;
		const destR = nearestRotation(Math.atan2(value.y - target.y, value.x - target.x) - Math.PI * 0.5, currR, Math.PI)
		if(Math.abs(destR - currR) > Math.PI * 0.3){
			target.playAnimationWithAction('stand')
		}
		return [[currR, destR]];
	},
	(target, [v]) => target.rotation = target.rotation.fromEulerAngles(0, 0, v)
);

const FaceAndMoveAction = value => Sequence([
	FaceToAction({...value,speed:0.01}),
	CallFunc(target => target.playAnimationWithAction('walk')),
	//MoveToAction({...value,speed:0.2}),
	Spawn([Delay(1000), MoveToAction({...value,speed:0.2})], 1),
	CallFunc(target => target.playAnimationWithAction('run')),
	MoveToAction({...value,speed:/*0.3*/100}),
	CallFunc(target => target.playAnimationWithAction('stand')),
]);

MeshEntity.prototype.playAnimationWithAction = function(action, mode='repeat'){
	this.info.action = action;
	return this.playAnimationByIndex(calcAniIndex(this.info), mode);
}

MeshEntity.prototype.playAnimationByIndex = function(index=0, mode='repeat'){
	mode = mode.split('-');
	const reverse = mode.includes('reverse');
	const repeat = mode.includes('repeat');
	const rewind = mode.includes('rewind');
	const value = this.mesh.animationList.find(v => v.name == index);
	if(!value)return;
	if(this.animation == value)return;
	this.animation = value;
	this.playAction?.cancel();
	this.playAction = runAction(this, PlayAnimationAction(value, {reverse, repeat, rewind}));
	return this.playAction;
}

MeshEntity.prototype.faceAndMove = function(pt){
	this.moveAction?.cancel();
	this.moveAction = runAction(this, FaceAndMoveAction(pt));
	return this.moveAction;
}

module.exports = MeshEntity;
