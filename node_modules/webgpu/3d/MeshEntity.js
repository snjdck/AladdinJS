'use strict';

const Vulkan = require('../Vulkan');

const DisplayObject = require('../DisplayObject');
const DisplayObject3D = require('../DisplayObject3D');

const BoneObject = require('opengl/3d/BoneObject');
const MaterialDict = require('./MaterialDict');
const AttachmentMixin = require('./AttachmentMixin');

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialDict = new MaterialDict();

		if(!(createSkeleton && mesh.boneList.length > 0))return;
		this.buildBoneTree();
		this.animationList = mesh.animationList;
		this.animation = this.animationList[0];
		this.animationTime = 0;
	}

	addMaterial(material, subMeshFilter=0xFFFFFFFF){
		this.materialDict.addMaterial(material, subMeshFilter);
		return this;
	}

	onCollectDrawUnits(drawUnitBucket){
		this.materialDict.collectDrawUnits(this, drawUnitBucket);
		if(this.attachmentDict){
			for(const [attachment, boneName] of this.attachmentDict){
				const {worldTransform} = attachment;
				worldTransform.copyFrom(this.skeleton.rootBone.getBoneWorldMatrix(boneName));
				worldTransform.prepend(attachment.transform);
				worldTransform.append(this.worldTransform);
				attachment.onCollectDrawUnits?.(drawUnitBucket);
			}
		}
	}

	onDraw(){}

	onUpdate(){
		const {animation, animationTime} = this;
		if(animation){
			let timeElapsed = 1000 / 60;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(this.attachmentDict){
			for(const [attachment] of this.attachmentDict){
				//DisplayObject.updateWorldTransform(attachment);
				DisplayObject.updateTree(attachment);
			}
		}
		if(!this._skeleton){
			this.rootBone?.updateBone(this);
		}
	}

	buildBoneTree(){
		const boneDict = Object.create(null);
		const boneList = [];
		let rootBone;
		for(let {boneName, boneID, bonePID} of this.mesh.boneList){
			let boneParent = bonePID < 0 ? null : boneList[bonePID];
			let bone = new BoneObject(boneParent, boneID);

			boneDict[boneName] = bone;
			boneList[boneID] = bone;

			if(bonePID >= 0){
				boneParent.addChild(bone);
			}else if(rootBone){
				rootBone.addSibling(bone);
			}else{
				rootBone = bone;
			}
		}
		rootBone.boneDict = boneDict;
		this.rootBone = rootBone;
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton || this;
	}
}

AttachmentMixin(MeshEntity);

module.exports = MeshEntity;
