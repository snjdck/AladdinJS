'use strict';

const DisplayObject3D = require('../DisplayObject3D');

const BoneObject = require('./BoneObject');
const AttachmentMixin = require('./AttachmentMixin');
const {runAction, ActionBuilder, Sequence, Spawn, Delay, Repeat, CallFunc, nearestRotation} = require('game/engine/action/Action');
const {PlayAnimationListAction, parseModeArg} = require('animation/calcTime');
const {interpolateKeyFrames} = require('animation/interpolate');
const Vector3D = require('webgpu/math/Vector3D');
const {calcAniIndex} = require('mu/calcAniIndex');

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialSet = new Set();

		if(!(createSkeleton && mesh.boneList?.length > 0))return;
		this.animationList = mesh.animationList;
		this.rootBone = new BoneObject(this.mesh.boneList);
		this.boneState = this.rootBone.buildBoneState();
		this.rootBone.updateBone(mesh.animationList[0], 0, this.boneState);

		this.info = {role:'sorcerer',action:'stand'};
		this.timeScale = 0.006;
	}

	get boneCount(){
		return this.rootBone.boneCount;
	}

	addMaterial(material){
		this.materialSet.add(material);
		return this;
	}

	removeMaterial(material){
		this.materialSet.delete(material);
	}

	getMaterials(){
		return this.materialSet;
	}
/*
	*onCollectEntities(camera){
		if(this.materialSet.size > 0)yield this;
		yield* super.onCollectEntities(camera);
		if(!this.hasAttachment())return;
		const {boneState} = this.skeleton;
		for(const [attachment, boneID] of this.attachmentDict){
			boneState[boneID]
			.copyToMatrix(attachment.worldTransform)
			.prepend(attachment.transform)
			.append(this.worldTransform);
			yield* attachment.collectEntities(camera);
		}
	}
*/
	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton ?? this;
	}

	copyBoneStateToBuffer(buffer){
		const {boneState} = this.skeleton;
		for(let i=0, n=boneState.length; i<n; ++i){
			boneState[i]?.copyToArray(buffer, i << 3);
		}
		return buffer;
	}
}

MeshEntity.prototype.copyBoneStateToTempBuffer = function(){
	const buffer = new Float32Array(256 << 2);
	return function(){
		return this.copyBoneStateToBuffer(buffer);
	}
}();

AttachmentMixin(MeshEntity);

const MoveAction = ActionBuilder(
	(target, value) => [[target.x, value.x ?? target.x + (value.dx ?? 0)], [target.y, value.y ?? target.y + (value.dy ?? 0)]],
	(target, [x, y]) => {target.x=x; target.y=y;}
);

const MoveToAction = ({x, y, speed}) => CallFunc(({animation}) => animation.offsetData.length ? OffsetMoveAction({x, y, animation}) : MoveAction({x, y, speed}));

const PlayAnimationAction = PlayAnimationListAction((target, animation, time) => {
	target.animationIndex = target.mesh.animationList.indexOf(animation);
	target.animationTime = time;
	if(!target.hasAttachment())return;
	const set = new Set();
	const {boneList} = target.skeleton.mesh;
	for(let boneID of target.attachmentDict.values()){
		while(boneID >= 0){
			set.add(boneID);
			boneID = boneList.find(v => v.id == boneID).parent?.id ?? -1;
		}
	}
	target.rootBone.updateBoneWith(animation, time, target.boneState, set)
});

const OffsetMoveAction = ({x, y, animation}) => function*(target){
	const oldX = target.x;
	const oldY = target.y;
	let time = 0;
	while(Math.hypot(x - target.x, y - target.y) > 10){
		let b = animation.offsetData.at(-1).scaleBy(time / animation.duration >> 0, {});
		let a = interpolateKeyFrames(animation.keyFrameTimes, animation.offsetData, time % animation.duration, new Vector3D());
		target.rotation.rotateVector(a.add(b));
		target.x = oldX + a.x;
		target.y = oldY + a.y;
		time = (yield) * target.timeScale;
	}
};

const FaceToAction = ActionBuilder(
	(target, value) => {
		const currR = target.rotation.toEulerAngles({}).z;
		const destR = nearestRotation(Math.atan2(value.y - target.y, value.x - target.x) - Math.PI * 0.5, currR, Math.PI)
		if(Math.abs(destR - currR) > Math.PI * 0.3){
			target.playAnimationWithAction('stand')
		}
		return [[currR, destR]];
	},
	(target, [v]) => target.rotation = target.rotation.fromEulerAngles(0, 0, v)
);

const FaceAndMoveAction = value => Sequence([
	FaceToAction({...value,speed:0.01}),
	CallFunc(target => target.playAnimationWithAction('walk')),
	//MoveToAction({...value,speed:0.2}),
	Spawn([Delay(1000), MoveToAction({...value,speed:0.2})], 1),
	CallFunc(target => target.playAnimationWithAction('run')),
	MoveToAction({...value,speed:/*0.3*/100}),
	CallFunc(target => target.playAnimationWithAction('stand')),
]);

MeshEntity.prototype.playAnimationWithAction = function(action, mode='repeat'){
	this.info.action = action;
	let result = calcAniIndex(this.info);
	if(Array.isArray(result)){
		return this.playAnimationByIndexList(result, mode);
	}
	return this.playAnimationByIndex(result, mode);
}

MeshEntity.prototype.playAnimationByIndex = function(index=0, mode='repeat'){
	const value = this.mesh.animationList.find(v => v.name == index);
	if(!value)return;
	if(this.animation == value)return;
	this.animation = value;
	this.playAction?.cancel();
	this.playAction = runAction(this, PlayAnimationAction([value], this.timeScale, parseModeArg(mode)));
	return this.playAction;
}

MeshEntity.prototype.playAnimationByIndexList = function(indexList, mode='repeat'){
	let aniList = indexList.map(index => this.mesh.animationList.find(v => v.name == index))
	this.animation = aniList[0];
	this.playAction?.cancel();
	this.playAction = runAction(this, PlayAnimationAction(aniList, this.timeScale, parseModeArg(mode)));
	return this.playAction;
}

MeshEntity.prototype.faceAndMove = function(pt){
	this.moveAction?.cancel();
	this.moveAction = runAction(this, FaceAndMoveAction(pt));
	return this.moveAction;
}

module.exports = MeshEntity;
