'use strict';

const Matrix3D = require('opengl/math/Matrix3D');
const Mat3x4 = require('../mat3x4');
const {createGetSet} = require('utils/cache');

class BoneBase
{
	constructor(){
		this.nextSibling = null;
		this.firstChild = null;
	}

	get lastSibling(){
		let target = this;
		while(target.nextSibling)
			target = target.nextSibling;
		return target;
	}

	addSibling(value){
		this.lastSibling.nextSibling = value;
	}

	addChild(value){
		if(this.firstChild){
			this.firstChild.addSibling(value);
		}else{
			this.firstChild = value;
		}
	}

	forEach(handler, self, parent){
		handler.call(self, this, parent);
		this.nextSibling?.forEach(handler, self, parent);
		this.firstChild?.forEach(handler, self, this);
	}
}

class BoneObject extends BoneBase
{
	constructor(id){
		super();
		this.id = id;
		this.transform = new Matrix3D();
		this.worldTransform = new Matrix3D();
		addPropWorldMatrix(this);
	}

	getBoneWorldMatrix(boneName){
		return this.boneDict[boneName].worldMatrix;
	}
}

const addPropWorldMatrix = function(){
	function newFn(){
		const {rotation, translation} = this.worldTransform;
		return this.worldMatrix.compose(rotation, translation);
	}
	return function(target){
		const [getFn, setFn] = createGetSet(newFn, false, new Mat3x4());
		Object.defineProperty(target, 'worldMatrix', {get: getFn});
		target.markWorldMatrixDirty = setFn;
	}
}();

BoneObject.prototype.updateBone = function(){
	function onUpdate(bone, parent){
		const {animation, animationTime} = this;
		const {id, worldTransform, transform} = bone;
		bone.markWorldMatrixDirty();
		animation.calcTransform(id, animationTime, transform);
		if(parent){
			transform.append(parent.worldTransform, worldTransform);
		}else{
			worldTransform.copyFrom(transform);
		}
	}
	return function(entity){
		this.forEach(onUpdate, entity);
	}
}();

BoneObject.prototype.copyToBuffer = function(){
	function onUpdate(bone){
		const {id, worldTransform} = bone;
		worldTransform.copyToArray(this, id << 3);
	}
	return function(buffer){
		this.forEach(onUpdate, buffer);
	}
}();

BoneObject.buildBoneTree = function(boneInfoList){
	const boneDict = Object.create(null);
	const boneList = [];
	let rootBone;
	for(const {boneName, boneID, bonePID} of boneInfoList){
		const bone = new this(boneID);
		if(bonePID >= 0){
			boneList[bonePID].addChild(bone);
		}else if(rootBone){
			rootBone.addSibling(bone);
		}else{
			rootBone = bone;
		}
		boneDict[boneName] = bone;
		boneList[boneID] = bone;
		bone.boneDict = boneDict;
	}
	return rootBone;
}

module.exports = BoneObject;
