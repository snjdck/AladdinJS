'use strict';

const KeyFrame = require('./KeyFrame');
const DisplayObject3D = require('../DisplayObject3D');
/*
class BoneObject
{
	constructor(id, name){
		this.id = id;
		this.name = name;
	}

	addChild(value){
		value.nextSibling = this.firstChild;
		this.firstChild = value;
	}

	forEach(handler, self, parent){
		//handler.call(self, this, parent);
		//this.nextSibling?.forEach(handler, self, parent);
		//this.firstChild?.forEach(handler, self, this);
		//for(let node=this; node; node=node.nextSibling){
		//	handler.call(self, node, parent);
		//	node.firstChild?.forEach(handler, self, node);
		//}
		for(let node=this; node; node=node.firstChild){
			handler.call(self, node, parent);
			node.nextSibling?.forEach(handler, self, parent);
			parent = node;
		}
		return self;
	}
}

BoneObject.prototype.updateBone = function(){
	const transform = new Matrix3D();
	function onUpdate(bone, parent){
		const {animation, time, boneState} = this;
		const {worldTransform} = boneState[bone.name];
		animation.calcTransform(bone.id, time, transform);
		if(parent){
			const parentWorldTransform = boneState[parent.name].worldTransform;
			transform.append(parentWorldTransform, worldTransform);
		}else{
			worldTransform.copyFrom(transform);
		}
	}
	return function(animation, time, boneState){
		this.forEach(onUpdate, {animation, time, boneState});
	}
}();

BoneObject.prototype.buildBoneState = function(){
	class BoneTransform {
		constructor(id){
			this.id = id;
			this.worldTransform = new Matrix3D();
		}
		copyToBuffer(buffer){
			const {id, worldTransform} = this;
			worldTransform.copyToArray(buffer, id << 3);
		}
		copyToWorldMatrix(matrix){
			const {rotation, translation} = this.worldTransform;
			return matrix.compose(rotation, translation);
		}
	}
	function onUpdate(bone){
		this[bone.name] = new BoneTransform(bone.id);
	}
	return function(){
		return this.forEach(onUpdate, Object.create(null));
	}
}();

BoneObject.buildBoneTree = function(boneInfoList){
	const boneList = [];
	let rootBone;
	for(const {boneName, boneID, bonePID} of boneInfoList){
		const bone = new this(boneID, boneName);
		if(bonePID >= 0){
			boneList[bonePID].addChild(bone);
		}else{
			bone.nextSibling = rootBone;
			rootBone = bone;
		}
		boneList[boneID] = bone;
	}
	return rootBone;
}
*/

const keyFrame = new KeyFrame();

const calcBoneList = function(){
	function insert(boneList, result, bone){
		if(bone)result.push(bone);
		for(let child of boneList){
			if(child.parent != bone)continue;
			insert(boneList, result, child);
		}
		return result;
	}
	return boneList => insert(boneList, []);
}();

function calcBoneCount(boneList){
	let maxID = -1;
	for(let bone of boneList){
		if(maxID < bone.id){
			maxID = bone.id;
		}
	}
	return maxID + 1;
}

class BoneObject
{
	constructor(boneList){
		this.boneList = calcBoneList(boneList);
		this.boneCount = calcBoneCount(boneList);
	}

	getBoneID(name){
		return this.boneList.find(v => v.name == name)?.id;
	}

	updateBone(animation, time, boneState){
		const {boneList} = this;
		for(let i=0, n=boneList.length; i<n; ++i){
			const {id, parent} = boneList[i];
			/*
			if(parent){
				animation.calcTransform(id, time, boneState[id]).append(boneState[parent.id]);
			}else{
				animation.calcTransform(id, time, boneState[id]);
			}
			*/
			animation.calcTransform(id, time, keyFrame);
			boneState[id].transform = keyFrame.copyToMatrix(boneState[id].transform);
		}
	}
/*
	updateBoneWith(animation, time, boneState, boneSet){
		const {boneList} = this;
		for(let i=0, n=boneList.length; i<n; ++i){
			const {id, parent} = boneList[i];
			if(!boneSet.has(id))continue;
			if(parent){
				animation.calcTransform(id, time, boneState[id]).append(boneState[parent.id]);
			}else{
				animation.calcTransform(id, time, boneState[id]);
			}
		}
	}
*/
	buildBoneState(root){
		const result = new Array(this.boneCount);
		for(let bone of this.boneList){
			let display = new DisplayObject3D();
			display.name = bone.name;
			display.type = 'bone';
			result[bone.id] = display;
			if(bone.parent){
				result[bone.parent.id].addChild(display);
			}else{
				root.addChild(display);
			}
		}
		return result;
	}
}

module.exports = BoneObject;
