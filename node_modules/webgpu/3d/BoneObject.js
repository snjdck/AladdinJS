'use strict';

const Matrix3D = require('../math/Matrix3D');

class BoneObject
{
	constructor(id, name){
		this.id = id;
		this.name = name;
	}

	addChild(value){
		value.nextSibling = this.firstChild;
		this.firstChild = value;
	}

	forEach(handler, self, parent){
		handler.call(self, this, parent);
		this.nextSibling?.forEach(handler, self, parent);
		this.firstChild?.forEach(handler, self, this);
		return self;
	}
}

BoneObject.prototype.updateBone = function(){
	const transform = new Matrix3D();
	function onUpdate(bone, parent){
		const {animation, animationTime, boneState} = this;
		const {worldTransform} = boneState[bone.name];
		animation.calcTransform(bone.id, animationTime, transform);
		if(parent){
			const parentWorldTransform = boneState[parent.name].worldTransform;
			transform.append(parentWorldTransform, worldTransform);
		}else{
			worldTransform.copyFrom(transform);
		}
	}
	return function(entity){
		this.forEach(onUpdate, entity);
	}
}();

BoneObject.prototype.buildBoneState = function(){
	class BoneTransform {
		constructor(id){
			this.id = id;
			this.worldTransform = new Matrix3D();
		}
		copyToBuffer(buffer){
			const {id, worldTransform} = this;
			worldTransform.copyToArray(buffer, id << 3);
		}
		copyToWorldMatrix(matrix){
			const {rotation, translation} = this.worldTransform;
			return matrix.compose(rotation, translation);
		}
	}
	function onUpdate(bone){
		this[bone.name] = new BoneTransform(bone.id);
	}
	return function(){
		return this.forEach(onUpdate, Object.create(null));
	}
}();

BoneObject.buildBoneTree = function(boneInfoList){
	const boneList = [];
	let rootBone;
	for(const {boneName, boneID, bonePID} of boneInfoList){
		const bone = new this(boneID, boneName);
		if(bonePID >= 0){
			boneList[bonePID].addChild(bone);
		}else{
			bone.nextSibling = rootBone;
			rootBone = bone;
		}
		boneList[boneID] = bone;
	}
	return rootBone;
}

module.exports = BoneObject;
