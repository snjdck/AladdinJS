'use strict';

//const {groupDrawResult} = require('../helper/groupDraw');

class MaterialDict
{
	constructor(){
		this.dict = [];
	}

	addMaterial(material, subMeshFilter=0xFFFFFFFF){
		const {dict} = this;
		dict.push({material, subMeshFilter});
		/*
		for(let i=0; i<subMeshCount; ++i){
			if(subMeshFilter & (1 << i)){
				list[i] = material;
			}
		}
		*/
	}

	collectDrawUnits(entity, drawUnitBucket){
		for(let drawUnit of this.dict){
			drawUnitBucket.add(Object.assign({entity}, drawUnit));
		}
	}
/*
	addMaterial(material, group=0){
		const {dict} = this;
		console.assert(0 <= group && group <= dict.length);
		const list = dict[group];
		if(list){
			list.push(material);
		}else{
			dict[group] = [material];
		}
	}

	setMaterial(index, material, group=0){
		const {dict} = this;
		console.assert(0 <= group && group < dict.length);
		const list = dict[group];
		console.assert(0 <= index && index < list.length);
		list[index] = material;
	}

	delMaterial(index, group=0){
		const {dict} = this;
		console.assert(0 <= group && group < dict.length);
		const list = dict[group];
		console.assert(0 <= index && index < list.length);
		list.splice(index, 1);
	}

	*getMaterial(subMeshCount){
		const subMeshList = new Array(subMeshCount).fill(0).map((v, i) => i);
		
		const {dict} = this;
		for(let i=0; i<dict.length; ++i){
			const list = dict[i];
			for(let j=0; j<list.length; ++j){
				const material = list[j];
				groupDrawResult(subMeshList, 0, subMeshCount, v => v % list.length == j)
				yield {
					material,
					subMeshIndex: 
				};
			}
			for(const material of list){
				set.add(material.constructor);
			}
		}
	}

	getUsedMaterialTypes(){
		const set = new Set();
		const {dict} = this;
		for(const list of dict){
			for(const material of list){
				set.add(material.constructor);
			}
		}
		return set;
	}
	*/
}

module.exports = MaterialDict;
