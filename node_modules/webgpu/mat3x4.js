'use strict';
/*

x1 = (a00 * x0 + a01 * y0 + a02 * z0 + a03);
y1 = (a10 * x0 + a11 * y0 + a12 * z0 + a13);
z1 = (a20 * x0 + a21 * y0 + a22 * z0 + a23);

x2 = (b00 * x1 + b01 * y1 + b02 * z1 + b03);
y2 = (b10 * x1 + b11 * y1 + b12 * z1 + b13);
z2 = (b20 * x1 + b21 * y1 + b22 * z1 + b23);

x2 = (a00 * b00 + a10 * b01 + a20 * b02) * x0 + (a01 * b00 + a11 * b01 + a21 * b02) * y0 + (a02 * b00 + a12 * b01 + a22 * b02) * z0 + (a03 * b00 + a13 * b01 + a23 * b02 + b03);
y2 = (a00 * b10 + a10 * b11 + a20 * b12) * x0 + (a01 * b10 + a11 * b11 + a21 * b12) * y0 + (a02 * b10 + a12 * b11 + a22 * b12) * z0 + (a03 * b10 + a13 * b11 + a23 * b12 + b13);
z2 = (a00 * b20 + a10 * b21 + a20 * b22) * x0 + (a01 * b20 + a11 * b21 + a21 * b22) * y0 + (a02 * b20 + a12 * b21 + a22 * b22) * z0 + (a03 * b20 + a13 * b21 + a23 * b22 + b23);

//*/

class Mat3x4
{
	static compose(matrix, quaternion, x=0, y=0, z=0, scaleX=1, scaleY=1, scaleZ=1){
		compose(matrix.rawData, quaternion, x, y, z, scaleX, scaleY, scaleZ);
		return matrix;
	}

	static concat(va, vb, output){
		concat(va.rawData, vb.rawData, output.rawData);
		return output;
	}

	constructor(rawData){
		if(rawData){
			this.rawData = rawData;
		}else{
			this.rawData = new Float32Array(12);
			this.identity();
		}
	}

	identity(){
		const {rawData} = this;
		rawData.fill(0);
		rawData[0] = rawData[5] = rawData[10] = 1;
		return this;
	}

	moveTo(x, y, z){
		const {rawData} = this;
		rawData[3] = x;
		rawData[7] = y;
		rawData[11] = z;
		return this;
	}

	moveBy(x, y, z){
		const {rawData} = this;
		rawData[3] += x;
		rawData[7] += y;
		rawData[11] += z;
		return this;
	}

	compose(quaternion, translation){
		compose(this.rawData, quaternion, translation.x, translation.y, translation.z, 1, 1, 1);
		return this;
	}

	append(other, result=this){
		concat(this.rawData, other.rawData, result.rawData);
		return result;
	}

	prepend(other, result=this){
		concat(other.rawData, this.rawData, result.rawData);
		return result;
	}

	appendRotation(quaternion, result=this){
		//复制区域--begin
		const {x, y, z, w} = quaternion;
		
		const xx = x*x;
		const yy = y*y;
		const zz = z*z;
		const ww = w*w;
		
		const xy = x*y;
		const yz = y*z;
		const zx = z*x;
		const xw = x*w;
		const yw = y*w;
		const zw = z*w;
		//复制区域--end
		
		const b00 = xx + ww - yy - zz;
		const b01 = (xy - zw) * 2;
		const b02 = (zx + yw) * 2;
		
		const b10 = (xy + zw) * 2;
		const b11 = yy + ww - zz - xx;
		const b12 = (yz - xw) * 2;
		
		const b20 = (zx - yw) * 2;
		const b21 = (yz + xw) * 2;
		const b22 = zz + ww - xx - yy;

		const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23] = this.rawData;
		const output = result.rawData;

		output[ 0] = a00 * b00 + a10 * b01 + a20 * b02;
		output[ 1] = a01 * b00 + a11 * b01 + a21 * b02;
		output[ 2] = a02 * b00 + a12 * b01 + a22 * b02;
		output[ 3] = a03 * b00 + a13 * b01 + a23 * b02;

		output[ 4] = a00 * b10 + a10 * b11 + a20 * b12;
		output[ 5] = a01 * b10 + a11 * b11 + a21 * b12;
		output[ 6] = a02 * b10 + a12 * b11 + a22 * b12;
		output[ 7] = a03 * b10 + a13 * b11 + a23 * b12;

		output[ 8] = a00 * b20 + a10 * b21 + a20 * b22;
		output[ 9] = a01 * b20 + a11 * b21 + a21 * b22;
		output[10] = a02 * b20 + a12 * b21 + a22 * b22;
		output[11] = a03 * b20 + a13 * b21 + a23 * b22;

		return result;
	}

	prependRotation(quaternion, result=this){
		//复制区域--begin
		const {x, y, z, w} = quaternion;
		
		const xx = x*x;
		const yy = y*y;
		const zz = z*z;
		const ww = w*w;
		
		const xy = x*y;
		const yz = y*z;
		const zx = z*x;
		const xw = x*w;
		const yw = y*w;
		const zw = z*w;
		//复制区域--end
		
		const a00 = xx + ww - yy - zz;
		const a01 = (xy - zw) * 2;
		const a02 = (zx + yw) * 2;
		
		const a10 = (xy + zw) * 2;
		const a11 = yy + ww - zz - xx;
		const a12 = (yz - xw) * 2;
		
		const a20 = (zx - yw) * 2;
		const a21 = (yz + xw) * 2;
		const a22 = zz + ww - xx - yy;

		const [b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23] = this.rawData;
		const output = result.rawData;

		output[ 0] = a00 * b00 + a10 * b01 + a20 * b02;
		output[ 1] = a01 * b00 + a11 * b01 + a21 * b02;
		output[ 2] = a02 * b00 + a12 * b01 + a22 * b02;

		output[ 4] = a00 * b10 + a10 * b11 + a20 * b12;
		output[ 5] = a01 * b10 + a11 * b11 + a21 * b12;
		output[ 6] = a02 * b10 + a12 * b11 + a22 * b12;

		output[ 8] = a00 * b20 + a10 * b21 + a20 * b22;
		output[ 9] = a01 * b20 + a11 * b21 + a21 * b22;
		output[10] = a02 * b20 + a12 * b21 + a22 * b22;

		if(result == this)return this;

		output[ 3] = b03;
		output[ 7] = b13;
		output[11] = b23;

		return result;
	}

	appendScale(sx, sy=sx, sz=sy, result=this){
		const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23] = this.rawData;
		const output = result.rawData;

		output[ 0] = a00 * sx;
		output[ 1] = a01 * sx;
		output[ 2] = a02 * sx;
		output[ 3] = a03 * sx;

		output[ 4] = a10 * sy;
		output[ 5] = a11 * sy;
		output[ 6] = a12 * sy;
		output[ 7] = a13 * sy;

		output[ 8] = a20 * sz;
		output[ 9] = a21 * sz;
		output[10] = a22 * sz;
		output[11] = a23 * sz;

		return result;
	}

	prependScale(sx, sy, sz, result=this){
		const [b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23] = this.rawData;
		const output = result.rawData;

		output[ 0] = sx * b00;
		output[ 1] = sy * b01;
		output[ 2] = sz * b02;

		output[ 4] = sx * b10;
		output[ 5] = sy * b11;
		output[ 6] = sz * b12;

		output[ 8] = sx * b20;
		output[ 9] = sy * b21;
		output[10] = sz * b22;

		if(result == this)return this;

		output[ 3] = b03;
		output[ 7] = b13;
		output[11] = b23;

		return result;
	}

	appendTranslation(tx, ty, tz, result=this){
		const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23] = this.rawData;
		const output = result.rawData;

		output[ 3] = a03 + tx;
		output[ 7] = a13 + ty;
		output[11] = a23 + tz;

		if(result == this)return this;

		output[ 0] = a00;
		output[ 1] = a01;
		output[ 2] = a02;

		output[ 4] = a10;
		output[ 5] = a11;
		output[ 6] = a12;

		output[ 8] = a20;
		output[ 9] = a21;
		output[10] = a22;

		return result;
	}

	prependTranslation(tx, ty, tz, result=this){
		const [b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23] = this.rawData;
		const output = result.rawData;

		output[ 3] = tx * b00 + ty * b01 + tz * b02 + b03;
		output[ 7] = tx * b10 + ty * b11 + tz * b12 + b13;
		output[11] = tx * b20 + ty * b21 + tz * b22 + b23;

		if(result == this)return this;

		output[ 0] = b00;
		output[ 1] = b01;
		output[ 2] = b02;

		output[ 4] = b10;
		output[ 5] = b11;
		output[ 6] = b12;

		output[ 8] = b20;
		output[ 9] = b21;
		output[10] = b22;

		return result;
	}

	clone(){
		const {constructor, rawData} = this;
		return new constructor(rawData.slice());
	}

	copyFrom(other){
		if(other != this)
			this.rawData.set(other.rawData);
		return this;
	}

	invert(result=this){
		invert(this.rawData, result.rawData);
		return result;
	}

	transformCoords(vertex){
		const {rawData} = this;
		const {x, y, z} = vertex;
		vertex.x = (rawData[0] * x) + (rawData[1] * y) + (rawData[ 2] * z) + rawData[ 3];
		vertex.y = (rawData[4] * x) + (rawData[5] * y) + (rawData[ 6] * z) + rawData[ 7];
		vertex.z = (rawData[8] * x) + (rawData[9] * y) + (rawData[10] * z) + rawData[11];
		return vertex;
	}

	transformCoordsDelta(vertex){
		const {rawData} = this;
		const {x, y, z} = vertex;
		vertex.x = (rawData[0] * x) + (rawData[1] * y) + (rawData[ 2] * z);
		vertex.y = (rawData[4] * x) + (rawData[5] * y) + (rawData[ 6] * z);
		vertex.z = (rawData[8] * x) + (rawData[9] * y) + (rawData[10] * z);
		return vertex;
	}

	transformPlane(input, output){
		const [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23] = this.rawData;
		const [a, b, c, d] = input;

		output[0] = a * m00 + b * m10 + c * m20;
		output[1] = a * m01 + b * m11 + c * m21;
		output[2] = a * m02 + b * m12 + c * m22;
		output[3] = a * m03 + b * m13 + c * m23 + d;

		return output;
	}

	getTranslation(result){
		const {rawData} = this;
		result.x = rawData[ 3];
		result.y = rawData[ 7];
		result.z = rawData[11];
		return result;
	}

	*[Symbol.iterator](){
		yield * this.rawData;
	}
}

function concat(va, vb, output){
	const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23] = va;
	const [b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23] = vb;

	output[ 0] = a00 * b00 + a10 * b01 + a20 * b02;
	output[ 1] = a01 * b00 + a11 * b01 + a21 * b02;
	output[ 2] = a02 * b00 + a12 * b01 + a22 * b02;
	output[ 3] = a03 * b00 + a13 * b01 + a23 * b02 + b03;

	output[ 4] = a00 * b10 + a10 * b11 + a20 * b12;
	output[ 5] = a01 * b10 + a11 * b11 + a21 * b12;
	output[ 6] = a02 * b10 + a12 * b11 + a22 * b12;
	output[ 7] = a03 * b10 + a13 * b11 + a23 * b12 + b13;

	output[ 8] = a00 * b20 + a10 * b21 + a20 * b22;
	output[ 9] = a01 * b20 + a11 * b21 + a21 * b22;
	output[10] = a02 * b20 + a12 * b21 + a22 * b22;
	output[11] = a03 * b20 + a13 * b21 + a23 * b22 + b23;
}

function invert(matrix, output){
	const [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23] = matrix;

	const t00 = m11 * m22 - m12 * m21;
	const t01 = m12 * m20 - m10 * m22;
	const t02 = m10 * m21 - m11 * m20;

	const det = m00 * t00 + m01 * t01 + m02 * t02;

	if(det === 0)return false;

	const t10 = m02 * m21 - m01 * m22;
	const t11 = m00 * m22 - m02 * m20;
	const t12 = m01 * m20 - m00 * m21;

	const t20 = m01 * m12 - m02 * m11;
	const t21 = m02 * m10 - m00 * m12;
	const t22 = m00 * m11 - m01 * m10;

	const detInv = 1 / det;

	const n00 = t00 * detInv;
	const n01 = t10 * detInv;
	const n02 = t20 * detInv;
	const n03 = - n00 * m03 - n01 * m13 - n02 * m23;

	const n10 = t01 * detInv;
	const n11 = t11 * detInv;
	const n12 = t21 * detInv;
	const n13 = - n10 * m03 - n11 * m13 - n12 * m23;

	const n20 = t02 * detInv;
	const n21 = t12 * detInv;
	const n22 = t22 * detInv;
	const n23 = - n20 * m03 - n21 * m13 - n22 * m23;

	output[ 0] = n00;
	output[ 1] = n01;
	output[ 2] = n02;
	output[ 3] = n03;
	output[ 4] = n10;
	output[ 5] = n11;
	output[ 6] = n12;
	output[ 7] = n13;
	output[ 8] = n20;
	output[ 9] = n21;
	output[10] = n22;
	output[11] = n23;

	return true;
	/*
	output[ 0] = t00 * detInv;
	output[ 1] = t10 * detInv;
	output[ 2] = t20 * detInv;
	output[ 3] = (t00 * m03 + t10 * m13 + t20 * m23) * -detInv;

	output[ 4] = t01 * detInv;
	output[ 5] = t11 * detInv;
	output[ 6] = t21 * detInv;
	output[ 7] = (t01 * m03 + t11 * m13 + t21 * m23) * -detInv;

	output[ 8] = t02 * detInv;
	output[ 9] = t12 * detInv;
	output[10] = t22 * detInv;
	output[11] = (t02 * m03 + t12 * m13 + t22 * m23) * -detInv;
	*/
}
/*
function invert(matrix, output){
	const [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23] = matrix;
	const m30 = 0, m31 = 0, m32 = 0, m33 = 1;

	const t0 = m21 * m32 * m13 - m31 * m22 * m13 + m31 * m12 * m23 - m11 * m32 * m23 - m21 * m12 * m33 + m11 * m22 * m33,
	const t1 = m30 * m22 * m13 - m20 * m32 * m13 - m30 * m12 * m23 + m10 * m32 * m23 + m20 * m12 * m33 - m10 * m22 * m33,
	const t2 = m20 * m31 * m13 - m30 * m21 * m13 + m30 * m11 * m23 - m10 * m31 * m23 - m20 * m11 * m33 + m10 * m21 * m33,
	const t3 = m30 * m21 * m12 - m20 * m31 * m12 - m30 * m11 * m22 + m10 * m31 * m22 + m20 * m11 * m32 - m10 * m21 * m32;

	const det = m00 * t0 + m01 * t1 + m02 * t2 + m03 * t3;

	if(det === 0){
		return console.error('det zero!');
	}

	const detInv = 1 / det;

	output[ 0] = t0 * detInv;
	output[ 1] = ( m31 * m22 * m03 - m21 * m32 * m03 - m31 * m02 * m23 + m01 * m32 * m23 + m21 * m02 * m33 - m01 * m22 * m33 ) * detInv;
	output[ 2] = ( m11 * m32 * m03 - m31 * m12 * m03 + m31 * m02 * m13 - m01 * m32 * m13 - m11 * m02 * m33 + m01 * m12 * m33 ) * detInv;
	output[ 3] = ( m21 * m12 * m03 - m11 * m22 * m03 - m21 * m02 * m13 + m01 * m22 * m13 + m11 * m02 * m23 - m01 * m12 * m23 ) * detInv;

	output[ 4] = t1 * detInv;
	output[ 5] = ( m20 * m32 * m03 - m30 * m22 * m03 + m30 * m02 * m23 - m00 * m32 * m23 - m20 * m02 * m33 + m00 * m22 * m33 ) * detInv;
	output[ 6] = ( m30 * m12 * m03 - m10 * m32 * m03 - m30 * m02 * m13 + m00 * m32 * m13 + m10 * m02 * m33 - m00 * m12 * m33 ) * detInv;
	output[ 7] = ( m10 * m22 * m03 - m20 * m12 * m03 + m20 * m02 * m13 - m00 * m22 * m13 - m10 * m02 * m23 + m00 * m12 * m23 ) * detInv;

	output[ 8] = t2 * detInv;
	output[ 9] = ( m30 * m21 * m03 - m20 * m31 * m03 - m30 * m01 * m23 + m00 * m31 * m23 + m20 * m01 * m33 - m00 * m21 * m33 ) * detInv;
	output[10] = ( m10 * m31 * m03 - m30 * m11 * m03 + m30 * m01 * m13 - m00 * m31 * m13 - m10 * m01 * m33 + m00 * m11 * m33 ) * detInv;
	output[11] = ( m20 * m11 * m03 - m10 * m21 * m03 - m20 * m01 * m13 + m00 * m21 * m13 + m10 * m01 * m23 - m00 * m11 * m23 ) * detInv;

	output[12] = t3 * detInv;
	output[13] = ( m20 * m31 * m02 - m30 * m21 * m02 + m30 * m01 * m22 - m00 * m31 * m22 - m20 * m01 * m32 + m00 * m21 * m32 ) * detInv;
	output[14] = ( m30 * m11 * m02 - m10 * m31 * m02 - m30 * m01 * m12 + m00 * m31 * m12 + m10 * m01 * m32 - m00 * m11 * m32 ) * detInv;
	output[15] = ( m10 * m21 * m02 - m20 * m11 * m02 + m20 * m01 * m12 - m00 * m21 * m12 - m10 * m01 * m22 + m00 * m11 * m22 ) * detInv;
}
*/

function compose(output, quaternion, tx, ty, tz, sx, sy, sz){
	//复制区域--begin
	const {x, y, z, w} = quaternion;
	
	const xx = x*x;
	const yy = y*y;
	const zz = z*z;
	const ww = w*w;
	
	const xy2 = 2*x*y;
	const xz2 = 2*x*z;
	const xw2 = 2*x*w;
	const yz2 = 2*y*z;
	const yw2 = 2*y*w;
	const zw2 = 2*z*w;
	//复制区域--end

	output[ 0] = (xx + ww - yy - zz) * sx;
	output[ 1] = (xy2 - zw2) * sy;
	output[ 2] = (xz2 + yw2) * sz;

	output[ 4] = (xy2 + zw2) * sx;
	output[ 5] = (yy + ww - zz - xx) * sy;
	output[ 6] = (yz2 - xw2) * sz;

	output[ 8] = (xz2 - yw2) * sx;
	output[ 9] = (yz2 + xw2) * sy;
	output[10] = (zz + ww - xx - yy) * sz;

	output[ 3] = tx;
	output[ 7] = ty;
	output[11] = tz;
}

/*
x' = x - a * (x * a + y * b + z * c + d) * 2
y' = y - b * (x * a + y * b + z * c + d) * 2
z' = z - c * (x * a + y * b + z * c + d) * 2
*/
Mat3x4.mirror = function(plane, result, isPlaneNormalized=true){
	const [a, b, c, d] = plane;
	const factor = isPlaneNormalized ? -2 : -2 / (a * a + b * b + c * c);

	result[ 0] = a * a * factor + 1;
	result[ 1] = a * b * factor;
	result[ 2] = a * c * factor;
	result[ 3] = a * d * factor;

	result[ 4] = result[1];
	result[ 5] = b * b * factor + 1;
	result[ 6] = b * c * factor;
	result[ 7] = b * d * factor;

	result[ 8] = result[2];
	result[ 9] = result[6];
	result[10] = c * c * factor + 1;
	result[11] = c * d * factor;
}

/*
x' = x - lx * (x * a + y * b + z * c + d) / (light dot plane)
y' = y - ly * (x * a + y * b + z * c + d) / (light dot plane)
z' = z - lz * (x * a + y * b + z * c + d) / (light dot plane)
*/
Mat3x4.planeShadow = function(light, plane, result){
	const {x:lx, y:ly, z:lz} = light;
	const [a, b, c, d] = plane;
	const factor = -1 / (a * lx + b * ly + c * lz);

	result[ 0] = lx * a * factor + 1;
	result[ 1] = lx * b * factor;
	result[ 2] = lx * c * factor;
	result[ 3] = lx * d * factor;

	result[ 4] = ly * a * factor;
	result[ 5] = ly * b * factor + 1;
	result[ 6] = ly * c * factor;
	result[ 7] = ly * d * factor;

	result[ 8] = lz * a * factor;
	result[ 9] = lz * b * factor;
	result[10] = lz * c * factor + 1;
	result[11] = lz * d * factor;
}

Mat3x4.lookAtDirection = function(eye, direction, up, result){
	const zAxis = direction.clone().normalize();
	const yAxis = up.clone();
	const xAxis = up.clone();
	yAxis.crossProd(zAxis, xAxis).normalize();
	zAxis.crossProd(xAxis, yAxis);//当两个单位向量正交的时候，叉乘得到也是单位向量

	result[ 0] = xAxis.x;
	result[ 1] = yAxis.x;
	result[ 2] = zAxis.x;
	result[ 3] = eye.x;

	result[ 4] = xAxis.y;
	result[ 5] = yAxis.y;
	result[ 6] = zAxis.y;
	result[ 7] = eye.y;

	result[ 8] = xAxis.z;
	result[ 9] = yAxis.z;
	result[10] = zAxis.z;
	result[11] = eye.z;
}

Mat3x4.lookAtTarget = function(eye, target, up, result){
	this.lookAtDirection(eye, target.clone().subtract(eye), up, result);
}

/*
v1 dot v2 = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
v1 dot v2 * M = v1.x * (v2 dot M0) + v1.y * (v2 dot M1) + v1.z * (v2 dot M2);
v1 dot v2 * M = v1.x * (v2.x * M00 + v2.y * M01 + v2.z * M02) + v1.y * (v2.x * M10 + v2.y * M11 + v2.z * M12) + v1.z * (v2.x * M20 + v2.y * M21 + v2.z * M22);
v1 dot v2 * M = v2.x * (v1.x * M00 + v1.y * M10 + v1.z * M20) + v2.y * (v1.x * M01 + v1.y * M11 + v1.z * M21) + v2.z * (v1.x * M02 + v1.y * M12 + v1.z * M22);
v1 dot v2 * M = v1 * MT dot v2

ax   + by   + cz   + d  = 0
a'x' + b'y' + c'z' + d' = 0
(x', y', z', 1 ) = (x, y, z, 1) * M
(a', b', c', d') = (a, b, c, d) * M'

(a, b, c, d) dot (x, y, z, 1) = 0
(a, b, c, d) dot (x', y', z', 1) * -M = 0
(a, b, c, d) * (M * -1 * T) dot (x', y', z', 1) = 0
(a', b', c', d') dot (x', y', z', 1) = 0
=>
(a', b', c', d') = (a, b, c, d) * (M * -1 * T)
M' = M * -1 * T

*/

Mat3x4.prototype.transformBound = function(source, result){
	var sourceMinX = source.minX;
	var sourceMaxX = source.maxX;
	var sourceMinY = source.minY;
	var sourceMaxY = source.maxY;
	var sourceMinZ = source.minZ;
	var sourceMaxZ = source.maxZ;
	
	var rawData = this.rawData;
	var minX = rawData[12], maxX = minX;
	var minY = rawData[13], maxY = minY;
	var minZ = rawData[14], maxZ = minZ;
	var factor;
	
	if((factor = rawData[0]) > 0){
		minX += factor * sourceMinX;
		maxX += factor * sourceMaxX;
	}else{
		minX += factor * sourceMaxX;
		maxX += factor * sourceMinX;
	}
	if((factor = rawData[4]) > 0){
		minX += factor * sourceMinY;
		maxX += factor * sourceMaxY;
	}else{
		minX += factor * sourceMaxY;
		maxX += factor * sourceMinY;
	}
	if((factor = rawData[8]) > 0){
		minX += factor * sourceMinZ;
		maxX += factor * sourceMaxZ;
	}else{
		minX += factor * sourceMaxZ;
		maxX += factor * sourceMinZ;
	}
	if((factor = rawData[1]) > 0){
		minY += factor * sourceMinX;
		maxY += factor * sourceMaxX;
	}else{
		minY += factor * sourceMaxX;
		maxY += factor * sourceMinX;
	}
	if((factor = rawData[5]) > 0){
		minY += factor * sourceMinY;
		maxY += factor * sourceMaxY;
	}else{
		minY += factor * sourceMaxY;
		maxY += factor * sourceMinY;
	}
	if((factor = rawData[9]) > 0){
		minY += factor * sourceMinZ;
		maxY += factor * sourceMaxZ;
	}else{
		minY += factor * sourceMaxZ;
		maxY += factor * sourceMinZ;
	}
	if((factor = rawData[2]) > 0){
		minZ += factor * sourceMinX;
		maxZ += factor * sourceMaxX;
	}else{
		minZ += factor * sourceMaxX;
		maxZ += factor * sourceMinX;
	}
	if((factor = rawData[6]) > 0){
		minZ += factor * sourceMinY;
		maxZ += factor * sourceMaxY;
	}else{
		minZ += factor * sourceMaxY;
		maxZ += factor * sourceMinY;
	}
	if((factor = rawData[10]) > 0){
		minZ += factor * sourceMinZ;
		maxZ += factor * sourceMaxZ;
	}else{
		minZ += factor * sourceMaxZ;
		maxZ += factor * sourceMinZ;
	}
	
	result.setMinMax(minX, minY, minZ, maxX, maxY, maxZ);
}

Mat3x4.decompose = function(rawData){
	const a0 = (rawData[4] - rawData[ 1]) * 0.25;
	const a1 = (rawData[2] - rawData[ 8]) * 0.25;
	const a2 = (rawData[9] - rawData[ 6]) * 0.25;
	const b0 = (rawData[0] + rawData[ 5]) * 0.25;
	const b1 = (rawData[0] + rawData[10]) * 0.25;
	const b2 = (rawData[5] + rawData[10]) * 0.25;
	const x = Math.sqrt(Math.hypot(a2,b2)-b2);
	const y = Math.sqrt(Math.hypot(a1,b1)-b1);
	const z = Math.sqrt(Math.hypot(a0,b0)-b0);
	const w = Math.sqrt(1-x*x-y*y-z*z);
	const xx = x*x;
	const yy = y*y;
	const zz = z*z;
	const ww = w*w;
	const xy = x*y;
	const yz = y*z;
	const zx = z*x;
	const xw = x*w;
	const yw = y*w;
	const zw = z*w;
	const scaleX = (rawData[0]+rawData[4]+rawData[ 8]) / (xx + ww - yy - zz + (xy + zw + zx - yw) * 2);
	const scaleY = (rawData[1]+rawData[5]+rawData[ 9]) / (yy + ww - zz - xx + (yz + xw + xy - zw) * 2);
	const scaleZ = (rawData[2]+rawData[6]+rawData[10]) / (zz + ww - xx - yy + (zx + yw + yz - xw) * 2);
	return {rotation:{x, y, z, w}, scale:{x:scaleX, y:scaleY, z:scaleZ}, translation:{x:rawData[3], y:rawData[7], z:rawData[11]}};
}

module.exports = Mat3x4;
