/*
const vertex3DShaderGLSL = `#version 450

struct MVP
{
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
	vec4 viewportXYWH;
};

layout(binding=0)
uniform MVP_BLOCK {
	MVP cameraList[100];
};

layout(set=1, binding=0)
uniform WORLD_BLOCK {
	mat4x4 worldMatrixList[256];
};

layout(location = 0)
out vec2 uv;

void main()
{
	vec2 vertex = vec2(gl_VertexIndex >> 1, gl_VertexIndex & 1);
	vec2 xyDiff = fma(vertex, vec2(2.0), vec2(-1.0)) * vec2(16,32);
	vec3 worldPosition = vec3(0);

	mat4x4 worldMatrix = worldMatrixList[gl_InstanceIndex << 2];
	uint cameraIndex = uint(worldMatrix[3][0]);
	worldPosition = vec4(worldPosition, 1) * mat3x4(worldMatrix);
	
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraList[cameraIndex].cameraMatrix;

	cameraPosition.xy += xyDiff;

	vec4 screenPosition = vec4(cameraPosition, 1) * cameraList[cameraIndex].screenMatrix;

	vec4 viewportXYWH = cameraList[cameraIndex].viewportXYWH;
	screenPosition.xy = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);

	gl_Position = screenPosition;
	uv = vertex;
}
`;
//*/
const vertex3DShaderGLSL = `

	struct MVP {
		screenMatrix: mat4x4<f32>;
		cameraMatrix: mat3x4<f32>;
		viewportXYWH: vec4<f32>;
	};

	[[block]] struct MVP_BLOCK {
		cameraList: array<MVP, 100>;
	};

	[[block]] struct TRANSFORM_BLOCK {
		matrixList: array<mat4x4<f32>, 256>;
	};

	[[binding(0), group(0)]] var<uniform> mvp: MVP_BLOCK;
	[[binding(0), group(1)]] var<uniform> worldMatrixBlock: TRANSFORM_BLOCK;

	struct Input {
		[[builtin(vertex_index)]] vertexIndex: u32;
		[[builtin(instance_index)]] instanceIndex: u32;
	};

	struct Output {
		[[builtin(position)]] position: vec4<f32>;
		[[location(0)]] uv: vec2<f32>;
	};

	[[stage(vertex)]]
	fn main(input: Input) -> Output {
		var vertex: vec2<f32>;
		vertex.x = f32(input.vertexIndex >> 1u);
		vertex.y = f32(input.vertexIndex & 1u);
		var xyDiff: vec2<f32> = vertex * 2.0 - vec2<f32>(1.0, 1.0);
		xyDiff = xyDiff * vec2<f32>(16.0, 32.0);

		
		var worldMatrix: mat4x4<f32> = worldMatrixBlock.matrixList[input.instanceIndex << 2u];
		var cameraIndex: u32 = u32(worldMatrix[3][0]);
		var worldPosition: vec4<f32> = vec4<f32>(worldMatrix[0].w, worldMatrix[1].w, worldMatrix[2].w, 1.0);
		var cameraPosition: vec3<f32> = worldPosition * mvp.cameraList[cameraIndex].cameraMatrix;

		cameraPosition.x = cameraPosition.x + xyDiff.x;
		cameraPosition.y = cameraPosition.y + xyDiff.y;

		var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.cameraList[cameraIndex].screenMatrix;

		var viewportXYWH: vec4<f32> = mvp.cameraList[cameraIndex].viewportXYWH;
		var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);
		screenPosition.x = t.x;
		screenPosition.y = t.y;

		var output: Output;
		output.position = screenPosition;
		output.uv = vertex;
		return output;
	}
`;

const fragment3DShaderGLSL = `

	[[binding(1), group(0)]] var mySampler: sampler;
	[[binding(0), group(2)]] var myTexture: texture_2d<f32>;

	[[stage(fragment)]]
	fn main([[location(0)]] uv: vec2<f32>) -> [[location(0)]] vec4<f32> {
		return textureSample(myTexture, mySampler, uv);
	}
`;


exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
