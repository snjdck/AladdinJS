
const vertex3DShaderGLSL = `#version 450

struct MVP
{
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
	vec4 viewportXYWH;
};

layout(binding=0)
uniform MVP_BLOCK {
	MVP cameraList[100];
};

layout(set=1, binding=0)
uniform WORLD_BLOCK {
	mat4x4 worldMatrixList[256];
};

layout(location = 0)
out vec2 uv;

void main()
{
	vec2 vertex = vec2(gl_VertexIndex >> 1, gl_VertexIndex & 1);
	vec2 xyDiff = fma(vertex, vec2(2.0), vec2(-1.0)) * vec2(16,32);
	vec3 worldPosition = vec3(0);

	mat4x4 worldMatrix = worldMatrixList[gl_InstanceIndex << 2];
	uint cameraIndex = uint(worldMatrix[3][0]);
	worldPosition = vec4(worldPosition, 1) * mat3x4(worldMatrix);
	
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraList[cameraIndex].cameraMatrix;

	cameraPosition.xy += xyDiff;

	vec4 screenPosition = vec4(cameraPosition, 1) * cameraList[cameraIndex].screenMatrix;

	vec4 viewportXYWH = cameraList[cameraIndex].viewportXYWH;
	screenPosition.xy = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);

	gl_Position = screenPosition;
	uv = vertex;
}
`;

const fragment3DShaderGLSL = `

	[[binding(1), group(0)]] var mySampler: sampler;
	[[binding(0), group(2)]] var myTexture: texture_2d<f32>;

	[[stage(fragment)]]
	fn main([[location(0)]] uv: vec2<f32>) -> [[location(0)]] vec4<f32> {
		return textureSample(myTexture, mySampler, uv);
	}
`;


exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
