
const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

layout(binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
};

layout(set=1, binding=0)
uniform WORLD_BLOCK {
	mat3x4 worldMatrixList[100];
};

layout(set=2, binding=0)
uniform BONE_BLOCK {
	vec4 boneList[1024];
};

layout(location=0)
in vec3 inputPosition;

layout(location=1)
in vec3 inputNormal;

layout(location=2)
in vec2 inputUV;

layout(location=3)
in uint boneIndex;

layout(location = 0)
out vec2 uv;

layout(location = 1)
flat out uint instanceIndex;
/*
const vec3 pos[3] = vec3[](
	vec3(-100.0, 100.0, 0),
	vec3(100.0, 100.0, 0),
	vec3(0, -100.0, 0)
);
*/

void main()
{
	vec3 worldPosition = vec3(0);
	for(int i=0; i<1; ++i){
		uint index = (gl_InstanceIndex << 8) + (boneIndex << 1);//every object use 256 registers, every bone use two registers
		worldPosition += transform2(boneList[index], boneList[index+1], inputPosition) * 1.0;
	}
	worldPosition = vec4(worldPosition, 1) * worldMatrixList[gl_InstanceIndex];
	//vec3 cameraPosition = transform2(cameraMatrix[0], cameraMatrix[1], worldPosition);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * screenMatrix;

	//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;

	gl_Position = screenPosition;
	uv = inputUV;
	instanceIndex = gl_InstanceIndex;
}
`;

const fragment3DShaderGLSL = `#version 450

	layout(binding=1)uniform sampler _sampler;
	layout(set=3, binding=0)uniform texture2D _texture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		outColor = texture(sampler2D(_texture, _sampler), uv);
	}
`;

const fragment3DColorShaderGLSL = `#version 450

	layout(set=3, binding=0)
	uniform COLOR_BLOCK {
		vec4 colorList[10];
	};

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;
	layout(location=1)flat in uint instanceIndex;

	void main() {
		outColor = colorList[instanceIndex];
	}
`;


exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
exports.fragment3DColorCode = fragment3DColorShaderGLSL;
