
const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

layout(binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
};

layout(set=1, binding=0)
uniform WORLD_BLOCK {
	mat4x4 worldMatrixList[256];
};

layout(set=2, binding=0)
uniform BONE_BLOCK {
	vec4 boneList[1024];
};

layout(location=0)
in vec3 inputPosition;

layout(location=1)
in vec3 inputNormal;

layout(location=2)
in vec2 inputUV;

layout(location=3)
in uint boneIndex;

layout(location = 0)
out vec2 uv;

layout(location = 1)
flat out uint instanceIndex;

layout(location = 2)
out vec3 outNormal;
/*
const vec3 pos[3] = vec3[](
	vec3(-100.0, 100.0, 0),
	vec3(100.0, 100.0, 0),
	vec3(0, -100.0, 0)
);
*/

void main()
{
	vec3 worldPosition = vec3(0);
	vec3 worldNormal = vec3(0);
	for(int i=0; i<1; ++i){
		uint index = (gl_InstanceIndex << 8) + (boneIndex << 1);//every object use 256 registers, every bone use two registers
		worldPosition += transform2(boneList[index], boneList[index+1], inputPosition) * 1.0;
		worldNormal += rotate(boneList[index], inputNormal);
	}
	mat4x4 worldMatrix = worldMatrixList[gl_InstanceIndex << 2];
	worldPosition = vec4(worldPosition, 1) * mat3x4(worldMatrix);
	worldNormal *= mat3x3(worldMatrix);
	//vec3 cameraPosition = transform2(cameraMatrix[0], cameraMatrix[1], worldPosition);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * screenMatrix;

	//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;

	gl_Position = screenPosition;
	uv = inputUV;
	instanceIndex = gl_InstanceIndex;
	outNormal = worldNormal;
}
`;

const fragment3DShaderGLSL = `

	[[binding(1), set(0)]] var _sampler: sampler;
	[[binding(0), set(3)]] var _texture: texture_2d<f32>;

	[[location(0)]] var<in> uv: vec2<f32>;
	[[location(0)]] var<out> outColor: vec4<f32>;

	[[stage(fragment)]]
	fn main() -> void {
		outColor = textureSample(_texture, _sampler, uv);
		return;
	}
`;

const fragment3DColorShaderGLSL = `#version 450

	layout(set=3, binding=0)
	uniform COLOR_BLOCK {
		vec4 colorList[1024];
	};

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;
	layout(location=1)flat in uint instanceIndex;
	layout(location=2)in vec3 normal;

	void main() {
		float base = 0;
		float factor = dot(normalize(vec3(1,0,1)), normalize(normal));
		factor = base + (1 - base) * max(factor, 0);
		vec4 baseColor = colorList[instanceIndex << 4];
		outColor = vec4(baseColor.rgb * factor, baseColor.a);
	}
`;


exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
exports.fragment3DColorCode = fragment3DColorShaderGLSL;
