
const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

struct MVP
{
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
	vec4 viewportXYWH;
};

layout(binding=0)
uniform MVP_BLOCK {
	MVP cameraList[100];
};

layout(set=1, binding=0)
uniform WORLD_BLOCK {
	mat4x4 worldMatrixList[256];
};

layout(set=2, binding=0)
uniform BONE_BLOCK {
	vec4 boneList[1024];
};

layout(location=0)
in vec3 inputPosition;

layout(location=1)
in vec3 inputNormal;

layout(location=2)
in vec2 inputUV;

layout(location=3)
in uint boneIndex;

layout(location = 0)
out vec2 uv;

layout(location = 1)
flat out uint instanceIndex;

layout(location = 2)
out vec3 outNormal;
/*
const vec3 pos[3] = vec3[](
	vec3(-100.0, 100.0, 0),
	vec3(100.0, 100.0, 0),
	vec3(0, -100.0, 0)
);
*/

void main()
{
	vec3 worldPosition = vec3(0);
	vec3 worldNormal = vec3(0);
	for(int i=0; i<1; ++i){
		uint index = (gl_InstanceIndex << 8) + (boneIndex << 1);//every object use 256 registers, every bone use two registers
		worldPosition += transform2(boneList[index], boneList[index+1], inputPosition) * 1.0;
		worldNormal += rotate(boneList[index], inputNormal);
	}
	mat4x4 worldMatrix = worldMatrixList[gl_InstanceIndex << 2];
	worldPosition = vec4(worldPosition, 1) * mat3x4(worldMatrix);
	worldNormal *= mat3x3(worldMatrix);
	uint cameraIndex = uint(worldMatrix[3][0]);
	//vec3 cameraPosition = transform2(cameraMatrix[0], cameraMatrix[1], worldPosition);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraList[cameraIndex].cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * cameraList[cameraIndex].screenMatrix;

	vec4 viewportXYWH = cameraList[cameraIndex].viewportXYWH;
	//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;
	screenPosition.xy = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);

	gl_Position = screenPosition;
	uv = inputUV;
	instanceIndex = gl_InstanceIndex;
	outNormal = worldNormal;
}
`;

const fragment3DShaderGLSL = `

	[[binding(1), group(0)]] var _sampler: sampler;
	[[binding(0), group(3)]] var _texture: texture_2d<f32>;

	struct Input {
		[[location(0)]] uv: vec2<f32>;
	};

	struct Output {
		[[location(0)]] color: vec4<f32>;
	};

	[[stage(fragment)]]
	fn main(input: Input) -> Output {
		var output: Output;
		output.color = textureSample(_texture, _sampler, input.uv);
		return output;
	}
`;

const fragment3DColorShaderGLSL = `

	[[block]] struct COLOR_BLOCK {
		colorList: array<vec4<f32>, 1024>;
	};

	[[binding(0), group(3)]] var<uniform> colorBlock: COLOR_BLOCK;

	struct Input {
		[[location(0)]] uv: vec2<f32>;
		[[location(1)]] instanceIndex: u32;
		[[location(2)]] normal: vec3<f32>;
	};

	struct Output {
		[[location(0)]] color: vec4<f32>;
	};

	[[stage(fragment)]]
	fn main(input: Input) -> Output {
		var base: f32 = 0.0;
		var factor: f32 = dot(normalize(vec3<f32>(1.0, 0.0, 1.0)), normalize(input.normal));
		factor = base + (1.0 - base) * max(factor, 0.0);
		var baseColor: vec4<f32> = colorBlock.colorList[input.instanceIndex << 4u];
		var output: Output;
		output.color = vec4<f32>(baseColor.rgb * factor, baseColor.a);
		return output;
	}
`;


exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
exports.fragment3DColorCode = fragment3DColorShaderGLSL;
