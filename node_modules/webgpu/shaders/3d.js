/*
const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

struct MVP
{
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
	vec4 viewportXYWH;
};

layout(binding=0)
uniform MVP_BLOCK {
	MVP cameraList[100];
};

layout(set=1, binding=0)
uniform WORLD_BLOCK {
	mat4x4 worldMatrixList[256];
};

layout(set=2, binding=0)
uniform BONE_BLOCK {
	vec4 boneList[1024];
};

layout(location=0)
in vec3 inputPosition;

layout(location=1)
in vec3 inputNormal;

layout(location=2)
in vec2 inputUV;

layout(location=3)
in uint boneIndex;

layout(location = 0)
out vec2 uv;

layout(location = 1)
flat out uint instanceIndex;

layout(location = 2)
out vec3 outNormal;

void main()
{
	vec3 worldPosition = vec3(0);
	vec3 worldNormal = vec3(0);
	for(int i=0; i<1; ++i){
		uint index = (gl_InstanceIndex << 8) + (boneIndex << 1);//every object use 256 registers, every bone use two registers
		worldPosition += transform2(boneList[index], boneList[index+1], inputPosition) * 1.0;
		worldNormal += rotate(boneList[index], inputNormal);
	}
	mat4x4 worldMatrix = worldMatrixList[gl_InstanceIndex << 2];
	worldPosition = vec4(worldPosition, 1) * mat3x4(worldMatrix);
	worldNormal *= mat3x3(worldMatrix);
	uint cameraIndex = uint(worldMatrix[3][0]);
	//vec3 cameraPosition = transform2(cameraMatrix[0], cameraMatrix[1], worldPosition);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraList[cameraIndex].cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * cameraList[cameraIndex].screenMatrix;

	vec4 viewportXYWH = cameraList[cameraIndex].viewportXYWH;
	//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;
	screenPosition.xy = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);

	gl_Position = screenPosition;
	uv = inputUV;
	instanceIndex = gl_InstanceIndex;
	outNormal = worldNormal;
}
`;
//*/
//*
const vertex3DShaderGLSL = `

fn cast2mat(quaternion: vec4<f32>) -> mat3x3<f32> {
	var t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	var t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
	var t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

	var a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
	var b: vec3<f32> = (t0     - t1.zxy) * 2.0;
	var c: vec3<f32> = (t0.zxy + t1.yzx) * 2.0;

	return mat3x3<f32>(
		vec3<f32>(a.x, b.x, c.x),
		vec3<f32>(c.y, a.y, b.y),
		vec3<f32>(b.z, c.z, a.z)
	);
}

struct MVP {
	screenMatrix: mat4x4<f32>;
	cameraMatrix: mat3x4<f32>;
	viewportXYWH: vec4<f32>;
};

[[block]] struct MVP_BLOCK {
	cameraList: array<MVP, 100>;
};

[[block]] struct TRANSFORM_BLOCK {
	matrixList: array<mat4x4<f32>, 256>;
};

[[block]] struct BONE_BLOCK {
	boneList: array<vec4<f32>, 1024>;
};

[[binding(0), group(0)]] var<uniform> mvp: MVP_BLOCK;
[[binding(0), group(1)]] var<uniform> worldMatrixBlock: TRANSFORM_BLOCK;
[[binding(0), group(2)]] var<uniform> boneBlock: BONE_BLOCK;

struct Input {
	[[builtin(instance_index)]] instanceIndex: u32;
	[[location(0)]] position: vec3<f32>;
	[[location(1)]] normal: vec3<f32>;
	[[location(2)]] uv: vec2<f32>;
	[[location(3)]] boneIndex: u32;
};

struct Output {
	[[builtin(position)]] position: vec4<f32>;
	[[location(0)]] uv: vec2<f32>;
	[[location(1)]] instanceIndex: u32;
	[[location(2)]] normal: vec3<f32>;
};

[[stage(vertex)]]
fn main(input: Input) -> Output {
	var worldPosition: vec3<f32> = vec3<f32>();
	var worldNormal: vec3<f32> = vec3<f32>();

	//for(var i: i32=0; i<1; i = i+1){
		var index: u32 = input.instanceIndex << 8u | input.boneIndex << 1u;//every object use 256 registers, every bone use two registers
		var boneMatrix: mat3x3<f32> = cast2mat(boneBlock.boneList[index]);
		worldPosition = worldPosition + (input.position * boneMatrix + boneBlock.boneList[index+1u].xyz) * 1.0;//boneWeight
		worldNormal = worldNormal + (input.normal * boneMatrix) * 1.0;
	//}

	var worldMatrix: mat4x4<f32> = worldMatrixBlock.matrixList[input.instanceIndex << 2u];
	var cameraIndex: u32 = u32(worldMatrix[3][0]);

	worldPosition = vec4<f32>(worldPosition, 1.0) * mat3x4<f32>(worldMatrix[0], worldMatrix[1], worldMatrix[2]);
	worldNormal = worldNormal * mat3x3<f32>(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz);
	
	var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraList[cameraIndex].cameraMatrix;
	var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.cameraList[cameraIndex].screenMatrix;

	var viewportXYWH: vec4<f32> = mvp.cameraList[cameraIndex].viewportXYWH;
	var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy * screenPosition.w);
	screenPosition.x = t.x;
	screenPosition.y = t.y;

	var output: Output;
	output.position = screenPosition;
	output.normal = worldNormal;
	output.uv = input.uv;
	output.instanceIndex = input.instanceIndex;
	return output;
}
`;
//*/

const fragment3DShaderGLSL = `

	[[binding(1), group(0)]] var _sampler: sampler;
	[[binding(0), group(3)]] var _texture: texture_2d<f32>;

	struct Input {
		[[location(0)]] uv: vec2<f32>;
	};

	struct Output {
		[[location(0)]] color: vec4<f32>;
	};

	[[stage(fragment)]]
	fn main(input: Input) -> Output {
		var output: Output;
		output.color = textureSample(_texture, _sampler, input.uv);
		return output;
	}
`;

const fragment3DColorShaderGLSL = `

	[[block]] struct COLOR_BLOCK {
		colorList: array<vec4<f32>, 1024>;
	};

	[[binding(0), group(3)]] var<uniform> colorBlock: COLOR_BLOCK;

	struct Input {
		[[location(0)]] uv: vec2<f32>;
		[[location(1)]] instanceIndex: u32;
		[[location(2)]] normal: vec3<f32>;
	};

	struct Output {
		[[location(0)]] color: vec4<f32>;
	};

	[[stage(fragment)]]
	fn main(input: Input) -> Output {
		var base: f32 = 0.0;
		var factor: f32 = dot(normalize(vec3<f32>(1.0, 0.0, 1.0)), normalize(input.normal));
		factor = base + (1.0 - base) * max(factor, 0.0);
		var baseColor: vec4<f32> = colorBlock.colorList[input.instanceIndex << 4u];
		var output: Output;
		output.color = vec4<f32>(baseColor.rgb * factor, baseColor.a);
		return output;
	}
`;


exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
exports.fragment3DColorCode = fragment3DColorShaderGLSL;
