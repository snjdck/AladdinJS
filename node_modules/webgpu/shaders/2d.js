//*
const vertexShaderGLSL = `#version 450

const uint indexList[54] = uint[](
	 4, 5, 0, 5, 1, 0,
	 5, 6, 1, 6, 2, 1,
	 6, 7, 2, 7, 3, 2,
	 8, 9, 4, 9, 5, 4,
	 9,10, 5,10, 6, 5,
	10,11, 6,11, 7, 6,
	12,13, 8,13, 9, 8,
	13,14, 9,14,10, 9,
	14,15,10,15,11,10
);

layout(binding=0)
uniform _ {
	vec2 screenWH;
};

//layout(location=0)in mat2x3 worldMatrix;

layout(location=0)
in vec3 worldMatrixX;

layout(location=1)
in vec3 worldMatrixY;

layout(location=2)
in vec4 textureMul;

layout(location=3)
in vec4 textureAdd;

layout(location=4)
in vec4 rectSize;//w,rw,h,rh

layout(location=5)
in vec4 scale9grid;//lm,rm,tm,bm

layout(location = 0)
out vec2 uv;

void main() {
	uint vertexID = indexList[gl_VertexIndex];
	mat2x3 worldMatrix = mat2x3(worldMatrixX, worldMatrixY);
	vec2 inputPosition = vec2(vertexID >> 1 & 1, vertexID >> 3);
	vec4 inputMargin = vec4(equal(
		ivec2(vertexID & 3, vertexID >> 2).xxyy,
		ivec2(1, 2).xyxy
	));
	inputMargin.yw = -inputMargin.yw;
	vec4 margin = inputMargin * scale9grid;
	margin = margin.xxzz + margin.yyww;

	vec4 xyuv = fma(inputPosition.xxyy, rectSize, margin);
	xyuv.yw /= rectSize.yw;
	xyuv = fma(xyuv.xzyw, textureMul, textureAdd);

	xyuv.xy = vec3(xyuv.xy, 1) * worldMatrix;
	xyuv.xy = fma(xyuv.xy, screenWH, vec2(-1, 1));

	gl_Position = vec4(xyuv.xy, 0, 1);
	uv = xyuv.zw;
}
`;
//*/
/*
const vertexShaderGLSL = `
const indexList : array<i32, 54> = array<i32, 54>(
	 4, 5, 0, 5, 1, 0,
	 5, 6, 1, 6, 2, 1,
	 6, 7, 2, 7, 3, 2,
	 8, 9, 4, 9, 5, 4,
	 9,10, 5,10, 6, 5,
	10,11, 6,11, 7, 6,
	12,13, 8,13, 9, 8,
	13,14, 9,14,10, 9,
	14,15,10,15,11,10
);

[[block]] struct Screen {
	[[offset(0)]] screenWH : vec2<f32>;
};

[[binding(0), set(0)]] var<uniform> uniforms: Screen;

[[location(0)]] var<in> worldMatrixX: vec3<f32>;
[[location(1)]] var<in> worldMatrixY: vec3<f32>;
[[location(2)]] var<in> textureMul  : vec4<f32>;
[[location(3)]] var<in> textureAdd  : vec4<f32>;
[[location(4)]] var<in> rectSize    : vec4<f32>; #w,rw,h,rh
[[location(5)]] var<in> scale9grid  : vec4<f32>; #lm,rm,tm,bm

[[location(0)]] var<out> uv: vec2<f32>;

[[builtin(position)]] var<out> gl_Position: vec4<f32>;
[[builtin(vertex_idx)]] var<in> gl_VertexIndex: i32;

[[stage(vertex)]]
fn main() -> void {
	var vertexID: i32 = indexList[gl_VertexIndex];
	var worldMatrix : mat3x2<f32> = mat3x2<f32>();#worldMatrixX, worldMatrixY);
	var inputPosition : vec2<f32> = vec2<f32>(vec2<i32>(vertexID >> 1 & 1, vertexID >> 3));
	var inputMargin : vec4<f32> = inputPosition.xxxx;#select(vec4<f32>(1), vec4<f32>(0), vec2<i32>(vertexID & 3, vertexID >> 2).xxyy == vec2<i32>(1, 2).xyxy);
	inputMargin.yw = vec2<f32>(0.0, 0.0) - inputMargin.yw;
	var margin : vec4<f32> = inputMargin * scale9grid;
	#margin = margin.xxzz + margin.yyww;

	var xyuv : vec4<f32> = fma(inputPosition.xxyy, rectSize, margin);
	xyuv.yw = xyuv.yw / rectSize.yw;
	xyuv = fma(xyuv.xzyw, textureMul, textureAdd);

	#xyuv.xy = vec3<f32>(xyuv.xy, 1.0) * worldMatrix;
	#xyuv.xy = fma(xyuv.xy, uniforms.screenWH, vec2<f32>(-1.0, 1.0));

	gl_Position = vec4<f32>(xyuv.xy, 0.0, 1.0);
	uv = xyuv.zw;
	return;
}

`;
//*/

/*
const fragmentShaderGLSL = `#version 450
	layout(binding=1)uniform sampler mySampler;
	layout(set=1, binding=0)uniform texture2D myTexture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		vec4 temp = texture(sampler2D(myTexture, mySampler), uv);
		outColor = temp;
	}
`;
//*/
//*
const fragmentShaderGLSL = `

	[[binding(1), set(0)]] var mySampler: sampler;
	[[binding(0), set(1)]] var myTexture: texture_2d<f32>;

	[[location(0)]] var<in> uv: vec2<f32>;
	[[location(0)]] var<out> outColor: vec4<f32>;

	[[stage(fragment)]]
	fn main() -> void {
		outColor = textureSample(myTexture, mySampler, uv);
		return;
	}

`;
//*/
exports.vertexCode = vertexShaderGLSL;
exports.fragmentCode = fragmentShaderGLSL;
