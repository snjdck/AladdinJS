
const vertexShaderGLSL = `#version 450

const uint indexList[54] = uint[](
	 4, 5, 0, 5, 1, 0,
	 5, 6, 1, 6, 2, 1,
	 6, 7, 2, 7, 3, 2,
	 8, 9, 4, 9, 5, 4,
	 9,10, 5,10, 6, 5,
	10,11, 6,11, 7, 6,
	12,13, 8,13, 9, 8,
	13,14, 9,14,10, 9,
	14,15,10,15,11,10
);

layout(binding=0)
uniform _ {
	vec2 screenWH;
};

//layout(location=0)in mat2x3 worldMatrix;

layout(location=0)
in vec3 worldMatrixX;

layout(location=1)
in vec3 worldMatrixY;

layout(location=2)
in vec4 textureMul;

layout(location=3)
in vec4 textureAdd;

layout(location=4)
in vec4 rectSize;//w,rw,h,rh

layout(location=5)
in vec4 scale9grid;//lm,rm,tm,bm

layout(location = 0)
out vec2 uv;

void main() {
	uint vertexID = indexList[gl_VertexIndex];
	mat2x3 worldMatrix = mat2x3(worldMatrixX, worldMatrixY);
	vec2 inputPosition = vec2(vertexID >> 1 & 1, vertexID >> 3);
	vec4 inputMargin = vec4(equal(
		ivec2(vertexID & 3, vertexID >> 2).xxyy,
		ivec2(1, 2).xyxy
	));
	inputMargin.yw = -inputMargin.yw;
	vec4 margin = inputMargin * scale9grid;
	margin = margin.xxzz + margin.yyww;

	vec4 xyuv = fma(inputPosition.xxyy, rectSize, margin);
	xyuv.yw /= rectSize.yw;
	xyuv = fma(xyuv.xzyw, textureMul, textureAdd);

	xyuv.xy = vec3(xyuv.xy, 1) * worldMatrix;
	xyuv.xy = fma(xyuv.xy, screenWH, vec2(-1, 1));

	gl_Position = vec4(xyuv.xy, 0, 1);
	uv = xyuv.zw;
}
`;

/*
const vertexShaderGLSL = `
const indexList : array<u32, 54> = array<u32, 54>(
	 4, 5, 0, 5, 1, 0,
	 5, 6, 1, 6, 2, 1,
	 6, 7, 2, 7, 3, 2,
	 8, 9, 4, 9, 5, 4,
	 9,10, 5,10, 6, 5,
	10,11, 6,11, 7, 6,
	12,13, 8,13, 9, 8,
	13,14, 9,14,10, 9,
	14,15,10,15,11,10
);

[[block]]
struct my_struct {
	[[offset 0]] screenWH : vec2<f32>;
};

[[binding 0, set 1]]
var<uniform> _: my_struct;

[[location 0]] var<in> worldMatrixX: vec3<f32>;
[[location 1]] var<in> worldMatrixY: vec3<f32>;
[[location 2]] var<in> textureMul  : vec4<f32>;
[[location 3]] var<in> textureAdd  : vec4<f32>;
[[location 4]] var<in> rectSize    : vec4<f32>; #w,rw,h,rh
[[location 5]] var<in> scale9grid  : vec4<f32>; #lm,rm,tm,bm

[[location 0]] var<out> uv: vec2<f32>;

[[builtin position]] var gl_Position: vec4<f32>;
[[builtin vertex_idx]] var gl_VertexIndex: i32;

fn main() -> void {
	var vertexID: u32 = indexList[gl_VertexIndex];
	var worldMatrix : mat2x3<f32> = mat2x3<f32>(worldMatrixX, worldMatrixY);
	var inputPosition : vec2<f32> = vec2<f32>(vertexID >> 1 & 1, vertexID >> 3);
	var inputMargin : vec4<f32> = vec4<f32>(equal(
		ivec2(vertexID & 3, vertexID >> 2).xxyy,
		ivec2(1, 2).xyxy
	));
	inputMargin.yw = -inputMargin.yw;
	var margin : vec4<f32> = inputMargin * scale9grid;
	margin = margin.xxzz + margin.yyww;

	var xyuv : vec4<f32> = fma(inputPosition.xxyy, rectSize, margin);
	xyuv.yw /= rectSize.yw;
	xyuv = fma(xyuv.xzyw, textureMul, textureAdd);

	xyuv.xy = vec3<f32>(xyuv.xy, 1) * worldMatrix;
	xyuv.xy = fma(xyuv.xy, screenWH, vec2<f32>(-1, 1));

	gl_Position = vec4<f32>(xyuv.xy, 0, 1);
	uv = xyuv.zw;
	return;
}

entry_point vertex = main;
`;
//*/

//*
const fragmentShaderGLSL = `#version 450
	layout(binding=1)uniform sampler mySampler;
	layout(set=1, binding=0)uniform texture2D myTexture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		vec4 temp = texture(sampler2D(myTexture, mySampler), uv);
		outColor = temp;
	}
`;
//*/
/*
const fragmentShaderGLSL = `

	[[binding(1), set(0)]]
	var<uniform> mySampler: sampler;

	[[binding(0), set(1)]]
	var<uniform> myTexture: texture_sampled_2d<f32>;

	[[location(0)]]
	var<in> uv: vec2<f32>;

	[[location(0)]]
	var<out> outColor: vec4<f32>;

	[[stage(fragment)]]
	fn main() -> void {
		#outColor = vec4<f32>(1.0, 0, 0, 1.0);
		outColor = textureSample(myTexture, mySampler, uv);
		return;
	}

`;
//*/
exports.vertexCode = vertexShaderGLSL;
exports.fragmentCode = fragmentShaderGLSL;
