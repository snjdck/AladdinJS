/*
const vertexShaderGLSL = `#version 450

const uint indexList[54] = uint[](
	 4, 5, 0, 5, 1, 0,
	 5, 6, 1, 6, 2, 1,
	 6, 7, 2, 7, 3, 2,
	 8, 9, 4, 9, 5, 4,
	 9,10, 5,10, 6, 5,
	10,11, 6,11, 7, 6,
	12,13, 8,13, 9, 8,
	13,14, 9,14,10, 9,
	14,15,10,15,11,10
);

struct Viewport
{
	vec4 screenXYWH;
	mat2x3 matrixInv;
};

layout(binding=0)
uniform _ {
	Viewport viewportList[256];
};

//layout(location=0)in mat2x3 worldMatrix;

layout(location=0)
in vec4 worldMatrixX;

layout(location=1)
in vec4 worldMatrixY;

layout(location=2)
in vec4 textureMul;

layout(location=3)
in vec4 textureAdd;

layout(location=4)
in vec4 rectSize;//w,rw,h,rh

layout(location=5)
in vec4 scale9grid;//lm,rm,tm,bm

layout(location = 0)
out vec2 uv;

void main() {
	uint vertexID = indexList[gl_VertexIndex];
	mat2x3 worldMatrix = mat2x3(vec3(worldMatrixX), vec3(worldMatrixY));
	vec2 inputPosition = vec2(vertexID >> 1 & 1, vertexID >> 3);
	vec4 inputMargin = vec4(equal(
		ivec2(vertexID & 3, vertexID >> 2).xxyy,
		ivec2(1, 2).xyxy
	));
	inputMargin.yw = -inputMargin.yw;
	vec4 margin = inputMargin * scale9grid;
	margin = margin.xxzz + margin.yyww;

	vec4 xyuv = fma(inputPosition.xxyy, rectSize, margin);
	xyuv.yw /= rectSize.yw;
	xyuv = fma(xyuv.xzyw, textureMul, textureAdd);

	xyuv.xy = vec3(xyuv.xy, 1) * worldMatrix;
	uint viewportIndex = uint(worldMatrixX.w);
	xyuv.xy = vec3(xyuv.xy, 1) * viewportList[viewportIndex].matrixInv;
	vec4 screenXYWH = viewportList[viewportIndex].screenXYWH;
	xyuv.xy = fma(xyuv.xy, screenXYWH.xy, screenXYWH.zw);

	gl_Position = vec4(xyuv.xy, 0, 1);
	uv = xyuv.zw;
}
`;
//*/

const vertexShaderGLSL = `
const indexList : array<vec4<i32>, 14> = array<vec4<i32>, 14>(
	vec4<i32>( 4, 5, 0, 5),
	vec4<i32>( 1, 0, 5, 6),
	vec4<i32>( 1, 6, 2, 1),
	vec4<i32>( 6, 7, 2, 7), 
	vec4<i32>( 3, 2, 8, 9),
	vec4<i32>( 4, 9, 5, 4),
	vec4<i32>( 9,10, 5,10),
	vec4<i32>( 6, 5,10,11),
	vec4<i32>( 6,11, 7, 6),
	vec4<i32>(12,13, 8,13),
	vec4<i32>( 9, 8,13,14),
	vec4<i32>( 9,14,10, 9),
	vec4<i32>(14,15,10,15),
	vec4<i32>(11,10,-1,-1)
);

struct Viewport {
	screenXYWH: vec4<f32>;
	matrixInv: mat2x3<f32>;
};

[[block]] struct Viewport_Block {
	viewportList: array<Viewport, 256>;
};

[[binding(0), group(0)]] var<uniform> viewportBlock: Viewport_Block;

struct Input {
	[[location(0)]] worldMatrixX: vec4<f32>;
	[[location(1)]] worldMatrixY: vec4<f32>;
	[[location(2)]] textureMul  : vec4<f32>;
	[[location(3)]] textureAdd  : vec4<f32>;
	[[location(4)]] rectSize    : vec4<f32>; //w,rw,h,rh
	[[location(5)]] scale9grid  : vec4<f32>; //lm,rm,tm,bm
	[[builtin(vertex_index)]] vertexIndex: u32;
	//[[builtin(instance_index)]] instanceIndex: u32;
};

struct Output {
	[[builtin(position)]] position: vec4<f32>;
	//[[location(0), interpolate(linear)]]//(perspective, linear, flat), (center, centroid, sample)
	[[location(0)]] uv: vec2<f32>;
};

[[stage(vertex)]]
fn main(input: Input) -> Output {
	var vertexID: i32 = indexList[input.vertexIndex >> 2u][input.vertexIndex & 3u];
	var viewport: Viewport = viewportBlock.viewportList[u32(input.worldMatrixX.w)];

	var inputPosition: vec2<f32> = vec2<f32>(f32(vertexID >> 1u & 1), f32(vertexID >> 3u));

	var test: vec4<bool> = vec2<i32>(vertexID & 3, vertexID >> 2u).xxyy == vec2<i32>(1, 2).xyxy;
	//var inputMargin: vec4<f32> = select(vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(), test);
	var inputMargin: vec4<f32> = vec4<f32>();
	if(test.x){inputMargin.x =  1.0;}
	if(test.y){inputMargin.y = -1.0;}
	if(test.z){inputMargin.z =  1.0;}
	if(test.w){inputMargin.w = -1.0;}

	var margin: vec4<f32> = inputMargin * input.scale9grid;

	var xyuv: vec4<f32> = fma(inputPosition.xxyy, input.rectSize, margin.xxzz + margin.yyww);
	xyuv.y = xyuv.y / input.rectSize.y;
	xyuv.w = xyuv.w / input.rectSize.w;
	xyuv = fma(xyuv.xzyw, input.textureMul, input.textureAdd);

	var position: vec2<f32> = xyuv.xy;
	position = vec3<f32>(position, 1.0) * mat2x3<f32>(input.worldMatrixX.xyz, input.worldMatrixY.xyz);
	position = vec3<f32>(position, 1.0) * viewport.matrixInv;
	position = fma(position, viewport.screenXYWH.xy, viewport.screenXYWH.zw);

	var output: Output;
	output.position = vec4<f32>(position, 0.0, 1.0);
	output.uv = xyuv.zw;
	return output;
}

`;

const fragmentShaderGLSL = `

	[[binding(1), group(0)]] var mySampler: sampler;
	[[binding(0), group(1)]] var myTexture: texture_2d<f32>;

	struct Input {
		[[location(0)]] uv: vec2<f32>;
	};

	[[stage(fragment)]]
	fn main(input: Input) -> [[location(0)]] vec4<f32> {
		return textureSample(myTexture, mySampler, input.uv);
	}

`;

exports.vertexCode = vertexShaderGLSL;
exports.fragmentCode = fragmentShaderGLSL;
