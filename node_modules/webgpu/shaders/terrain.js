/*
const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

layout(binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
};

const float tileSize = 100.0;
const float uvScale = tileSize / 128.0;
const ivec2 vertexCount = ivec2(256, 256);

layout(location=0)
in uvec2 map_layer;//layer0, layer1

layout(location=1)
in vec2 map_layermix_height;//mix, z-height

const float height_scale = 0;//400.0;

layout(location=2)
in vec4 map_light;

layout(location=0)
out vec2 uv;

layout(location=1)
out vec3 layer;

layout(location=2)
out vec4 light;

void main()
{
	ivec2 vertex = ivec2(gl_VertexIndex % vertexCount.x, gl_VertexIndex / vertexCount.x);
	vec3 worldPosition  = vec3(vec2(vertex) * tileSize, map_layermix_height.y * height_scale);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * screenMatrix;

	gl_Position = screenPosition;
	uv = vec2(vertex) * uvScale;
	layer = vec3(map_layer, map_layermix_height.x);
	light = map_light;
}
`;

const fragment3DShaderGLSL = `#version 450

	layout(binding=1)uniform sampler _sampler;
	layout(set=1, binding=0)uniform texture2DArray _texture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;
	layout(location=1)in vec3 layer;
	layout(location=2)in vec4 light;

	void main() {
		outColor = mix(
			texture(sampler2DArray(_texture, _sampler), vec3(uv, layer.x)),
			texture(sampler2DArray(_texture, _sampler), vec3(uv, layer.y)),
			layer.z
		) * light;
	}
`;
*/

const vertexShaderGLSL = `
	const height_scale: f32 = 0.0;//400.0
	const tileSize: f32 = 100.0;
	const uvScale: f32 = 0.78125;//100 / 128
	const vertexCount: vec2<i32> = vec2<i32>(256, 256);

	struct MVP
	{
		screenMatrix: mat4x4<f32>;
		cameraMatrix: mat3x4<f32>;
		viewportXYWH: vec4<f32>;
	};

	[[block]] struct MVP_BLOCK {
		cameraList: array<MVP, 100>;
	};

	[[block]] struct TRANSFORM_BLOCK {
		matrixList: array<mat4x4<f32>, 256>;
	};

	[[binding(0), set(0)]] var<uniform> mvp: MVP_BLOCK;
	[[binding(0), set(2)]] var<uniform> worldMatrix: TRANSFORM_BLOCK;

	[[location(0)]] var<in> map_layer: vec2<u32>;
	[[location(1)]] var<in> map_layermix_height: vec2<f32>;//mix, z-height
	[[location(2)]] var<in> map_light: vec4<f32>;

	[[builtin(vertex_idx)]] var<in> gl_VertexIndex: i32;
	[[builtin(instance_index)]] var<in> instance_index: u32;
	[[builtin(position)]] var<out> gl_Position: vec4<f32>;

	[[location(0)]] var<out> uv: vec2<f32>;
	[[location(1)]] var<out> layer: vec3<f32>;
	[[location(2)]] var<out> light: vec4<f32>;

	[[stage(vertex)]]
	fn main() -> void {
		var cameraIndex: u32 = u32(worldMatrix.matrixList[instance_index << 2u][3][0]);

		var vertexXY: vec2<f32> = vec2<f32>(vec2<i32>(gl_VertexIndex % vertexCount.x, gl_VertexIndex / vertexCount.x));
		var worldPosition: vec3<f32> = vec3<f32>(vertexXY * tileSize, map_layermix_height.y * height_scale);
		var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraList[cameraIndex].cameraMatrix;
		var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.cameraList[cameraIndex].screenMatrix;

		var viewportXYWH: vec4<f32> = mvp.cameraList[cameraIndex].viewportXYWH;
		//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;
		var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);
		screenPosition.x = t.x;
		screenPosition.y = t.y;
		//screenPosition.xy = t;
		gl_Position = screenPosition;
		uv = vertexXY * uvScale;
		layer = vec3<f32>(vec2<f32>(map_layer), map_layermix_height.x);
		light = map_light;
	}
`;

const fragmentShaderGLSL = `
	[[binding(1), set(0)]] var _sampler: sampler;
	[[binding(0), set(1)]] var _texture: texture_2d_array<f32>;

	[[location(0)]] var<in> uv: vec2<f32>;
	[[location(1)]] var<in> layer: vec3<f32>;
	[[location(2)]] var<in> light: vec4<f32>;

	[[location(0)]] var<out> outColor: vec4<f32>;

	[[stage(fragment)]]
	fn main() -> void {
		outColor = mix(
			textureSample(_texture, _sampler, vec2<f32>(uv), i32(layer.x)),
			textureSample(_texture, _sampler, vec2<f32>(uv), i32(layer.y)),
			layer.zzzz
		) * light;
	}
`;

exports.vertexCode = vertexShaderGLSL
exports.fragmentCode = fragmentShaderGLSL;
