/*
const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

layout(binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
};

const float tileSize = 100.0;
const float uvScale = tileSize / 128.0;
const ivec2 vertexCount = ivec2(256, 256);

layout(location=0)
in uvec2 map_layer;//layer0, layer1

layout(location=1)
in vec2 map_layermix_height;//mix, z-height

const float height_scale = 0;//400.0;

layout(location=2)
in vec4 map_light;

layout(location=0)
out vec2 uv;

layout(location=1)
out vec3 layer;

layout(location=2)
out vec4 light;

void main()
{
	ivec2 vertex = ivec2(gl_VertexIndex % vertexCount.x, gl_VertexIndex / vertexCount.x);
	vec3 worldPosition  = vec3(vec2(vertex) * tileSize, map_layermix_height.y * height_scale);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * screenMatrix;

	gl_Position = screenPosition;
	uv = vec2(vertex) * uvScale;
	layer = vec3(map_layer, map_layermix_height.x);
	light = map_light;
}
`;

const fragment3DShaderGLSL = `#version 450

	layout(binding=1)uniform sampler _sampler;
	layout(set=1, binding=0)uniform texture2DArray _texture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;
	layout(location=1)in vec3 layer;
	layout(location=2)in vec4 light;

	void main() {
		outColor = mix(
			texture(sampler2DArray(_texture, _sampler), vec3(uv, layer.x)),
			texture(sampler2DArray(_texture, _sampler), vec3(uv, layer.y)),
			layer.z
		) * light;
	}
`;
*/

const vertexShaderGLSL = `
	const height_scale: f32 = 0.0;#400.0
	const tileSize: f32 = 100.0;
	const uvScale: f32 = 0.78125;#100 / 128
	const vertexCount: vec2<i32> = vec2<i32>(256, 256);

	[[block]] struct MVP_BLOCK {
		[[offset( 0)]] screenMatrix: mat4x4<f32>;
		[[offset(64)]] cameraMatrix: mat3x4<f32>;
	};

	[[binding(0), set(0)]] var<uniform> mvp: MVP_BLOCK;

	[[location(0)]] var<in> map_layer: vec2<u32>;
	[[location(1)]] var<in> map_layermix_height: vec2<f32>;#mix, z-height
	[[location(2)]] var<in> map_light: vec4<f32>;

	[[builtin(vertex_idx)]] var<in> gl_VertexIndex: i32;
	[[builtin(position)]] var<out> gl_Position: vec4<f32>;

	[[location(0)]] var<out> uv: vec2<f32>;
	[[location(1)]] var<out> layer: vec3<f32>;
	[[location(2)]] var<out> light: vec4<f32>;

	[[stage(vertex)]]
	fn main() -> void {
		var vertexXY: vec2<f32> = vec2<f32>(vec2<i32>(gl_VertexIndex % vertexCount.x, gl_VertexIndex / vertexCount.x));
		var worldPosition: vec3<f32> = vec3<f32>(vertexXY * tileSize, map_layermix_height.y * height_scale);
		var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraMatrix;
		var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.screenMatrix;
		gl_Position = screenPosition;
		uv = vertexXY * uvScale;
		layer = vec3<f32>(vec2<f32>(map_layer), map_layermix_height.x);
		light = map_light;
	}
`;

const fragmentShaderGLSL = `
	[[binding(1), set(0)]] var<uniform_constant> _sampler: sampler;
	[[binding(0), set(1)]] var<uniform_constant> _texture: texture_2d_array<f32>;

	[[location(0)]] var<in> uv: vec2<f32>;
	[[location(1)]] var<in> layer: vec3<f32>;
	[[location(2)]] var<in> light: vec4<f32>;

	[[location(0)]] var<out> outColor: vec4<f32>;

	[[stage(fragment)]]
	fn main() -> void {
		outColor = mix(
			textureSample(_texture, _sampler, vec3<f32>(uv, layer.x), layer.x),
			textureSample(_texture, _sampler, vec3<f32>(uv, layer.y), layer.y),
			layer.zzzz
		) * light;
	}
`;

exports.vertexCode = vertexShaderGLSL
exports.fragmentCode = fragmentShaderGLSL;
