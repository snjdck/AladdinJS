
const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

layout(binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
};
/*
layout(set=1, binding=0)
uniform BONE_BLOCK {
	float tileSize;
	float uvScale;
	ivec2 vertexCount;
};
*/

const float tileSize = 5;
const float uvScale = 100.0 / 128.0;
const ivec2 vertexCount = ivec2(256, 256);

layout(location=0)
in vec2 map_layer;//layer0, layer1

layout(location=1)
in vec2 map_layermix_height;//mix, z-height

const float height_scale = 0;//400.0;

layout(location=2)
in vec4 map_light;

layout(location=0)
out vec2 uv;

layout(location=1)
out vec3 layer;

layout(location=2)
out vec4 light;

void main()
{
	ivec2 vertex = ivec2(gl_VertexIndex % vertexCount.x, gl_VertexIndex / vertexCount.x);
	vec3 worldPosition  = vec3(vec2(vertex) * tileSize, map_layermix_height.y * height_scale);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * screenMatrix;

	gl_Position = screenPosition;
	uv = vec2(vertex) * uvScale;
	layer = vec3(map_layer, map_layermix_height.x);
	light = map_light;
}
`;

const fragment3DShaderGLSL = `#version 450

	layout(binding=1)uniform sampler _sampler;
	//layout(set=2, binding=0)uniform sampler2DArray _texture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;
	layout(location=1)in vec3 layer;
	layout(location=2)in vec4 light;

	void main() {
		outColor = light;
		outColor = vec4(0, 0.3, 0, 1);
		/*
		outColor = mix(
			texture(sampler2D(_texture, _sampler), vec3(uv, layer.x)),
			texture(sampler2D(_texture, _sampler), vec3(uv, layer.y)),
			layer.z
		) * light;
		*/
	}
`;


exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
