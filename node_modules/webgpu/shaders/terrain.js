/*
const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

layout(binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
};

const float tileSize = 100.0;
const float uvScale = tileSize / 128.0;
const ivec2 vertexCount = ivec2(256, 256);

layout(location=0)
in uvec2 map_layer;//layer0, layer1

layout(location=1)
in vec2 map_layermix_height;//mix, z-height

const float height_scale = 0;//400.0;

layout(location=2)
in vec4 map_light;

layout(location=0)
out vec2 uv;

layout(location=1)
out vec3 layer;

layout(location=2)
out vec4 light;

void main()
{
	ivec2 vertex = ivec2(gl_VertexIndex % vertexCount.x, gl_VertexIndex / vertexCount.x);
	vec3 worldPosition  = vec3(vec2(vertex) * tileSize, map_layermix_height.y * height_scale);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * screenMatrix;

	gl_Position = screenPosition;
	uv = vec2(vertex) * uvScale;
	layer = vec3(map_layer, map_layermix_height.x);
	light = map_light;
}
`;

const fragment3DShaderGLSL = `#version 450

	layout(binding=1)uniform sampler _sampler;
	layout(set=1, binding=0)uniform texture2DArray _texture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;
	layout(location=1)in vec3 layer;
	layout(location=2)in vec4 light;

	void main() {
		outColor = mix(
			texture(sampler2DArray(_texture, _sampler), vec3(uv, layer.x)),
			texture(sampler2DArray(_texture, _sampler), vec3(uv, layer.y)),
			layer.z
		) * light;
	}
`;
*/

const vertexShaderGLSL = `
	let height_scale: f32 = 0.0;//400.0
	let tileSize: f32 = 100.0;
	let uvScale: f32 = 0.78125;//100 / 128
	let vertexCount: vec2<u32> = vec2<u32>(256u, 256u);

	struct MVP {
		screenMatrix: mat4x4<f32>;
		cameraMatrix: mat3x4<f32>;
		viewportXYWH: vec4<f32>;
	};

	struct MVP_BLOCK {
		cameraList: array<MVP, 100>;
	};

	struct TRANSFORM_BLOCK {
		matrixList: array<mat4x4<f32>, 256>;
	};

	@binding(0) @group(0) var<uniform> mvp: MVP_BLOCK;
	@binding(0) @group(2) var<uniform> worldMatrix: TRANSFORM_BLOCK;

	struct Input {
		@location(0) map_layer: vec2<u32>;
		@location(1) map_layermix_height: vec2<f32>;//mix, z-height
		@location(2) map_light: vec4<f32>;
		@builtin(vertex_index) vertexIndex: u32;
		@builtin(instance_index) instanceIndex: u32;
	};

	struct Output {
		@builtin(position) position: vec4<f32>;
		@location(0) uv: vec2<f32>;
		@location(1) layer: vec3<f32>;
		@location(2) light: vec4<f32>;
	};

	@stage(vertex)
	fn main(input: Input) -> Output {
		var cameraIndex: u32 = u32(worldMatrix.matrixList[input.instanceIndex << 2u][3][0]);

		var vertexXY: vec2<f32> = vec2<f32>(f32(input.vertexIndex % vertexCount.x), f32(input.vertexIndex / vertexCount.x));
		var worldPosition: vec3<f32> = vec3<f32>(vertexXY * tileSize, input.map_layermix_height.y * height_scale);
		var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraList[cameraIndex].cameraMatrix;
		var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.cameraList[cameraIndex].screenMatrix;

		var viewportXYWH: vec4<f32> = mvp.cameraList[cameraIndex].viewportXYWH;
		//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;
		var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);
		screenPosition.x = t.x;
		screenPosition.y = t.y;
		//screenPosition.xy = t;

		var output: Output;
		output.position = screenPosition;
		output.uv = vertexXY * uvScale;
		output.layer = vec3<f32>(vec2<f32>(input.map_layer), input.map_layermix_height.x);
		output.light = input.map_light;
		return output;
	}
`;

const fragmentShaderGLSL = `
	@binding(1) @group(0) var g_sampler: sampler;
	@binding(0) @group(1) var g_texture: texture_2d_array<f32>;

	struct Input {
		@location(0) uv: vec2<f32>;
		@location(1) layer: vec3<f32>;
		@location(2) light: vec4<f32>;
	};

	struct Output {
		@location(0) color: vec4<f32>;
	};

	@stage(fragment)
	fn main(input: Input) -> Output {
		var output: Output;
		output.color = mix(
			textureSample(g_texture, g_sampler, vec2<f32>(input.uv), i32(input.layer.x)),
			textureSample(g_texture, g_sampler, vec2<f32>(input.uv), i32(input.layer.y)),
			input.layer.zzzz
		) * input.light;
		return output;
	}
`;

exports.vertexCode = vertexShaderGLSL
exports.fragmentCode = fragmentShaderGLSL;
