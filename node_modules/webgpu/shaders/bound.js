//*
const vertex3DShaderGLSL = `#version 450

const uint indexList[24] = uint[](
	0, 1, 1, 3, 3, 2, 2, 0,
	4, 5, 5, 7, 7, 6, 6, 4,
	0, 4, 1, 5, 3, 7, 2, 6
);

struct MVP
{
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
	vec4 viewportXYWH;
};

layout(binding=0)
uniform MVP_BLOCK {
	MVP cameraList[100];
};

layout(set=1, binding=0)
uniform BOUND_BLOCK {
	vec4 boundList[1024];
};

void main()
{
	uint vertexID = indexList[gl_VertexIndex];
	uvec3 xyz = uvec3(vertexID & 1, (vertexID >> 1) & 1, vertexID >> 2);
	vec3 vertex;
	for(int i=0; i<3; ++i){
		vertex[i] = boundList[gl_InstanceIndex << 4 | xyz[i]][i];
	}
	uint cameraIndex = uint(boundList[gl_InstanceIndex << 4].w);
	vec3 worldPosition = vertex;
	//worldPosition = vec4(worldPosition, 1) * mat3x4(worldMatrixList[gl_InstanceIndex << 2]);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraList[cameraIndex].cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * cameraList[cameraIndex].screenMatrix;

	vec4 viewportXYWH = cameraList[cameraIndex].viewportXYWH;
	//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;
	screenPosition.xy = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);

	gl_Position = screenPosition;
}
`;
//*/
/*
const fragment3DShaderGLSL = `#version 450
	layout(location=0)out vec4 outColor;

	void main() {
		outColor = vec4(1, 0, 1, 1);
	}
`;
//*/
/*
const vertex3DShaderGLSL = `

	const indexList : array<i32, 24> = array<i32, 24>(
		0, 1, 1, 3, 3, 2, 2, 0,
		4, 5, 5, 7, 7, 6, 6, 4,
		0, 4, 1, 5, 3, 7, 2, 6
	);

	[[block]] struct MVP_BLOCK {
		[[offset( 0)]] screenMatrix: mat4x4<f32>;
		[[offset(64)]] cameraMatrix: mat3x4<f32>;
	};

	[[block]] struct BOUND_BLOCK {
		[[offset( 0)]] boundList: array<vec3<f32>, 1024>;
	};

	[[binding(0), set(0)]] var<uniform> mvp: MVP_BLOCK;

	[[binding(0), set(1)]] var<uniform> bound: BOUND_BLOCK;


	[[builtin(vertex_idx)]] var<in> gl_VertexIndex: i32;
	[[builtin(instance_idx)]] var<in> gl_InstanceIndex: u32;
	[[builtin(position)]] var<out> gl_Position: vec4<f32>;

	[[stage(vertex)]]
	fn main() -> void {
		var vertexID : i32 = indexList[gl_VertexIndex];
		var xyz : vec3<i32> = vec3<i32>(vertexID & 1, (vertexID >> 1u) & 1, vertexID >> 2u);
		var result : vec3<f32>;

		result[0] = bound.boundList[gl_InstanceIndex << 4u | xyz[0] ][0];
		result[1] = bound.boundList[gl_InstanceIndex << 4u | xyz[1] ][1];
		result[2] = bound.boundList[gl_InstanceIndex << 4u | xyz[2] ][2];

		var worldPosition : vec3<f32> = result;

		var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraMatrix;
		var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.screenMatrix;

		gl_Position = screenPosition;
		return;
	}
`;
//*/
const fragment3DShaderGLSL = `

	[[stage(fragment)]]
	fn main() -> [[location(0)]] vec4<f32> {
		return vec4<f32>(1.0, 0.0, 1.0, 1.0);
	}
`;



exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
