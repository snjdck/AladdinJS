/*
const vertex3DShaderGLSL = `#version 450

const uint indexList[24] = uint[](
	0, 1, 1, 3, 3, 2, 2, 0,
	4, 5, 5, 7, 7, 6, 6, 4,
	0, 4, 1, 5, 3, 7, 2, 6
);

struct MVP
{
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
	vec4 viewportXYWH;
};

layout(binding=0)
uniform MVP_BLOCK {
	MVP cameraList[100];
};

layout(set=1, binding=0)
uniform BOUND_BLOCK {
	vec4 boundList[1024];
};

void main()
{
	uint vertexID = indexList[gl_VertexIndex];
	uvec3 xyz = uvec3(vertexID & 1, (vertexID >> 1) & 1, vertexID >> 2);
	vec3 vertex;
	for(int i=0; i<3; ++i){
		vertex[i] = boundList[gl_InstanceIndex << 4 | xyz[i]][i];
	}
	uint cameraIndex = uint(boundList[gl_InstanceIndex << 4].w);
	vec3 worldPosition = vertex;
	//worldPosition = vec4(worldPosition, 1) * mat3x4(worldMatrixList[gl_InstanceIndex << 2]);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraList[cameraIndex].cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * cameraList[cameraIndex].screenMatrix;

	vec4 viewportXYWH = cameraList[cameraIndex].viewportXYWH;
	//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;
	screenPosition.xy = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);

	gl_Position = screenPosition;
}
`;
//*/
/*
const fragment3DShaderGLSL = `#version 450
	layout(location=0)out vec4 outColor;

	void main() {
		outColor = vec4(1, 0, 1, 1);
	}
`;
//*/
//*
const vertex3DShaderGLSL = `

	var<private> indexList : array<vec4<u32>, 6> = array<vec4<u32>, 6>(
		vec4<u32>(0u, 1u, 1u, 3u),
		vec4<u32>(3u, 2u, 2u, 0u),
		vec4<u32>(4u, 5u, 5u, 7u),
		vec4<u32>(7u, 6u, 6u, 4u),
		vec4<u32>(0u, 4u, 1u, 5u),
		vec4<u32>(3u, 7u, 2u, 6u)
	);

	struct MVP {
		screenMatrix: mat4x4<f32>;
		cameraMatrix: mat3x4<f32>;
		viewportXYWH: vec4<f32>;
	};

	[[block]] struct MVP_BLOCK {
		cameraList: array<MVP, 100>;
	};

	[[block]] struct BOUND_BLOCK {
		boundList: array<vec4<f32>, 1024>;
	};

	[[binding(0), group(0)]] var<uniform> mvp: MVP_BLOCK;
	[[binding(0), group(1)]] var<uniform> boundBlock: BOUND_BLOCK;

	struct Input {
		[[builtin(vertex_index)]] vertexIndex: u32;
		[[builtin(instance_index)]] instanceIndex: u32;
	};

	[[stage(vertex)]]
	fn main(input: Input) -> [[builtin(position)]] vec4<f32> {
		var vertexID : u32 = indexList[input.vertexIndex >> 2u][input.vertexIndex & 3u];
		var xyz : vec3<u32> = vec3<u32>(vertexID & 1u, (vertexID >> 1u) & 1u, vertexID >> 2u);

		var index: u32 = input.instanceIndex << 4u;
		var cameraIndex: u32 = u32(boundBlock.boundList[index].w);

		var vertex: vec3<f32>;
		for(var i:i32=0; i<3; i=i+1){
			vertex[i] = boundBlock.boundList[index | xyz[i]][i];
		}

		var cameraPosition: vec3<f32> = vec4<f32>(vertex, 1.0) * mvp.cameraList[cameraIndex].cameraMatrix;
		var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.cameraList[cameraIndex].screenMatrix;
		
		var viewportXYWH: vec4<f32> = mvp.cameraList[cameraIndex].viewportXYWH;
		var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);
		screenPosition.x = t.x;
		screenPosition.y = t.y;

		return screenPosition;
	}
`;
//*/
const fragment3DShaderGLSL = `

	[[stage(fragment)]]
	fn main() -> [[location(0)]] vec4<f32> {
		return vec4<f32>(1.0, 0.0, 1.0, 1.0);
	}
`;

const wireframeGLSL = `

	struct Input {
		[[location(0)]] uv: vec2<f32>;
		[[location(1)]] instanceIndex: u32;
		[[location(2)]] normal: vec3<f32>;
	};

	[[stage(fragment)]]
	fn main(input: Input) -> [[location(0)]] vec4<f32> {
		return vec4<f32>(1.0, 0.0, 1.0, 1.0);
	}
`;



exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
exports.wireframeGLSL = wireframeGLSL;
