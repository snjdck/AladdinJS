
const vertex3DShaderGLSL = `#version 450

const uint indexList[24] = uint[](
	0, 1, 1, 3, 3, 2, 2, 0,
	4, 5, 5, 7, 7, 6, 6, 4,
	0, 4, 1, 5, 3, 7, 2, 6
);

layout(binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
};

layout(set=1, binding=0)
uniform BOUND_BLOCK {
	vec3 boundList[1024];
};

void main()
{
	uint vertexID = indexList[gl_VertexIndex];
	uvec3 xyz = uvec3(vertexID & 1, (vertexID >> 1) & 1, vertexID >> 2);
	vec3 vertex;
	for(int i=0; i<3; ++i){
		vertex[i] = boundList[gl_InstanceIndex << 4 | xyz[i]][i];
	}

	vec3 worldPosition = vertex;
	//worldPosition = vec4(worldPosition, 1) * mat3x4(worldMatrixList[gl_InstanceIndex << 2]);
	vec3 cameraPosition = vec4(worldPosition, 1) * cameraMatrix;
	vec4 screenPosition = vec4(cameraPosition, 1) * screenMatrix;

	gl_Position = screenPosition;
}
`;
/*
const fragment3DShaderGLSL = `#version 450
	layout(location=0)out vec4 outColor;

	void main() {
		outColor = vec4(1, 0, 1, 1);
	}
`;
//*/
const fragment3DShaderGLSL = `
	[[location 0]]
	var<out> outColor: vec4<f32>;

	#[[stage(fragment)]]
	fn main() -> void {
		outColor = vec4<f32>(1.0, 0.0, 1.0, 1.0);
		return;
	}

	entry_point fragment = main;
`;



exports.vertexCode = vertex3DShaderGLSL
exports.fragmentCode = fragment3DShaderGLSL;
