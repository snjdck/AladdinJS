const numParticles = 10;
const code = `#version 450
/*
// work group dimensions
in uvec3 gl_NumWorkGroups; (dispatch_x, dispatch_y, dispatch_z)
const uvec3 gl_WorkGroupSize; (local_size_x, local_size_y, local_size_z)

// work group and invocation IDs
in uvec3 gl_WorkGroupID; ([0, dispatch_x), [0, dispatch_y), [0, dispatch_z))
in uvec3 gl_LocalInvocationID; ([0, local_size_x), [0, local_size_y), [0, local_size_z))

// derived variables
in uvec3 gl_GlobalInvocationID;
= gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
in uint gl_LocalInvocationIndex;
= gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;




    void draw(GPUSize32 vertexCount, optional GPUSize32 instanceCount = 1,
              optional GPUSize32 firstVertex = 0, optional GPUSize32 firstInstance = 0);
    void drawIndexed(GPUSize32 indexCount, optional GPUSize32 instanceCount = 1,
                     optional GPUSize32 firstIndex = 0,
                     optional GPUSignedOffset32 baseVertex = 0,
                     optional GPUSize32 firstInstance = 0);
*/

/*
layout(std140, set = 0, binding = 0)
uniform SimParams {
	float deltaT;
	float rule1Distance;
	float rule2Distance;
	float rule3Distance;
	float rule1Scale;
	float rule2Scale;
	float rule3Scale;
} params;
*/

layout(set=1, binding=0)
uniform WORLD_BLOCK {
	mat3x4 worldMatrixList[100];
};

layout(set=2, binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	mat3x4 cameraMatrix;
};

layout(set=3, binding=0)
uniform BOUND_BLOCK {
	vec3 boundList[20];//(min, max),every bound use two vec3.
};

layout(set=0, binding=0)
buffer DrawInfo {
	uvec4 drawInfo[];
};


struct Item{
	bvec2 flag[3];
};
shared Item cullFlag[8];
shared bvec3 result[2];
bool canCull(uint axis, uint idx){
	for(int i=0; i<8; ++i){
		if(cullFlag[i].flag[axis][idx]){
			return false;
		}
	}
	return true;
}

layout(local_size_x=8, local_size_y=3, local_size_z=2)in;

void main(){
	uint index = gl_WorkGroupID.x;
	uint boundIndex = index << 1;
	
	uint vertexID = gl_LocalInvocationID.x;
	uint axis = gl_LocalInvocationID.y;
	uint side = gl_LocalInvocationID.z;
	
	uvec3 xyz = uvec3(vertexID & 1, (vertexID >> 1) & 1, vertexID >> 2);
	vec4 vertex = vec4(0, 0, 0, 1);
	for(int i=0; i<3; ++i){
		vertex[i] = boundList[boundIndex + xyz[i]][i];
	}
	vertex = vec4(vec4(vertex * worldMatrixList[drawInfo[index].w], 1) * cameraMatrix, 1) * screenMatrix;
	cullFlag[vertexID].flag[axis][side] = vertex.w + (side > 0 ? vertex[axis] : - vertex[axis]) > 0;
	barrier();
	result[side][axis] = canCull(axis, side);
	barrier();
	if(any(result[0]) || any(result[1]))return;
	drawInfo[index].y = 1;
}
`;


module.exports = code;
