/*
const filterVertexShaderGLSL = `#version 450

layout(set=1, binding=0)
uniform _ {
	vec4 sourceRect;
	vec4 destRect;
};
//vec4 sourceRect = vec4(0, 0, 1, 1);
//vec4 destRect = vec4(-1, -1, 2, 2);

layout(location = 0)
out vec2 uv;

void main() {
	vec2 vertex = vec2(gl_VertexIndex >> 1, gl_VertexIndex & 1);
	//gl_Position = vec4(fma(vertex, vec2(2), vec2(-1)), 0, 1);
	//uv = vertex;
	gl_Position = vec4(fma(vertex, destRect.zw, destRect.xy), 0, 1);
	uv = fma(vertex, sourceRect.zw, sourceRect.xy);
}
`;
const filterFragmentShaderGLSL = `#version 450
	layout(binding=0)uniform sampler _sampler;
	layout(binding=1)uniform texture2D _texture;

	layout(set=1, binding=1)
	uniform _ {
		vec4 mixColor;
	};

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		float s = dFdx(uv.x);
		float t = dFdy(uv.y);

		vec2 tc0 = uv + vec2(-s, -t);
		vec2 tc1 = uv + vec2( 0, -t);
		vec2 tc2 = uv + vec2( s, -t);
		vec2 tc3 = uv + vec2(-s,  0);
		vec2 tc4 = uv;
		vec2 tc5 = uv + vec2( s,  0);
		vec2 tc6 = uv + vec2(-s,  t);
		vec2 tc7 = uv + vec2( 0,  t);
		vec2 tc8 = uv + vec2( s,  t);

		vec4 col0 = texture(sampler2D(_texture, _sampler), tc0);
		vec4 col1 = texture(sampler2D(_texture, _sampler), tc1);
		vec4 col2 = texture(sampler2D(_texture, _sampler), tc2);
		vec4 col3 = texture(sampler2D(_texture, _sampler), tc3);
		vec4 col4 = texture(sampler2D(_texture, _sampler), tc4);
		vec4 col5 = texture(sampler2D(_texture, _sampler), tc5);
		vec4 col6 = texture(sampler2D(_texture, _sampler), tc6);
		vec4 col7 = texture(sampler2D(_texture, _sampler), tc7);
		vec4 col8 = texture(sampler2D(_texture, _sampler), tc8);

		vec4 sum = (
			1.0 * col0 + 2.0 * col1 + 1.0 * col2 +
			2.0 * col3 + 4.0 * col4 + 2.0 * col5 +
			1.0 * col6 + 2.0 * col7 + 1.0 * col8
		) / 16.0;

		outColor = sum * mixColor;
	}
`;
//*/
//*
const filterVertexShaderGLSL = `

	struct Input {
		[[builtin(vertex_index)]] vertexIndex: u32;
		[[builtin(instance_index)]] instanceIndex: u32;
		[[location(0)]] sourceRect: vec4<f32>;
	};

	struct Output {
		[[builtin(position)]] position: vec4<f32>;
		[[location(0)]] uv: vec2<f32>;
		[[location(1)]] instanceIndex: u32;//flat
	};

	[[stage(vertex)]]
	fn main(input: Input) -> Output {
		var destRect:vec4<f32> = input.sourceRect * vec2<f32>(2.0, -2.0).xyxy;
		//destRect.xy = destRect.xy + vec2<f32>(-1.0, 1.0);
		destRect.x = destRect.x - 1.0;
		destRect.y = destRect.y + 1.0;
		var vertexXY: vec2<f32> = vec2<f32>(f32(input.vertexIndex >> 1u), f32(input.vertexIndex & 1u));
		var output: Output;
		output.position = vec4<f32>(fma(vertexXY, destRect.zw, destRect.xy), 0.0, 1.0);
		output.uv = fma(vertexXY, input.sourceRect.zw, input.sourceRect.xy);
		output.instanceIndex = input.instanceIndex << 4u;//min bindgroup is 256 bytes, 16 of vec4<f32>
		return output;
	}
`;
const filterFragmentShaderGLSL = `

	[[block]] struct Color {
		mixColor : array<vec4<f32>, 100>;
	};

	[[binding(0), group(0)]] var _sampler: sampler;
	[[binding(1), group(0)]] var _texture: texture_2d<f32>;
	[[binding(0), group(1)]] var<uniform> _color: Color;

	struct Input {
		[[location(0)]] uv: vec2<f32>;
		[[location(1)]] instanceIndex: u32;
	};

	struct Output {
		[[location(0)]] color: vec4<f32>;
	};

	[[stage(fragment)]]
	fn main(input: Input) -> Output {
		var s : f32 = dpdx(input.uv.x);
		var t : f32 = dpdy(input.uv.y);

		var ns: f32 = - s;
		var nt: f32 = - t;

		var tc0 : vec2<f32> = input.uv + vec2<f32>(ns,   nt);
		var tc1 : vec2<f32> = input.uv + vec2<f32>( 0.0, nt);
		var tc2 : vec2<f32> = input.uv + vec2<f32>( s,   nt);
		var tc3 : vec2<f32> = input.uv + vec2<f32>(ns,  0.0);
		var tc4 : vec2<f32> = input.uv;
		var tc5 : vec2<f32> = input.uv + vec2<f32>( s,    0.0);
		var tc6 : vec2<f32> = input.uv + vec2<f32>(ns,    t);
		var tc7 : vec2<f32> = input.uv + vec2<f32>( 0.0,  t);
		var tc8 : vec2<f32> = input.uv + vec2<f32>( s,    t);

		var col0 : vec4<f32> = textureSample(_texture, _sampler, tc0);
		var col1 : vec4<f32> = textureSample(_texture, _sampler, tc1);
		var col2 : vec4<f32> = textureSample(_texture, _sampler, tc2);
		var col3 : vec4<f32> = textureSample(_texture, _sampler, tc3);
		var col4 : vec4<f32> = textureSample(_texture, _sampler, tc4);
		var col5 : vec4<f32> = textureSample(_texture, _sampler, tc5);
		var col6 : vec4<f32> = textureSample(_texture, _sampler, tc6);
		var col7 : vec4<f32> = textureSample(_texture, _sampler, tc7);
		var col8 : vec4<f32> = textureSample(_texture, _sampler, tc8);

		var sum : vec4<f32> = (
			1.0 * col0 + 2.0 * col1 + 1.0 * col2 +
			2.0 * col3 + 4.0 * col4 + 2.0 * col5 +
			1.0 * col6 + 2.0 * col7 + 1.0 * col8
		) * (1.0 / 16.0);

		var output: Output;
		output.color = sum * _color.mixColor[input.instanceIndex];
		return output;
	}
`;
//*/

exports.vertexCode = filterVertexShaderGLSL;
exports.fragmentCode = filterFragmentShaderGLSL;
