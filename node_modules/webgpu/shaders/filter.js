/*
const filterVertexShaderGLSL = `#version 450

layout(set=1, binding=0)
uniform _ {
	vec4 sourceRect;
	vec4 destRect;
};
//vec4 sourceRect = vec4(0, 0, 1, 1);
//vec4 destRect = vec4(-1, -1, 2, 2);

layout(location = 0)
out vec2 uv;

void main() {
	vec2 vertex = vec2(gl_VertexIndex >> 1, gl_VertexIndex & 1);
	//gl_Position = vec4(fma(vertex, vec2(2), vec2(-1)), 0, 1);
	//uv = vertex;
	gl_Position = vec4(fma(vertex, destRect.zw, destRect.xy), 0, 1);
	uv = fma(vertex, sourceRect.zw, sourceRect.xy);
}
`;
const filterFragmentShaderGLSL = `#version 450
	layout(binding=0)uniform sampler _sampler;
	layout(binding=1)uniform texture2D _texture;

	layout(set=1, binding=1)
	uniform _ {
		vec4 mixColor;
	};

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		float s = dFdx(uv.x);
		float t = dFdy(uv.y);

		vec2 tc0 = uv + vec2(-s, -t);
		vec2 tc1 = uv + vec2( 0, -t);
		vec2 tc2 = uv + vec2( s, -t);
		vec2 tc3 = uv + vec2(-s,  0);
		vec2 tc4 = uv;
		vec2 tc5 = uv + vec2( s,  0);
		vec2 tc6 = uv + vec2(-s,  t);
		vec2 tc7 = uv + vec2( 0,  t);
		vec2 tc8 = uv + vec2( s,  t);

		vec4 col0 = texture(sampler2D(_texture, _sampler), tc0);
		vec4 col1 = texture(sampler2D(_texture, _sampler), tc1);
		vec4 col2 = texture(sampler2D(_texture, _sampler), tc2);
		vec4 col3 = texture(sampler2D(_texture, _sampler), tc3);
		vec4 col4 = texture(sampler2D(_texture, _sampler), tc4);
		vec4 col5 = texture(sampler2D(_texture, _sampler), tc5);
		vec4 col6 = texture(sampler2D(_texture, _sampler), tc6);
		vec4 col7 = texture(sampler2D(_texture, _sampler), tc7);
		vec4 col8 = texture(sampler2D(_texture, _sampler), tc8);

		vec4 sum = (
			1.0 * col0 + 2.0 * col1 + 1.0 * col2 +
			2.0 * col3 + 4.0 * col4 + 2.0 * col5 +
			1.0 * col6 + 2.0 * col7 + 1.0 * col8
		) / 16.0;

		outColor = sum * mixColor;
	}
`;
//*/
//*
const filterVertexShaderGLSL = `

	[[block]] struct Rect {
		[[offset(0)]] sourceRect: vec4<f32>;
		[[offset(16)]] destRect: vec4<f32>;
	};

	[[binding(0), set(1)]] var<uniform> _rect: Rect;

	//vec4 sourceRect = vec4(0, 0, 1, 1);
	//vec4 destRect = vec4(-1, -1, 2, 2);

	[[builtin(position)]] var<out> gl_Position: vec4<f32>;
	[[builtin(vertex_idx)]] var<in> gl_VertexIndex: i32;

	[[location(0)]] var<out> uv: vec2<f32>;

	[[stage(vertex)]]
	fn main() -> void {
		var vertexXY: vec2<f32> = vec2<f32>(vec2<i32>(gl_VertexIndex >> 1, gl_VertexIndex & 1));
		gl_Position = vec4<f32>(fma(vertexXY, _rect.destRect.zw, _rect.destRect.xy), 0.0, 1.0);
		uv = fma(vertexXY, _rect.sourceRect.zw, _rect.sourceRect.xy);
		return;
	}
`;
const filterFragmentShaderGLSL = `

	[[binding(0), set(0)]] var<uniform_constant> _sampler: sampler;
	[[binding(1), set(0)]] var<uniform_constant> _texture: texture_2d<f32>;

	[[block]] struct Color {
		[[offset(0)]] mixColor : vec4<f32>;
	};

	[[binding(1), set(1)]] var<uniform> _color: Color;

	[[location(0)]] var<in> uv: vec2<f32>;
	[[location(0)]] var<out> outColor: vec4<f32>;

	[[stage(fragment)]]
	fn main() -> void {
		var s : f32 = dpdx(uv.x);
		var t : f32 = dpdy(uv.y);

		var ns: f32 = - s;
		var nt: f32 = - t;

		var tc0 : vec2<f32> = uv + vec2<f32>(ns,   nt);
		var tc1 : vec2<f32> = uv + vec2<f32>( 0.0, nt);
		var tc2 : vec2<f32> = uv + vec2<f32>( s,   nt);
		var tc3 : vec2<f32> = uv + vec2<f32>(ns,  0.0);
		var tc4 : vec2<f32> = uv;
		var tc5 : vec2<f32> = uv + vec2<f32>( s,    0.0);
		var tc6 : vec2<f32> = uv + vec2<f32>(ns,    t);
		var tc7 : vec2<f32> = uv + vec2<f32>( 0.0,  t);
		var tc8 : vec2<f32> = uv + vec2<f32>( s,    t);

		var col0 : vec4<f32> = textureSample(_texture, _sampler, tc0);
		var col1 : vec4<f32> = textureSample(_texture, _sampler, tc1);
		var col2 : vec4<f32> = textureSample(_texture, _sampler, tc2);
		var col3 : vec4<f32> = textureSample(_texture, _sampler, tc3);
		var col4 : vec4<f32> = textureSample(_texture, _sampler, tc4);
		var col5 : vec4<f32> = textureSample(_texture, _sampler, tc5);
		var col6 : vec4<f32> = textureSample(_texture, _sampler, tc6);
		var col7 : vec4<f32> = textureSample(_texture, _sampler, tc7);
		var col8 : vec4<f32> = textureSample(_texture, _sampler, tc8);

		var sum : vec4<f32> = (
			1.0 * col0 + 2.0 * col1 + 1.0 * col2 +
			2.0 * col3 + 4.0 * col4 + 2.0 * col5 +
			1.0 * col6 + 2.0 * col7 + 1.0 * col8
		) * (1.0 / 16.0);

		outColor = sum * _color.mixColor;
		return;
	}
`;
//*/

exports.vertexCode = filterVertexShaderGLSL;
exports.fragmentCode = filterFragmentShaderGLSL;
