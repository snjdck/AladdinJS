'use strict';

const Vulkan = require('../Vulkan');
const DisplayObject2D = require('../DisplayObject2D');
const DisplayObject3D = require('../DisplayObject3D');
const drawScene = require('./drawScene');
const {tickByFrame} = require('webonly/timer');
const {showDetailFactory, average} = require('utils/stats');

const showDetail = showDetailFactory(average(
	v => document.getElementById('text_fps').textContent = `fps: ${Math.round(v)}`
));

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();
		
		tickByFrame(this.onTick.bind(this));

		const {width, height} = Vulkan.canvas;
		this.depthTexture = Vulkan.createDepthTexture(width, height);
	}

	onTick(timeElapsed){
		//console.log('---------------');
		showDetail(1000 / timeElapsed);
		//document.getElementById('text_fps').textContent = 'fps: ' + Math.round(1000 / timeElapsed);
		//Vulkan.updateManagers('onFrameBegin');
		//this.updateScene();
		//console.log('draw scene')
		this.drawScene();
		//Vulkan.mouseMgr.update();
		//scheduler.postTask(() => console.log('blocking'), {priority: 'user-blocking'});
		//Vulkan.updateManagers('onFrameEnd');
		//Vulkan.events.dispatchEvent(new Event('update'));
	}
/*
	updateScene(){
		//DisplayObject.updateWorldTransform(this.scene3d);
		//DisplayObject.updateWorldTransform(this.scene2d);
		DisplayObject.updateTree(this.scene3d);
		DisplayObject.updateTree(this.scene2d);
	}
*/
	drawScene(){
		Vulkan.commandEncoder = Vulkan.device.createCommandEncoder();
		Vulkan.mainColorTexture = Vulkan.swapChain.getCurrentTexture().createView();
		Vulkan.mainDepthStencil = this.depthTexture.createView();
		drawScene(this);
		Vulkan.device.queue.submit([Vulkan.commandEncoder.finish()]);
		//Vulkan.device.queue.onSubmittedWorkDone().then(() => console.log('submit done!'));
	}
}

module.exports = View3D;
