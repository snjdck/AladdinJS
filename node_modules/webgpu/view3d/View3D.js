'use strict';

const DisplayObject2D = require('../DisplayObject2D');
const DisplayObject3D = require('../DisplayObject3D');
const {mouseEvents} = require('../core/Events');

function forEachDo({currTarget:target, position}, handler){
	if(target == null)return;
	if(target instanceof DisplayObject2D){
		while(target){
			handler(target);
			target = target.parent;
		}
	}else{
		target.mouseDownSignal.notify(position);
		//target.visible = false;
		//setTimeout(() => target.visible=true, 1000);
	}
}

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();

		this.scene3d._scene = this;
		this.scene2d._scene = this;

		this.picking = new Picking();

		mouseEvents.mouseDownSignal.add(evt => forEachDo(this.picking, target => target.mouseDownSignal.notify(evt)));
		mouseEvents.mouseUpSignal.add(evt => forEachDo(this.picking, target => target.mouseUpSignal.notify(evt)));
		mouseEvents.mouseMoveSignal.add(evt => {
			let {currTarget, prevTarget} = this.picking;
			if(currTarget instanceof DisplayObject3D){
				currTarget = null;
			}
			if(prevTarget instanceof DisplayObject3D){
				prevTarget = null;
			}
			if(currTarget === prevTarget)return;
			let target = prevTarget;
			while(target && !target.contains(currTarget)){
				target.mouseOutSignal.notify();
				target = target.parent;
			}
			const shareParent = target;
			target = currTarget;
			while(target && target != shareParent){
				target.mouseOverSignal.notify();
				target = target.parent;
			}
		})
	}

	render(encoder){
		const {scene3d, scene2d} = this;
		const canvasSize = encoder.canvas;
		
		const pickColorTexture = encoder.fetchTempTexture(pickTextureSize, 'rgba32float,0x11');
		const pickDepthTexture = encoder.fetchTempTexture(pickTextureSize, 'depth24plus-stencil8,0x10');
		const pickColorView = encoder.fetchTextureView(pickColorTexture);
		const pickDepthStencilView = encoder.fetchTextureView(pickDepthTexture);
		const pickBuffer = encoder.fetchTempBuffer(16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);

		scene3d.camera.collectDrawUnits(scene3d);
		scene2d.camera.collectDrawUnits(scene2d);

		const colorTexture = encoder.fetchTempTexture(canvasSize, 'bgra8unorm,0x11');
		const depthTexture = encoder.fetchTempTexture(canvasSize, 'depth24plus-stencil8,0x14');
		const colorView = encoder.fetchTextureView(colorTexture);
		const depthStencilView = encoder.fetchTextureView(depthTexture);

		this.picking.reset();
		for(let commandEncoder of encoder.createCommandEncoder()){
			for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store;load+discard;load+discard', colorView, depthStencilView)){
				scene3d.camera.draw(renderPassEncoder, {colorTexture, depthTexture});
			}
			for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store', colorView)){
				scene2d.camera.draw(renderPassEncoder);
			}
			commandEncoder.copyTextureToTexture({texture:colorTexture}, {texture:commandEncoder.getCurrentTexture()}, canvasSize);
			for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store;1+discard;0+discard', pickColorView, pickDepthStencilView)){
				scene2d.camera.drawPick(renderPassEncoder, scene2d, mouseEvents.mouseX, mouseEvents.mouseY, this.picking);
				renderPassEncoder.setPipeline(null);
				scene3d.camera.drawPick(renderPassEncoder, scene3d, mouseEvents.mouseX, mouseEvents.mouseY, this.picking);
			}
			commandEncoder.copyTextureToBuffer({texture:pickColorTexture}, {buffer:pickBuffer}, pickTextureSize);
		}
		encoder.readBuffer(pickBuffer, this.onBufferRead.bind(this, this.picking.itemMap));
	}

	onBufferRead(itemMap, arrayBuffer){
		const [x, y, z, value] = new Float32Array(arrayBuffer);
		this.picking.setTarget(itemMap.get(value), x, y, z);
	}
}

const pickTextureSize = {width:1, height:1};

class Picking
{
	constructor(){
		this.prevTarget = null;
		this.currTarget = null;
		this.position = {};
	}

	reset(){
		this.itemMap = new Map();
		this.nextID = 0;
	}

	register(drawUnit){
		drawUnit.pickID = ++this.nextID;
		this.itemMap.set(drawUnit.pickID, drawUnit);
	}

	setTarget(target, x, y, z){
		this.prevTarget = this.currTarget;
		this.currTarget = target;
		this.position.x = x;
		this.position.y = y;
		this.position.z = z;
	}
}

module.exports = View3D;
