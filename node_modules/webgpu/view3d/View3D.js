'use strict';

const Vulkan = require('../Vulkan');
const DisplayObject = require('../DisplayObject');
const DisplayObject2D = require('../DisplayObject2D');
const DisplayObject3D = require('../DisplayObject3D');

const drawScene3D = require('./drawScene3D');

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();
		
		frameDo(this.onTick.bind(this));

		const {device, canvas, swapChainFormat} = Vulkan;

		const ctx = canvas.getContext('gpupresent');
		//console.log(ctx.getSwapChainPreferredFormat());
		this.swapChain = ctx.configureSwapChain({
			device,
			format: swapChainFormat,
			usage: GPUTextureUsage.RENDER_ATTACHMENT
		});

		this.depthTexture = Vulkan.createDepthTexture(canvas.width, canvas.height);

		this._drawer2Ds = [];
	}

	onTick(){
		console.log('-------');
		Vulkan.updateManagers('onFrameBegin');
		this.updateScene();
		this.drawScene();
		Vulkan.updateManagers('onFrameEnd');
		Vulkan.events.dispatchEvent(new Event('update'));
	}

	registerDrawer2D(drawer){
		this._drawer2Ds.push(drawer);
	}

	updateScene(){
		DisplayObject.updateWorldTransform(this.scene3d);
		DisplayObject.updateWorldTransform(this.scene2d);
		DisplayObject.updateTree(this.scene3d);
		DisplayObject.updateTree(this.scene2d);
	}

	drawScene(){
		Vulkan.commandEncoder = Vulkan.device.createCommandEncoder();
		Vulkan.mainColorTexture = this.swapChain.getCurrentTexture().createView();
		Vulkan.mainDepthStencil = this.depthTexture.createView();
		
		drawScene3D(this.scene3d);
		for(const drawer of this._drawer2Ds)drawer(this.scene2d);

		Vulkan.device.queue.submit([Vulkan.commandEncoder.finish()]);
		Vulkan.device.queue.onSubmittedWorkDone?.().then(() => console.log('submit done!'));
	}
}

const frameDo = fn => requestAnimationFrame(function loop(){
	requestAnimationFrame(loop);
	fn();
});

module.exports = View3D;
