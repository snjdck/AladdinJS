'use strict';

const Vulkan = require('../Vulkan');
const DisplayObject2D = require('../DisplayObject2D');
const DisplayObject3D = require('../DisplayObject3D');
const {CommandEncoder} = require('../core/CommandEncoder');
const {fetchTextures} = require('../Vulkan/resource');
const {requestSwapChain} = require('webonly/utils_gpu');

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();

		this.scene3d._scene = this;
		this.scene2d._scene = this;

		this.swapChain = requestSwapChain(Vulkan.canvas, Vulkan.device);
	}

	render(device){
		//console.time('render')
		const {scene3d, scene2d} = this;

		scene3d.camera.collectDrawUnits(scene3d);
		scene2d.camera.collectDrawUnits(scene2d);

		const {width, height} = Vulkan.canvas;

		for(let commandEncoder of CommandEncoder(device)){
			const ctx = fetchTextures(Vulkan.canvas, device);
			for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store;load+discard;load+discard', ctx.colorView, ctx.depthStencilView)){
				renderPassEncoder.setViewportWH(width, height);
				scene3d.camera.draw(renderPassEncoder, ctx);
			}
			for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store', ctx.colorView)){
				renderPassEncoder.setViewportWH(width, height);
				scene2d.camera.draw(renderPassEncoder);
			}
			commandEncoder.copyTextureToTexture(
				{texture:ctx.colorTexture},
				{texture:this.swapChain.getCurrentTexture()},
				Vulkan.canvas
			);
		}
		//console.timeEnd('render')
	}
}

module.exports = View3D;
