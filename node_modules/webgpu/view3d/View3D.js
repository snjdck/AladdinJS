'use strict';

const Vulkan = require('../Vulkan');
const DisplayObject = require('../DisplayObject');
const DisplayObject2D = require('../DisplayObject2D');
const DisplayObject3D = require('../DisplayObject3D');

const drawScene3D = require('./drawScene3D');
const drawScene2D = require('./drawScene2D');

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();
		
		frameDo(this.onTick.bind(this));

		const {device, canvas, swapChainFormat} = Vulkan;

		this.swapChain = canvas.getContext('gpupresent').configureSwapChain({
			device,
			format: swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT
		});

		this.depthTexture = device.createTexture({
			size: [canvas.width, canvas.height, 1],
			format: 'depth24plus-stencil8',
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT
		});

		this.fence = device.defaultQueue.createFence();
		this.preDrawerList = [];
	}

	onTick(){
		console.log('-------');
		Vulkan.updateManagers('onFrameBegin');
		this.updateScene();
		this.drawScene();
		Vulkan.updateManagers('onFrameEnd');
	}

	registerPreDrawer(drawer){
		this.preDrawerList.push(drawer);
	}

	updateScene(){
		DisplayObject.updateWorldTransform(this.scene3d);
		DisplayObject.updateWorldTransform(this.scene2d);
		DisplayObject.updateTree(this.scene3d);
		DisplayObject.updateTree(this.scene2d);
	}

	drawScene(){
		Vulkan.mainColorTexture = this.swapChain.getCurrentTexture().createView();
		Vulkan.mainDepthStencil = this.depthTexture.createView();

		Vulkan.commandEncoder = Vulkan.device.createCommandEncoder();
		
		drawScene3D(this.scene3d);
		for(const drawer of this.preDrawerList)drawer(this.scene2d);//move up?
		drawScene2D(this.scene2d);

		Vulkan.device.defaultQueue.submit([Vulkan.commandEncoder.finish()]);
	}
}

const frameDo = fn => requestAnimationFrame(function loop(){
	requestAnimationFrame(loop);
	fn();
});

module.exports = View3D;
