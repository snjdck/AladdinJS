'use strict';

const Vulkan = require('../Vulkan');
const DisplayObject = require('../DisplayObject');
const DisplayObject2D = require('../DisplayObject2D');
const DisplayObject3D = require('../DisplayObject3D');
const drawScene = require('./drawScene');
const {tickByFrame} = require('webonly/timer');

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();
		
		tickByFrame(this.onTick.bind(this));

		const {device, canvas, swapChainFormat} = Vulkan;

		const ctx = this.swapChain = canvas.getContext('webgpu');
		//console.log(ctx.getSwapChainPreferredFormat());
		ctx.configure({
			device,
			format: swapChainFormat,
			usage: GPUTextureUsage.RENDER_ATTACHMENT
		});

		this.depthTexture = Vulkan.createDepthTexture(canvas.width, canvas.height);
	}

	onTick(timeElapsed){
		document.getElementById('text_fps').textContent = 'fps: ' + Math.round(1000 / timeElapsed);
		Vulkan.updateManagers('onFrameBegin');
		//this.updateScene();
		this.drawScene();
		Vulkan.updateManagers('onFrameEnd');
		Vulkan.events.dispatchEvent(new Event('update'));
	}

	updateScene(){
		//DisplayObject.updateWorldTransform(this.scene3d);
		//DisplayObject.updateWorldTransform(this.scene2d);
		DisplayObject.updateTree(this.scene3d);
		DisplayObject.updateTree(this.scene2d);
	}

	drawScene(){
		Vulkan.commandEncoder = Vulkan.device.createCommandEncoder();
		Vulkan.mainColorTexture = this.swapChain.getCurrentTexture().createView();
		Vulkan.mainDepthStencil = this.depthTexture.createView();
		drawScene(this);
		Vulkan.device.queue.submit([Vulkan.commandEncoder.finish()]);
		//Vulkan.device.queue.onSubmittedWorkDone().then(() => console.log('submit done!'));
	}
}

module.exports = View3D;
