'use strict';

const DisplayObject2D = require('../DisplayObject2D');
const DisplayObject3D = require('../DisplayObject3D');
const {mouseEvents} = require('../core/Events');

function forEachDo({currTarget:target, position}, handler){
	if(target == null)return;
	if(target instanceof DisplayObject2D){
		while(target){
			handler(target);
			target = target.parent;
		}
	}else{
		target.mouseDownSignal.notify(position);
		//target.visible = false;
		//setTimeout(() => target.visible=true, 1000);
	}
}

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();

		this.scene3d._scene = this;
		this.scene2d._scene = this;

		this.picking = new Picking();
		this.taskList = [];

		mouseEvents.mouseDownSignal.add(evt => forEachDo(this.picking, target => target.mouseDownSignal.notify(evt)));
		mouseEvents.mouseUpSignal.add(evt => forEachDo(this.picking, target => target.mouseUpSignal.notify(evt)));
		mouseEvents.mouseMoveSignal.add(evt => {
			let {currTarget, prevTarget} = this.picking;
			if(currTarget instanceof DisplayObject3D){
				currTarget = null;
			}
			if(prevTarget instanceof DisplayObject3D){
				prevTarget = null;
			}
			if(currTarget === prevTarget)return;
			let target = prevTarget;
			while(target && !target.contains(currTarget)){
				target.mouseOutSignal.notify();
				target = target.parent;
			}
			const shareParent = target;
			target = currTarget;
			while(target && target != shareParent){
				target.mouseOverSignal.notify();
				target = target.parent;
			}
		})
	}

	render(encoder){
		const {scene3d, scene2d} = this;
		const canvasSize = encoder.canvas;

		scene3d.camera.collectDrawUnits(scene3d);
		scene2d.camera.collectDrawUnits(scene2d);

		const colorTexture = encoder.fetchTempTexture(canvasSize, 'bgra8unorm,0x11');
		const depthTexture = encoder.fetchTempTexture(canvasSize, 'depth24plus-stencil8,0x14');
		const colorView = encoder.fetchTextureView(colorTexture);
		const depthStencilView = encoder.fetchTextureView(depthTexture);

		for(let commandEncoder of encoder.createCommandEncoder()){
			for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store;load+discard;load+discard', colorView, depthStencilView)){
				scene3d.camera.draw(renderPassEncoder, {colorTexture, depthTexture});
			}
			for(let renderPassEncoder of commandEncoder.beginRenderPass('load+store', colorView)){
				scene2d.camera.draw(renderPassEncoder);
			}
			commandEncoder.copyTextureToTexture({texture:colorTexture}, {texture:commandEncoder.getCurrentTexture()}, canvasSize);
		}
		this.drawPick(encoder, {x:mouseEvents.mouseX, y:mouseEvents.mouseY, width:1, height:1}, this.onReadPixel);
		const {taskList} = this;
		while(taskList.length > 0){
			const task = taskList.shift();
			this.drawPick(encoder, task[0], this.onReadArea.bind(task));
		}
	}

	onReadPixel(itemMap, arrayBuffer){
		const [x, y, z, value] = new Float32Array(arrayBuffer);
		this.picking.setTarget(itemMap.get(value), x, y, z);
	}

	onReadArea(itemMap, arrayBuffer){
		const [rect, callback] = this;
		const array = new Float32Array(arrayBuffer);
		const result = new Set();
		const itemsPerRow = Math.ceil(rect.width / 16) << 4;
		for(let j=0; j<rect.height; ++j){
			for(let i=0; i<rect.width; ++i){
				const index = (itemsPerRow * j + i) << 2;
				let target = itemMap.get(array[index+3]);
				if(target)result.add(target);
			}
		}
		callback[0](result);
	}

	drawPick(encoder, rect, callback){
		const {scene3d, scene2d} = this;
		const bytesPerRow = Math.ceil(rect.width / 16) << 8;//bytesPerRow is a multiple of 256
		const size = rect.height > 1 ? bytesPerRow * rect.height : rect.width << 4;
		const colorTexture = encoder.fetchTempTexture(rect, 'rgba32float,0x11');
		const depthTexture = encoder.fetchTempTexture(rect, 'depth24plus-stencil8,0x10');
		const colorView = encoder.fetchTextureView(colorTexture);
		const depthStencilView = encoder.fetchTextureView(depthTexture);
		const buffer = encoder.fetchTempBuffer(size, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
		this.picking.reset();
		for(let commandEncoder of encoder.createCommandEncoder()){
			for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store;1+discard;0+discard', colorView, depthStencilView)){
				scene2d.camera.drawPick(renderPassEncoder, scene2d, rect, this.picking);
				renderPassEncoder.setPipeline(null);
				scene3d.camera.drawPick(renderPassEncoder, scene3d, rect, this.picking);
			}
			commandEncoder.copyTextureToBuffer({texture:colorTexture}, {buffer, bytesPerRow}, colorTexture);
		}
		encoder.readBuffer(buffer, size, callback.bind(this, this.picking.itemMap));
	}

	selectArea(rect){
		if(rect.width < 1 || rect.height < 1)return Promise.resolve(new Set());
		return new Promise((...args) => this.taskList.push([rect, args]));
	}
}

class Picking
{
	constructor(){
		this.prevTarget = null;
		this.currTarget = null;
		this.position = {};
	}

	reset(){
		this.itemMap = new Map();
		this.nextID = 0;
	}

	register(drawUnit){
		drawUnit.pickID = ++this.nextID;
		this.itemMap.set(drawUnit.pickID, drawUnit);
	}

	setTarget(target, x, y, z){
		this.prevTarget = this.currTarget;
		this.currTarget = target;
		this.position.x = x;
		this.position.y = y;
		this.position.z = z;
	}
}

module.exports = View3D;
