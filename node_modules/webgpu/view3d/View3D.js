'use strict';

const Vulkan = require('../Vulkan');
const DisplayObject2D = require('../DisplayObject2D');
const DisplayObject3D = require('../DisplayObject3D');
const {CommandEncoder, RenderPass} = require('../helper/CommandEncoder');
const {fetchTextures} = require('../Vulkan/resource');
const {requestSwapChain} = require('webonly/utils_gpu');

const renderPass3D = RenderPass({
	colorAttachments:[{loadOp:'load', storeOp:'store'}],
	depthStencilAttachment:{depthLoadOp:'load', depthStoreOp:'discard', stencilLoadOp:'load', stencilStoreOp:'discard'}
});

const renderPass2D = RenderPass({colorAttachments:[{loadOp:'load', storeOp:'store'}]});//clear is better

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();

		this.scene3d._scene = this;
		this.scene2d._scene = this;

		this.swapChain = requestSwapChain(Vulkan.canvas, Vulkan.device);
	}

	render(){
		//console.time('render')
		const {scene3d, scene2d} = this;

		scene3d.camera.collectDrawUnits(scene3d);
		scene2d.camera.collectDrawUnits(scene2d);

		const {width, height} = Vulkan.canvas;
		const ctx = fetchTextures(Vulkan.canvas);

		for(let commandEncoder of CommandEncoder(Vulkan.device)){
			for(let renderPassEncoder of renderPass3D(commandEncoder, ctx.colorView, ctx.depthView)){
				renderPassEncoder.setViewport(0, 0, width, height, 0, 1);
				scene3d.camera.draw(renderPassEncoder, ctx);
			}
			for(let renderPassEncoder of renderPass2D(commandEncoder, ctx.colorView)){
				renderPassEncoder.setViewport(0, 0, width, height, 0, 1);
				scene2d.camera.draw(renderPassEncoder);
			}
			commandEncoder.copyTextureToTexture(
				{texture:ctx.colorTexture},
				{texture:this.swapChain.getCurrentTexture()},
				Vulkan.canvas
			);
		}
		//console.timeEnd('render')
	}
}

module.exports = View3D;
