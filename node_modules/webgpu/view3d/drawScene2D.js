'use strict';

const Vulkan = require('../Vulkan');
const Material2D = require('../materials/Material2D');
const BufferBindGroup = require('../helper/BufferBindGroup');
const traverseTree = require('utils/traverseTree');

Vulkan.mvpBindGroup2D = new BufferBindGroup([[GPUBufferUsage.UNIFORM, 2 * 4, true]], buffer => {
	new Float32Array(buffer.getMappedRange()).set([2 / Vulkan.canvas.width, -2 / Vulkan.canvas.height]);
	buffer.unmap();
	return [['0', {buffer}, Vulkan.getSampler('linear_clamp')]];
});

const drawUnitBucket = [];

function addToBucket(item){
	drawUnitBucket.push(item);
}

function addToBucketWithCheck(item){
	if(item.type == 'bitmap' || item.type == 'bitmap3d'){
		addToBucket(item);
	}else if(item.type == 'label2d'){
		if(!item._text)return;
		const {worldTransform, fontSize} = item;
		for(let bitmap of Vulkan.textMgr.getTextBitmap(worldTransform, item._text, fontSize)){
			addToBucket(bitmap);
		}
	}
}

function onCollect(item){
	if(!item.visible)return true;
	const {filter} = item;
	if(filter){
		addToBucket(filter);
		return true;
	}
	addToBucketWithCheck(item);
}

function drawScene2D(root, forceDrawFlag=false, setPipelineMvpFlag=true){
	if(setPipelineMvpFlag){
		Vulkan.renderPassEncoder.setBindGroup(0, Vulkan.mvpBindGroup2D.getBindGroup());
	}
	if(forceDrawFlag)addToBucketWithCheck(root);
	traverseTree(root, onCollect, !forceDrawFlag);
	Material2D.draw(drawUnitBucket, null, setPipelineMvpFlag);
	drawUnitBucket.length = 0;
}

module.exports = drawScene2D;
