'use strict';

const Vulkan = require('../Vulkan');
const traverseTree = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const {FrameBuffer, FrameBufferList} = require('../helper/FrameBuffer');
const DrawUnitBucket = require('../DrawUnitBucket');
const compose = require('utils/function/compose');

const calcDrawRectListFactory = function(){
	const rectPack = new MaxRectsBinPack(8192, 8192);
	function onInsert(element){
		return rectPack.insert(...this(element));
	}
	return calcSizeFn => elementList => {
		const drawRectList = elementList.map(onInsert, calcSizeFn);
		rectPack.clear();
		return drawRectList;
	}
}();

function Filter2DCollector(){
	const drawUnitBucket = new DrawUnitBucket(false);
	const list = [];

	const onCollect = (level => (onLeave => item => {
		if(!item.visible)return true;
		if(!item.filter)return;
		if(list[level]){
			list[level].push(item);
		}else{
			list[level] = [item];
		}
		++level;
		return onLeave;
	})(() => --level))(0);

	const frameBufferList = new FrameBufferList(false);
	const calcDrawRectList = calcDrawRectListFactory(() => [Vulkan.canvas.width, Vulkan.canvas.height]);

	function *renderFn(){
		yield Vulkan.viewportMgr.draw();
		Vulkan.renderPassEncoder.setBindGroup(0, Vulkan.createBindGroup('filter2D', Vulkan.getSampler('linear_clamp'), frameBufferList.getFrameBuffer(0).colorView));
		yield drawUnitBucket.draw().clear();
	}

	return function(root){
		traverseTree(root, onCollect);
		for(const group of list.reverse()){
			if(group.length <= 0)continue;
			
			const drawRectList = calcDrawRectList(group);
			const frameRect = Rect.Merge(drawRectList);

			frameBufferList.resize(frameRect);
			
			for(let i=0, n=group.length; i<n; ++i){
				const item = group[i];
				const texture = item.filter.texture;
				const drawRect = drawRectList[i];
				Vulkan.viewportMgr.addViewPort(frameRect, drawRect, item.worldTransform);
				Vulkan.viewportMgr.collectDrawUnits(item, true);
				drawUnitBucket.add({frameRect, drawRect, material: item.filter});
				texture.rawTexture = frameBufferList.getFrameBuffer(1).colorView;
				texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			}

			frameBufferList.render(renderFn());

			group.length = 0;
		}
	}
}

function Bitmap3DCollector(){
	const collectBitmap3DList = function(){
		const elementList = [];
		function onCollect(item){
			if(!item.visible)return true;
			if(item.type === 'bitmap3d'){
				elementList.push(item);
			}
		}
		return root => {
			traverseTree(root, onCollect);
			return elementList;
		}
	}();

	const calcDrawRectList = calcDrawRectListFactory(({width, height}) => [width, height]);

	const frameBuffer = new FrameBuffer(true);
	return function(root){
		const elementList = collectBitmap3DList(root);
		if(elementList.length <= 0)return;
		const drawRectList = calcDrawRectList(elementList);
		const frameRect = Rect.Merge(drawRectList);
		frameBuffer.resize(frameRect);
		for(let i=0, n=elementList.length; i<n; ++i){
			const bitmap3D = elementList[i];
			const drawRect = drawRectList[i];
			bitmap3D.texture.rawTexture = frameBuffer.colorView;
			bitmap3D.texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			bitmap3D.camera.setViewport(frameRect, drawRect);
			Vulkan.cameraMgr.collectDrawUnits(bitmap3D.camera, bitmap3D.root3d);
		}
		frameBuffer.render(Vulkan.cameraMgr.draw, Vulkan.cameraMgr);
		elementList.length = 0;
	}
}

function normalDraw(){
	const frameBuffer = new FrameBuffer(false, 'load');
	function renderFn(){
		Vulkan.viewportMgr.addViewPort(Vulkan.canvas);
		Vulkan.viewportMgr.collectDrawUnits(this);
		Vulkan.viewportMgr.draw();
	}
	return function(root){
		frameBuffer.setColorAttachment(Vulkan.mainColorTexture);
		frameBuffer.render(renderFn, root);
	}
}

const drawScene2D = (drawFnList => root => drawFnList.forEach(drawFn => drawFn(root)))([
	Bitmap3DCollector(),
	Filter2DCollector(),
	normalDraw(),
]);

//compose(Bitmap3DCollector, Filter2DCollector, normalDraw);

module.exports = drawScene2D;
