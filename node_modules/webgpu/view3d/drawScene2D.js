'use strict';

const Vulkan = require('../Vulkan');
const traverseTree = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const {FrameBuffer, FrameBufferList} = require('../helper/FrameBuffer');
const DrawUnitBucket = require('../DrawUnitBucket');

const calcDrawRectListFactory = function(){
	const rectPack = new MaxRectsBinPack(8192, 8192);
	function onInsert(element){
		return rectPack.insert(...this(element));
	}
	return calcSizeFn => elementList => {
		const drawRectList = elementList.map(onInsert, calcSizeFn);
		rectPack.clear();
		return drawRectList;
	}
}();

function collectElementListFactory(onCollect){
	const elementList = [];
	return function(root){
		traverseTree.call(elementList, root, onCollect);
		return elementList;
	}
}

function ElementCollectorFactory(frameBuffer, calcSizeFn, onCollect, handler, renderFn, wrapFn){
	const calcDrawRectList = calcDrawRectListFactory(calcSizeFn);
	const collectElementList = collectElementListFactory(onCollect);
	function drawFn(elementList){
		if(elementList.length <= 0)return;
		const drawRectList = calcDrawRectList(elementList);
		const frameRect = Rect.Merge(drawRectList);
		frameBuffer.resize(frameRect);
		for(let i=0, n=elementList.length; i<n; ++i){
			handler(elementList[i], drawRectList[i], frameBuffer, frameRect);
		}
		elementList.length = 0;
		frameBuffer.render(renderFn.call(frameBuffer));
	}
	return root => wrapFn(collectElementList(root), drawFn);
}

const drawBitmap3D = ElementCollectorFactory(
	new FrameBuffer(true),
	({width, height}) => [width, height],
	function(item){
		if(!item.visible)return true;
		if(item.type != 'bitmap3d')return;
		this.push(item);
	},
	(bitmap3D, drawRect, frameBuffer, frameRect) => {
		bitmap3D.texture.rawTexture = frameBuffer.colorView;
		bitmap3D.texture.setUV(frameRect.width, frameRect.height, drawRect, false);
		bitmap3D.camera.setViewport(frameRect, drawRect);
		Vulkan.cameraMgr.collectDrawUnits(bitmap3D.camera, bitmap3D.root3d);
	},
	(v => () => v)(() => Vulkan.cameraMgr.draw()),
	(elementList, drawFn) => drawFn(elementList)
);

const drawFilter2D = (drawUnitBucket => ElementCollectorFactory(
	new FrameBufferList(false),
	() => [Vulkan.canvas.width, Vulkan.canvas.height],
	function(level){
		const onLeave = () => --level;
		return function(item){
			if(!item.visible)return true;
			if(!item.filter)return;
			if(this[level]){
				this[level].push(item);
			}else{
				this[level] = [item];
			}
			++level;
			return onLeave;
		};
	}(0),
	(item, drawRect, frameBufferList, frameRect) => {
		const texture = item.filter.texture;
		Vulkan.viewportMgr.addViewPort(frameRect, drawRect, item.worldTransform);
		Vulkan.viewportMgr.collectDrawUnits(item, true);
		drawUnitBucket.add({frameRect, drawRect, material: item.filter});
		texture.rawTexture = frameBufferList.getFrameBuffer(1).colorView;
		texture.setUV(frameRect.width, frameRect.height, drawRect, false);
	},
	function*(){
		yield Vulkan.viewportMgr.draw();
		Vulkan.renderPassEncoder.setBindGroup(0, Vulkan.createBindGroup('filter2D', Vulkan.getSampler('linear_clamp'), this.getFrameBuffer(0).colorView));
		yield drawUnitBucket.draw().clear();
	},
	(elementList, drawFn) => elementList.reverse().forEach(drawFn)
))(new DrawUnitBucket(false));

const drawScene2D = function(){
	const frameBuffer = new FrameBuffer(false, 'load');
	function renderFn(){
		Vulkan.viewportMgr.addViewPort(Vulkan.canvas);
		Vulkan.viewportMgr.collectDrawUnits(this);
		Vulkan.viewportMgr.draw();
	}
	return function(root){
		frameBuffer.setColorAttachment(Vulkan.mainColorTexture);
		frameBuffer.render(renderFn, root);
	}
}();

module.exports = function(root){
	drawBitmap3D(root);
	drawFilter2D(root);
	drawScene2D(root);
}
