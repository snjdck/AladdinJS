'use strict';

const Vulkan = require('../Vulkan');
const {collectTree} = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const Matrix2D = require('opengl/math/Matrix2D');
const {FrameBuffer, FrameBufferList} = require('../helper/FrameBuffer');
const DrawUnitBucket = require('../DrawUnitBucket');

const calcDrawRectList = function(){
	const rectPack = new MaxRectsBinPack(8192, 8192);
	const onInsert = areaRect => areaRect && rectPack.insert(areaRect.width, areaRect.height);
	return areaRectList => {
		const drawRectList = areaRectList.map(onInsert);
		rectPack.clear();
		return drawRectList;
	}
}();

function ElementCollectorFactory(frameBuffer, calcSizeFn, onCollect, handler, renderFn, wrapFn){
	const collectElementList = collectTree(onCollect);
	function drawFn(elementList){
		if(elementList.length <= 0)return;
		const areaRectList = elementList.map(calcSizeFn);
		const drawRectList = calcDrawRectList(areaRectList);
		const frameRect = Rect.Merge(drawRectList.filter(Boolean));
		if(!frameRect)return;
		frameBuffer.resize(frameRect);
		for(let i=0, n=elementList.length; i<n; ++i){
			handler(elementList[i], drawRectList[i], frameBuffer, frameRect, areaRectList[i]);
		}
		elementList.length = 0;
		frameBuffer.render(renderFn.call(frameBuffer));
	}
	return root => wrapFn(collectElementList(root), drawFn);
}

const drawBitmap3D = ElementCollectorFactory(
	new FrameBuffer({}), ({width, height}) => new Rect(width, height),
	function(item){
		if(!item.visible)return true;
		if(item.type != 'bitmap3d')return;
		this.push(item);
	},
	(bitmap3D, drawRect, frameBuffer, frameRect) => {
		bitmap3D.texture.rawTexture = frameBuffer.colorView;
		bitmap3D.texture.setUV(frameRect.width, frameRect.height, drawRect, false);
		bitmap3D.camera.setViewport(frameRect, drawRect);
		Vulkan.cameraMgr.collectDrawUnits(bitmap3D.camera, bitmap3D.root3d);
	},
	(v => () => v)(() => Vulkan.cameraMgr.draw()),
	(elementList, drawFn) => drawFn(elementList)
);

const drawFilter2D = ((drawUnitBucket, matrixInv, copyList) => ElementCollectorFactory(
	new FrameBufferList(), item => item.getBoundingRect(),
	function(level){
		const onLeave = () => --level;
		return function(item){
			if(!item.visible)return true;
			if(!item.filter)return;
			if(this[level]){
				this[level].push(item);
			}else{
				this[level] = [item];
			}
			++level;
			return onLeave;
		};
	}(0),
	(item, drawRect, frameBufferList, frameRect, areaRect) => {
		const {texture} = item.filter;
		if(!areaRect)return texture.rawTexture = null;
		item.worldTransform.invert(matrixInv);
		matrixInv.translate(-areaRect.x, -areaRect.y);
		Vulkan.viewportMgr.addViewPort(frameRect, drawRect, matrixInv);
		Vulkan.viewportMgr.collectDrawUnits(item, true);
		texture.rawTexture = frameBufferList.getFrameBuffer(1).colorView;
		if(item.filter.justCopyFlag){
			const clipRect = Object.assign(new Rect(), item.filter.clipRect).intersect(areaRect);
			if(!clipRect)return;
			copyList.push([
				drawRect.x + clipRect.x - areaRect.x,
				drawRect.y + clipRect.y - areaRect.y,
				drawRect.x,
				drawRect.y,
				clipRect.width,
				clipRect.height,
			]);
			texture.setUV(frameRect.width, frameRect.height, {
				x: drawRect.x,
				y: drawRect.y,
				width: clipRect.width,
				height: clipRect.height,
			}, false);
			const {adjustX, adjustY} = item.filter;
			texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
			texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
		}else{
			drawUnitBucket.add({frameRect, drawRect, material: item.filter});
			texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			texture.xyuvAdd[0] = areaRect.x;
			texture.xyuvAdd[1] = areaRect.y;
		}
	},
	function*(){
		yield Vulkan.viewportMgr.draw();
		Vulkan.renderPassEncoder.setBindGroup(0, Vulkan.createBindGroup('filter2D', Vulkan.getSampler('linear_clamp'), this.getFrameBuffer(0).colorView));
		yield drawUnitBucket.draw().clear();
		while(copyList.length > 0){
			const [sx, sy, dx, dy, w, h] = copyList.pop();
			Vulkan.commandEncoder.copyTextureToTexture(
				{texture: this.getFrameBuffer(0).colorBuffer, origin: [sx, sy, 0]},
				{texture: this.getFrameBuffer(1).colorBuffer, origin: [dx, dy, 0]},
				[w, h, 1]
			);
		}
	},
	(elementList, drawFn) => elementList.reverse().forEach(drawFn)
))(new DrawUnitBucket(false), new Matrix2D(), []);

const drawSceneFactory = (frameBuffer, renderFn) => root => {
	frameBuffer.setColorAttachment(Vulkan.mainColorTexture);
	frameBuffer.setDepthStencilAttachment(Vulkan.mainDepthStencil);
	frameBuffer.render(renderFn, root);
};

const drawScene = drawSceneFactory(new FrameBuffer({}, [0,0,0,1]), function(){
	const {scene3d, scene2d} = this;
	const {cameraMgr, viewportMgr} = Vulkan;
	cameraMgr.collectDrawUnits(scene3d.camera, scene3d);
	cameraMgr.draw();
	viewportMgr.addViewPort(Vulkan.canvas);
	viewportMgr.collectDrawUnits(scene2d);
	viewportMgr.draw(0, true);
});

module.exports = function(view3d){
	const {scene3d, scene2d} = view3d;
	drawBitmap3D(scene2d);
	drawFilter2D(scene2d);
	drawScene(view3d);
};
