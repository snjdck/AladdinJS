'use strict';

const Vulkan = require('../Vulkan');
const Camera3D = require('../cameras/Camera3D');
const LevelStack = require('../../ds/LevelStack');
const {deferDo, deferBunchDo} = require('../../utils/function/deferDo');
const {walkTree} = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const Matrix2D = require('../math/Matrix2D');
const {FrameBuffer, FrameBufferBase, FrameBufferList} = require('../helper/FrameBuffer');
const renderDrawUnits = require('../helper/renderDrawUnits');

const calcDrawRectList = function(){
	const rectPack = new MaxRectsBinPack(8192, 8192);
	const onInsert = areaRect => areaRect && rectPack.insert(areaRect.width, areaRect.height);
	return areaRectList => {
		const drawRectList = areaRectList.map(onInsert);
		rectPack.clear();
		return drawRectList;
	}
}();

const ElementCollectorFactory = (frameBuffer, calcSizeFn, handler) => elementList => {
	if(elementList.length <= 0)return;
	const areaRectList = elementList.map(calcSizeFn);
	const drawRectList = calcDrawRectList(areaRectList);
	const frameRect = Rect.Merge(drawRectList.filter(Boolean));
	if(!frameRect)return;
	frameBuffer.resize(frameRect);
	for(let i=0, n=elementList.length; i<n; ++i){
		handler(elementList[i], drawRectList[i], frameBuffer, frameRect, areaRectList[i]);
	}
	return frameBuffer;
}

const drawBitmap3D = function(){
	const elementList = [];
	const collectFn = walkTree(function(item){
		if(!item.visible)return true;
		if(item.type != 'bitmap3d')return;
		elementList.push(item);
	});
	const drawFn = ElementCollectorFactory(
		new FrameBuffer({}),
		({width, height}) => new Rect(width, height),
		(bitmap3D, drawRect, frameBuffer, frameRect) => {
			bitmap3D.texture.rawTexture = frameBuffer.colorView;
			bitmap3D.texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			bitmap3D.camera.setViewport(frameRect, drawRect);
			Camera3D.collectDrawUnits(bitmap3D.camera, bitmap3D.root3d);
		}
	);
	return root => {
		collectFn(root);
		drawFn(elementList)?.render(Camera3D.draw);
		elementList.length = 0;
	};
}();

const drawFilter2D = function(){
	const levelStack = new LevelStack();
	const collectFn = walkTree(function(item){
		if(!item.visible)return true;
		if(!item.filter)return;
		levelStack.push(item);
		levelStack.next();
	}, function(item){
		if(!item.filter)return;
		levelStack.prev();
	});
	const calcViewPortMatrix = function(){
		const matrixInv = new Matrix2D();
		return function(item, areaRect){
			matrixInv.copyFrom(item.worldTransformInvert);
			matrixInv.translate(-areaRect.x, -areaRect.y);
			return matrixInv;
		};
	}();
	const [addDrawTask, runDrawTask] = deferBunchDo(function(drawUnits, frameBuffer){
		Vulkan.renderPassEncoder.setBindGroup(0, Vulkan.createBindGroup('filter2D', Vulkan.getSampler('linear_clamp'), frameBuffer.getColorView(0)));
		renderDrawUnits(drawUnits);
	});
	const [addCopyTask, runCopyTask] = deferDo();
	const drawFn = ElementCollectorFactory(
		new FrameBufferList(),
		item => item.getBoundingRect(),
		(item, drawRect, frameBufferList, frameRect, areaRect) => {
			const {texture} = item.filter;
			if(!areaRect)return texture.rawTexture = null;
			Vulkan.viewportMgr.addViewPort(frameRect, drawRect, calcViewPortMatrix(item, areaRect));
			Vulkan.viewportMgr.collectDrawUnits(item, true);
			texture.rawTexture = frameBufferList.getColorView(1);
			if(item.filter.justCopyFlag){
				const clipRect = Object.assign(new Rect(), item.filter.clipRect).intersect(areaRect);
				if(!clipRect)return;
				const sx = drawRect.x + clipRect.x - areaRect.x;
				const sy = drawRect.y + clipRect.y - areaRect.y;
				const {x: dx, y: dy} = drawRect;
				const {width, height} = clipRect;
				addCopyTask(() => Vulkan.commandEncoder.copyTextureToTexture(
					{texture: frameBufferList.colorBuffer, origin: [sx, sy, 0]},
					{texture: frameBufferList.colorBuffer, origin: [dx, dy, 1]},
					[width, height, 1]
				));
				texture.setUV(frameRect.width, frameRect.height, {x: dx, y: dy, width, height}, false);
				const {adjustX, adjustY} = item.filter;
				texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
				texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
			}else{
				addDrawTask({frameRect, drawRect, material: item.filter});
				texture.setUV(frameRect.width, frameRect.height, drawRect, false);
				texture.xyuvAdd[0] = areaRect.x;
				texture.xyuvAdd[1] = areaRect.y;
			}
		}
	);
	function onDraw(index){
		if(index == 0)return Vulkan.viewportMgr.draw();
		runDrawTask(this);
	}
	return root => {
		collectFn(root);
		for(const elementList of levelStack){
			drawFn(elementList)?.render(onDraw);
			runCopyTask();
		}
		levelStack.clear();
	};
}();

const drawSceneFactory = (frameBuffer, renderFn) => root => {
	frameBuffer.setColorAttachment(Vulkan.mainColorTexture);
	frameBuffer.setDepthStencilAttachment(Vulkan.mainDepthStencil);
	frameBuffer.render(renderFn, root);
};

const drawScene = drawSceneFactory(new FrameBufferBase({}, {clearValue:[0,0,0,1]}), function(){
	const {scene3d, scene2d} = this;
	const {viewportMgr} = Vulkan;
	Camera3D.collectDrawUnits(scene3d.camera, scene3d);
	Camera3D.draw();
	viewportMgr.addViewPort(Vulkan.canvas);
	viewportMgr.collectDrawUnits(scene2d);
	viewportMgr.draw(0, true);
});

module.exports = function(view3d){
	const {scene3d, scene2d} = view3d;
	drawBitmap3D(scene2d);
	drawFilter2D(scene2d);
	drawScene(view3d);
};
