'use strict';

const Vulkan = require('../Vulkan');
const traverseTree = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const {FrameBufferList} = require('../helper/FrameBuffer');
const DrawUnitBucket = require('../DrawUnitBucket');

const drawUnitBucket = new DrawUnitBucket(false);

function Filter2DCollector(){
	const list = [];

	const onCollect = (level => (onLeave => item => {
		if(!item.visible)return true;
		if(!item.filter)return;
		if(list[level]){
			list[level].push(item);
		}else{
			list[level] = [item];
		}
		++level;
		return onLeave;
	})(() => --level))(0);

	const onInsert = () => rectPack.insert(Vulkan.canvas.width, Vulkan.canvas.height);
	const frameBufferList = new FrameBufferList(false);
	const rectPack = new MaxRectsBinPack(8192, 8192);

	function *renderFn(){
		yield Vulkan.viewportMgr.draw();
		Vulkan.renderPassEncoder.setBindGroup(0, Vulkan.createBindGroup('filter2D', Vulkan.getSampler('linear_clamp'), frameBufferList.getFrameBuffer(0).colorView));
		yield drawUnitBucket.draw().clear();
	}

	return function(root){
		traverseTree(root, onCollect);
		for(const group of list.reverse()){
			if(group.length == 0)continue;
			
			const drawRectList = group.map(onInsert);
			const frameRect = Rect.Merge(drawRectList);

			frameBufferList.resize(frameRect);
			
			for(let i=0, n=group.length; i<n; ++i){
				const item = group[i];
				const texture = item.filter.texture;
				const drawRect = drawRectList[i];
				Vulkan.viewportMgr.addViewPort(frameRect, drawRect, item.worldTransform);
				Vulkan.viewportMgr.collectDrawUnits(item, true);
				drawUnitBucket.add({frameRect, drawRect, material: item.filter});
				texture.rawTexture = frameBufferList.getFrameBuffer(1).colorView;
				texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			}

			frameBufferList.render(renderFn());

			rectPack.clear();
			group.length = 0;
		}
	}
}

module.exports = Filter2DCollector;
