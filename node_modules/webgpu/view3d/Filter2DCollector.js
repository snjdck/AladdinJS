'use strict';

const Vulkan = require('../Vulkan');
const traverseTree = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const FrameBuffer = require('../helper/FrameBuffer');
const drawScene2D = require('./drawScene2D');

function Filter2DCollector(){
	const list = [];

	const onCollect = (level => (onLeave => item => {
		if(!item.visible)return true;
		if(!item.filter)return;
		if(list[level]){
			list[level].push(item);
		}else{
			list[level] = [item];
		}
		++level;
		return onLeave;
	})(() => --level))(0);

	const onInsert = () => rectPack.insert(Vulkan.canvas.width, Vulkan.canvas.height);
	const frameBufferA = new FrameBuffer(false);
	const frameBufferB = new FrameBuffer(false);
	const rectPack = new MaxRectsBinPack(8192, 8192);

	return function(root){
		traverseTree(root, onCollect);
		for(const group of list.reverse()){
			if(group.length == 0)continue;
			
			const drawRectList = group.map(onInsert);
			const frameRect = Rect.Merge(drawRectList);
			frameBufferA.beginRenderPass(frameRect);

			for(let i=0, n=group.length; i<n; ++i){
				const filterItem = group[i];
				const rect = drawRectList[i];
				Vulkan.renderPassEncoder.setViewport(rect.x, rect.y, rect.width, rect.height, 0, 1);
				drawScene2D(filterItem, true, i == 0);
			}
			
			Vulkan.renderPassEncoder.endPass();
			frameBufferB.beginRenderPass(frameRect);

			Vulkan.renderPassEncoder.setBindGroup(0, Vulkan.createBindGroup('filter2D', Vulkan.getSampler('linear_clamp'), frameBufferA.colorView));
			for(let i=0, n=group.length; i<n; ++i){
				const {filter} = group[i];
				const drawRect = drawRectList[i];
				filter.onDraw(frameRect, drawRect);
				filter.width = drawRect.width;
				filter.height = drawRect.height;
				filter.texture.rawTexture = frameBufferB.colorView;
				filter.texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			}

			Vulkan.renderPassEncoder.endPass();

			rectPack.clear();
			group.length = 0;
		}
	}
}

module.exports = Filter2DCollector;
