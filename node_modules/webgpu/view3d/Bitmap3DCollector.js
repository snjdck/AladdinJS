'use strict';

const Vulkan = require('../Vulkan');
const traverseTree = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const {FrameBuffer} = require('../helper/FrameBuffer');

const collectBitmap3DList = function(){
	const elementList = [];
	function onCollect(item){
		if(!item.visible)return true;
		if(item.type === 'bitmap3d'){
			elementList.push(item);
		}
	}
	return root => {
		traverseTree(root, onCollect);
		return elementList;
	}
}();

const calcDrawRectList = function(){
	const rectPack = new MaxRectsBinPack(8192, 8192);
	const onInsert = ({width, height}) => rectPack.insert(width, height);
	return elementList => {
		const drawRectList = elementList.map(onInsert);
		rectPack.clear();
		return drawRectList;
	}
}();

function Bitmap3DCollector(){
	const frameBuffer = new FrameBuffer(true);
	return function(root){
		const elementList = collectBitmap3DList(root);
		if(elementList.length <= 0)return;
		const drawRectList = calcDrawRectList(elementList);
		const frameRect = Rect.Merge(drawRectList);
		frameBuffer.resize(frameRect);
		for(let i=0, n=elementList.length; i<n; ++i){
			const bitmap3D = elementList[i];
			const drawRect = drawRectList[i];
			bitmap3D.texture.rawTexture = frameBuffer.colorView;
			bitmap3D.texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			bitmap3D.camera.setViewport(frameRect, drawRect);
			Vulkan.cameraMgr.collectDrawUnits(bitmap3D.camera, bitmap3D.root3d);
		}
		frameBuffer.beginRenderPass();
		Vulkan.cameraMgr.draw();
		Vulkan.renderPassEncoder.endPass();
		elementList.length = 0;
	}
}

module.exports = Bitmap3DCollector;
