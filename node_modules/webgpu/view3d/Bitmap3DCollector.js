'use strict';

const Vulkan = require('../Vulkan');
const traverseTree = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');

const MAX_W = 4096;
const MAX_H = 4096;

function Bitmap3DCollector(){
	const frameBuffer = Vulkan.device.createTexture({
		size: [MAX_W, MAX_H, 1],
		format: Vulkan.swapChainFormat,
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
	});
	const depthBuffer = Vulkan.createDepthTexture(MAX_W, MAX_H);
	const frameView = frameBuffer.createView();
	const depthView = depthBuffer.createView();
	const renderPassDesc = {
		colorAttachments: [{
			attachment: frameView,
			loadValue: [0,0,0,0]
		}],
		depthStencilAttachment: {
			attachment: depthView,
			depthLoadValue: 1.0,
			depthStoreOp: 'store',
			stencilLoadValue: 0,
			stencilStoreOp: 'store'
		}
	};
	const rectPack = new MaxRectsBinPack(MAX_W, MAX_H);
	const elementList = [];
	function onCollect(item){
		if(!item.visible)return true;
		if(item.type === 'bitmap3d'){
			elementList.push(item);
		}
	}
	return function(root){
		traverseTree(root, onCollect);
		if(elementList.length <= 0)return;
		const renderPassEncoder = Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass(renderPassDesc);
		for(const bitmap3D of elementList){
			const {width, height, texture} = bitmap3D;
			const drawRect = rectPack.insert(width, height);
			texture.rawTexture = frameView;
			texture.setUV(MAX_W, MAX_H, drawRect, false);
			
			renderPassEncoder.setViewport(drawRect.x, drawRect.y, drawRect.width, drawRect.height, 0, 1);
			//*
			bitmap3D.camera._gpuAsset = Vulkan.camera3DGPUResourceMgr.getOut();
			bitmap3D.camera.draw(bitmap3D.root3d);
			//*/
		}
		renderPassEncoder.endPass();
		rectPack.clear();
		elementList.length = 0;
	}
}

module.exports = Bitmap3DCollector;
