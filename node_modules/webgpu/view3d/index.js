'use strict';

const Vulkan = require('../Vulkan');
const Camera3D = require('../cameras/Camera3D');
const LevelStack = require('../../ds/LevelStack');
const {deferDo, deferBunchDo} = require('../../utils/function/deferDo');
const {walkTree} = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const Matrix2D = require('../math/Matrix2D');
const renderDrawUnits = require('../helper/renderDrawUnits');
const {createTexture, createDepthTexture} = require('webonly/utils_gpu');
const RenderPass = require('../helper/RenderPass');
const {delayNew} = require('utils/cache');

const defaultTextureSize = 1024;

const colorTexture3D = delayNew(() => {
	let texture = createTexture(Vulkan.device, defaultTextureSize, defaultTextureSize, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT);
	return {texture, view:texture.createView()};
});
const depthTexture = delayNew(() => {
	let texture = createDepthTexture(Vulkan.device, defaultTextureSize, defaultTextureSize);
	return {texture, view:texture.createView()};
});
const colorTexture2D = delayNew(() => {
	let texture = createTexture(Vulkan.device, defaultTextureSize, defaultTextureSize, 2, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST);
	return {
		texture,
		view0:texture.createView({dimension:'2d', baseArrayLayer:0, arrayLayerCount:1}),
		view1:texture.createView({dimension:'2d', baseArrayLayer:1, arrayLayerCount:1})
	};
});
const renderPass3D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}],
	depthStencilAttachment:{
		depthLoadOp:'clear',//load
		depthClearValue:1,//[0,1],when depthLoadOp is clear
		depthStoreOp:'discard',//store
		depthReadOnly:false,
		stencilLoadOp:'clear',//load
		stencilClearValue:0,
		stencilStoreOp:'discard',//store
		stencilReadOnly:false,
		view:null
	}
});
const renderPass2D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}]
});

const calcDrawRectList = function(){
	const rectPack = new MaxRectsBinPack(8192, 8192);
	const onInsert = areaRect => areaRect && rectPack.insert(areaRect.width, areaRect.height);
	return areaRectList => {
		const drawRectList = areaRectList.map(onInsert);
		rectPack.clear();
		return drawRectList;
	}
}();

const ElementCollectorFactory = (calcSizeFn, handler) => elementList => {
	if(elementList.length <= 0)return;
	const areaRectList = elementList.map(calcSizeFn);
	const drawRectList = calcDrawRectList(areaRectList);
	const frameRect = Rect.Merge(drawRectList.filter(Boolean));
	if(!frameRect)return;
	frameRect.width = defaultTextureSize;
	frameRect.height = defaultTextureSize;
	for(let i=0, n=elementList.length; i<n; ++i){
		handler(elementList[i], drawRectList[i], frameRect, areaRectList[i]);
	}
}

const drawBitmap3D = function(){
	const elementList = [];
	const collectFn = walkTree(function(item){
		if(!item.visible)return true;
		if(item.type != 'bitmap3d')return;
		elementList.push(item);
	});
	const drawFn = ElementCollectorFactory(
		({width, height}) => new Rect(width, height),
		(bitmap3D, drawRect, frameRect) => {
			bitmap3D.texture.rawTexture = colorTexture3D().view;
			bitmap3D.texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			bitmap3D.camera.setViewport(frameRect, drawRect);
			bitmap3D.camera.collectDrawUnits(bitmap3D.root3d, bitmap3D.scene.nextCameraIndex++);
		}
	);
	return root => {
		collectFn(root);
		drawFn(elementList);
		renderPass3D(() => Camera3D.draw(), colorTexture3D().view, depthTexture().view);
		elementList.length = 0;
	};
}();

const drawFilter2D = function(){
	const levelStack = new LevelStack();
	const collectFn = walkTree(function(item){
		if(!item.visible)return true;
		if(!item.filter)return;
		levelStack.push(item);
		levelStack.next();
	}, function(item){
		if(!item.filter)return;
		levelStack.prev();
	});
	const calcViewPortMatrix = function(){
		const matrixInv = new Matrix2D();
		return function(item, areaRect){
			matrixInv.copyFrom(item.worldTransformInvert);
			matrixInv.translate(-areaRect.x, -areaRect.y);
			return matrixInv;
		};
	}();
	const [addDrawTask, runDrawTask] = deferBunchDo(function(drawUnits){
		let bindGroup = drawUnits[0].material.constructor.createBindGroupWith(colorTexture2D().view0)
		Vulkan.renderPassEncoder.setBindGroup(0, bindGroup);
		renderDrawUnits(drawUnits);
	});
	const [addCopyTask, runCopyTask] = deferBunchDo(taskList => {
		for(let {sx, sy, dx, dy, width, height} of taskList){
			Vulkan.commandEncoder.copyTextureToTexture(
				{texture: colorTexture2D().texture, origin: [sx, sy, 0]},
				{texture: colorTexture2D().texture, origin: [dx, dy, 1]},
				[width, height, 1]
			);
		}
	});
	const drawFn = ElementCollectorFactory(
		item => item.getBoundingRect(),
		(item, drawRect, frameRect, areaRect) => {
			const {texture} = item.filter;
			if(!areaRect)return texture.rawTexture = null;
			Vulkan.viewportMgr.addViewPort(item.scene.nextViewportIndex++, frameRect, drawRect, calcViewPortMatrix(item, areaRect));
			Vulkan.viewportMgr.collectDrawUnits(item, true);
			texture.rawTexture = colorTexture2D().view1;
			if(item.filter.justCopyFlag){
				const clipRect = Object.assign(new Rect(), item.filter.clipRect).intersect(areaRect);
				if(!clipRect)return;
				const sx = drawRect.x + clipRect.x - areaRect.x;
				const sy = drawRect.y + clipRect.y - areaRect.y;
				const {x: dx, y: dy} = drawRect;
				const {width, height} = clipRect;
				addCopyTask({sx, sy, dx, dy, width, height});
				texture.setUV(frameRect.width, frameRect.height, {x: dx, y: dy, width, height}, false);
				const {adjustX, adjustY} = item.filter;
				texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
				texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
			}else{
				addDrawTask({frameRect, drawRect, material: item.filter});
				texture.setUV(frameRect.width, frameRect.height, drawRect, false);
				texture.xyuvAdd[0] = areaRect.x;
				texture.xyuvAdd[1] = areaRect.y;
			}
		}
	);
	return root => {
		collectFn(root);
		for(const elementList of levelStack){
			drawFn(elementList);
			renderPass2D(() => Vulkan.viewportMgr.draw(), colorTexture2D().view0);
			renderPass2D(runDrawTask, colorTexture2D().view1);
			runCopyTask();
		}
		levelStack.clear();
	};
}();

const View3D = require('./View3D');

module.exports = class extends View3D {
	constructor(){
		super();
		this.addPreDrawTask(({scene2d}) => drawBitmap3D(scene2d));
		this.addPreDrawTask(({scene2d}) => drawFilter2D(scene2d));
		this.addDrawTask(view3d => {
			let {scene3d} = view3d;
			scene3d.camera.collectDrawUnits(scene3d, view3d.nextCameraIndex++);
			Camera3D.draw();
		});
		this.addDrawTask(view3d => {
			const {viewportMgr} = Vulkan;
			viewportMgr.addViewPort(view3d.nextViewportIndex++, Vulkan.canvas);
			viewportMgr.collectDrawUnits(view3d.scene2d);
			viewportMgr.draw(0, true);
		});
	}
}
