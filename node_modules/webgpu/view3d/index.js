'use strict';

const Vulkan = require('../Vulkan');
const Camera3D = require('../cameras/Camera3D');
const {Rect} = require('utils/MaxRectsBinPack');
const Matrix2D = require('../math/Matrix2D');
const {createTexture, createDepthTexture} = require('webonly/utils_gpu');
const RenderPass = require('../helper/RenderPass');
const {TexturePool} = require('../helper/ResourcePool');

const fetchView3D = TexturePool(1000, (width, height) => {
	console.log('new',width, height);
	let colorTexture = createTexture(Vulkan.device, width, height, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT);
	let depthTexture = createDepthTexture(Vulkan.device, width, height);
	return {
		colorView:colorTexture.createView(),
		depthView:depthTexture.createView(),
		onDestroy(){
			console.log('destroy',width, height);
			colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchView2D = TexturePool(1000, (width, height) => {
	console.log('new filter',width, height);
	let texture = createTexture(Vulkan.device, width, height, 2, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST);
	return {
		view0:texture.createView({dimension:'2d', baseArrayLayer:0, arrayLayerCount:1}),
		view1:texture.createView({dimension:'2d', baseArrayLayer:1, arrayLayerCount:1}),
		onDestroy(){
			texture.destroy();
			console.log('delete filter',width, height)
		},
		copyTexture(sx, sy, width, height){
			Vulkan.commandEncoder.copyTextureToTexture(
				{texture, origin: [sx, sy, 0]},
				{texture, origin: [0, 0, 1]},
				[width, height, 1]
			);
		}
	};
});

const renderPass3D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}],
	depthStencilAttachment:{
		depthLoadOp:'clear',//load
		depthClearValue:1,//[0,1],when depthLoadOp is clear
		depthStoreOp:'discard',//store
		depthReadOnly:false,
		stencilLoadOp:'clear',//load
		stencilClearValue:0,
		stencilStoreOp:'discard',//store
		stencilReadOnly:false,
		view:null
	}
});
const renderPass2D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}]
});

function visitByDepth(root){
	const result = [];
	const queue = [root];
	while(queue.length > 0){
		const node = queue.shift();
		if(!node.visible)continue;
		queue.push(...node.children);
		result.push(node);
	}
	return result;
}

const calcViewPortMatrix = function(){
	const matrixInv = new Matrix2D();
	return function(item, areaRect){
		matrixInv.copyFrom(item.worldTransformInvert);
		matrixInv.translate(-areaRect.x, -areaRect.y);
		return matrixInv;
	};
}();
const drawFn = item => {
	const areaRect = item.getBoundingRect();
	const {texture} = item.filter;
	if(!areaRect)return texture.rawTexture = null;
	const {width, height, copyTexture, view0, view1} = fetchView2D(areaRect);
	const drawRect = new Rect(areaRect.width, areaRect.height);
	const frameRect = new Rect(width, height);
	Vulkan.viewportMgr.addViewPort(item.scene.nextViewportIndex++, frameRect, drawRect, calcViewPortMatrix(item, areaRect));
	Vulkan.viewportMgr.collectDrawUnits(item, true);
	texture.rawTexture = view1;
	renderPass2D(() => Vulkan.viewportMgr.draw(), view0);
	if(item.filter.justCopyFlag){
		const clipRect = Object.assign(new Rect(), item.filter.clipRect).intersect(areaRect);
		if(!clipRect)return;
		copyTexture(clipRect.x - areaRect.x, clipRect.y - areaRect.y, clipRect.width, clipRect.height);
		texture.setUV(width, height, {x: 0, y: 0, width:clipRect.width, height:clipRect.height}, false);
		const {adjustX, adjustY} = item.filter;
		texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
		texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
	}else{
		texture.setUV(width, height, drawRect, false);
		texture.xyuvAdd[0] = areaRect.x;
		texture.xyuvAdd[1] = areaRect.y;
		renderPass2D(() => {
			const materialType = item.filter.constructor;
			Vulkan.renderPassEncoder.setBindGroup(0, materialType.createBindGroupWith(view0));
			materialType.draw([{frameRect, drawRect, material: item.filter}]);
		}, view1);
	}
}

function drawScene2D(root){
	fetchView3D();
	fetchView2D();
	for(let item of visitByDepth(root).reverse()){
		if(item.type == 'bitmap3d'){
			let {colorView, depthView, width, height} = fetchView3D(item);
			item.texture.rawTexture = colorView;
			item.texture.width = width;
			item.texture.height = height;
			item.camera.collectDrawUnits(item.root3d, item.scene.nextCameraIndex++);
			renderPass3D(() => Camera3D.draw(), colorView, depthView);
		}
		if(item.filter){
			drawFn(item);
		}
	}
}

const View3D = require('./View3D');

module.exports = class extends View3D {
	constructor(){
		super();
		this.addPreDrawTask(({scene2d}) => drawScene2D(scene2d));
		this.addDrawTask(view3d => {
			let {scene3d} = view3d;
			scene3d.camera.collectDrawUnits(scene3d, view3d.nextCameraIndex++);
			Camera3D.draw();
		});
		this.addDrawTask(view3d => {
			const {viewportMgr} = Vulkan;
			viewportMgr.addViewPort(view3d.nextViewportIndex++, Vulkan.canvas);
			viewportMgr.collectDrawUnits(view3d.scene2d);
			viewportMgr.draw(0, true);
		});
	}
}
