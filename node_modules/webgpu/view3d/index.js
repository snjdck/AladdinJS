'use strict';

const {intersect} = require('../math/rectangle');
const RenderPass = require('../helper/RenderPass');
const Camera2D = require('../cameras/Camera2D');
const {fetchBuffer, fetchView3D, fetchView2D} = require('../Vulkan/resource');

const renderPass3D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}],
	depthStencilAttachment:{
		depthLoadOp:'clear',//load
		depthClearValue:1,//[0,1],when depthLoadOp is clear
		depthStoreOp:'discard',//store
		depthReadOnly:false,
		stencilLoadOp:'clear',//load
		stencilClearValue:0,
		stencilStoreOp:'discard',//store
		stencilReadOnly:false,
		view:null
	}
});

const renderPass2D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}]
});

function visitByDepth(root){
	const result = [];
	const queue = [root];
	while(queue.length > 0){
		const node = queue.shift();
		if(!node.visible)continue;
		queue.push(...node.children);
		result.push(node);
	}
	return result;
}

const drawFilter = (camera => item => {
	const areaRect = item.getBoundingRect();
	const {texture} = item.filter;
	if(!areaRect)return texture.rawTexture = null;
	const {width, height, copyTexture, view0, view1} = fetchView2D.fetch(areaRect);
	const drawRect = {width:areaRect.width, height:areaRect.height, x:0, y:0};
	const frameRect = {width, height};

	camera.setLens(frameRect);
	camera.worldTransformInvert.copyFrom(item.worldTransformInvert);
	camera.worldTransformInvert.translate(-areaRect.x, -areaRect.y);
	camera.collectDrawUnits(item, true);

	texture.rawTexture = view1;
	renderPass2D(() => camera.draw(), view0);
	if(item.filter.justCopyFlag){
		const clipRect = intersect(areaRect, item.filter.clipRect);
		if(!clipRect)return;
		copyTexture(clipRect.x - areaRect.x, clipRect.y - areaRect.y, clipRect.width, clipRect.height);
		texture.setUV(width, height, {x: 0, y: 0, width:clipRect.width, height:clipRect.height}, false);
		const {adjustX, adjustY} = item.filter;
		texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
		texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
	}else{
		texture.setUV(width, height, drawRect, false);
		texture.xyuvAdd[0] = areaRect.x;
		texture.xyuvAdd[1] = areaRect.y;
		renderPass2D(() => {
			const materialType = item.filter.constructor;
			materialType.setBindGroup(0, [{binding:0, resource:view0}]);
			materialType.draw([{frameRect, drawRect, material: item.filter}]);
		}, view1);
	}
})(new Camera2D());

const drawScene2D = function(){
	function onRender(renderPassEncoder){
		renderPassEncoder.setViewport(0, 0, this.width, this.height, 0, 1);
		this.camera.draw();
	}
	return root => {
		for(let item of visitByDepth(root).reverse()){
			if(item.type == 'bitmap3d'){
				const {colorView, depthView, width, height} = fetchView3D.fetch(item);
				item.texture.rawTexture = colorView;
				item.texture.setUV(width, height, {x:0,y:0,width:item.width,height:item.height}, false);
				item.camera.collectDrawUnits(item.root3d);
				renderPass3D.call(item, onRender, colorView, depthView);
			}
			if(item.filter)drawFilter(item);
		}
	}
}();

const View3D = require('./View3D');

module.exports = class extends View3D {
	constructor(){
		super();
		this.addPreDrawTask(view3d => drawScene2D(view3d.scene2d));
	}
	onSubmitDone(){
		fetchView3D.reset();
		fetchView2D.reset();
		fetchBuffer.reset();
	}
}
