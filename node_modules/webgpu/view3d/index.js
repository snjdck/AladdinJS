'use strict';

const Vulkan = require('../Vulkan');
const Camera3D = require('../cameras/Camera3D');
const LevelStack = require('../../ds/LevelStack');
const {deferDo, deferBunchDo} = require('../../utils/function/deferDo');
const {walkTree} = require('utils/traverseTree');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const Matrix2D = require('../math/Matrix2D');
const {FrameBuffer, FrameBufferBase, FrameBufferList} = require('../helper/FrameBuffer');
const renderDrawUnits = require('../helper/renderDrawUnits');

const calcDrawRectList = function(){
	const rectPack = new MaxRectsBinPack(8192, 8192);
	const onInsert = areaRect => areaRect && rectPack.insert(areaRect.width, areaRect.height);
	return areaRectList => {
		const drawRectList = areaRectList.map(onInsert);
		rectPack.clear();
		return drawRectList;
	}
}();

const ElementCollectorFactory = (frameBuffer, calcSizeFn, handler) => elementList => {
	if(elementList.length <= 0)return;
	const areaRectList = elementList.map(calcSizeFn);
	const drawRectList = calcDrawRectList(areaRectList);
	const frameRect = Rect.Merge(drawRectList.filter(Boolean));
	if(!frameRect)return;
	frameBuffer.resize(frameRect);
	for(let i=0, n=elementList.length; i<n; ++i){
		handler(elementList[i], drawRectList[i], frameBuffer, frameRect, areaRectList[i]);
	}
	return frameBuffer;
}

const drawBitmap3D = function(){
	const elementList = [];
	const collectFn = walkTree(function(item){
		if(!item.visible)return true;
		if(item.type != 'bitmap3d')return;
		elementList.push(item);
	});
	const drawFn = ElementCollectorFactory(
		new FrameBuffer({}),
		({width, height}) => new Rect(width, height),
		(bitmap3D, drawRect, frameBuffer, frameRect) => {
			bitmap3D.texture.rawTexture = frameBuffer.colorView;
			bitmap3D.texture.setUV(frameRect.width, frameRect.height, drawRect, false);
			bitmap3D.camera.setViewport(frameRect, drawRect);
			bitmap3D.camera.collectDrawUnits(bitmap3D.root3d, bitmap3D.scene.nextCameraIndex++);
		}
	);
	return root => {
		collectFn(root);
		drawFn(elementList)?.render(Camera3D.draw);
		elementList.length = 0;
	};
}();

const drawFilter2D = function(){
	const levelStack = new LevelStack();
	const collectFn = walkTree(function(item){
		if(!item.visible)return true;
		if(!item.filter)return;
		levelStack.push(item);
		levelStack.next();
	}, function(item){
		if(!item.filter)return;
		levelStack.prev();
	});
	const calcViewPortMatrix = function(){
		const matrixInv = new Matrix2D();
		return function(item, areaRect){
			matrixInv.copyFrom(item.worldTransformInvert);
			matrixInv.translate(-areaRect.x, -areaRect.y);
			return matrixInv;
		};
	}();
	const [addDrawTask, runDrawTask] = deferBunchDo(function(drawUnits, frameBuffer){
		let bindGroup = drawUnits[0].material.constructor.createBindGroupWith(frameBuffer.getColorView(0))
		Vulkan.renderPassEncoder.setBindGroup(0, bindGroup);
		renderDrawUnits(drawUnits);
	});
	const [addCopyTask, runCopyTask] = deferDo();
	const drawFn = ElementCollectorFactory(
		new FrameBufferList(),
		item => item.getBoundingRect(),
		(item, drawRect, frameBufferList, frameRect, areaRect) => {
			const {texture} = item.filter;
			if(!areaRect)return texture.rawTexture = null;
			Vulkan.viewportMgr.addViewPort(item.scene.nextViewportIndex++, frameRect, drawRect, calcViewPortMatrix(item, areaRect));
			Vulkan.viewportMgr.collectDrawUnits(item, true);
			texture.rawTexture = frameBufferList.getColorView(1);
			if(item.filter.justCopyFlag){
				const clipRect = Object.assign(new Rect(), item.filter.clipRect).intersect(areaRect);
				if(!clipRect)return;
				const sx = drawRect.x + clipRect.x - areaRect.x;
				const sy = drawRect.y + clipRect.y - areaRect.y;
				const {x: dx, y: dy} = drawRect;
				const {width, height} = clipRect;
				addCopyTask(() => Vulkan.commandEncoder.copyTextureToTexture(
					{texture: frameBufferList.colorBuffer, origin: [sx, sy, 0]},
					{texture: frameBufferList.colorBuffer, origin: [dx, dy, 1]},
					[width, height, 1]
				));
				texture.setUV(frameRect.width, frameRect.height, {x: dx, y: dy, width, height}, false);
				const {adjustX, adjustY} = item.filter;
				texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
				texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
			}else{
				addDrawTask({frameRect, drawRect, material: item.filter});
				texture.setUV(frameRect.width, frameRect.height, drawRect, false);
				texture.xyuvAdd[0] = areaRect.x;
				texture.xyuvAdd[1] = areaRect.y;
			}
		}
	);
	return root => {
		collectFn(root);
		for(const elementList of levelStack){
			let frameBuffer = drawFn(elementList);
			if(frameBuffer){
				frameBuffer.setColorAttachment(frameBuffer.getColorView(0));
				frameBuffer.render(() => Vulkan.viewportMgr.draw());
				frameBuffer.setColorAttachment(frameBuffer.getColorView(1));
				frameBuffer.render(() => runDrawTask(frameBuffer));
			}
			runCopyTask();
		}
		levelStack.clear();
	};
}();

const View3D = require('./View3D');

module.exports = class extends View3D {
	constructor(){
		super();
		this.addPreDrawTask(({scene2d}) => drawBitmap3D(scene2d));
		this.addPreDrawTask(({scene2d}) => drawFilter2D(scene2d));
		this.addDrawTask(view3d => {
			let {scene3d} = view3d;
			scene3d.camera.collectDrawUnits(scene3d, view3d.nextCameraIndex++);
			Camera3D.draw();
		});
		this.addDrawTask(view3d => {
			const {viewportMgr} = Vulkan;
			viewportMgr.addViewPort(view3d.nextViewportIndex++, Vulkan.canvas);
			viewportMgr.collectDrawUnits(view3d.scene2d);
			viewportMgr.draw(0, true);
		});
	}
}
