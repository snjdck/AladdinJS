'use strict';

const Vulkan = require('../Vulkan');
const {Rect} = require('utils/MaxRectsBinPack');
const Matrix2D = require('../math/Matrix2D');
const {createTexture, createDepthTexture} = require('webonly/utils_gpu');
const RenderPass = require('../helper/RenderPass');
const {TexturePool, BufferPool} = require('../helper/ResourcePool');
const Material2D = require('../materials/Material2D');
const {walkTree} = require('utils/traverseTree');

const fetchBuffer = BufferPool(1000, size => {
	console.log('new buffer', size);
	let buffer = Vulkan.device.createBuffer({usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, size})
	return {
		buffer,
		onDestroy(){
			console.log('destroy buffer', size);
			buffer.destroy();
		}
	};
});

const calcViewport = function(){
	const float32List = new Float32Array(12);
	return (frameRect, rootMatrix) => {
		float32List[0] =  2 / frameRect.width;
		float32List[1] = -2 / frameRect.height;
		//if(drawRect){
		//	float32List[2] = 2 * drawRect.x / frameRect.width - 1;
		//	/=float32List[3] = 1 - 2 * drawRect.y / frameRect.height;
		//}else{
			float32List[2] = -1;
			float32List[3] =  1;
		//}
		if(rootMatrix){
			rootMatrix.copyToArray(float32List, 4);
		}else{
			float32List[4] = float32List[9] = 1;
			float32List[5] = float32List[6] = float32List[7] = 
			float32List[8] = float32List[10] = float32List[11] = 0;
		}
		return float32List;
	}
}();

const collectDrawUnits = function(){
	const fn = walkTree(function(item, root, forceDrawFlag, result){
		if(!item.visible)return true;
		if(item.filter && !(item == root && forceDrawFlag)){
			const {texture} = item.filter;
			const drawUnit = Object.create(item);
			drawUnit.texture = texture;
			drawUnit.width = texture.width;
			drawUnit.height = texture.height;
			result.push(drawUnit);
			return true;
		}else if(item.texture){
			result.push(item);
		}
	});
	return (root, forceDrawFlag=false, result=[]) => fn(root, true, root, forceDrawFlag, result) ?? result;
}();

function drawViewport(frameRect, rootMatrix, drawUnitBucket){
	if(drawUnitBucket.length <= 0)return;
	const data = calcViewport(frameRect, rootMatrix)
	const bufferInfo = fetchBuffer(data.byteLength);
	Vulkan.device.queue.writeBuffer(bufferInfo.buffer, 0, data);
	Vulkan.renderPassEncoder.setBindGroup(0, Material2D.createBindGroupWith(bufferInfo));
	Material2D.draw(drawUnitBucket, !rootMatrix);
}

const fetchView3D = TexturePool(1000, (width, height) => {
	console.log('new',width, height);
	let colorTexture = createTexture(Vulkan.device, width, height, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT);
	let depthTexture = createDepthTexture(Vulkan.device, width, height);
	return {
		colorView:colorTexture.createView(),
		depthView:depthTexture.createView(),
		onDestroy(){
			console.log('destroy',width, height);
			colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchView2D = TexturePool(1000, (width, height) => {
	console.log('new filter',width, height);
	let texture = createTexture(Vulkan.device, width, height, 2, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST);
	return {
		view0:texture.createView({dimension:'2d', baseArrayLayer:0, arrayLayerCount:1}),
		view1:texture.createView({dimension:'2d', baseArrayLayer:1, arrayLayerCount:1}),
		onDestroy(){
			texture.destroy();
			console.log('delete filter',width, height)
		},
		copyTexture(sx, sy, width, height){
			Vulkan.commandEncoder.copyTextureToTexture(
				{texture, origin: [sx, sy, 0]},
				{texture, origin: [0, 0, 1]},
				[width, height, 1]
			);
		}
	};
});

const renderPass3D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}],
	depthStencilAttachment:{
		depthLoadOp:'clear',//load
		depthClearValue:1,//[0,1],when depthLoadOp is clear
		depthStoreOp:'discard',//store
		depthReadOnly:false,
		stencilLoadOp:'clear',//load
		stencilClearValue:0,
		stencilStoreOp:'discard',//store
		stencilReadOnly:false,
		view:null
	}
});
const renderPass2D = RenderPass({
	colorAttachments:[{
		loadOp:'clear',//load
		clearValue:[0,0,0,0],//when loadOp is clear
		storeOp:'store',//discard
		view:null
	}]
});

function visitByDepth(root){
	const result = [];
	const queue = [root];
	while(queue.length > 0){
		const node = queue.shift();
		if(!node.visible)continue;
		queue.push(...node.children);
		result.push(node);
	}
	return result;
}

const calcViewPortMatrix = function(){
	const matrixInv = new Matrix2D();
	return function(item, areaRect){
		matrixInv.copyFrom(item.worldTransformInvert);
		matrixInv.translate(-areaRect.x, -areaRect.y);
		return matrixInv;
	};
}();
const drawFn = item => {
	const areaRect = item.getBoundingRect();
	const {texture} = item.filter;
	if(!areaRect)return texture.rawTexture = null;
	const {width, height, copyTexture, view0, view1} = fetchView2D(areaRect);
	const drawRect = new Rect(areaRect.width, areaRect.height);
	const frameRect = new Rect(width, height);

	texture.rawTexture = view1;
	renderPass2D(() => drawViewport(frameRect, calcViewPortMatrix(item, areaRect), collectDrawUnits(item, true)), view0);
	if(item.filter.justCopyFlag){
		const clipRect = Object.assign(new Rect(), item.filter.clipRect).intersect(areaRect);
		if(!clipRect)return;
		copyTexture(clipRect.x - areaRect.x, clipRect.y - areaRect.y, clipRect.width, clipRect.height);
		texture.setUV(width, height, {x: 0, y: 0, width:clipRect.width, height:clipRect.height}, false);
		const {adjustX, adjustY} = item.filter;
		texture.xyuvAdd[0] = clipRect.x - (adjustX ? item.filter.clipRect.x : 0);
		texture.xyuvAdd[1] = clipRect.y - (adjustY ? item.filter.clipRect.y : 0);
	}else{
		texture.setUV(width, height, drawRect, false);
		texture.xyuvAdd[0] = areaRect.x;
		texture.xyuvAdd[1] = areaRect.y;
		renderPass2D(() => {
			const materialType = item.filter.constructor;
			Vulkan.renderPassEncoder.setBindGroup(0, materialType.createBindGroupWith(view0));
			materialType.draw([{frameRect, drawRect, material: item.filter}]);
		}, view1);
	}
}

function drawScene2D(root){
	fetchView3D();
	fetchView2D();
	fetchBuffer();
	for(let item of visitByDepth(root).reverse()){
		if(item.type == 'bitmap3d'){
			let {colorView, depthView, width, height} = fetchView3D(item);
			item.texture.rawTexture = colorView;
			item.texture.width = width;
			item.texture.height = height;
			item.camera.collectDrawUnits(item.root3d);
			renderPass3D(() => item.camera.draw(fetchBuffer), colorView, depthView);
		}
		if(item.filter){
			drawFn(item);
		}
	}
}

const View3D = require('./View3D');

module.exports = class extends View3D {
	constructor(){
		super();
		this.addPreDrawTask(({scene2d}) => drawScene2D(scene2d));
		this.addDrawTask(view3d => {
			let {scene3d} = view3d;
			scene3d.camera.collectDrawUnits(scene3d);
			scene3d.camera.draw(fetchBuffer);
		});
		this.addDrawTask(view3d => {
			drawViewport(Vulkan.canvas, null, collectDrawUnits(view3d.scene2d));
		});
	}
}
