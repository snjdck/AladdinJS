'use strict';

const Vulkan = require('../Vulkan');
const BitmapQueue = require('opengl/renderers/BitmapQueue');
const traverseTree = require('utils/traverseTree');

class Render2D
{
	constructor(){
		this.handlerDict = {};
		this.bitmapQueue = new BitmapQueue(v => v.texture.getRawAsset());
		this.mvpBindGroup = createMvpBindGroup();
		this.textureBindGroupDesc = createBindGroupDesc();
	}

	calcKey(type, mode){
		return type + '@' + mode;
	}

	register(type, handler, mode=''){
		this.handlerDict[this.calcKey(type, mode)] = handler;
	}

	tryAdd(target, mode=''){
		const type = target.type;
		const handler = this.handlerDict[this.calcKey(type, mode)];
		if(!handler)return;
		handler.call(target, mode, type);
	}

	add(target){
		this.bitmapQueue.add(target);
	}

	collect(root, includeRoot=true){
		traverseTree.call(this, root, onCollect, includeRoot);
	}

	prepareToDraw(){
		const {renderPassEncoder, pipelineDict} = Vulkan;
		renderPassEncoder.setPipeline(pipelineDict.pipeline2D);
		renderPassEncoder.setBindGroup(0, this.mvpBindGroup);
	}

	draw(){
		this.bitmapQueue.draw(onBatchDraw2D, this).clear();
	}
}

function createMvpBindGroup(){
	const {device, canvas} = Vulkan;

	const uniformBuffer = Vulkan.createBufferMapped(GPUBufferUsage.UNIFORM, new Float32Array([2 / canvas.width, -2 / canvas.height]));

	return device.createBindGroup({
		layout: Vulkan.bindGroupLayoutDict.bindGroupLayout,
		entries: [{
			binding: 0,
			resource: {buffer: uniformBuffer}
		},{	binding: 1,
			resource: device.createSampler({
				magFilter: 'linear',
				minFilter: 'linear',
			})
		}]
	});
}

function createBindGroupDesc(){
	return {
		layout: Vulkan.bindGroupLayoutDict.bindGroupLayout3,
		entries: [{binding: 0,
			resource: null//bind later
		}]
	};
}

function onBatchDraw2D(instanceList){
	const {textureBindGroupDesc} = this;
	const {device, renderPassEncoder} = Vulkan;
	const texture = instanceList[0].texture.getRawAsset();
	textureBindGroupDesc.layout = Vulkan.bindGroupLayoutDict.bindGroupLayout3;
	textureBindGroupDesc.entries[0].resource = texture;
	renderPassEncoder.setBindGroup(1, device.createBindGroup(textureBindGroupDesc));
	Vulkan.vertexBufferMgr.draw(instanceList);
}

function onCollect(item){
	if(!item.visible)return true;
	const {filter} = item;
	if(filter){
		this.add(filter);
		return true;
	}
	this.tryAdd(item);
}

module.exports = Render2D;
