'use strict';

const DisplayObject2D = require('opengl/DisplayObject2D');
const Transform = require('opengl/Transform');
const traverseTree = require('utils/traverseTree');
const batchDraw = require('opengl/renderers/batchDraw');
const BitmapQueue = require('opengl/renderers/BitmapQueue');
const {createMeshIndices} = require('utils/geometry');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const overrideMethod = require('utils/function/overrideMethod');
const {loadData} = require('utils/loader');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');
const Matrix2D = require('opengl/math/Matrix2D');
const {Texture2D} = require('opengl/textures');
const Mat3x4 = require('./mat3x4');
const collectAllTypes = require('utils/class/collectAllTypes');
const ArrayValueMap = require('ds/ArrayValueMap');
const BoneObject = require('opengl/3d/BoneObject');

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	return view;
});

const Vulkan = {
	bitmapQueue: new BitmapQueue(v => v.texture.getRawAsset()),
	device: null,
	canvas: null,
	swapChain: null,
	pipelineDict: {},
	bindGroupLayoutDict: {},
};
Vulkan.fetchTexture = createFetch(function(name, callback){
	const {device} = this;
	if(name.endsWith('.tga')){
		loadData(name, 'arraybuffer').then(data => {
			let image = imageUtil.decode(name, data);
			const texture = device.createTexture({
				size: [image.width, image.height, 1],
				format: 'rgba8unorm',
				usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
			});
			texture.transparent = true;
			texture.name = name;
			texture.width = image.width;
			texture.height = image.height;
			createImageBitmap(
				new ImageData(new Uint8ClampedArray(image.data), image.width, image.height)
			).then(imageBitmap => {
				device.defaultQueue.copyImageBitmapToTexture(
					{imageBitmap},
					{texture, mipLevel: 0, arrayLayer: 0, origin: [0, 0, 0]},
					[image.width, image.height, 1]
				);
				callback(texture);
			});
		});
	}else{
		this.loadTexture(this.device, name).then(callback);
	}
});
Vulkan.loadModel = async path => parse(new Uint8Array(await loadData(path, 'arraybuffer')));
Vulkan.loadTexture = async (device, path) => {
	const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path));
	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
	});
	device.defaultQueue.copyImageBitmapToTexture(
		{imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, arrayLayer: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);
	texture.transparent = false;
	texture.name = path;
	texture.width = imageBitmap.width;
	texture.height = imageBitmap.height;
	return texture;
};

Vulkan.loadImage = async path => {
	let image = new Image();
	image.src = path;
	await image.decode();
	return image;
};
Object.defineProperties(Vulkan, {
	swapChainFormat: {value: 'bgra8unorm'},
	_default2DRenderPassDesc:{
		value: {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load',
				storeOp: 'store'
			}],
			/*depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 'load',
				depthStoreOp: 'store',
				stencilLoadValue: 'load',
				stencilStoreOp: 'store'
			}*/
		}
	},
	init:{value(device, canvas){
		this.device = device;
		this.canvas = canvas;
		this.swapChain = canvas.getContext('gpupresent').configureSwapChain({
			device,
			format: this.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT
		});
		this.mgrList = [];
		this.filterSwapChain = new FilterSwapChain();
		this.textMgr = new TextManager();
		Filter2D.Init();
		preparePipelines();
		this.regMgr('transformUniformMgr', new TransformUniformManager());
	}},
	regMgr:{value(name, value){
		this[name] = value;
		this.mgrList.push(value);
	}},
	reset:{value(){
		this.mgrList.forEach(v => v.reset?.());
	}},
	setRenderPassDesc:{value(desc, colorAttachments, depthStencilAttachment){
		if(colorAttachments)colorAttachments.forEach((v, i) => desc.colorAttachments[i].attachment = v);
		if(desc.depthStencilAttachment)desc.depthStencilAttachment.attachment = depthStencilAttachment;
	}},
	copyRenderPassDesc:{value(from, to, loadValue='load', depthLoadValue='load', stencilLoadValue='load'){
		to.colorAttachments.forEach((v, i) => v.attachment = from.colorAttachments[i].attachment);
		to.depthStencilAttachment.attachment = from.depthStencilAttachment.attachment;
	}},
	pushRenderPass:{value(desc, colorAttachments, depthStencilAttachment){
		this.setRenderPassDesc(desc, colorAttachments, depthStencilAttachment);
		//this._currentRenderPassDesc = desc;
		return this.renderPassEncoder = this.commandEncoder.beginRenderPass(desc);
	}},
});
//Object.seal(Vulkan);

function preparePipelines(){
	const {device} = Vulkan;
	Vulkan.bindGroupLayoutDict.bindGroupLayout = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.VERTEX,
			type: 'uniform-buffer',
		},{binding: 1,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampler'
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout2 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.VERTEX,
			type: 'uniform-buffer',
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout3 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampled-texture'
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout4 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'uniform-buffer',
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout5 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampled-texture',
			viewDimension: '2d-array',
		}]
	});

	function createPipelineDesc3D(bindGroupLayouts, vertexCode, fragmentCode){
		return {
			layout: device.createPipelineLayout({
				bindGroupLayouts
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-list',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			},
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: 9 << 2,
					stepMode: 'vertex',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'float3'
					},{
						shaderLocation: 1,
						offset: 3 << 2,
						format: 'float3'
					},{
						shaderLocation: 2,
						offset: 6 << 2,
						format: 'float2'
					},{
						shaderLocation: 3,
						offset: 8 << 2,
						format: 'uint'
					}]
				}]
			}
		};
	}

	Vulkan.pipelineDict.pipeline = device.createRenderPipeline(createPipelineDesc3D(
		[
			Vulkan.bindGroupLayoutDict.bindGroupLayout,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout3,
		],
		Vulkan.shader_3d.vertexCode,
		Vulkan.shader_3d.fragmentCode,
	));

	Vulkan.pipelineDict.pipelineColor = device.createRenderPipeline(createPipelineDesc3D(
		[
			Vulkan.bindGroupLayoutDict.bindGroupLayout,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout4,
		],
		Vulkan.shader_3d.vertexCode,
		Vulkan.shader_3d_color.fragmentCode,
	));

	Vulkan.pipelineDict.pipelineTerrain = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts:[
					Vulkan.bindGroupLayoutDict.bindGroupLayout,
					Vulkan.bindGroupLayoutDict.bindGroupLayout5,
				]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_terrain.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_terrain.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-list',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			},
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: 12,
					stepMode: 'vertex',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'uchar2'
					},{
						shaderLocation: 1,
						offset: 4,
						format: 'uchar2norm'
					},{
						shaderLocation: 2,
						offset: 8,
						format: 'uchar4norm'
					}]
				}]
			}
	});
}

const frameDo = fn => requestAnimationFrame(function loop(){
	requestAnimationFrame(loop);
	fn();
});

class Lens
{
	static OrthoLH(width, height, zNear, zFar){
		let matrix = new Float32Array(16);
		matrix[ 0] = 2 / width;
		matrix[ 5] = 2 / height;
		matrix[10] = 1 / (zFar - zNear);
		matrix[11] = zNear / (zNear - zFar);
		matrix[15] = 1;
		return matrix;
	}
}

class Camera3D extends Transform
{
	constructor(lens){
		super(Mat3x4);
		const {device} = Vulkan;
		this.lens = lens;
		this.drawUnitBucket = new DrawUnitBucket();

		this.uniformBuffer = device.createBuffer({
			size: 7 * 4 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});

		this.mvpBindGroup = device.createBindGroup({
			layout: Vulkan.bindGroupLayoutDict.bindGroupLayout,
			entries: [{
				binding: 0,
				resource: {buffer: this.uniformBuffer}
			},{	binding: 1,
				resource: device.createSampler({
					addressModeU: 'repeat',
					addressModeV: 'repeat',
					magFilter: 'linear',
					minFilter: 'linear',
				})
			}]
		});
	}

	prepareData(root){
		const {uniformBuffer, lens, worldTransformInvert} = this;
		copyDataToBuffer(uniformBuffer, lens);
		copyDataToBuffer(uniformBuffer, worldTransformInvert.rawData, lens.byteLength);
	}

	draw(root){
		const {renderPassEncoder} = Vulkan;
		const {drawUnitBucket} = this;

		renderPassEncoder.setBindGroup(0, this.mvpBindGroup);
		this.uniformBuffer.setSubData(0, this.lens);
		this.uniformBuffer.setSubData(64, this.worldTransformInvert.rawData);

		traverseTree.call(drawUnitBucket, root, drawUnitBucket.add);
		drawUnitBucket.draw().clear();
	}
}

class Scene3D
{
	constructor(){
		this.root = new DisplayObject3D();
		this.root._scene = this;
		this.renderPassDesc = {
			colorAttachments: [{
				attachment: null,
				loadValue: [0,0,0,1]
			}],
			depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 1.0,
				depthStoreOp: 'store',
				stencilLoadValue: 0,
				stencilStoreOp: 'store'
			}
		};
	}

	update(){
		updateTree(this.root);
	}

	draw(){
		const {renderPassDesc} = this;
		const {mainColorTexture, mainDepthStencil} = Vulkan;

		//this.camera.prepareData(this.root);

		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture], mainDepthStencil);

		this.camera.draw(this.root);

		renderPassEncoder.endPass();
	}
}

const updateTree = (onUpdate => root => traverseTree(root, onUpdate))(item => !item.visible || item.onUpdate?.());

class FilterBucket
{
	constructor(){
		this.list = [];
		this.level = 0;
		this.leaveFilter = this.leaveFilter.bind(this);
	}

	getLevelList(){
		const {list, level} = this;
		return list[level] || (list[level] = []);
	}

	enterFilter(item){
		this.getLevelList().push(item);
		++this.level;
	}

	leaveFilter(){
		--this.level;
	}

	clear(){
		for(let group of this.list){
			group.length = 0;
		}
	}

	onDraw(item){
		const {bitmapQueue} = Vulkan;
		const {filter} = item;
		if(filter && item != this){
			bitmapQueue.add(filter);
			return true;
		}
		item.onDraw?.();
	}

	onCollectFilter(item){
		if(!item.visible)return true;
		if(item.filter){
			this.enterFilter(item);
			return this.leaveFilter;
		}
	}

	collect(root){
		traverseTree.call(this, root, this.onCollectFilter);
	}

	draw(scene){
		const {commandEncoder, device, canvas:{width, height}} = Vulkan;
		const {filterSwapChain, bitmapQueue} = Vulkan;

		const frameBufferA = filterSwapChain.frameBufferA.createView();
		const frameBufferB = filterSwapChain.frameBufferB.createView();
		const {rectPack} = filterSwapChain;

		for(let group of this.list.reverse()){
			if(group.length == 0)continue;
			rectPack.clear();
			this.beginRenderPass(frameBufferA);

			scene.initRenderPassEncoder();
			for(let filterItem of group){
				const rect = filterItem.filter.drawRect = rectPack.insert(width, height);
				Vulkan.renderPassEncoder.setViewport(rect.x, rect.y, rect.width, rect.height, 0, 1);
				traverseTree.call(filterItem, filterItem, this.onDraw);
				bitmapQueue.draw(scene.onBatchDraw, scene).clear();
			}
			
			Vulkan.renderPassEncoder.endPass();
			this.beginRenderPass(frameBufferB);

			Vulkan.renderPassEncoder.setBindGroup(0, Filter2D.textureBindGroup);
			for(const {filter} of group){
				filter.onDraw();
				filter.width = width;
				filter.height = height;
				filter.texture = new Texture2D(frameBufferB);
				filter.texture.setUV(MAX_W, MAX_H, filter.drawRect, false);
			}

			Vulkan.renderPassEncoder.endPass();
		}
		return this;
	}

	beginRenderPass(colorAttachment){
		Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass({
			colorAttachments: [{
				attachment: colorAttachment,
				loadValue: [0,0,0,0]
			}]
		});
	}
}

class Scene2D
{
	constructor(){
		this.filterBucket = new FilterBucket();

		const maxDrawCount = 100;
		this.root = new DisplayObject2D();
		this.root._scene = this;
		this.batchDraw = batchDraw.bind(this, maxDrawCount);

		const {device, canvas} = Vulkan;
		this.vertexData = new Float32Array(instanceFloatCount);
		const vertexBuffer = device.createBuffer({
			size: instanceByteSize * maxDrawCount,
			usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
		});

		//this.vertexBufferListCache = createVertexBufferListCache(instanceFloatCount * 100);

		const indexBuffer = createBufferMapped(GPUBufferUsage.INDEX, new Uint16Array(createMeshIndices(4, 4)));
		const uniformBuffer = createBufferMapped(GPUBufferUsage.UNIFORM, new Float32Array([2 / canvas.width, -2 / canvas.height]));

		const bindGroupLayout = device.createBindGroupLayout({
			entries:[{
				binding: 0,
				visibility: GPUShaderStage.VERTEX,
				type: 'uniform-buffer',
			},{
				binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampler'
			}]
		});

		this.bindGroup = device.createBindGroup({
			layout: bindGroupLayout,
			entries: [{
				binding: 0,
				resource: {buffer: uniformBuffer}
			},{	binding: 1,
				resource: device.createSampler({
					magFilter: 'linear',
					minFilter: 'linear',
				})
			}]
		});

		const textureBindGroupLayout = device.createBindGroupLayout({
			entries:[{
				binding: 0,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampled-texture'
			}]
		});

		this.textureBindGroupDesc = {
			layout: textureBindGroupLayout,
			entries: [{binding: 0,
				resource: null//bind later
			}]
		};

		this.pipeline = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts: [bindGroupLayout, textureBindGroupLayout]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_2d.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_2d.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-list',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: instanceFloatCount << 2,
					stepMode: 'instance',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'float3'
					},{
						shaderLocation: 1,
						offset: 3 << 2,
						format: 'float3'
					},{
						shaderLocation: 2,
						offset: 6 << 2,
						format: 'float4'
					},{
						shaderLocation: 3,
						offset: 10 << 2,
						format: 'float4'
					},{
						shaderLocation: 4,
						offset: 14 << 2,
						format: 'float4'
					},{
						shaderLocation: 5,
						offset: 18 << 2,
						format: 'float4'
					}]
				}]
			}
		});

		this.vertexBuffer = vertexBuffer;
		this.indexBuffer = indexBuffer;

		this.renderPassDesc = {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load'
			}],
			/*depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 1.0,
				depthStoreOp: 'store',
				stencilLoadValue: 0,
				stencilStoreOp: 'store'
			}*/
		};

		this.bitmap3dMgr = new Bitmap3DManager();
	}

	initRenderPassEncoder(){
		const {renderPassEncoder} = Vulkan;
		renderPassEncoder.setPipeline(this.pipeline);
		renderPassEncoder.setVertexBuffer(0, this.vertexBuffer);
		renderPassEncoder.setIndexBuffer(this.indexBuffer);
		renderPassEncoder.setBindGroup(0, this.bindGroup);
	}

	update(){
		updateTree(this.root);
	}

	draw(){
		const {vertexBuffer, renderPassDesc} = this;
		const {mainColorTexture, mainDepthStencil, bitmapQueue} = Vulkan;

		this.totalDrawCount = 0;

		this.bitmap3dMgr.draw(this.root);

		this.filterBucket.collect(this.root);
		this.filterBucket.draw(this).clear();

		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture], mainDepthStencil);

		this.initRenderPassEncoder();

		traverseTree.call(null, this.root, this.onDraw);

		bitmapQueue.draw(this.onBatchDraw, this).clear();
		renderPassEncoder.endPass();
	}

	onDraw(item){
		const {bitmapQueue} = Vulkan;
		if(!item.visible)return true;
		const {filter} = item;
		const filterFlag = !this && filter;
		if(filterFlag){
			bitmapQueue.add(filter);
			return true;
		}
		item.onDraw?.();
	}

	onBatchDraw(instanceList){
		const {device, renderPassEncoder} = Vulkan;
		const texture = instanceList[0].texture.getRawAsset();
		this.textureBindGroupDesc.entries[0].resource = texture;
		renderPassEncoder.setBindGroup(1, device.createBindGroup(this.textureBindGroupDesc));
		this.batchDraw(instanceList);
		//drawBatched.call(this, 100, instanceList, this.onUpdateBufferBatch);
	}

	onUpdateBufferBatch(instanceList, offset, instanceCount){
		const {vertexData, totalDrawCount} = this;
		for(let i=0; i<instanceCount; ++i){
			const {worldTransform, texture, width, height, fgColor} = instanceList[offset+i];
			worldTransform.copyToArray(tempList, 0, 3);
			const j = 0;
			vertexData.set(tempList, j);
			if(texture){
				vertexData.set(texture.xyuvMul, j+6);
				vertexData.set(texture.xyuvAdd, j+10);
				vertexData.set(texture.scale9grid, j+18);
				vertexData[j+14] = width;
				vertexData[j+15] = texture.width;
				vertexData[j+16] = height;
				vertexData[j+17] = texture.height;
			}else{
				vertexData.set(allOne, j+6);
				vertexData.set(allZero, j+10);
				vertexData.set(allZero, j+18);
				vertexData[j+14] = width;
				vertexData[j+15] = width;
				vertexData[j+16] = height;
				vertexData[j+17] = height;
			}
			this.vertexBuffer.setSubData(instanceByteSize * (i + totalDrawCount), vertexData);
		}
		const {renderPassEncoder} = Vulkan;
		renderPassEncoder.drawIndexed(triangleCount, instanceCount, 0, 0, this.totalDrawCount);
		this.totalDrawCount += instanceCount;
	}

	onUploadBufferAndDraw(instanceCount){}
}

const tempList = new Array(6);
const allZero = new Float32Array(4);
const allOne = new Float32Array(4).fill(1);

const instanceFloatCount = 22;
const instanceByteSize = instanceFloatCount << 2;

const vertexCountX = 4;
const vertexCountY = 4;
const triangleCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.


class View3D
{
	constructor(){
		this.scene3d = new Scene3D();
		this.scene2d = new Scene2D();
		frameDo(this.onTick.bind(this));

		const {device, canvas} = Vulkan;
		this.depthTexture = createDepthTexture(canvas.width, canvas.height);

		this.fence = device.defaultQueue.createFence();
	}

	onTick(){
		console.log('-------');
		Vulkan.reset();
		this.updateScene();
		this.drawScene();
	}

	updateScene(){
		this.scene3d.update();
		this.scene2d.update();
	}

	drawScene(){
		const {device, swapChain} = Vulkan;
		const {depthTexture} = this;

		const mainColorTexture = swapChain.getCurrentTexture().createView();
		const mainDepthStencil = depthTexture.createView();

		const commandEncoder = device.createCommandEncoder();

		Vulkan.commandEncoder = commandEncoder;
		Vulkan.mainColorTexture = mainColorTexture;
		Vulkan.mainDepthStencil = mainDepthStencil;

		this.scene3d.draw();
		this.scene2d.draw();

		device.defaultQueue.submit([commandEncoder.finish()]);
		//console.log('submit', performance.now());
		//device.defaultQueue.signal(this.fence, 0);
		/*console.log('signal begin', performance.now());
		this.fence.onCompletion(23).then(() => {
			console.log('fence complete', performance.now(), this.fence.getCompletedValue())
		});
		console.log('signal end', performance.now());
		//*/
	}
}

class Bitmap extends DisplayObject2D
{
	constructor(){
		super();
		this._texture = null;
		this.width = 0;
		this.height = 0;
	}

	get texture(){
		return this._texture;
	}

	set texture(value){
		this._texture = value;
		if(value == null){
			return;
		}
		this.width = value.width;
		this.height = value.height;
	}

	onDraw(mode){
		Vulkan.bitmapQueue.add(this);
	}
}

class Bitmap3D extends DisplayObject2D
{
	constructor(width, height, lens){
		super();
		this.root3d = new DisplayObject3D();
		this.width = width;
		this.height = height;
		this.updateEnabled = true;
		this.camera = new Camera3D(lens);
		this.texture = new Texture2D();
	}

	onUpdate(){
		if(this.updateEnabled){
			updateTree(this.root3d);
		}
	}

	onDraw(){
		Vulkan.bitmapQueue.add(this);
	}
}

class Filter2D
{
	static Init(){
		const {device, filterSwapChain} = Vulkan;
		const frameBuffer = filterSwapChain.frameBufferA.createView();
		const textureBindGroupLayout = device.createBindGroupLayout({
			entries:[{
				binding: 0,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampler'
			},{
				binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampled-texture'
			}]
		});
		this.prototype.textureBindGroupLayout = textureBindGroupLayout;
		this.textureBindGroup = device.createBindGroup({
			layout: textureBindGroupLayout,
			entries: [{
				binding: 0,
				resource: device.createSampler({
					magFilter: 'linear',
					minFilter: 'linear',
				})
			},{	binding: 1,
				resource: frameBuffer
			}]
		});
	}

	constructor(){
		this.worldTransform = new Matrix2D();
	}

	onDraw(){}
}

class BlurFilter extends Filter2D
{
	constructor(color=[1,0,1,1]){
		super();
		const {device, canvas} = Vulkan;

		this.uniformBuffer = device.createBuffer({
			size: 8 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});

		this.uniformBuffer2 = device.createBuffer({
			size: 4 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});
		this.uniformBuffer2.setSubData(0, new Float32Array(color));

		const bindGroupLayout = device.createBindGroupLayout({
			entries:[{
				binding: 0,
				visibility: GPUShaderStage.VERTEX,
				type: 'uniform-buffer',
			},{
				binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'uniform-buffer'
			}]
		});

		const bindGroupDesc = {
			layout: bindGroupLayout,
			entries: [{
				binding: 0,
				resource: {
					buffer: this.uniformBuffer
				}
			},{	binding: 1,
				resource: {
					buffer: this.uniformBuffer2
				}
			}]
		};

		this.bindGroup = device.createBindGroup(bindGroupDesc);
		
		this.pipeline = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts: [this.textureBindGroupLayout, bindGroupLayout]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_filter.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_filter.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-strip',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}]
		});
	}

	onDraw(){
		const {device, renderPassEncoder} = Vulkan;
		const rect = this.drawRect;
		renderPassEncoder.setPipeline(this.pipeline);
		renderPassEncoder.setBindGroup(1, this.bindGroup);
		renderPassEncoder.draw(4, 1, 0, 0);//rect

		this.uniformBuffer.setSubData(0, new Float32Array([
			rect.x / MAX_W, rect.y / MAX_H, rect.width / MAX_W, rect.height / MAX_H,
			rect.x / MAX_W - 1, rect.y / MAX_H + 1, 2 * rect.width / MAX_W, -2 * rect.height / MAX_H,

			//0,0,1,1,
			//-1, 1, 2, -2
		]));
	}
}

class ColorMatrixFilter extends BlurFilter
{
	constructor(){
		super([0,1,1,1]);
	}
}

const MAX_W = 4096;
const MAX_H = 4096;

class Bitmap3DManager
{
	constructor(){
		this.rectPack = new MaxRectsBinPack(MAX_W, MAX_H);
		this.frameBuffer = Vulkan.device.createTexture({
			size: [MAX_W, MAX_H, 1],
			format: Vulkan.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
		});
		this.depthBuffer = createDepthTexture(MAX_W, MAX_H);
		this.elementList = [];

		const frameView = this.frameBuffer.createView();
		const depthView = this.depthBuffer.createView();
		this.frameView = frameView;
		this.renderPassDesc = {
			colorAttachments: [{
				attachment: frameView,
				loadValue: [0,0,0,0]
			}],
			depthStencilAttachment: {
				attachment: depthView,
				depthLoadValue: 1.0,
				depthStoreOp: 'store',
				stencilLoadValue: 0,
				stencilStoreOp: 'store'
			}
		};
	}

	onCollect(item){
		if(item instanceof Bitmap3D){
			this.elementList.push(item);
		}
	}

	draw(root){
		traverseTree.call(this, root, this.onCollect);
		const renderPassEncoder = Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass(this.renderPassDesc);
		for(const bitmap3D of this.elementList){
			const {width, height, texture} = bitmap3D;
			const drawRect = this.rectPack.insert(width, height);
			texture.rawTexture = this.frameView;
			texture.setUV(MAX_W, MAX_H, drawRect, false);
			renderPassEncoder.setViewport(drawRect.x, drawRect.y, drawRect.width, drawRect.height, 0, 1);
			bitmap3D.camera.draw(bitmap3D.root3d);
		}
		renderPassEncoder.endPass();
		this.rectPack.clear();
		this.elementList.length = 0;
	}
}

class FilterSwapChain
{
	constructor(){
		this.rectPack = new MaxRectsBinPack(MAX_W, MAX_H);
		this.frameBufferA = Vulkan.device.createTexture({
			size: [MAX_W, MAX_H, 1],
			format: Vulkan.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
		});
		this.frameBufferB = Vulkan.device.createTexture({
			size: [MAX_W, MAX_H, 1],
			format: Vulkan.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
		});
	}
}

class DisplayObject3D extends Transform
{
	constructor(){
		super(Mat3x4);
		this.visible = true;
		this.castShadow = false;
		this.mouseEnabled = true;
		this.mouseChildren = true;
	}

	isVisible(){
		return this.visible;
	}

	onChildAdding(child){
		if(child.parent){
			if(child.parent === this){
				return child;
			}
			child.parent.removeChild(child);
		}
	}

	onChildAdded(child){
		child._parent = this;
		child.markWorldMatrixDirty();

		this.root.events.emit('childAdded', child);
	}

	onChildRemoved(child){
		child._parent = null;
		child.markWorldMatrixDirty();

		this.root.events.emit('childRemoved', child);
	}
}

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialDict = new Map();

		if(!(createSkeleton && mesh.boneList.length > 0))return;
		this.buildBoneTree();
		this.animationList = mesh.animationList;
		this.animation = this.animationList[20] || this.animationList[0];
		this.animationTime = 0;
	}

	addMaterial(material){
		const materialType = material.constructor;
		if(!materialType.initFlag){
			materialType.initFlag = true;
			materialType.onInit?.();
		}
		this.materialDict.set(material.constructor, material);
		return this;
	}

	getMaterial(materialType){
		return this.materialDict.get(materialType);
	}

	onDraw(){}

	onUpdate(){
		const {animation, animationTime} = this;
		if(animation){
			let timeElapsed = 1000 / 60;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(this.attachmentDict){
			for(const [attachment] of this.attachmentDict){
				updateTree(attachment);
			}
		}
		if(!this._skeleton){
			this.rootBone?.updateBone(this);
		}
	}

	buildBoneTree(){
		const boneDict = Object.create(null);
		const boneList = [];
		let rootBone;
		for(let {boneName, boneID, bonePID} of this.mesh.boneList){
			let boneParent = bonePID < 0 ? null : boneList[bonePID];
			let bone = new BoneObject(boneParent, boneID);

			boneDict[boneName] = bone;
			boneList[boneID] = bone;

			if(bonePID >= 0){
				boneParent.addChild(bone);
			}else if(rootBone){
				rootBone.addSibling(bone);
			}else{
				rootBone = bone;
			}
		}
		rootBone.boneDict = boneDict;
		this.rootBone = rootBone;
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton || this;
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		if(!this.attachmentDict){
			this.attachmentDict = new Map();
		}
		if(clearOtherObjects)this.unbindObjects(boneName);
		this.attachmentDict.set(target, boneName);
	}

	unbindObject(target){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		attachmentDict.delete(target);
	}

	unbindObjects(boneName){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		if(boneName == null){
			attachmentDict.clear();
			return;
		}
		for(const [attachment, name] of attachmentDict){
			if(name != boneName)continue;
			attachmentDict.delete(attachment);
		}
	}
}

function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}

class Material{
	static order = 0;
	static maxCountPerBatch = 1;
	/*
	static calcDrawCount(entityCount){
		return Math.ceil(entityCount / this.maxCountPerBatch);
	}
	*/
	get group(){
		return 0;
	}

	static draw(entityList){
		const {transformUniformMgr} = Vulkan;
		this.onDraw(drawBatched.call(transformUniformMgr, this.maxCountPerBatch, entityList, transformUniformMgr.register));
	}
}
class TextureMaterial extends Material{
	//static maxCountPerBatch = 10;
	static get pipeline(){
		return Vulkan.pipelineDict.pipeline;
	}
	static onDraw(infoList){
		const {transformUniformCache} = Vulkan.transformUniformMgr;
		const {renderPassEncoder, device, currentMesh} = Vulkan;
		const {maxCountPerBatch} = this;
		for(const subMesh of currentMesh.subMeshList){
			if(!subMesh.texture)continue;
			const {vertexCount, vertexOffset} = subMesh;
			let texture = Vulkan.fetchTexture(subMesh.texture);
			if(!texture)continue;
			renderPassEncoder.setBindGroup(2, device.createBindGroup({
				layout: Vulkan.bindGroupLayoutDict.bindGroupLayout3,
				entries: [{
					binding: 0,
					resource: texture.createView()
				}]
			}));
			for(const [index, offset, count] of infoList){
				renderPassEncoder.setBindGroup(1, transformUniformCache(index));
				renderPassEncoder.draw(vertexCount, count, vertexOffset, offset);
			}
		}
	}
	constructor(){
		super();
	}
}
class ColorMaterial extends Material{
	//static maxCountPerBatch = 10;
	static get pipeline(){
		return Vulkan.pipelineDict.pipelineColor;
	}
	static onInit(){
		class T{
			constructor(){
				this.uniformCache = createUniformBufferListCache(
					Vulkan.bindGroupLayoutDict.bindGroupLayout4,
					10 * 4 * 4
				);
				this.dict = new Map();
			}

			reset(){
				this.dict.clear();
			}

			call(index, offset, value){
				const {dict, uniformCache} = this;
				if(!dict.has(index)){
					dict.set(index, dict.size);
				}
				return uniformCache(dict.get(index), offset, value);
			}
		}
		Vulkan.regMgr('colorDataMgr', new T());
	}
	static onDraw(infoList){
		const {transformUniformCache} = Vulkan.transformUniformMgr;
		const {renderPassEncoder, currentMesh} = Vulkan;
		const {maxCountPerBatch} = this;
		for(const [index, offset, count] of infoList){
			renderPassEncoder.setBindGroup(2, Vulkan.colorDataMgr.call(index));
			renderPassEncoder.setBindGroup(1, transformUniformCache(index));
			renderPassEncoder.draw(currentMesh.vertexCount, count, 0, offset);
		}
	}

	static onUpdateBuffer(instance, i, [index, offset]){
		Vulkan.colorDataMgr.call(index, 16 * (offset + i), new Float32Array(instance.getMaterial(this).color));
	}
	
	constructor(color){
		super();
		this.color = color;
	}
}

class TerrainMaterial extends Material{
	static get pipeline(){
		return Vulkan.pipelineDict.pipelineTerrain;
	}
	static onDraw(){
		const {renderPassEncoder, currentMesh, device} = Vulkan;
		if(!this.bindGroup){
			this.bindGroup = device.createBindGroup({
				layout: Vulkan.bindGroupLayoutDict.bindGroupLayout5,
				entries: [{
					binding: 0,
					resource: this.texture
				}]
			});
		}
		renderPassEncoder.setBindGroup(1, this.bindGroup);
		renderPassEncoder.drawIndexed(currentMesh.indexCount, 1, 0, 0, 0);
	}
	static onUpdateBuffer(instance){
		this.texture = instance.getMaterial(this).texture;
	}
	constructor(texture){
		super();
		this.texture = texture;
	}
}

function createVertexBufferListCache(size=0x10000){
	const bufferList = [];
	return function(batchIndex, offset, value){
		const {device} = Vulkan;
		let buffer = bufferList[batchIndex];
		if(buffer == null){
			buffer = bufferList[batchIndex] = device.createBuffer({
				size,
				usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
			});
		}
		return value ? buffer.setSubData(offset, value) : buffer;
	}
}

function createUniformBufferListCache(layout, size=0x10000){
	const bufferList = [];
	const bindGroupList = [];
	return function(batchIndex, offset, value){
		const {device} = Vulkan;
		let uniformBuffer = bufferList[batchIndex];
		if(uniformBuffer == null){
			uniformBuffer = bufferList[batchIndex] = device.createBuffer({
				size,
				usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
			});
			bindGroupList[batchIndex] = device.createBindGroup({
				layout,
				entries: [{
					binding: 0,
					resource: {buffer: uniformBuffer}
				}]
			});
		}
		return value ? uniformBuffer.setSubData(offset, value) : bindGroupList[batchIndex];
	}
}

class Alloter
{
	constructor(){
		this.index = 0;
		this.maxCount = 4;
		this.waitList = [];
	}

	reset(){
		this.index = 0;
		this.waitList.length = 0;
	}

	add(count){
		const {maxCount, waitList} = this;
		if(count > maxCount)return;
		if(count < maxCount){
			for(let i=0, n=waitList.length; i<n; ++i){
				const info = waitList[i];
				const [index, offset] = info;
				const newOffset = offset + count;
				if(newOffset > maxCount)continue;
				if(newOffset == maxCount){
					waitList.splice(i, 1);
				}else{
					waitList[i] = [index, newOffset];
				}
				return info;
			}
			waitList.push([this.index, count]);
		}
		return [this.index++, 0];
	}
}

class TransformUniformManager
{
	constructor(){
		this.transformUniformCache = createUniformBufferListCache(
			Vulkan.bindGroupLayoutDict.bindGroupLayout2
		);
		this.alloter = new Alloter();
	}

	reset(){
		this.alloter.reset();
	}

	register(instanceList, offset, instanceCount){
		const info = this.alloter.add(instanceCount);
		info[2] = instanceCount;
		const {currentMaterial} = Vulkan;
		for(let i=0; i<instanceCount; ++i){
			let instance = instanceList[offset+i];
			currentMaterial.onUpdateBuffer?.(instance, i, info);
			objectBuffer3D.set(instance.worldTransform.rawData);
			instance.skeleton.rootBone?.copyToBuffer(objectBuffer3D);
			this.transformUniformCache(info[0], objectBuffer3D.byteLength * (info[1] + i), objectBuffer3D);
		}
		return info;
	}
}

const ObjectCache = require('utils/ObjectCache');
const ObjectBucket = require('ds/ObjectBucket');

const mapObjCache = new ObjectCache(Map, v => v.clear());

class DrawUnitBucket extends ObjectBucket
{
	constructor(){
		super();
		this.regKeyFn(getMaterialType, updateMaterialType, sortMaterialType);
		this.regKeyFn(getMesh, updateMesh);
	}

	newMap(){
		return mapObjCache.getOut();
	}

	add(element, override){
		if(!element.visible)return true;
		if(element.attachmentDict){
			for(const [attachment, boneName] of element.attachmentDict){
				this.add(attachment);
				const {worldTransform} = attachment;
				worldTransform.copyFrom(element.skeleton.rootBone.getBoneWorldMatrix(boneName));
				worldTransform.prepend(attachment.transform);
				worldTransform.append(element.worldTransform);
			}
		}
		if(!element.materialDict)return;
		for(const materialType of element.materialDict.keys()){
			super.add(element, materialType);
		}
	}

	clear(){
		super.clear();
		mapObjCache.putAllIn();
	}

	draw(){
		this.forEach(this.onMaterialDraw, this);
		return this;
	}

	onMaterialDraw(entityList){
		Vulkan.currentMaterial.draw(entityList);
	}
}

const objectBuffer3D = new Float32Array(515*4);

const sortMaterialType = (fn => list => list.sort(fn))((a, b) => a.order - b.order);

function getMaterialType(drawUnit, key){
	let material = drawUnit.getMaterial(key);
	//let material = key ? drawUnit[key] : drawUnit.material;
	return material.constructor;
}

function getMesh(drawUnit, key){
	return drawUnit.mesh;
}

function updateMaterialType(materialType){
	const {renderPassEncoder} = Vulkan;
	Vulkan.currentMaterial = materialType;
	renderPassEncoder.setPipeline(materialType.pipeline);
}

function updateMesh(mesh){
	const {renderPassEncoder, device} = Vulkan;
	if(!mesh._vertexBuffer){
		mesh._vertexBuffer = createBufferMapped(GPUBufferUsage.VERTEX, mesh.vertexData);;
		if(mesh.indexData){
			mesh._indexBuffer = createBufferMapped(GPUBufferUsage.INDEX, mesh.indexData);
		}
	}
	Vulkan.currentMesh = mesh;
	renderPassEncoder.setVertexBuffer(0, mesh._vertexBuffer);
	if(mesh._indexBuffer){
		renderPassEncoder.setIndexBuffer(mesh._indexBuffer);
	}
}

function createBufferMapped(usage, data){
	const {device} = Vulkan;
	const [buffer, mapping] = device.createBufferMapped({usage, size: data.byteLength});
	new data.constructor(mapping).set(data);
	buffer.unmap();
	return buffer;
}

function copyDataToBuffer(buffer, data, offset=0){
	const {commandEncoder} = Vulkan;
	const copyBuffer = createBufferMapped(GPUBufferUsage.COPY_SRC, data);
	commandEncoder.copyBufferToBuffer(copyBuffer, 0, buffer, offset, data.byteLength);
	//copyBuffer.destroy();
	return copyBuffer;
}

function createDepthTexture(width, height){
	const {device} = Vulkan;
	return device.createTexture({
		size: [width, height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT
	});
}

class Label extends DisplayObject2D
{
	constructor(){
		super();
		this.fontSize = 12;
	}

	get text(){
		return this._text;
	}

	set text(value){
		this._text = value;
	}

	onDraw(mode){
		if(!this._text)return;
		const {worldTransform, fontSize} = this;
		const {bitmapQueue, textMgr} = Vulkan;
		for(let bitmap of textMgr.getTextBitmap(worldTransform, this._text, fontSize)){
			bitmapQueue.add(bitmap);
		}
	}
}

class TextManager
{
	constructor(){
		const {device} = Vulkan;
		this.rectPack = new MaxRectsBinPack(MAX_W, MAX_H);
		this.fontDict = new Map();
		this.context = createCanvasContext(MAX_W, MAX_H);
		this.rawTexture = device.createTexture({
			size: [MAX_W, MAX_H, 1],
			format: 'rgba8unorm',
			usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
		});
		this.dirtyRectList = [];
	}

	getCharTexture2D(char, fontSize){
		const {rawTexture, fontDict, rectPack, context, dirtyRectList} = this;
		if(!fontDict.has(fontSize)){
			fontDict.set(fontSize, new Map());
		}
		const charDict = fontDict.get(fontSize);
		if(!charDict.has(char)){
			const textRect = calcTextRect(context, char);
			const packRect = rectPack.insert(textRect.width, textRect.height);
			const texture = new Texture2D(rawTexture.createView());
			texture.setUV(MAX_W, MAX_H, packRect, false);
			texture.xyuvAdd[1] = fontSize - textRect.y;
			charDict.set(char, texture);
			context.fillText(char, packRect.x + textRect.x, packRect.y + textRect.y);
			dirtyRectList.push(packRect);
		}
		return charDict.get(char);
	}

	needUpdate(text, fontSize){
		let list = text.split('').filter(v => /\S/.test(v));
		if(list.length <= 0)return false;
		const {fontDict} = this;
		if(!fontDict.has(fontSize))return true;
		const charDict = fontDict.get(fontSize);
		return !list.every(v => charDict.has(v));
	}

	*getTextBitmap(matrix, text, fontSize){
		const {context, dirtyRectList} = this;
		context.font = `${fontSize}px 微软雅黑`;
		let offset = 0;
		for(let i=0; i<text.length; ++i){
			let char = text.charAt(i);
			const texture = this.getCharTexture2D(char, fontSize);
			let worldTransform = matrix.clone();
			worldTransform.translate(offset, 0);
			offset += texture.width;
			yield {
				width: texture.width,
				height: texture.height,
				worldTransform, texture
			};
		}
		if(dirtyRectList.length > 0){
			const {device} = Vulkan;
			const area = Rect.Merge(dirtyRectList);
			createImageBitmap(context.canvas, area.x, area.y, area.width, area.height).then(imageBitmap => {
				device.defaultQueue.copyImageBitmapToTexture(
					{imageBitmap},
					{texture:this.rawTexture, origin: [area.x, area.y, 0]},
					[area.width, area.height, 1]
				);
			});
			dirtyRectList.length = 0;
		}
	}
}

function calcTextRect(context, char){
	let metrics = context.measureText(char);
	return {
		x: metrics.actualBoundingBoxLeft,
		y: metrics.actualBoundingBoxAscent,
		width: metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight,
		height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
	};
}

function createCanvasContext(width, height){
	let canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;
	let context = canvas.getContext('2d');
	context.fillStyle = '#FFFFFF';
	context.strokeStyle = 'green';
	context.textBaseline = 'ideographic';//bottom,top
	/*
	canvas.setAttribute('style', 'position: absolute;left: 0;');
	document.body.appendChild(canvas)
	context.fillText("你好,world", 100, 30);
	//*/
	return context;
}

exports.Vulkan = Vulkan;
exports.View3D = View3D;
exports.Bitmap = Bitmap;
exports.Bitmap3D = Bitmap3D;
exports.BlurFilter = BlurFilter;
exports.ColorMatrixFilter = ColorMatrixFilter;
exports.MeshEntity = MeshEntity;
exports.Camera3D = Camera3D;
exports.Lens = Lens;
exports.Label = Label;
exports.TextureMaterial = TextureMaterial;
exports.ColorMaterial = ColorMaterial;
exports.TerrainMaterial = TerrainMaterial;
