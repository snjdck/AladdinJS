'use strict';

const DisplayObject2D = require('opengl/DisplayObject2D');
const traverseTree = require('utils/traverseTree');
const batchDraw = require('opengl/renderers/batchDraw');
const BitmapQueue = require('opengl/renderers/BitmapQueue');
const {createMeshIndices} = require('utils/geometry');

const Vulkan = {
	bitmapQueue: new BitmapQueue(v => v.texture.getRawAsset())
};
Object.defineProperties(Vulkan, {
	_default2DRenderPassDesc:{
		value: {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load',
				storeOp: 'store'
			}],
			depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 'load',
				depthStoreOp: 'store',
				stencilLoadValue: 'load',
				stencilStoreOp: 'store'
			}
		}
	},
	_renderPassDescStack:{value:[]},
	_currentRenderPassDesc:{value:null, writable:true},
	setRenderPassDesc:{value(desc, colorAttachments, depthStencilAttachment){
		if(colorAttachments)colorAttachments.forEach((v, i) => desc.colorAttachments[i].attachment = v);
		if(depthStencilAttachment)desc.depthStencilAttachment.attachment = depthStencilAttachment;
	}},
	copyRenderPassDesc:{value(from, to, loadValue='load', depthLoadValue='load', stencilLoadValue='load'){
		to.colorAttachments.forEach((v, i) => v.attachment = from.colorAttachments[i].attachment);
		to.depthStencilAttachment.attachment = from.depthStencilAttachment.attachment;
	}},
	pushRenderPass:{value(desc, colorAttachments, depthStencilAttachment){
		this.setRenderPassDesc(desc, colorAttachments, depthStencilAttachment);
		this._currentRenderPassDesc = desc;
		return this.renderPassEncoder = this.commandEncoder.beginRenderPass(desc);
	}},
	popRenderPass:{value(){
		this.renderPassEncoder.endPass();
		this.renderPassEncoder = null;
		this._currentRenderPassDesc = null;
	}},
	saveRenderPass:{value(){
		this._renderPassDescStack.push(this._currentRenderPassDesc);
	}},
	loadRenderPass:{value(){
		const desc = this._currentRenderPassDesc = this._renderPassDescStack.pop();
		const {depthStencilAttachment} = desc;
		desc.colorAttachments.forEach(v => v.loadValue = 'load');
		if(depthStencilAttachment){
			depthStencilAttachment.depthLoadValue = 'load';
			depthStencilAttachment.stencilLoadValue = 'load';
		}
		return this.renderPassEncoder = this.commandEncoder.beginRenderPass(desc);
	}},
});

const frameDo = fn => requestAnimationFrame(function loop(){
	requestAnimationFrame(loop);
	fn();
});

class Scene3D
{
	constructor(){
		this.renderPassDesc = {
			colorAttachments: [{
				attachment: null,
				loadValue: [0,0,0,1]
			}],
			depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 1.0,
				depthStoreOp: 'store',
				stencilLoadValue: 0,
				stencilStoreOp: 'store'
			}
		};
	}

	update(){

	}

	draw(){
		const {renderPassDesc} = this;
		const {commandEncoder, mainColorTexture, mainDepthStencil} = Vulkan;

		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture], mainDepthStencil);
		Vulkan.popRenderPass();
	}
}

class Scene2D
{
	constructor(){
		const maxDrawCount = 100;
		this.root = new DisplayObject2D();
		this.root._scene = this;
		this.batchDraw = batchDraw.bind(this, maxDrawCount);

		const {device} = Vulkan;
		const vertexData = new Float32Array(instanceFloatCount * maxDrawCount);
		const vertexBuffer = device.createBuffer({
			size: vertexData.byteLength,
			usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
		});
		const [indexBuffer, indexData] = device.createBufferMapped({
			size: 54 * 2,
			usage: GPUBufferUsage.INDEX
		});
		new Uint16Array(indexData).set(createMeshIndices(4, 4));
		indexBuffer.unmap();

		this.vertexBuffer = vertexBuffer;
		this.indexBuffer = indexBuffer;
		this.vertexData = vertexData;

		this.renderPassDesc = {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load'
			}],
			depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 1.0,
				depthStoreOp: 'store',
				stencilLoadValue: 0,
				stencilStoreOp: 'store'
			}
		};
	}

	initRenderPassEncoder(){
		const {vertexBuffer, indexBuffer} = this;
		const {renderPassEncoder, pipeline2D} = Vulkan;
		renderPassEncoder.setPipeline(pipeline2D);
		renderPassEncoder.setVertexBuffer(0, vertexBuffer);
		renderPassEncoder.setIndexBuffer(indexBuffer);
	}

	update(){
		traverseTree.call(null, this.root, this.onUpdate);
	}

	draw(){
		const {vertexBuffer, vertexData, renderPassDesc} = this;
		const {mainColorTexture, mainDepthStencil} = Vulkan;

		Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture], mainDepthStencil);

		this.initRenderPassEncoder();
		this.totalDrawCount = 0;
		traverseTree.call(null, this.root, this.onDraw);

		this.submit();
		vertexBuffer.setSubData(0, vertexData);
	}

	onUpdate(item){
		if(!item.visible)return true;
		const {onUpdate} = item;
		return onUpdate && onUpdate.apply(item);
	}

	submit(){
		const {bitmapQueue} = Vulkan;
		bitmapQueue.draw(this.onBatchDraw, this).clear();
		Vulkan.popRenderPass();
	}

	onDraw(item){
		if(!item.visible)return true;
		const {filter, onDraw} = item;
		const filterFlag = !this && filter;
		if(filterFlag)filter.onDrawBegin(item);
		if(onDraw)onDraw.call(item, this);
		return filterFlag && filter.onDrawEnd;
	}

	onBatchDraw(instanceList){
		const {device, renderPassEncoder, bindGroupDesc} = Vulkan;
		const texture = instanceList[0].texture.getRawAsset();
		bindGroupDesc.bindings[2].resource = texture;
		renderPassEncoder.setBindGroup(0, device.createBindGroup(bindGroupDesc));
		this.batchDraw(instanceList);
	}

	onUpdateBufferBatch(instanceList, offset, instanceCount, batchIndex){
		const {vertexData, totalDrawCount} = this;
		for(let i=0; i<instanceCount; ++i){
			const {worldTransform, texture, width, height, fgColor} = instanceList[offset+i];
			worldTransform.copyToArray(tempList, 0, 3);
			const j = instanceFloatCount * (i + totalDrawCount);
			vertexData.set(tempList, j);
			if(texture){
				vertexData.set(texture.xyuvMul, j+6);
				vertexData.set(texture.xyuvAdd, j+10);
				vertexData.set(texture.scale9grid, j+18);
				vertexData[j+14] = width;
				vertexData[j+15] = texture.width;
				vertexData[j+16] = height;
				vertexData[j+17] = texture.height;
			}else{
				vertexData.set(allOne, j+6);
				vertexData.set(allZero, j+10);
				vertexData.set(allZero, j+18);
				vertexData[j+14] = width;
				vertexData[j+15] = width;
				vertexData[j+16] = height;
				vertexData[j+17] = height;
			}
		}
	}

	onUploadBufferAndDraw(instanceCount){
		const {renderPassEncoder} = Vulkan;
		renderPassEncoder.drawIndexed(triangleCount, instanceCount, 0, 0, this.totalDrawCount);
		this.totalDrawCount += instanceCount;
	}
}

const tempList = new Array(6);
const allZero = new Float32Array(4);
const allOne = new Float32Array(4).fill(1);

const instanceFloatCount = 22;
const instanceByteSize = instanceFloatCount << 2;

const vertexCountX = 4;
const vertexCountY = 4;
const triangleCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.


class View3D
{
	constructor(){
		this.scene3d = new Scene3D();
		this.scene2d = new Scene2D();
		frameDo(this.onTick.bind(this));

		const {device, canvas} = Vulkan;

		this.depthTexture = device.createTexture({
			size: [canvas.width, canvas.height, 1],
			format: 'depth24plus-stencil8',
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
			dimension: '2d',//optional, default 2d(1d, 3d)
		});
	}

	onTick(){
		this.updateScene();
		this.drawScene();
	}

	updateScene(){
		this.scene3d.update();
		this.scene2d.update();
	}

	drawScene(){
		const {device, swapChain} = Vulkan;
		const {depthTexture} = this;

		const mainColorTexture = swapChain.getCurrentTexture().createView();
		const mainDepthStencil = depthTexture.createView();

		const commandEncoder = device.createCommandEncoder();

		Vulkan.commandEncoder = commandEncoder;
		Vulkan.mainColorTexture = mainColorTexture;
		Vulkan.mainDepthStencil = mainDepthStencil;

		console.log(Vulkan._renderPassDescStack.length)

		this.scene3d.draw();
		this.scene2d.draw();

		device.defaultQueue.submit([commandEncoder.finish()]);
	}
}

class Bitmap extends DisplayObject2D
{
	constructor(){
		super();
		this._texture = null;
		this.width = 0;
		this.height = 0;
	}

	get texture(){
		return this._texture;
	}

	set texture(value){
		this._texture = value;
		if(value == null){
			return;
		}
		this.width = value.width;
		this.height = value.height;
	}

	onDraw(mode){
		const {bitmapQueue} = Vulkan;
		bitmapQueue.add(this);
	}
}

class Filter2D
{
	constructor(){
		this.renderPassDesc = {
			colorAttachments: [{
				attachment: null,
				loadValue: [0,0,0,0]
			}],
			depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 'load',
				depthStoreOp: 'store',
				stencilLoadValue: 'load',
				stencilStoreOp: 'store'
			}
		};

		this.restoreRenderPassDesc = {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load'
			}],
			depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 'load',
				depthStoreOp: 'store',
				stencilLoadValue: 'load',
				stencilStoreOp: 'store'
			}
		};
	}
	onDraw(image, address){}

	onDrawBegin(item){
		const {renderPassDesc} = this;
		const {mainDepthStencil} = Vulkan;

		Vulkan.saveRenderPass();

		item.scene.submit();

		Vulkan.pushRenderPass(renderPassDesc, [this.frameBuffer.createView()], mainDepthStencil);

		item.scene.initRenderPassEncoder();

		//renderPassEncoder.setViewport(-220, 0, canvas.width, canvas.height, 0, 1);
	}

	onDrawEnd(item){
		const {filterBindGroup, filterUniformBuffer, restoreRenderPassDesc} = item.filter;
		const {filterPipeline} = Vulkan;
		item.scene.submit();

		const renderPassEncoder = Vulkan.loadRenderPass();

		renderPassEncoder.setPipeline(filterPipeline);
		renderPassEncoder.setBindGroup(0, filterBindGroup);
		renderPassEncoder.draw(4, 1, 0, 0);//rect

		filterUniformBuffer.setSubData(0, new Float32Array([
			0, 0, 1, 1,
			-1, 1, 2, -2
		]));

		item.scene.initRenderPassEncoder();
	}
}

class BlurFilter extends Filter2D
{
	constructor(){
		super();
		const {device, canvas, bindGroupLayout} = Vulkan;
		this.frameBuffer = device.createTexture({
			size: [canvas.width, canvas.height, 1],
			format: 'bgra8unorm',
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
		});

		const filterUniformBuffer = device.createBuffer({
			size: 8 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});

		const sampler = device.createSampler({
			magFilter: 'linear',
			minFilter: 'linear',
		});

		this.filterBindGroup = device.createBindGroup({
			layout: bindGroupLayout,
			bindings: [{
				binding: 0,
				resource: {
					buffer: filterUniformBuffer
				}
			},{
				binding: 1,
				resource: sampler
			},{
				binding: 2,
				resource: this.frameBuffer.createView()
			}]
		});

		this.filterUniformBuffer = filterUniformBuffer;
	}
}

exports.Vulkan = Vulkan;
exports.View3D = View3D;
exports.Bitmap = Bitmap;
exports.BlurFilter = BlurFilter;
