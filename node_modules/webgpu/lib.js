'use strict';

const ObjectCache = require('utils/ObjectCache');
const DrawUnitBucket = require('./DrawUnitBucket');
const DisplayObject = require('./DisplayObject');
const DisplayObject2D = require('./DisplayObject2D');
const DisplayObject3D = require('./DisplayObject3D');
const traverseTree = require('utils/traverseTree');
const BitmapQueue = require('opengl/renderers/BitmapQueue');
//const {createMeshIndices} = require('utils/geometry');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const overrideMethod = require('utils/function/overrideMethod');
const {loadData} = require('utils/loader');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');
const Matrix2D = require('opengl/math/Matrix2D');
const {Texture2D} = require('opengl/textures');
const Mat3x4 = require('./mat3x4');
//const collectAllTypes = require('utils/class/collectAllTypes');
const ArrayValueMap = require('ds/ArrayValueMap');
const BoneObject = require('opengl/3d/BoneObject');

const TextManager = require('./managers/TextManager');
const VertexBufferManager = require('./managers/VertexBufferManager');
const TransformUniformManager = require('./managers/TransformUniformManager');
const DirectBufferManager = require('./managers/DirectBufferManager');
const MouseManager = require('./managers/MouseManager');

const Material = require('./materials/Material')
const TextureMaterial = require('./materials/TextureMaterial')
const ColorMaterial = require('./materials/ColorMaterial')
const BoundMaterial = require('./materials/BoundMaterial')
const TerrainMaterial = require('./materials/TerrainMaterial')
const WireframeMaterial = require('./materials/WireframeMaterial')

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	return view;
});

const Vulkan = require('./Vulkan');
Vulkan.fetchTexture = createFetch(function(name, callback){
	const {device} = this;
	if(name.endsWith('.tga')){
		loadData(name, 'arraybuffer').then(data => {
			let image = imageUtil.decode(name, data);
			const texture = device.createTexture({
				size: [image.width, image.height, 1],
				format: 'rgba8unorm',
				usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
			});
			texture.transparent = true;
			texture.name = name;
			texture.width = image.width;
			texture.height = image.height;
			createImageBitmap(
				new ImageData(new Uint8ClampedArray(image.data), image.width, image.height)
			).then(imageBitmap => {
				device.defaultQueue.copyImageBitmapToTexture(
					{imageBitmap},
					{texture, mipLevel: 0, origin: [0, 0, 0]},
					[image.width, image.height, 1]
				);
				callback(texture);
			});
		});
	}else{
		this.loadTexture(this.device, name).then(callback);
	}
});
Vulkan.loadModel = async path => parse(new Uint8Array(await loadData(path, 'arraybuffer')));
Vulkan.loadTexture = async (device, path) => {
	const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path));
	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
	});
	device.defaultQueue.copyImageBitmapToTexture(
		{imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);
	texture.transparent = false;
	texture.name = path;
	texture.width = imageBitmap.width;
	texture.height = imageBitmap.height;
	return texture;
};

Vulkan.loadImage = async path => {
	let image = new Image();
	image.src = path;
	await image.decode();
	return image;
};
Object.defineProperties(Vulkan, {
	swapChainFormat: {value: 'bgra8unorm'},
	_default2DRenderPassDesc:{
		value: {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load',
				storeOp: 'store'
			}],
			/*depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 'load',
				depthStoreOp: 'store',
				stencilLoadValue: 'load',
				stencilStoreOp: 'store'
			}*/
		}
	},
	init:{value(device, canvas){
		this.device = device;
		this.canvas = canvas;
		this.swapChain = canvas.getContext('gpupresent').configureSwapChain({
			device,
			format: this.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT
		});
		this.mgrList = [];
		this.filterSwapChain = new FilterSwapChain();
		this.textMgr = new TextManager();
		this.collectBitmap3Ds = Bitmap3DCollector();
		this.collectFilter2Ds = Filter2DCollector();
		this.render2D = createRender2D();
		Filter2D.Init();
		preparePipelines();
		this.drawBitmapQueue = function(){
			const textureBindGroupDesc = {
				layout: Vulkan.bindGroupLayoutDict.bindGroupLayout3,
				entries: [{binding: 0,
					resource: null//bind later
				}]
			};
			function onBatchDraw(instanceList){
				const {device, renderPassEncoder} = Vulkan;
				const texture = instanceList[0].texture.getRawAsset();
				textureBindGroupDesc.entries[0].resource = texture;
				renderPassEncoder.setBindGroup(1, device.createBindGroup(textureBindGroupDesc));
				Vulkan.vertexBufferMgr.draw(instanceList);
			}
			return function(){
				Vulkan.bitmapQueue.draw(onBatchDraw).clear();
			}
		}();
		this.prepareDraw2D = function(){
			const {device, canvas} = Vulkan;

			//const indexBuffer = createBufferMapped(GPUBufferUsage.INDEX, new Uint16Array(createMeshIndices(4, 4)));
			const uniformBuffer = Vulkan.createBufferMapped(GPUBufferUsage.UNIFORM, new Float32Array([2 / canvas.width, -2 / canvas.height]));

			const bindGroup = device.createBindGroup({
				layout: Vulkan.bindGroupLayoutDict.bindGroupLayout,
				entries: [{
					binding: 0,
					resource: {buffer: uniformBuffer}
				},{	binding: 1,
					resource: device.createSampler({
						magFilter: 'linear',
						minFilter: 'linear',
					})
				}]
			});

			return function(){
				const {renderPassEncoder, pipelineDict} = Vulkan;
				renderPassEncoder.setPipeline(pipelineDict.pipeline2D);
				//renderPassEncoder.setVertexBuffer(0, this.vertexBuffer);
				//renderPassEncoder.setIndexBuffer(indexBuffer);
				renderPassEncoder.setBindGroup(0, bindGroup);
			}
		}();
		this.regMgr('transformUniformMgr', new TransformUniformManager());
		this.regMgr('vertexBufferMgr', new VertexBufferManager());
		this.regMgr('directBufferMgr', new DirectBufferManager());
		this.regMgr('mouseMgr', new MouseManager());
		this.regMgr('camera3DGPUResourceMgr', new Camera3DGPUResourceMgr());
	}},
	regMgr:{value(name, value){
		this[name] = value;
		this.mgrList.push(value);
	}},
	resetManagers:{value(){
		this.mgrList.forEach(v => v.reset?.());
	}},
	updateManagers:{value(){
		this.mgrList.forEach(v => v.onUpdate?.());
	}},
	setRenderPassDesc:{value(desc, colorAttachments, depthStencilAttachment){
		if(colorAttachments)colorAttachments.forEach((v, i) => desc.colorAttachments[i].attachment = v);
		if(desc.depthStencilAttachment)desc.depthStencilAttachment.attachment = depthStencilAttachment;
	}},
	copyRenderPassDesc:{value(from, to, loadValue='load', depthLoadValue='load', stencilLoadValue='load'){
		to.colorAttachments.forEach((v, i) => v.attachment = from.colorAttachments[i].attachment);
		to.depthStencilAttachment.attachment = from.depthStencilAttachment.attachment;
	}},
	pushRenderPass:{value(desc, colorAttachments, depthStencilAttachment){
		this.setRenderPassDesc(desc, colorAttachments, depthStencilAttachment);
		//this._currentRenderPassDesc = desc;
		return this.renderPassEncoder = this.commandEncoder.beginRenderPass(desc);
	}},
});
//Object.seal(Vulkan);

function preparePipelines(){
	const {device} = Vulkan;
	Vulkan.bindGroupLayoutDict.bindGroupLayout = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.VERTEX,
			type: 'uniform-buffer',
		},{binding: 1,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampler'
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout2 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
			type: 'uniform-buffer',
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout3 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampled-texture'
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout4 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'uniform-buffer',
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout5 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampled-texture',
			viewDimension: '2d-array',
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayoutCull = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.COMPUTE,
			type: 'storage-buffer',
		}]
	});

	function createPipelineDesc3D(bindGroupLayouts, vertexCode, fragmentCode, primitiveTopology='triangle-list'){
		return {
			layout: device.createPipelineLayout({
				bindGroupLayouts
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology,
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			},
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: 9 << 2,
					stepMode: 'vertex',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'float3'
					},{
						shaderLocation: 1,
						offset: 3 << 2,
						format: 'float3'
					},{
						shaderLocation: 2,
						offset: 6 << 2,
						format: 'float2'
					},{
						shaderLocation: 3,
						offset: 8 << 2,
						format: 'uint'
					}]
				}]
			}
		};
	}

	Vulkan.pipelineDict.pipeline = device.createRenderPipeline(createPipelineDesc3D(
		[
			Vulkan.bindGroupLayoutDict.bindGroupLayout,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout3,
		],
		Vulkan.shader_3d.vertexCode,
		Vulkan.shader_3d.fragmentCode,
	));

	Vulkan.pipelineDict.pipelineColor = device.createRenderPipeline(createPipelineDesc3D(
		[
			Vulkan.bindGroupLayoutDict.bindGroupLayout,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout4,
		],
		Vulkan.shader_3d.vertexCode,
		Vulkan.shader_3d_color.fragmentCode,
	));

	Vulkan.pipelineDict.pipelineWireframe = device.createRenderPipeline(createPipelineDesc3D(
		[
			Vulkan.bindGroupLayoutDict.bindGroupLayout,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
		],
		Vulkan.shader_3d.vertexCode,
		Vulkan.shader_bound.fragmentCode,
		'line-list'
	));

	Vulkan.pipelineDict.pipeline2D = device.createRenderPipeline({
		layout: device.createPipelineLayout({
			bindGroupLayouts: [
				Vulkan.bindGroupLayoutDict.bindGroupLayout,
				Vulkan.bindGroupLayoutDict.bindGroupLayout3,
			]
		}),
		vertexStage: {
			module: device.createShaderModule({
				code: Vulkan.shader_2d.vertexCode,
			}),
			entryPoint: 'main'
		},
		fragmentStage: {
			module: device.createShaderModule({
				code: Vulkan.shader_2d.fragmentCode,
			}),
			entryPoint: 'main'
		},
		primitiveTopology: 'triangle-list',
		colorStates:[{
			format: Vulkan.swapChainFormat,
			colorBlend: {
				srcFactor: 'src-alpha',
				dstFactor: 'one-minus-src-alpha',
				operation: 'add'
			},
			alphaBlend: {
				srcFactor: 'src-alpha',
				dstFactor: 'one-minus-src-alpha',
				operation: 'add'
			}
		}],
		vertexState: {
			indexFormat: 'uint16',
			vertexBuffers:[{
				arrayStride: VertexBufferManager.instanceFloatCount << 2,
				stepMode: 'instance',
				attributes:[{
					shaderLocation: 0,
					offset: 0,
					format: 'float3'
				},{
					shaderLocation: 1,
					offset: 3 << 2,
					format: 'float3'
				},{
					shaderLocation: 2,
					offset: 6 << 2,
					format: 'float4'
				},{
					shaderLocation: 3,
					offset: 10 << 2,
					format: 'float4'
				},{
					shaderLocation: 4,
					offset: 14 << 2,
					format: 'float4'
				},{
					shaderLocation: 5,
					offset: 18 << 2,
					format: 'float4'
				}]
			}]
		}
	});

	Vulkan.pipelineDict.pipelineTerrain = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts:[
					Vulkan.bindGroupLayoutDict.bindGroupLayout,
					Vulkan.bindGroupLayoutDict.bindGroupLayout5,
				]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_terrain.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_terrain.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-list',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			},
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: 12,
					stepMode: 'vertex',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'uchar2'
					},{
						shaderLocation: 1,
						offset: 4,
						format: 'uchar2norm'
					},{
						shaderLocation: 2,
						offset: 8,
						format: 'uchar4norm'
					}]
				}]
			}
	});

	Vulkan.pipelineDict.pipelineBound = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts:[
					Vulkan.bindGroupLayoutDict.bindGroupLayout,
					Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			]}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_bound.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_bound.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'line-list',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			}
		});

	Vulkan.pipelineDict.pipelineCull = device.createComputePipeline({
		layout: device.createPipelineLayout({
			bindGroupLayouts:[
				Vulkan.bindGroupLayoutDict.bindGroupLayoutCull,//direct buffer
				Vulkan.bindGroupLayoutDict.bindGroupLayout2,//world matrix
				Vulkan.bindGroupLayoutDict.bindGroupLayout2,//camera
				Vulkan.bindGroupLayoutDict.bindGroupLayout2,//bound
			]
		}),
		computeStage:{
			module: device.createShaderModule({
				code: Vulkan.shader_cull,
			}),
			entryPoint: 'main'
		}
	});
}

const frameDo = fn => requestAnimationFrame(function loop(){
	requestAnimationFrame(loop);
	fn();
});

class Lens
{
	static OrthoLH(width, height, zNear, zFar){
		let matrix = new Float32Array(16);
		matrix[ 0] = 2 / width;
		matrix[ 5] = 2 / height;
		matrix[10] = 1 / (zFar - zNear);
		matrix[11] = zNear / (zNear - zFar);
		matrix[15] = 1;
		return matrix;
	}
}

function Camera3DGPUResourceMgr(){
	const cache = new ObjectCache(() => {
		const {device} = Vulkan;

		const uniformBuffer = device.createBuffer({
			size: 7 * 4 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});

		const mvpBindGroup = device.createBindGroup({
			layout: Vulkan.bindGroupLayoutDict.bindGroupLayout,
			entries: [{
				binding: 0,
				resource: {buffer: uniformBuffer}
			},{	binding: 1,
				resource: device.createSampler({
					addressModeU: 'repeat',
					addressModeV: 'repeat',
					magFilter: 'linear',
					minFilter: 'linear',
				})
			}]
		});

		const cullBindGroup = device.createBindGroup({
			layout: Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			entries: [{
				binding: 0,
				resource: {buffer: uniformBuffer}
			}]
		});

		return {
			uniformBuffer,
			mvpBindGroup,
			cullBindGroup,
		}
	});
	return {
		reset: () => cache.putAllIn(),
		getOut: () => cache.getOut(),
	}
}

function Camera3D(lens){
	const camera = new DisplayObject3D();
	camera.worldTransformInvert = new Mat3x4();
	camera.cullEnabled = false;
	camera.lens = lens;
	return camera;
}

const updateTree = (onUpdate => root => traverseTree(root, onUpdate))(item => item.visible && item.onUpdate?.());

const updateSceneTransform = DisplayObject.updateWorldTransform;

const drawScene2D = function(){
	const renderPassDesc = {
		colorAttachments: [{
			attachment: null,
			loadValue: 'load'
		}]
	};
	function onDraw(item){
		if(!item.visible)return true;
		const {filter} = item;
		if(filter){
			Vulkan.bitmapQueue.add(filter);
			return true;
		}
		Vulkan.render2D.draw(item);
	}
	return function(root){
		const {mainColorTexture, bitmapQueue} = Vulkan;

		Vulkan.collectBitmap3Ds(root);
		Vulkan.collectFilter2Ds(root);

		traverseTree(root, onDraw);
		
		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture]);
		Vulkan.prepareDraw2D();
		Vulkan.drawBitmapQueue();
		renderPassEncoder.endPass();
	}
}();

const drawCamera3D = function(){
	const drawUnitBucket = new DrawUnitBucket();
	return function(camera, root){
		const {lens, worldTransformInvert} = camera;

		Vulkan.currentCamera = camera;

		const {uniformBuffer, mvpBindGroup} = camera._gpuAsset;
		Vulkan.copyDataToBuffer(uniformBuffer, lens);
		Vulkan.copyDataToBuffer(uniformBuffer, worldTransformInvert.rawData, lens.byteLength);

		Vulkan.renderPassEncoder.setBindGroup(0, mvpBindGroup);
		traverseTree.call(drawUnitBucket, root, drawUnitBucket.add);
		drawUnitBucket.draw().clear();
	}
}();

const drawScene3D = function(){
	const renderPassDesc = {
		colorAttachments: [{
			attachment: null,
			loadValue: [0,0,0,1]
		}],
		depthStencilAttachment: {
			attachment: null,
			depthLoadValue: 1.0,
			depthStoreOp: 'store',
			depthReadOnly: true,//default false, optional
			stencilLoadValue: 0,
			stencilStoreOp: 'store',
			stencilReadOnly: true,//default false, optional
		}
	};
	return function(root){
		const {mainColorTexture, mainDepthStencil, camera3DGPUResourceMgr} = Vulkan;
		const camera = root.camera;

		camera._gpuAsset = camera3DGPUResourceMgr.getOut();

		if(camera.cullEnabled){
			Vulkan.directBufferMgr.prepareCull(camera);
		}

		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture], mainDepthStencil);
		
		drawCamera3D(camera, root);

		renderPassEncoder.endPass();

		if(camera.cullEnabled){
			Vulkan.directBufferMgr.setDispatchValue();
		}
	}
}();


class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();
		frameDo(this.onTick.bind(this));

		const {device, canvas} = Vulkan;
		this.depthTexture = createDepthTexture(canvas.width, canvas.height);

		this.fence = device.defaultQueue.createFence();
	}

	onTick(){
		console.log('-------');
		Vulkan.resetManagers();
		this.updateScene();
		this.drawScene();
		Vulkan.updateManagers();
	}

	updateScene(){
		DisplayObject.updateWorldTransform(this.scene3d);
		DisplayObject.updateWorldTransform(this.scene2d);
		updateTree(this.scene3d);
		updateTree(this.scene2d);
	}

	drawScene(){
		const {device, swapChain} = Vulkan;
		const {depthTexture} = this;

		const mainColorTexture = swapChain.getCurrentTexture().createView();
		const mainDepthStencil = depthTexture.createView();

		const commandEncoder = device.createCommandEncoder();

		Vulkan.commandEncoder = commandEncoder;
		Vulkan.mainColorTexture = mainColorTexture;
		Vulkan.mainDepthStencil = mainDepthStencil;
		//Vulkan.copyDataCommandEncoder = device.createCommandEncoder();

		drawScene3D(this.scene3d);
		drawScene2D(this.scene2d);

		device.defaultQueue.submit([
			//Vulkan.copyDataCommandEncoder.finish(),
			commandEncoder.finish()
		]);

		//while(Vulkan.destroyList.length > 0){
		//	Vulkan.destroyList.pop().destroy();
		//}
		//console.log('submit', performance.now());
		//device.defaultQueue.signal(this.fence, 0);
		/*console.log('signal begin', performance.now());
		this.fence.onCompletion(23).then(() => {
			console.log('fence complete', performance.now(), this.fence.getCompletedValue())
		});
		console.log('signal end', performance.now());
		//*/
	}
}

class Bitmap3D extends DisplayObject2D
{
	constructor(width, height, lens){
		super();
		this.type = 'bitmap3d';
		this.root3d = new DisplayObject3D();
		this.width = width;
		this.height = height;
		this.updateEnabled = true;
		this.camera = new Camera3D(lens);
		this.texture = new Texture2D();
	}

	onUpdate(){
		if(this.updateEnabled){
			updateSceneTransform(this.root3d);
			updateTree(this.root3d);
		}
	}
}

class Filter2D
{
	static Init(){
		const {device, filterSwapChain} = Vulkan;
		const frameBuffer = filterSwapChain.frameBufferA.createView();
		const textureBindGroupLayout = device.createBindGroupLayout({
			entries:[{
				binding: 0,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampler'
			},{
				binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampled-texture'
			}]
		});
		this.prototype.textureBindGroupLayout = textureBindGroupLayout;
		this.textureBindGroup = device.createBindGroup({
			layout: textureBindGroupLayout,
			entries: [{
				binding: 0,
				resource: device.createSampler({
					magFilter: 'linear',
					minFilter: 'linear',
				})
			},{	binding: 1,
				resource: frameBuffer
			}]
		});
	}

	constructor(){
		this.worldTransform = new Matrix2D();
	}

	onDraw(){}
}

class BlurFilter extends Filter2D
{
	constructor(color=[1,0,1,1]){
		super();
		const {device, canvas} = Vulkan;

		this.uniformBuffer = device.createBuffer({
			size: 8 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});

		this.uniformBuffer2 = Vulkan.createBufferMapped(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, new Float32Array(color));

		const bindGroupLayout = device.createBindGroupLayout({
			entries:[{
				binding: 0,
				visibility: GPUShaderStage.VERTEX,
				type: 'uniform-buffer',
			},{
				binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'uniform-buffer'
			}]
		});

		const bindGroupDesc = {
			layout: bindGroupLayout,
			entries: [{
				binding: 0,
				resource: {
					buffer: this.uniformBuffer
				}
			},{	binding: 1,
				resource: {
					buffer: this.uniformBuffer2
				}
			}]
		};

		this.bindGroup = device.createBindGroup(bindGroupDesc);
		
		this.pipeline = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts: [this.textureBindGroupLayout, bindGroupLayout]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_filter.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_filter.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-strip',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}]
		});
	}

	onDraw(){
		const {device, renderPassEncoder} = Vulkan;
		const rect = this.drawRect;
		renderPassEncoder.setPipeline(this.pipeline);
		renderPassEncoder.setBindGroup(1, this.bindGroup);
		renderPassEncoder.draw(4, 1, 0, 0);//rect

		Vulkan.copyDataToBuffer(this.uniformBuffer, new Float32Array([
			rect.x / MAX_W, rect.y / MAX_H, rect.width / MAX_W, rect.height / MAX_H,
			rect.x / MAX_W - 1, rect.y / MAX_H + 1, 2 * rect.width / MAX_W, -2 * rect.height / MAX_H,

			//0,0,1,1,
			//-1, 1, 2, -2
		]));
	}
}

class ColorMatrixFilter extends BlurFilter
{
	constructor(){
		super([0,1,1,1]);
	}
}

function Filter2DCollector(){
	const list = [];
	let level = 0;

	const getLevelList = () => list[level] || (list[level] = []);
	const onLeaveFilter = () => --level;
	const clearGroup = group => group.length = 0;

	function onCollect(item){
		if(!item.visible)return true;
		if(!item.filter)return;
		getLevelList().push(item);
		++level;
		return onLeaveFilter;
	}

	function onDraw(item){
		const {bitmapQueue} = Vulkan;
		const {filter} = item;
		if(filter && item != this){
			bitmapQueue.add(filter);
			return true;
		}
		Vulkan.render2D.draw(item);
	}

	const beginRenderPass = function(){
		const desc = {
			colorAttachments: [{
				attachment: null,
				loadValue: [0,0,0,0]
			}]
		}
		return function(colorAttachment){
			desc.colorAttachments[0].attachment = colorAttachment;
			Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass(desc);
		}
	}();

	return function(root){
		const {canvas:{width, height}} = Vulkan;
		const {filterSwapChain, bitmapQueue} = Vulkan;

		const frameBufferA = filterSwapChain.frameBufferA.createView();
		const frameBufferB = filterSwapChain.frameBufferB.createView();
		const {rectPack} = filterSwapChain;

		traverseTree(root, onCollect);
		for(const group of list.reverse()){
			if(group.length == 0)continue;
			rectPack.clear();
			beginRenderPass(frameBufferA);

			Vulkan.prepareDraw2D();
			for(let filterItem of group){
				const rect = filterItem.filter.drawRect = rectPack.insert(width, height);
				Vulkan.renderPassEncoder.setViewport(rect.x, rect.y, rect.width, rect.height, 0, 1);
				traverseTree.call(filterItem, filterItem, onDraw);
				Vulkan.drawBitmapQueue();
			}
			
			Vulkan.renderPassEncoder.endPass();
			beginRenderPass(frameBufferB);

			Vulkan.renderPassEncoder.setBindGroup(0, Filter2D.textureBindGroup);
			for(const {filter} of group){
				filter.onDraw();
				filter.width = width;
				filter.height = height;
				filter.texture = new Texture2D(frameBufferB);
				filter.texture.setUV(MAX_W, MAX_H, filter.drawRect, false);
			}

			Vulkan.renderPassEncoder.endPass();
		}
		list.forEach(clearGroup);
	}
}

function Bitmap3DCollector(){
	const frameBuffer = Vulkan.device.createTexture({
		size: [MAX_W, MAX_H, 1],
		format: Vulkan.swapChainFormat,
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
	});
	const depthBuffer = createDepthTexture(MAX_W, MAX_H);
	const frameView = frameBuffer.createView();
	const depthView = depthBuffer.createView();
	const renderPassDesc = {
		colorAttachments: [{
			attachment: frameView,
			loadValue: [0,0,0,0]
		}],
		depthStencilAttachment: {
			attachment: depthView,
			depthLoadValue: 1.0,
			depthStoreOp: 'store',
			stencilLoadValue: 0,
			stencilStoreOp: 'store'
		}
	};
	const rectPack = new MaxRectsBinPack(MAX_W, MAX_H);
	const elementList = [];
	function onCollect(item){
		if(!item.visible)return true;
		if(item.type === 'bitmap3d'){
			elementList.push(item);
		}
	}
	return function(root){
		traverseTree(root, onCollect);
		if(elementList.length <= 0)return;
		const renderPassEncoder = Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass(renderPassDesc);
		for(const bitmap3D of elementList){
			const {width, height, texture} = bitmap3D;
			const drawRect = rectPack.insert(width, height);
			texture.rawTexture = frameView;
			texture.setUV(MAX_W, MAX_H, drawRect, false);
			renderPassEncoder.setViewport(drawRect.x, drawRect.y, drawRect.width, drawRect.height, 0, 1);
			bitmap3D.camera._gpuAsset = Vulkan.camera3DGPUResourceMgr.getOut();
			drawCamera3D(bitmap3D.camera, bitmap3D.root3d);
		}
		renderPassEncoder.endPass();
		rectPack.clear();
		elementList.length = 0;
	}
}

const MAX_W = 4096;
const MAX_H = 4096;

class FilterSwapChain
{
	constructor(){
		this.rectPack = new MaxRectsBinPack(MAX_W, MAX_H);
		this.frameBufferA = Vulkan.device.createTexture({
			size: [MAX_W, MAX_H, 1],
			format: Vulkan.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
		});
		this.frameBufferB = Vulkan.device.createTexture({
			size: [MAX_W, MAX_H, 1],
			format: Vulkan.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
		});
	}
}

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialDict = new Map();

		if(!(createSkeleton && mesh.boneList.length > 0))return;
		this.buildBoneTree();
		this.animationList = mesh.animationList;
		this.animation = this.animationList[20] || this.animationList[0];
		this.animationTime = 0;
	}

	addMaterial(material){
		const materialType = material.constructor;
		if(!materialType.initFlag){
			materialType.initFlag = true;
			materialType.onInit?.();
		}
		this.materialDict.set(material.constructor, material);
		return this;
	}

	getMaterial(materialType){
		return this.materialDict.get(materialType);
	}

	onDraw(){}

	onUpdate(){
		const {animation, animationTime} = this;
		if(animation){
			let timeElapsed = 1000 / 60;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(this.attachmentDict){
			for(const [attachment] of this.attachmentDict){
				updateSceneTransform(attachment);
				updateTree(attachment);
			}
		}
		if(!this._skeleton){
			this.rootBone?.updateBone(this);
		}
	}

	buildBoneTree(){
		const boneDict = Object.create(null);
		const boneList = [];
		let rootBone;
		for(let {boneName, boneID, bonePID} of this.mesh.boneList){
			let boneParent = bonePID < 0 ? null : boneList[bonePID];
			let bone = new BoneObject(boneParent, boneID);

			boneDict[boneName] = bone;
			boneList[boneID] = bone;

			if(bonePID >= 0){
				boneParent.addChild(bone);
			}else if(rootBone){
				rootBone.addSibling(bone);
			}else{
				rootBone = bone;
			}
		}
		rootBone.boneDict = boneDict;
		this.rootBone = rootBone;
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton || this;
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		if(!this.attachmentDict){
			this.attachmentDict = new Map();
		}
		if(clearOtherObjects)this.unbindObjects(boneName);
		this.attachmentDict.set(target, boneName);
	}

	unbindObject(target){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		attachmentDict.delete(target);
	}

	unbindObjects(boneName){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		if(boneName == null){
			attachmentDict.clear();
			return;
		}
		for(const [attachment, name] of attachmentDict){
			if(name != boneName)continue;
			attachmentDict.delete(attachment);
		}
	}
}




function createDepthTexture(width, height){
	const {device} = Vulkan;
	return device.createTexture({
		size: [width, height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT
	});
}





exports.Vulkan = Vulkan;
exports.View3D = View3D;
exports.Bitmap3D = Bitmap3D;
exports.BlurFilter = BlurFilter;
exports.ColorMatrixFilter = ColorMatrixFilter;
exports.MeshEntity = MeshEntity;
exports.Camera3D = Camera3D;
exports.Lens = Lens;
exports.TextureMaterial = TextureMaterial;
exports.ColorMaterial = ColorMaterial;
exports.TerrainMaterial = TerrainMaterial;
exports.BoundMaterial = BoundMaterial;
exports.WireframeMaterial = WireframeMaterial;

const {createRender2D} = require('./Render2D');

