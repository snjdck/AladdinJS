'use strict';

const overrideMethod = require('utils/function/overrideMethod');
const {createFetch} = require('utils/cache');
const {parse} = require('mu/bmd');
const defineConstGetter = require('utils/object/defineConstGetter');
const {fetchArrayBuffer, loadImage} = require('webonly/utils');
const {createTexture} = require('webonly/utils_gpu');

const Vulkan = require('./Vulkan');

Vulkan.loadModel = createFetch(async name => Vulkan.addMeshBufferGetter(parse(new Uint8Array(await fetchArrayBuffer(name)))));

const SubMeshProto = {
	/*
	setBuffers(renderPassEncoder, vertex){
		if(!Array.isArray(vertex))return;
		for(let i=0, n=vertex.length; i<n; ++i){
			renderPassEncoder.setVertexBuffer(i, bufferCache(this.attributes[vertex[i]], GPUBufferUsage.VERTEX));
		}
	},
	draw(renderPassEncoder, instanceCount=1, firstInstance=0, index='index'){
		const indexData = this.attributes[index];
		if(indexData){
			const format = indexData instanceof Uint32Array ? 'uint32' : 'uint16';
			renderPassEncoder.setIndexBuffer(bufferCache(indexData, GPUBufferUsage.INDEX), format);
			renderPassEncoder.drawIndexed(indexData.length, instanceCount, 0, 0, firstInstance);
		}else{
			renderPassEncoder.draw(this.vertexCount, instanceCount, 0, firstInstance);
		}
	}
	*/
};

function calcIndexBufferWireframe(){
	const rawData = this.index;
	const indexCount = rawData ? rawData.length : (this.position.length >> 2);//trigCount * 3 << 2
	const indexData = new Uint16Array(indexCount << 1);
	if(rawData){
		for(let i=0; i<indexCount; i+=3){
			indexData.set([rawData[i], rawData[i+1], rawData[i+1], rawData[i+2], rawData[i+2], rawData[i]], i << 1);
		}
	}else{
		for(let i=0; i<indexCount; i+=3){
			indexData.set([i, i+1, i+1, i+2, i+2, i], i << 1);
		}
	}
	return indexData;
}

Vulkan.addMeshBufferGetter = mesh => {
	for(let subMesh of mesh.subMeshList){
		if(!subMesh.attributes)continue;
		/*
		Object.assign(subMesh, SubMeshProto);
		subMesh.buffers = new Proxy(subMesh.attributes, {
			get(target, property){
				const data = target[property];
				const usage = property.startsWith('index') ? GPUBufferUsage.INDEX : GPUBufferUsage.VERTEX;
				return data && bufferCache(data, usage);
			}
		});
		*/
		defineConstGetter(subMesh.attributes, 'indexWireframe', calcIndexBufferWireframe);
	}
	return mesh;
}
