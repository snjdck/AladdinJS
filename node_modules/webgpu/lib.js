'use strict';

const ObjectCache = require('utils/ObjectCache');
const DisplayObject = require('./DisplayObject');
const DisplayObject2D = require('./DisplayObject2D');
const DisplayObject3D = require('./DisplayObject3D');
const traverseTree = require('utils/traverseTree');
const BitmapQueue = require('opengl/renderers/BitmapQueue');
//const {createMeshIndices} = require('utils/geometry');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const overrideMethod = require('utils/function/overrideMethod');
const {loadData} = require('utils/loader');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');
const Matrix2D = require('opengl/math/Matrix2D');
const Filter2D = require('./filter2Ds/Filter2D');
const FilterSwapChain = require('./filter2Ds/FilterSwapChain');

const {Texture2D} = require('opengl/textures');
const Mat3x4 = require('./mat3x4');
//const collectAllTypes = require('utils/class/collectAllTypes');
const ArrayValueMap = require('ds/ArrayValueMap');
const BoneObject = require('opengl/3d/BoneObject');

const TextManager = require('./managers/TextManager');
const VertexBufferManager = require('./managers/VertexBufferManager');
const TransformUniformManager = require('./managers/TransformUniformManager');
const DirectBufferManager = require('./managers/DirectBufferManager');
const MouseManager = require('./managers/MouseManager');
const Camera3DGPUResourceManager = require('./managers/Camera3DGPUResourceManager');

const {createRender2D} = require('./Render2D');

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	return view;
});

const Vulkan = require('./Vulkan');
Vulkan.fetchTexture = createFetch(function(name, callback){
	const {device} = this;
	if(name.endsWith('.tga')){
		loadData(name, 'arraybuffer').then(data => {
			let image = imageUtil.decode(name, data);
			const texture = device.createTexture({
				size: [image.width, image.height, 1],
				format: 'rgba8unorm',
				usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
			});
			texture.transparent = true;
			texture.name = name;
			texture.width = image.width;
			texture.height = image.height;
			createImageBitmap(
				new ImageData(new Uint8ClampedArray(image.data), image.width, image.height)
			).then(imageBitmap => {
				device.defaultQueue.copyImageBitmapToTexture(
					{imageBitmap},
					{texture, mipLevel: 0, origin: [0, 0, 0]},
					[image.width, image.height, 1]
				);
				callback(texture);
			});
		});
	}else{
		this.loadTexture(this.device, name).then(callback);
	}
});
Vulkan.loadModel = async path => parse(new Uint8Array(await loadData(path, 'arraybuffer')));
Vulkan.loadTexture = async (device, path) => {
	const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path));
	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
	});
	device.defaultQueue.copyImageBitmapToTexture(
		{imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);
	texture.transparent = false;
	texture.name = path;
	texture.width = imageBitmap.width;
	texture.height = imageBitmap.height;
	return texture;
};

Object.defineProperties(Vulkan, {
	swapChainFormat: {value: 'bgra8unorm'},
	_default2DRenderPassDesc:{
		value: {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load',
				storeOp: 'store'
			}],
			/*depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 'load',
				depthStoreOp: 'store',
				stencilLoadValue: 'load',
				stencilStoreOp: 'store'
			}*/
		}
	},
	init:{value(device, canvas){
		this.device = device;
		this.canvas = canvas;
		this.swapChain = canvas.getContext('gpupresent').configureSwapChain({
			device,
			format: this.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT
		});
		this.mgrList = [];
		this.filterSwapChain = new FilterSwapChain();
		this.textMgr = new TextManager();
		this.render2D = createRender2D();
		Filter2D.Init();
		preparePipelines();
		this.drawBitmapQueue = function(){
			const textureBindGroupDesc = {
				layout: Vulkan.bindGroupLayoutDict.bindGroupLayout3,
				entries: [{binding: 0,
					resource: null//bind later
				}]
			};
			function onBatchDraw(instanceList){
				const {device, renderPassEncoder} = Vulkan;
				const texture = instanceList[0].texture.getRawAsset();
				textureBindGroupDesc.entries[0].resource = texture;
				renderPassEncoder.setBindGroup(1, device.createBindGroup(textureBindGroupDesc));
				Vulkan.vertexBufferMgr.draw(instanceList);
			}
			return function(){
				Vulkan.bitmapQueue.draw(onBatchDraw).clear();
			}
		}();
		this.prepareDraw2D = function(){
			const {device, canvas} = Vulkan;

			//const indexBuffer = createBufferMapped(GPUBufferUsage.INDEX, new Uint16Array(createMeshIndices(4, 4)));
			const uniformBuffer = Vulkan.createBufferMapped(GPUBufferUsage.UNIFORM, new Float32Array([2 / canvas.width, -2 / canvas.height]));

			const bindGroup = device.createBindGroup({
				layout: Vulkan.bindGroupLayoutDict.bindGroupLayout,
				entries: [{
					binding: 0,
					resource: {buffer: uniformBuffer}
				},{	binding: 1,
					resource: device.createSampler({
						magFilter: 'linear',
						minFilter: 'linear',
					})
				}]
			});

			return function(){
				const {renderPassEncoder, pipelineDict} = Vulkan;
				renderPassEncoder.setPipeline(pipelineDict.pipeline2D);
				//renderPassEncoder.setVertexBuffer(0, this.vertexBuffer);
				//renderPassEncoder.setIndexBuffer(indexBuffer);
				renderPassEncoder.setBindGroup(0, bindGroup);
			}
		}();
		this.regMgr('transformUniformMgr', new TransformUniformManager());
		this.regMgr('vertexBufferMgr', new VertexBufferManager());
		this.regMgr('directBufferMgr', new DirectBufferManager());
		this.regMgr('mouseMgr', new MouseManager());
		this.regMgr('camera3DGPUResourceMgr', new Camera3DGPUResourceManager());
	}},
	regMgr:{value(name, value){
		this[name] = value;
		this.mgrList.push(value);
	}},
	resetManagers:{value(){
		this.mgrList.forEach(v => v.reset?.());
	}},
	updateManagers:{value(){
		this.mgrList.forEach(v => v.onUpdate?.());
	}},
	setRenderPassDesc:{value(desc, colorAttachments, depthStencilAttachment){
		if(colorAttachments)colorAttachments.forEach((v, i) => desc.colorAttachments[i].attachment = v);
		if(desc.depthStencilAttachment)desc.depthStencilAttachment.attachment = depthStencilAttachment;
	}},
	copyRenderPassDesc:{value(from, to, loadValue='load', depthLoadValue='load', stencilLoadValue='load'){
		to.colorAttachments.forEach((v, i) => v.attachment = from.colorAttachments[i].attachment);
		to.depthStencilAttachment.attachment = from.depthStencilAttachment.attachment;
	}},
	pushRenderPass:{value(desc, colorAttachments, depthStencilAttachment){
		this.setRenderPassDesc(desc, colorAttachments, depthStencilAttachment);
		//this._currentRenderPassDesc = desc;
		return this.renderPassEncoder = this.commandEncoder.beginRenderPass(desc);
	}},
});
//Object.seal(Vulkan);

function preparePipelines(){
	const {device} = Vulkan;
	Vulkan.bindGroupLayoutDict.bindGroupLayout = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.VERTEX,
			type: 'uniform-buffer',
		},{binding: 1,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampler'
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout2 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
			type: 'uniform-buffer',
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout3 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampled-texture'
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout4 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'uniform-buffer',
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayout5 = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.FRAGMENT,
			type: 'sampled-texture',
			viewDimension: '2d-array',
		}]
	});

	Vulkan.bindGroupLayoutDict.bindGroupLayoutCull = device.createBindGroupLayout({
		entries:[{
			binding: 0,
			visibility: GPUShaderStage.COMPUTE,
			type: 'storage-buffer',
		}]
	});

	function createPipelineDesc3D(bindGroupLayouts, vertexCode, fragmentCode, primitiveTopology='triangle-list'){
		return {
			layout: device.createPipelineLayout({
				bindGroupLayouts
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology,
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			},
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: 9 << 2,
					stepMode: 'vertex',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'float3'
					},{
						shaderLocation: 1,
						offset: 3 << 2,
						format: 'float3'
					},{
						shaderLocation: 2,
						offset: 6 << 2,
						format: 'float2'
					},{
						shaderLocation: 3,
						offset: 8 << 2,
						format: 'uint'
					}]
				}]
			}
		};
	}

	Vulkan.pipelineDict.pipeline = device.createRenderPipeline(createPipelineDesc3D(
		[
			Vulkan.bindGroupLayoutDict.bindGroupLayout,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout3,
		],
		Vulkan.shader_3d.vertexCode,
		Vulkan.shader_3d.fragmentCode,
	));

	Vulkan.pipelineDict.pipelineColor = device.createRenderPipeline(createPipelineDesc3D(
		[
			Vulkan.bindGroupLayoutDict.bindGroupLayout,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout4,
		],
		Vulkan.shader_3d.vertexCode,
		Vulkan.shader_3d_color.fragmentCode,
	));

	Vulkan.pipelineDict.pipelineWireframe = device.createRenderPipeline(createPipelineDesc3D(
		[
			Vulkan.bindGroupLayoutDict.bindGroupLayout,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			Vulkan.bindGroupLayoutDict.bindGroupLayout2,
		],
		Vulkan.shader_3d.vertexCode,
		Vulkan.shader_bound.fragmentCode,
		'line-list'
	));

	Vulkan.pipelineDict.pipeline2D = device.createRenderPipeline({
		layout: device.createPipelineLayout({
			bindGroupLayouts: [
				Vulkan.bindGroupLayoutDict.bindGroupLayout,
				Vulkan.bindGroupLayoutDict.bindGroupLayout3,
			]
		}),
		vertexStage: {
			module: device.createShaderModule({
				code: Vulkan.shader_2d.vertexCode,
			}),
			entryPoint: 'main'
		},
		fragmentStage: {
			module: device.createShaderModule({
				code: Vulkan.shader_2d.fragmentCode,
			}),
			entryPoint: 'main'
		},
		primitiveTopology: 'triangle-list',
		colorStates:[{
			format: Vulkan.swapChainFormat,
			colorBlend: {
				srcFactor: 'src-alpha',
				dstFactor: 'one-minus-src-alpha',
				operation: 'add'
			},
			alphaBlend: {
				srcFactor: 'src-alpha',
				dstFactor: 'one-minus-src-alpha',
				operation: 'add'
			}
		}],
		vertexState: {
			indexFormat: 'uint16',
			vertexBuffers:[{
				arrayStride: VertexBufferManager.instanceFloatCount << 2,
				stepMode: 'instance',
				attributes:[{
					shaderLocation: 0,
					offset: 0,
					format: 'float3'
				},{
					shaderLocation: 1,
					offset: 3 << 2,
					format: 'float3'
				},{
					shaderLocation: 2,
					offset: 6 << 2,
					format: 'float4'
				},{
					shaderLocation: 3,
					offset: 10 << 2,
					format: 'float4'
				},{
					shaderLocation: 4,
					offset: 14 << 2,
					format: 'float4'
				},{
					shaderLocation: 5,
					offset: 18 << 2,
					format: 'float4'
				}]
			}]
		}
	});

	Vulkan.pipelineDict.pipelineTerrain = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts:[
					Vulkan.bindGroupLayoutDict.bindGroupLayout,
					Vulkan.bindGroupLayoutDict.bindGroupLayout5,
				]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_terrain.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_terrain.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-list',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			},
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: 12,
					stepMode: 'vertex',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'uchar2'
					},{
						shaderLocation: 1,
						offset: 4,
						format: 'uchar2norm'
					},{
						shaderLocation: 2,
						offset: 8,
						format: 'uchar4norm'
					}]
				}]
			}
	});

	Vulkan.pipelineDict.pipelineBound = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts:[
					Vulkan.bindGroupLayoutDict.bindGroupLayout,
					Vulkan.bindGroupLayoutDict.bindGroupLayout2,
			]}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_bound.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_bound.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'line-list',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			}
		});

	Vulkan.pipelineDict.pipelineCull = device.createComputePipeline({
		layout: device.createPipelineLayout({
			bindGroupLayouts:[
				Vulkan.bindGroupLayoutDict.bindGroupLayoutCull,//direct buffer
				Vulkan.bindGroupLayoutDict.bindGroupLayout2,//world matrix
				Vulkan.bindGroupLayoutDict.bindGroupLayout2,//camera
				Vulkan.bindGroupLayoutDict.bindGroupLayout2,//bound
			]
		}),
		computeStage:{
			module: device.createShaderModule({
				code: Vulkan.shader_cull,
			}),
			entryPoint: 'main'
		}
	});
}



const MAX_W = 4096;
const MAX_H = 4096;


class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.materialDict = new Map();

		if(!(createSkeleton && mesh.boneList.length > 0))return;
		this.buildBoneTree();
		this.animationList = mesh.animationList;
		this.animation = this.animationList[20] || this.animationList[0];
		this.animationTime = 0;
	}

	addMaterial(material){
		const materialType = material.constructor;
		if(!materialType.initFlag){
			materialType.initFlag = true;
			materialType.onInit?.();
		}
		this.materialDict.set(material.constructor, material);
		return this;
	}

	getMaterial(materialType){
		return this.materialDict.get(materialType);
	}

	onDraw(){}

	onUpdate(){
		const {animation, animationTime} = this;
		if(animation){
			let timeElapsed = 1000 / 60;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(this.attachmentDict){
			for(const [attachment] of this.attachmentDict){
				DisplayObject.updateWorldTransform(attachment);
				DisplayObject.updateTree(attachment);
			}
		}
		if(!this._skeleton){
			this.rootBone?.updateBone(this);
		}
	}

	buildBoneTree(){
		const boneDict = Object.create(null);
		const boneList = [];
		let rootBone;
		for(let {boneName, boneID, bonePID} of this.mesh.boneList){
			let boneParent = bonePID < 0 ? null : boneList[bonePID];
			let bone = new BoneObject(boneParent, boneID);

			boneDict[boneName] = bone;
			boneList[boneID] = bone;

			if(bonePID >= 0){
				boneParent.addChild(bone);
			}else if(rootBone){
				rootBone.addSibling(bone);
			}else{
				rootBone = bone;
			}
		}
		rootBone.boneDict = boneDict;
		this.rootBone = rootBone;
	}

	shareSkeletonWith(target){
		this._skeleton = target;
	}

	get skeleton(){
		return this._skeleton || this;
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		if(!this.attachmentDict){
			this.attachmentDict = new Map();
		}
		if(clearOtherObjects)this.unbindObjects(boneName);
		this.attachmentDict.set(target, boneName);
	}

	unbindObject(target){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		attachmentDict.delete(target);
	}

	unbindObjects(boneName){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		if(boneName == null){
			attachmentDict.clear();
			return;
		}
		for(const [attachment, name] of attachmentDict){
			if(name != boneName)continue;
			attachmentDict.delete(attachment);
		}
	}
}


exports.MeshEntity = MeshEntity;



