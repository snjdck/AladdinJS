'use strict';

const overrideMethod = require('utils/function/overrideMethod');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');
const {fetchArrayBuffer, backgroundDo, loadImage} = require('webonly/utils');
const {createTexture} = require('webonly/utils_gpu');

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	view.name = this.name;
	return view;
});

const Vulkan = require('./Vulkan');

Vulkan.loadTexture = createFetch(async name => {
	const {device} = Vulkan;
	let texture;
	if(name.toLowerCase().endsWith('.tga')){
		const data = await fetchArrayBuffer(name);
		const image = await backgroundDo(() => imageUtil.decode(name, data));
		const imageBitmap = await createImageBitmap(
			new ImageData(new Uint8ClampedArray(image.data), image.width, image.height),
			{imageOrientation:'flipY'}
		);
		texture = createTexture(device, imageBitmap);
	}else{
		//const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path), {imageOrientation:'none'});
		texture = createTexture(device, await loadImage(name));
	}
	texture.transparent = true;
	texture.name = name;
	return texture;
});

Vulkan.loadModel = createFetch(async name => Vulkan.addMeshBufferGetter(parse(new Uint8Array(await fetchArrayBuffer(name)))));

const SubMeshProto = {
	setBuffers(vertex, index='index'){
		const {renderPassEncoder} = Vulkan;
		const indexData = this.attributes[index];
		if(indexData){
			const format = indexData instanceof Uint32Array ? 'uint32' : 'uint16';
			renderPassEncoder.setIndexBuffer(this.buffers[index], format);
		}
		if(!Array.isArray(vertex))return;
		for(let i=0, n=vertex.length; i<n; ++i){
			renderPassEncoder.setVertexBuffer(i, this.buffers[vertex[i]]);
		}
	},
	draw(instanceCount, firstInstance=0, index='index'){
		const indexData = this.attributes[index];
		if(indexData){
			Vulkan.renderPassEncoder.drawIndexed(indexData.length, instanceCount, 0, 0, firstInstance);
		}else{
			Vulkan.renderPassEncoder.draw(this.vertexCount, instanceCount, 0, firstInstance);
		}
	}
};

function calcIndexBufferWireframe(){
	const rawData = this.index;
	const indexCount = rawData ? rawData.length : this.position.length / 3;
	const indexData = new Uint16Array(indexCount << 1);
	if(rawData){
		for(let i=0; i<indexCount; i+=3){
			indexData.set([rawData[i], rawData[i+1], rawData[i+1], rawData[i+2], rawData[i+2], rawData[i]], i << 1);
		}
	}else{
		for(let i=0; i<indexCount; i+=3){
			indexData.set([i, i+1, i+1, i+2, i+2, i], i << 1);
		}
	}
	return indexData;
}

Vulkan.addMeshBufferGetter = mesh => {
	for(let subMesh of mesh.subMeshList){
		if(!subMesh.attributes)continue;
		Object.assign(subMesh, SubMeshProto);
		const buffers = {};
		for(let [k, v] of Object.entries(subMesh.attributes)){
			const usage = k.startsWith('index') ? GPUBufferUsage.INDEX : GPUBufferUsage.VERTEX;
			Vulkan.defineConstGetter(buffers, k, () => Vulkan.createBufferMapped(usage, v));
		}
		Vulkan.defineConstGetter(subMesh.attributes, 'indexWireframe', calcIndexBufferWireframe);
		Vulkan.defineConstGetter(buffers, 'indexWireframe', () => Vulkan.createBufferMapped(GPUBufferUsage.INDEX, subMesh.attributes.indexWireframe));
		subMesh.buffers = buffers;
	}
	return mesh;
}
