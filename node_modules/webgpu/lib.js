'use strict';

const overrideMethod = require('utils/function/overrideMethod');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	view.name = this.name;
	return view;
});

const backgroundLoader = function(){
	const priority = {priority: 'background'};
	return loader => function(...args){
		scheduler.postTask(() => loader.apply(this, args), priority);
	}
}();

const fetchArrayBuffer = function(){
	const cast = response => response.arrayBuffer();
	return path => fetch(path).then(cast);
}();

const Vulkan = require('./Vulkan');
Vulkan.fetchTexture = createFetch(backgroundLoader(function(name, callback){
	const {device} = this;
	if(name.toLowerCase().endsWith('.tga')){
		fetchArrayBuffer(name).then(data => {
			let image = imageUtil.decode(name, data);
			const texture = device.createTexture({
				size: [image.width, image.height, 1],
				format: 'rgba8unorm',
				usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
			});
			texture.transparent = true;
			texture.name = name;
			createImageBitmap(
				new ImageData(new Uint8ClampedArray(image.data), image.width, image.height),
				{imageOrientation:'flipY'}
			).then(imageBitmap => {
				device.queue.copyExternalImageToTexture(
					{source: imageBitmap},
					{texture, mipLevel: 0, origin: [0, 0, 0]},
					[image.width, image.height, 1]
				);
				callback(texture);
			});
		});
	}else{
		this.loadTexture(this.device, name).then(callback);
	}
}));
Vulkan.loadModel = function(){
	const loadModel = createFetch(async function(path, callback){
		callback(Vulkan.addMeshBufferGetter(parse(new Uint8Array(await fetchArrayBuffer(path)))));
	});
	return path => new Promise(resolve => loadModel(path, resolve));
}();
Vulkan.loadTexture = async (device, path) => {
	const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path), {imageOrientation:'none'});
	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
	});
	device.queue.copyExternalImageToTexture(
		{source: imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);
	texture.transparent = false;
	texture.name = path;
	return texture;
};

Vulkan.addMeshBufferGetter = mesh => {
	for(let subMesh of mesh.subMeshList){
		if(!subMesh.attributes)continue;
		const buffers = {};
		for(let [k, v] of Object.entries(subMesh.attributes)){
			Vulkan.defineConstGetter(buffers, k, () => Vulkan.createBufferMapped(GPUBufferUsage.VERTEX, v));
		}
		subMesh.buffers = buffers;
	}
	if(mesh.vertexData){
		Vulkan.defineConstGetter(mesh, 'vertexBuffer', () => Vulkan.createBufferMapped(GPUBufferUsage.VERTEX, mesh.vertexData));
	}
	if(mesh.indexData){
		Vulkan.defineConstGetter(mesh, 'indexBuffer', () => Vulkan.createBufferMapped(GPUBufferUsage.INDEX, mesh.indexData));
	}
	Vulkan.defineConstGetter(mesh, 'wireframeIndexBuffer', () => {
		const rawData = mesh.indexData;
		const indexCount = rawData ? rawData.length : mesh.vertexCount;
		const indexData = new Uint16Array(indexCount << 1);
		if(rawData){
			for(let i=0; i<indexCount; i+=3){
				indexData.set([rawData[i], rawData[i+1], rawData[i+1], rawData[i+2], rawData[i+2], rawData[i]], i << 1);
			}
		}else{
			for(let i=0; i<indexCount; i+=3){
				indexData.set([i, i+1, i+1, i+2, i+2, i], i << 1);
			}
		}
		mesh.wireframeIndexCount = indexData.length;
		return Vulkan.createBufferMapped(GPUBufferUsage.INDEX, indexData);
	});
	return mesh;
}
