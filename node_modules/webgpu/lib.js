'use strict';

const overrideMethod = require('utils/function/overrideMethod');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const defineConstGetter = require('utils/object/defineConstGetter');
const {fetchArrayBuffer, loadImage} = require('webonly/utils');
const {createTexture} = require('webonly/utils_gpu');

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	view.name = this.name;
	return view;
});

const Vulkan = require('./Vulkan');

Vulkan.loadTexture = createFetch(async name => {
	let texture;
	if(name.toLowerCase().endsWith('.tga')){
		const ba = new Uint8Array(await fetchArrayBuffer(name));
		/*--head begin--*/
		const imageInfoSize = ba.readUInt8(0);
		const hasColorTable = ba.readUInt8(1);
		const imageType = ba.readUInt8(2);
		//const colorTableStart = ba.readUInt16LE(3);
		//const colorTableLength = ba.readUInt16LE(5);
		//const colorTableDepth = ba.readUInt8(7);
		const px = ba.readUInt16LE(8);
		const py = ba.readUInt16LE(10);
		const width = ba.readUInt16LE(12);
		const height = ba.readUInt16LE(14);
		const bitPerPixel = ba.readUInt8(16);//8, 16, 24, 32
		const flags = ba.readUInt8(17);
		/*--head end--*/

		/*--footer begin
		const developerAreaSize = ba.readUInt32LE(ba.length - 26);//0
		const extensionAreaSize = ba.readUInt32LE(ba.length - 22);//0
		const fileType = String.fromCharCode(...ba.subarray(-18, -2));//'TRUEVISION-XFILE'
		//ba.at(-2) == 0x2E
		//ba.at(-1) == 0
		/*--footer end--*/
		
		const right2left = ((flags >> 4) & 1) == 1;
		const bottom2top = ((flags >> 5) & 1) == 0;

		console.assert(!right2left && bottom2top && !hasColorTable && bitPerPixel == 32 && imageType == 2 && px == 0 && py == 0);
		console.assert(18 + imageInfoSize + width * height * 4 + 26 == ba.length);

		const imageOffset = 18 + imageInfoSize;
		const bytesPerRow = width << 2;
		const imageData = new Uint8Array(bytesPerRow * height);
		for(let i=0; i<height; ++i){
			imageData.set(ba.subarray(imageOffset + bytesPerRow * i, imageOffset + bytesPerRow * (i + 1)), bytesPerRow * (height - 1 - i));
		}
		/*
		const imageBitmap = await createImageBitmap(
			new ImageData(new Uint8ClampedArray(image.data), image.width, image.height),
			{imageOrientation:'flipY'}
		);
		texture = createTextureWithImage(Vulkan.device, imageBitmap);
		*/
		texture = createTexture(Vulkan.device, width, height, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST);//bgra
		Vulkan.device.queue.writeTexture(
			{texture, origin:[0,0,0], mipLevel:0, aspect:'all'},
			imageData,
			{offset:0, bytesPerRow, rowsPerImage:undefined},
			[width, height, 1]
		);
	}else{
		//const imageBitmap = await createImageBitmap(await loadImage(path), {imageOrientation:'none'});
		const image = await loadImage(name);
		texture = createTexture(Vulkan.device, image.width, image.height, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT);
		Vulkan.device.queue.copyExternalImageToTexture(
			{source:image, origin:[0,0], flipY:false},
			{texture, origin:[0,0,0], mipLevel:0, aspect:'all', colorSpace:'srgb', premultipliedAlpha:false},
			[image.width, image.height, 1]
		);
	}
	texture.transparent = true;
	texture.name = name;
	return texture;
});

Vulkan.loadModel = createFetch(async name => Vulkan.addMeshBufferGetter(parse(new Uint8Array(await fetchArrayBuffer(name)))));

const SubMeshProto = {
	/*
	setBuffers(renderPassEncoder, vertex){
		if(!Array.isArray(vertex))return;
		for(let i=0, n=vertex.length; i<n; ++i){
			renderPassEncoder.setVertexBuffer(i, bufferCache(this.attributes[vertex[i]], GPUBufferUsage.VERTEX));
		}
	},
	draw(renderPassEncoder, instanceCount=1, firstInstance=0, index='index'){
		const indexData = this.attributes[index];
		if(indexData){
			const format = indexData instanceof Uint32Array ? 'uint32' : 'uint16';
			renderPassEncoder.setIndexBuffer(bufferCache(indexData, GPUBufferUsage.INDEX), format);
			renderPassEncoder.drawIndexed(indexData.length, instanceCount, 0, 0, firstInstance);
		}else{
			renderPassEncoder.draw(this.vertexCount, instanceCount, 0, firstInstance);
		}
	}
	*/
};

function calcIndexBufferWireframe(){
	const rawData = this.index;
	const indexCount = rawData ? rawData.length : (this.position.length >> 2);//trigCount * 3 << 2
	const indexData = new Uint16Array(indexCount << 1);
	if(rawData){
		for(let i=0; i<indexCount; i+=3){
			indexData.set([rawData[i], rawData[i+1], rawData[i+1], rawData[i+2], rawData[i+2], rawData[i]], i << 1);
		}
	}else{
		for(let i=0; i<indexCount; i+=3){
			indexData.set([i, i+1, i+1, i+2, i+2, i], i << 1);
		}
	}
	return indexData;
}

Vulkan.addMeshBufferGetter = mesh => {
	for(let subMesh of mesh.subMeshList){
		if(!subMesh.attributes)continue;
		/*
		Object.assign(subMesh, SubMeshProto);
		subMesh.buffers = new Proxy(subMesh.attributes, {
			get(target, property){
				const data = target[property];
				const usage = property.startsWith('index') ? GPUBufferUsage.INDEX : GPUBufferUsage.VERTEX;
				return data && bufferCache(data, usage);
			}
		});
		*/
		defineConstGetter(subMesh.attributes, 'indexWireframe', calcIndexBufferWireframe);
	}
	return mesh;
}
