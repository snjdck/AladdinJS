'use strict';

const overrideMethod = require('utils/function/overrideMethod');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	view.name = this.name;
	return view;
});

const backgroundLoader = function(){
	const priority = {priority: 'background'};
	return loader => function(...args){
		scheduler.postTask(() => loader.apply(this, args), priority);
	}
}();

const fetchArrayBuffer = function(){
	const cast = response => response.arrayBuffer();
	return path => fetch(path).then(cast);
}();

const Vulkan = require('./Vulkan');
Vulkan.fetchTexture = createFetch(backgroundLoader(function(name, callback){
	const {device} = this;
	if(name.toLowerCase().endsWith('.tga')){
		fetchArrayBuffer(name).then(data => {
			let image = imageUtil.decode(name, data);
			const texture = device.createTexture({
				size: [image.width, image.height, 1],
				format: 'rgba8unorm',
				usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
			});
			texture.transparent = true;
			texture.name = name;
			createImageBitmap(
				new ImageData(new Uint8ClampedArray(image.data), image.width, image.height),
				{imageOrientation:'flipY'}
			).then(imageBitmap => {
				device.queue.copyExternalImageToTexture(
					{source: imageBitmap},
					{texture, mipLevel: 0, origin: [0, 0, 0]},
					[image.width, image.height, 1]
				);
				callback(texture);
			});
		});
	}else{
		this.loadTexture(this.device, name).then(callback);
	}
}));
Vulkan.loadModel = function(){
	const loadModel = createFetch(async function(path, callback){
		callback(Vulkan.addMeshBufferGetter(parse(new Uint8Array(await fetchArrayBuffer(path)))));
	});
	return path => new Promise(resolve => loadModel(path, resolve));
}();
Vulkan.loadTexture = async (device, path) => {
	const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path), {imageOrientation:'none'});
	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
	});
	device.queue.copyExternalImageToTexture(
		{source: imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);
	texture.transparent = false;
	texture.name = path;
	return texture;
};

const SubMeshProto = {
	setBuffers(vertex, index='index'){
		const {renderPassEncoder} = Vulkan;
		const indexData = this.attributes[index];
		if(indexData){
			const format = indexData instanceof Uint32Array ? 'uint32' : 'uint16';
			renderPassEncoder.setIndexBuffer(this.buffers[index], format);
		}
		if(!Array.isArray(vertex))return;
		for(let i=0, n=vertex.length; i<n; ++i){
			renderPassEncoder.setVertexBuffer(i, this.buffers[vertex[i]]);
		}
	},
	draw(instanceCount, firstInstance=0, index='index'){
		const indexData = this.attributes[index];
		if(indexData){
			Vulkan.renderPassEncoder.drawIndexed(indexData.length, instanceCount, 0, 0, firstInstance);
		}else{
			Vulkan.renderPassEncoder.draw(this.vertexCount, instanceCount, 0, firstInstance);
		}
	}
};

function calcIndexBufferWireframe(){
	const rawData = this.index;
	const indexCount = rawData ? rawData.length : this.position.length / 3;
	const indexData = new Uint16Array(indexCount << 1);
	if(rawData){
		for(let i=0; i<indexCount; i+=3){
			indexData.set([rawData[i], rawData[i+1], rawData[i+1], rawData[i+2], rawData[i+2], rawData[i]], i << 1);
		}
	}else{
		for(let i=0; i<indexCount; i+=3){
			indexData.set([i, i+1, i+1, i+2, i+2, i], i << 1);
		}
	}
	return indexData;
}

Vulkan.addMeshBufferGetter = mesh => {
	for(let subMesh of mesh.subMeshList){
		if(!subMesh.attributes)continue;
		Object.assign(subMesh, SubMeshProto);
		const buffers = {};
		for(let [k, v] of Object.entries(subMesh.attributes)){
			const usage = k.startsWith('index') ? GPUBufferUsage.INDEX : GPUBufferUsage.VERTEX;
			Vulkan.defineConstGetter(buffers, k, () => Vulkan.createBufferMapped(usage, v));
		}
		Vulkan.defineConstGetter(subMesh.attributes, 'indexWireframe', calcIndexBufferWireframe);
		Vulkan.defineConstGetter(buffers, 'indexWireframe', () => Vulkan.createBufferMapped(GPUBufferUsage.INDEX, subMesh.attributes.indexWireframe));
		subMesh.buffers = buffers;
	}
	return mesh;
}
