'use strict';

const DisplayObject2D = require('opengl/DisplayObject2D');
const DisplayObject3D = require('opengl/DisplayObject3D');
const traverseTree = require('utils/traverseTree');
const batchDraw = require('opengl/renderers/batchDraw');
const BitmapQueue = require('opengl/renderers/BitmapQueue');
const {createMeshIndices} = require('utils/geometry');
const {MaxRectsBinPack} = require('utils/MaxRectsBinPack');
const overrideMethod = require('utils/function/overrideMethod');
const {loadData} = require('utils/loader');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');
const Matrix2D = require('opengl/math/Matrix2D');
const {Texture2D} = require('opengl/textures');
const Mat3x4 = require('./mat3x4');
const collectAllTypes = require('utils/class/collectAllTypes');


overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	return view;
});

const Vulkan = {
	bitmapQueue: new BitmapQueue(v => v.texture.getRawAsset()),
	device: null,
	canvas: null,
	swapChain: null,
	bitmap3dMgr: null,
};
Vulkan.fetchTexture = createFetch(function(name, callback){
	const {device} = this;
	if(name.endsWith('.tga')){
		loadData(name, 'arraybuffer').then(data => {
			let image = imageUtil.decode(name, data);
			const texture = device.createTexture({
				size: [image.width, image.height, 1],
				format: 'rgba8unorm',
				usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
			});
			texture.transparent = true;
			texture.name = name;
			texture.width = image.width;
			texture.height = image.height;
			createImageBitmap(
				new ImageData(new Uint8ClampedArray(image.data), image.width, image.height)
			).then(imageBitmap => {
				device.defaultQueue.copyImageBitmapToTexture(
					{imageBitmap},
					{texture, mipLevel: 0, arrayLayer: 0, origin: [0, 0, 0]},
					[image.width, image.height, 1]
				);
				callback(texture);
			});
		});
	}else{
		this.loadTexture(this.device, name).then(callback);
	}
});
Vulkan.loadModel = async path => parse(new Uint8Array(await loadData(path, 'arraybuffer')));
Vulkan.loadTexture = async (device, path) => {
	const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path));
	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
	});
	device.defaultQueue.copyImageBitmapToTexture(
		{imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, arrayLayer: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);
	texture.transparent = false;
	texture.name = path;
	texture.width = imageBitmap.width;
	texture.height = imageBitmap.height;
	return texture;
};

Vulkan.loadImage = async path => {
	let image = new Image();
	image.src = path;
	await image.decode();
	return image;
};
Object.defineProperties(Vulkan, {
	swapChainFormat: {value: 'bgra8unorm'},
	_default2DRenderPassDesc:{
		value: {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load',
				storeOp: 'store'
			}],
			/*depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 'load',
				depthStoreOp: 'store',
				stencilLoadValue: 'load',
				stencilStoreOp: 'store'
			}*/
		}
	},
	//_renderPassDescStack:{value:[]},
	//_currentRenderPassDesc:{value:null, writable:true},
	//_currentViewPort:{value:null, writable:true},
	init:{value(device, canvas){
		this.device = device;
		this.canvas = canvas;
		this.swapChain = canvas.getContext('gpupresent').configureSwapChain({
			device,
			format: this.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT
		});
		this.bitmap3dMgr = new Bitmap3DManager();
		Filter2D.Init();
	}},
	setRenderPassDesc:{value(desc, colorAttachments, depthStencilAttachment){
		if(colorAttachments)colorAttachments.forEach((v, i) => desc.colorAttachments[i].attachment = v);
		if(desc.depthStencilAttachment)desc.depthStencilAttachment.attachment = depthStencilAttachment;
	}},
	copyRenderPassDesc:{value(from, to, loadValue='load', depthLoadValue='load', stencilLoadValue='load'){
		to.colorAttachments.forEach((v, i) => v.attachment = from.colorAttachments[i].attachment);
		to.depthStencilAttachment.attachment = from.depthStencilAttachment.attachment;
	}},
	pushRenderPass:{value(desc, colorAttachments, depthStencilAttachment){
		this.setRenderPassDesc(desc, colorAttachments, depthStencilAttachment);
		//this._currentRenderPassDesc = desc;
		return this.renderPassEncoder = this.commandEncoder.beginRenderPass(desc);
	}},
/*	popRenderPass:{value(){
		this.renderPassEncoder.endPass();
		this.renderPassEncoder = null;
		this._currentRenderPassDesc = null;
		this._currentViewPort = null;
	}},
	saveRenderPass:{value(){
		this._renderPassDescStack.push({
			desc: this._currentRenderPassDesc,
			viewport: this._currentViewPort
		});
	}},
	loadRenderPass:{value(){
		const {desc, viewport} = this._renderPassDescStack.pop();
		this._currentRenderPassDesc = desc;
		const {depthStencilAttachment} = desc;
		desc.colorAttachments.forEach(v => v.loadValue = 'load');
		if(depthStencilAttachment){
			depthStencilAttachment.depthLoadValue = 'load';
			depthStencilAttachment.stencilLoadValue = 'load';
		}
		this.renderPassEncoder = this.commandEncoder.beginRenderPass(desc);
		if(viewport)this.setViewport(...viewport);
		return this.renderPassEncoder;
	}},
	renderPassLevel:{get(){
		return this._renderPassDescStack.length;
	}},
	setViewport:{value(...xywh){
		this._currentViewPort = xywh;
		this.renderPassEncoder.setViewport(...xywh, 0, 1);
	}},*/
});
//Object.seal(Vulkan);

const frameDo = fn => requestAnimationFrame(function loop(){
	requestAnimationFrame(loop);
	fn();
});

class Camera3D
{
	constructor(){
		const {device, canvas} = Vulkan;
		const zf = 5000, zn = -5000;
		this.lens = new Float32Array([
			2 / canvas.width, 0, 0, 0,
			0, 2 / canvas.height, 0, 0,
			0, 0, 1 / (zf - zn), zn / (zn - zf),
			0, 0, 0, 1
		]);
		this.entityTypeDict = new Map();
	}

	draw(scene3d){
		const {renderPassEncoder} = Vulkan;

		scene3d.uniformBuffer.setSubData(0, this.lens);

		this.entityTypeDict.clear();
		traverseTree.call(this, scene3d.root, this.onDraw);
		for(const [klass, entityList] of this.entityTypeDict){
			klass.Draw(entityList);
		}
		renderPassEncoder.endPass();
	}

	findClass(item){
		for(let klass of collectAllTypes(item)){
			if(klass.Draw)return klass;
		}
	}

	onDraw(item){
		if(!item.onDraw)return;
		const klass = this.findClass(item);
		if(!klass)return console.error('no Draw on class', item);
		const {entityTypeDict} = this;
		if(entityTypeDict.has(klass)){
			entityTypeDict.get(klass).push(item);
		}else{
			entityTypeDict.set(klass, [item]);
		}
	}
}

class Scene3D
{
	constructor(){
		this.root = new DisplayObject3D();
		this.root._scene = this;
		const {device, canvas} = Vulkan;
		this.renderPassDesc = {
			colorAttachments: [{
				attachment: null,
				loadValue: [0,0,0,1]
			}],
			depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 1.0,
				depthStoreOp: 'store',
				stencilLoadValue: 0,
				stencilStoreOp: 'store'
			}
		};

		const bindGroupLayout = device.createBindGroupLayout({
			bindings:[{
				binding: 0,
				visibility: GPUShaderStage.VERTEX,
				type: 'uniform-buffer',
			},{binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampler'
			}]
		});

		const bindGroupLayout2 = device.createBindGroupLayout({
			bindings:[{
				binding: 0,
				visibility: GPUShaderStage.VERTEX,
				type: 'uniform-buffer',
			}]
		});

		const bindGroupLayout3 = device.createBindGroupLayout({
			bindings:[{
				binding: 0,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampled-texture'
			}]
		});

		const [uniformBuffer, uniformData] = device.createBufferMapped({
			size: 7 * 4 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});
		new Float32Array(uniformData).set([
			...new Array(16).fill(0),
			0, 0, 0, 1,
			0, 0, 0, 1,
			0, 0, 1, 1,
		]);
		uniformBuffer.unmap();
		this.uniformBuffer = uniformBuffer;

		this.mvpBindGroup = device.createBindGroup({
			layout: bindGroupLayout,
			bindings: [{
				binding: 0,
				resource: {buffer: uniformBuffer}
			},{	binding: 1,
				resource: device.createSampler({
					magFilter: 'linear',
					minFilter: 'linear',
				})
			}]
		});

		this.uniformBindGroupDesc = {
			layout: bindGroupLayout2,
			bindings: [{
				binding: 0,
				resource: {buffer: null}
			}]
		};

		this.textureBindGroupDesc = {
			layout: bindGroupLayout3,
			bindings: [{	
				binding: 0,
				resource: null
			}]
		};

		this.pipeline = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts: [bindGroupLayout, bindGroupLayout2, bindGroupLayout3]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_3d.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_3d.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-list',
			colorStates:[{
				format: Vulkan.swapChainFormat
			}],
			depthStencilState: {
				format: 'depth24plus-stencil8',
				depthWriteEnabled: true,
				depthCompare: 'less-equal',
			},
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: 9 << 2,
					stepMode: 'vertex',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'float3'
					},{
						shaderLocation: 1,
						offset: 3 << 2,
						format: 'float3'
					},{
						shaderLocation: 2,
						offset: 6 << 2,
						format: 'float2'
					},{
						shaderLocation: 3,
						offset: 8 << 2,
						format: 'uint'
					}]
				}]
			}
		});
	}

	update(){

	}

	draw(){
		const {renderPassDesc, textureBindGroupDesc} = this;
		const {device, commandEncoder, mainColorTexture, mainDepthStencil} = Vulkan;

		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture], mainDepthStencil);

		renderPassEncoder.setPipeline(this.pipeline);
		renderPassEncoder.setBindGroup(0, this.mvpBindGroup);

		this.camera.draw(this);
	}
}

class FilterBucket
{
	constructor(){
		this.list = [];
		this.level = 0;
		this.leaveFilter = this.leaveFilter.bind(this);
	}

	getLevelList(){
		const {list, level} = this;
		return list[level] || (list[level] = []);
	}

	enterFilter(item){
		this.getLevelList().push(item);
		++this.level;
	}

	leaveFilter(){
		--this.level;
	}

	clear(){
		for(let group of this.list){
			group.length = 0;
		}
	}

	onDraw(item){
		const {bitmapQueue} = Vulkan;
		const {filter, onDraw} = item;
		if(filter && item != this){
			bitmapQueue.add(filter);
			return true;
		}
		if(onDraw)onDraw.call(item);
	}

	draw(scene){
		const {commandEncoder, device, canvas} = Vulkan;
		const {bitmap3dMgr, bitmapQueue} = Vulkan;

		const frameBufferA = bitmap3dMgr.list[0].frameBuffer.createView();
		const frameBufferB = bitmap3dMgr.list[1].frameBuffer.createView();
		const rectPack = bitmap3dMgr.list[0].rectPack;

		for(let group of this.list.reverse()){
			if(group.length == 0)continue;
			rectPack.clear();
			this.beginRenderPass(frameBufferA);

			scene.initRenderPassEncoder();
			for(let filterItem of group){
				const rect = bitmap3dMgr.acquire(filterItem.filter);
				Vulkan.renderPassEncoder.setViewport(rect.x, rect.y, rect.width, rect.height, 0, 1);
				traverseTree.call(filterItem, filterItem, this.onDraw);
				bitmapQueue.draw(scene.onBatchDraw, scene).clear();
			}
			
			Vulkan.renderPassEncoder.endPass();
			this.beginRenderPass(frameBufferB);

			Vulkan.renderPassEncoder.setBindGroup(0, Filter2D.textureBindGroup);
			for(const {filter} of group){
				filter.onDraw();
				filter.width = canvas.width;
				filter.height = canvas.height;
				filter.texture = new Texture2D(frameBufferB);
				filter.texture.setUV(MAX_W, MAX_H, filter.drawRect, false);
			}

			Vulkan.renderPassEncoder.endPass();
		}
		return this;
	}

	beginRenderPass(colorAttachment){
		Vulkan.renderPassEncoder = Vulkan.commandEncoder.beginRenderPass({
			colorAttachments: [{
				attachment: colorAttachment,
				loadValue: [0,0,0,0]
			}]
		});
	}
}

class Scene2D
{
	constructor(){
		this.filterBucket = new FilterBucket();

		const maxDrawCount = 100;
		this.root = new DisplayObject2D();
		this.root._scene = this;
		this.batchDraw = batchDraw.bind(this, maxDrawCount);

		const {device, canvas} = Vulkan;
		const vertexData = new Float32Array(instanceFloatCount * maxDrawCount);
		const vertexBuffer = device.createBuffer({
			size: vertexData.byteLength,
			usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
		});
		const [indexBuffer, indexData] = device.createBufferMapped({
			size: 54 * 2,
			usage: GPUBufferUsage.INDEX
		});
		new Uint16Array(indexData).set(createMeshIndices(4, 4));
		indexBuffer.unmap();

		const [uniformBuffer, uniformData] = device.createBufferMapped({
			size: 2 * 4,
			usage: GPUBufferUsage.UNIFORM
		});
		new Float32Array(uniformData).set([2 / canvas.width, -2 / canvas.height]);
		uniformBuffer.unmap();

		const bindGroupLayout = device.createBindGroupLayout({
			bindings:[{
				binding: 0,
				visibility: GPUShaderStage.VERTEX,
				type: 'uniform-buffer',
			},{
				binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampler'
			}]
		});

		this.bindGroup = device.createBindGroup({
			layout: bindGroupLayout,
			bindings: [{
				binding: 0,
				resource: {buffer: uniformBuffer}
			},{	binding: 1,
				resource: device.createSampler({
					magFilter: 'linear',
					minFilter: 'linear',
				})
			}]
		});

		const textureBindGroupLayout = device.createBindGroupLayout({
			bindings:[{
				binding: 0,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampled-texture'
			}]
		});

		this.textureBindGroupDesc = {
			layout: textureBindGroupLayout,
			bindings: [{binding: 0,
				resource: null//bind later
			}]
		};

		this.pipeline = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts: [bindGroupLayout, textureBindGroupLayout]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_2d.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_2d.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-list',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}],
			vertexState: {
				indexFormat: 'uint16',
				vertexBuffers:[{
					arrayStride: instanceFloatCount << 2,
					stepMode: 'instance',
					attributes:[{
						shaderLocation: 0,
						offset: 0,
						format: 'float3'
					},{
						shaderLocation: 1,
						offset: 3 << 2,
						format: 'float3'
					},{
						shaderLocation: 2,
						offset: 6 << 2,
						format: 'float4'
					},{
						shaderLocation: 3,
						offset: 10 << 2,
						format: 'float4'
					},{
						shaderLocation: 4,
						offset: 14 << 2,
						format: 'float4'
					},{
						shaderLocation: 5,
						offset: 18 << 2,
						format: 'float4'
					}]
				}]
			}
		});

		this.vertexBuffer = vertexBuffer;
		this.indexBuffer = indexBuffer;
		this.vertexData = vertexData;

		this.renderPassDesc = {
			colorAttachments: [{
				attachment: null,
				loadValue: 'load'
			}],
			/*depthStencilAttachment: {
				attachment: null,
				depthLoadValue: 1.0,
				depthStoreOp: 'store',
				stencilLoadValue: 0,
				stencilStoreOp: 'store'
			}*/
		};
	}

	initRenderPassEncoder(){
		const {renderPassEncoder} = Vulkan;
		renderPassEncoder.setPipeline(this.pipeline);
		renderPassEncoder.setVertexBuffer(0, this.vertexBuffer);
		renderPassEncoder.setIndexBuffer(this.indexBuffer);
		renderPassEncoder.setBindGroup(0, this.bindGroup);
	}

	update(){
		traverseTree.call(null, this.root, this.onUpdate);
	}

	onCollectFilter(item){
		if(!item.visible)return true;
		if(item.filter){
			this.enterFilter(item);
			return this.leaveFilter;
		}
	}

	draw(){
		const {vertexBuffer, vertexData, renderPassDesc} = this;
		const {mainColorTexture, mainDepthStencil, bitmapQueue} = Vulkan;

		this.totalDrawCount = 0;

		traverseTree.call(this.filterBucket, this.root, this.onCollectFilter);
		this.filterBucket.draw(this).clear();

		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture], mainDepthStencil);

		this.initRenderPassEncoder();

		traverseTree.call(null, this.root, this.onDraw);

		bitmapQueue.draw(this.onBatchDraw, this).clear();
		renderPassEncoder.endPass();

		vertexBuffer.setSubData(0, vertexData);
	}

	onUpdate(item){
		if(!item.visible)return true;
		const {onUpdate} = item;
		return onUpdate && onUpdate.apply(item);
	}

	onDraw(item){
		const {bitmapQueue} = Vulkan;
		if(!item.visible)return true;
		const {filter, onDraw} = item;
		const filterFlag = !this && filter;
		if(filterFlag){
			bitmapQueue.add(filter);
			return true;
		}
		if(onDraw)onDraw.call(item, this);
	}

	onBatchDraw(instanceList){
		const {device, renderPassEncoder} = Vulkan;
		const texture = instanceList[0].texture.getRawAsset();
		this.textureBindGroupDesc.bindings[0].resource = texture;
		renderPassEncoder.setBindGroup(1, device.createBindGroup(this.textureBindGroupDesc));
		this.batchDraw(instanceList);
	}

	onUpdateBufferBatch(instanceList, offset, instanceCount, batchIndex){
		const {vertexData, totalDrawCount} = this;
		for(let i=0; i<instanceCount; ++i){
			const {worldTransform, texture, width, height, fgColor} = instanceList[offset+i];
			worldTransform.copyToArray(tempList, 0, 3);
			const j = instanceFloatCount * (i + totalDrawCount);
			vertexData.set(tempList, j);
			if(texture){
				vertexData.set(texture.xyuvMul, j+6);
				vertexData.set(texture.xyuvAdd, j+10);
				vertexData.set(texture.scale9grid, j+18);
				vertexData[j+14] = width;
				vertexData[j+15] = texture.width;
				vertexData[j+16] = height;
				vertexData[j+17] = texture.height;
			}else{
				vertexData.set(allOne, j+6);
				vertexData.set(allZero, j+10);
				vertexData.set(allZero, j+18);
				vertexData[j+14] = width;
				vertexData[j+15] = width;
				vertexData[j+16] = height;
				vertexData[j+17] = height;
			}
		}
	}

	onUploadBufferAndDraw(instanceCount){
		const {renderPassEncoder} = Vulkan;
		renderPassEncoder.drawIndexed(triangleCount, instanceCount, 0, 0, this.totalDrawCount);
		this.totalDrawCount += instanceCount;
	}
}

const tempList = new Array(6);
const allZero = new Float32Array(4);
const allOne = new Float32Array(4).fill(1);

const instanceFloatCount = 22;
const instanceByteSize = instanceFloatCount << 2;

const vertexCountX = 4;
const vertexCountY = 4;
const triangleCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.


class View3D
{
	constructor(){
		this.scene3d = new Scene3D();
		this.scene2d = new Scene2D();
		frameDo(this.onTick.bind(this));

		const {device, canvas} = Vulkan;

		this.depthTexture = device.createTexture({
			size: [canvas.width, canvas.height, 1],
			format: 'depth24plus-stencil8',
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
			dimension: '2d',//optional, default 2d(1d, 3d)
		});

		this.fence = device.defaultQueue.createFence();
	}

	onTick(){
		this.updateScene();
		this.drawScene();
	}

	updateScene(){
		this.scene3d.update();
		this.scene2d.update();
	}

	drawScene(){
		const {device, swapChain} = Vulkan;
		const {depthTexture} = this;

		const mainColorTexture = swapChain.getCurrentTexture().createView();
		const mainDepthStencil = depthTexture.createView();

		const commandEncoder = device.createCommandEncoder();

		Vulkan.commandEncoder = commandEncoder;
		Vulkan.mainColorTexture = mainColorTexture;
		Vulkan.mainDepthStencil = mainDepthStencil;

		//console.log(Vulkan._renderPassDescStack.length);
		Vulkan.bitmap3dMgr.reset();

		this.scene3d.draw();
		this.scene2d.draw();

		device.defaultQueue.submit([commandEncoder.finish()]);
		//console.log('submit', performance.now());
		//device.defaultQueue.signal(this.fence, 101);
		/*console.log('signal begin', performance.now());
		this.fence.onCompletion(23).then(() => {
			console.log('fence complete', performance.now(), this.fence.getCompletedValue())
		});
		console.log('signal end', performance.now());
		//*/
	}
}

class Bitmap extends DisplayObject2D
{
	constructor(){
		super();
		this._texture = null;
		this.width = 0;
		this.height = 0;
	}

	get texture(){
		return this._texture;
	}

	set texture(value){
		this._texture = value;
		if(value == null){
			return;
		}
		this.width = value.width;
		this.height = value.height;
	}

	onDraw(mode){
		Vulkan.bitmapQueue.add(this);
	}
}

class Filter2D
{
	static Init(){
		const {device, bitmap3dMgr} = Vulkan;
		const frameBuffer = bitmap3dMgr.list[0].frameBuffer.createView();
		const textureBindGroupLayout = device.createBindGroupLayout({
			bindings:[{
				binding: 0,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampler'
			},{
				binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'sampled-texture'
			}]
		});
		this.prototype.textureBindGroupLayout = textureBindGroupLayout;
		this.textureBindGroup = device.createBindGroup({
			layout: textureBindGroupLayout,
			bindings: [{
				binding: 0,
				resource: device.createSampler({
					magFilter: 'linear',
					minFilter: 'linear',
				})
			},{	binding: 1,
				resource: frameBuffer
			}]
		});
	}

	constructor(){
		this.worldTransform = new Matrix2D();
	}

	onDraw(){}
}

class BlurFilter extends Filter2D
{
	constructor(color=[1,0,1,1]){
		super();
		const {device, canvas} = Vulkan;

		this.uniformBuffer = device.createBuffer({
			size: 8 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});

		this.uniformBuffer2 = device.createBuffer({
			size: 4 * 4,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});
		this.uniformBuffer2.setSubData(0, new Float32Array(color));

		const bindGroupLayout = device.createBindGroupLayout({
			bindings:[{
				binding: 0,
				visibility: GPUShaderStage.VERTEX,
				type: 'uniform-buffer',
			},{
				binding: 1,
				visibility: GPUShaderStage.FRAGMENT,
				type: 'uniform-buffer'
			}]
		});

		const bindGroupDesc = {
			layout: bindGroupLayout,
			bindings: [{
				binding: 0,
				resource: {
					buffer: this.uniformBuffer
				}
			},{	binding: 1,
				resource: {
					buffer: this.uniformBuffer2
				}
			}]
		};

		this.bindGroup = device.createBindGroup(bindGroupDesc);
		
		this.pipeline = device.createRenderPipeline({
			layout: device.createPipelineLayout({
				bindGroupLayouts: [this.textureBindGroupLayout, bindGroupLayout]
			}),
			vertexStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_filter.vertexCode,
				}),
				entryPoint: 'main'
			},
			fragmentStage: {
				module: device.createShaderModule({
					code: Vulkan.shader_filter.fragmentCode,
				}),
				entryPoint: 'main'
			},
			primitiveTopology: 'triangle-strip',
			colorStates:[{
				format: Vulkan.swapChainFormat,
				colorBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				},
				alphaBlend: {
					srcFactor: 'src-alpha',
					dstFactor: 'one-minus-src-alpha',
					operation: 'add'
				}
			}]
		});
	}

	onDraw(){
		const {device, renderPassEncoder} = Vulkan;
		const rect = this.drawRect;
		renderPassEncoder.setPipeline(this.pipeline);
		renderPassEncoder.setBindGroup(1, this.bindGroup);
		renderPassEncoder.draw(4, 1, 0, 0);//rect

		this.uniformBuffer.setSubData(0, new Float32Array([
			rect.x / MAX_W, rect.y / MAX_H, rect.width / MAX_W, rect.height / MAX_H,
			rect.x / MAX_W - 1, rect.y / MAX_H + 1, 2 * rect.width / MAX_W, -2 * rect.height / MAX_H,

			//0,0,1,1,
			//-1, 1, 2, -2
		]));
	}
}

class ColorMatrixFilter extends BlurFilter
{
	constructor(){
		super([0,1,1,1]);
	}
}

const MAX_W = 4096;
const MAX_H = 4096;

class Element
{
	constructor(){
		this.rectPack = new MaxRectsBinPack(MAX_W, MAX_H);
		this.frameBuffer = Vulkan.device.createTexture({
			size: [MAX_W, MAX_H, 1],
			format: Vulkan.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.SAMPLED
		});
	}

	clear(){
		this.rectPack.clear();
	}
}

class Bitmap3DManager
{
	constructor(){
		this.list = [
			new Element(),
			new Element(),
		];
	}

	reset(){
		this.list.forEach(v => v.clear())
	}

	acquire(target){
		const {width, height} = Vulkan.canvas;
		const element = this.list[0];
		return target.drawRect = element.rectPack.insert(width, height);
	}

	draw(){
		if(this.list.length <= 0)return;
		const {frameBuffer, list} = this;
		const {gl, renderStateStack, textureMgr} = WebGL;
		renderStateStack.save(DRAW_FRAMEBUFFER_BINDING, VIEWPORT);
		frameBuffer.active();
		gl.clearBufferfv(gl.COLOR, 0, zero);
		gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);
		for(let bitmap3D of list){
			const {drawRect, camera, root3d} = bitmap3D;
			gl.viewport(drawRect.x, drawRect.y, drawRect.width, drawRect.height);
			camera.render(root3d);
			const texture = bitmap3D.texture;
			texture.rawTexture = frameBuffer.colorBuffer;
			texture.setUV(MAX_W, MAX_H, drawRect);
		}
		renderStateStack.load(DRAW_FRAMEBUFFER_BINDING, VIEWPORT);
	}
}

class MeshEntity extends DisplayObject3D
{
	static Draw(entityList){
		for(const entity of entityList){
			entity.onDraw();
		}
	}

	constructor(mesh, createSkeleton=true){
		super();
		this.matrix = new Mat3x4();
		const {device} = Vulkan;
		this.mesh = mesh;
		const vertexBufferSize = mesh.subMeshList.reduce((s, v) => s + v.vertexData.byteLength, 0);
		const vertexBuffer = this.vertexBuffer = device.createBuffer({
			size: vertexBufferSize,
			usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
		});
		let vertexOffset = 0;
		let byteOffset = 0;
		this.subEntityList = mesh.subMeshList.map(subMesh => Object.create(this, {
			entity: {value: this},
			subMesh: {value: subMesh},
			//vao: {value: MeshVertexArray.new(subMesh)},
			//boneMatrixList: {value: new Float32Array(Math.max(subMesh.boneData.length, 1) * 8)},
			vertexCount: {
				value: subMesh.vertexCount
			},
			vertexOffset: {value: function(){
				vertexBuffer.setSubData(byteOffset, subMesh.vertexData);
				byteOffset += subMesh.vertexData.byteLength;
				const value = vertexOffset;
				vertexOffset += subMesh.vertexCount;
				return value;
			}()},
		}));
		this.uniformBuffer = function(){
			const uniformBuffer = device.createBuffer({
				size: 5 * 4 * 4,
				usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
			});
			uniformBuffer.setSubData(0, new Float32Array([
				...new Array(12).fill(0),
				0,0,0,1,
				0,0,0,1
			]));
			return uniformBuffer;
		}()
	}

	onDraw(){
		const {textureBindGroupDesc, uniformBindGroupDesc} = this.scene;
		const {device, commandEncoder, mainColorTexture, mainDepthStencil, renderPassEncoder} = Vulkan;

		this.uniformBuffer.setSubData(0, this.matrix.rawData);

		renderPassEncoder.setVertexBuffer(0, this.vertexBuffer);
		uniformBindGroupDesc.bindings[0].resource.buffer = this.uniformBuffer;
		renderPassEncoder.setBindGroup(1, device.createBindGroup(uniformBindGroupDesc));

		this.subEntityList.forEach(subEntity => {
			let texture = Vulkan.fetchTexture(subEntity.subMesh.texture)
			if(!texture)return;
			textureBindGroupDesc.bindings[0].resource = texture.createView();
			renderPassEncoder.setBindGroup(2, device.createBindGroup(textureBindGroupDesc));
			renderPassEncoder.draw(subEntity.vertexCount, 1, subEntity.vertexOffset, 0);
		})
	}
}



exports.Vulkan = Vulkan;
exports.View3D = View3D;
exports.Bitmap = Bitmap;
exports.BlurFilter = BlurFilter;
exports.ColorMatrixFilter = ColorMatrixFilter;
exports.MeshEntity = MeshEntity;
exports.Camera3D = Camera3D;
