'use strict';

const overrideMethod = require('utils/function/overrideMethod');
const {loadData} = require('utils/loader');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	return view;
});

const Vulkan = require('./Vulkan');
Vulkan.fetchTexture = createFetch(function(name, callback){
	const {device} = this;
	if(name.toLowerCase().endsWith('.tga')){
		loadData(name, 'arraybuffer').then(data => {
			let image = imageUtil.decode(name, data);
			const texture = device.createTexture({
				size: [image.width, image.height, 1],
				format: 'rgba8unorm',
				usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
			});
			texture.transparent = true;
			texture.name = name;
			texture.width = image.width;
			texture.height = image.height;
			createImageBitmap(
				new ImageData(new Uint8ClampedArray(image.data), image.width, image.height),
				{imageOrientation:'flipY'}
			).then(imageBitmap => {
				device.queue.copyImageBitmapToTexture(
					{imageBitmap},
					{texture, mipLevel: 0, origin: [0, 0, 0]},
					[image.width, image.height, 1]
				);
				callback(texture);
			});
		});
	}else{
		this.loadTexture(this.device, name).then(callback);
	}
});
Vulkan.loadModel = async path => Vulkan.addMeshBufferGetter(parse(new Uint8Array(await loadData(path, 'arraybuffer'))));
Vulkan.loadTexture = async (device, path) => {
	const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path), {imageOrientation:'none'});
	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
	});
	device.queue.copyImageBitmapToTexture(
		{imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);
	texture.transparent = false;
	texture.name = path;
	texture.width = imageBitmap.width;
	texture.height = imageBitmap.height;
	return texture;
};

Vulkan.addMeshBufferGetter = mesh => {
	if(mesh.vertexData){
		Vulkan.defineConstGetter(mesh, 'vertexBuffer', () => Vulkan.createBufferMapped(GPUBufferUsage.VERTEX, mesh.vertexData));
	}
	if(mesh.indexData){
		Vulkan.defineConstGetter(mesh, 'indexBuffer', () => Vulkan.createBufferMapped(GPUBufferUsage.INDEX, mesh.indexData));
	}
	Vulkan.defineConstGetter(mesh, 'wireframeIndexBuffer', () => {
		const rawData = mesh.indexData;
		const indexCount = rawData ? rawData.length : mesh.vertexCount;
		const indexData = new Uint16Array(indexCount << 1);
		if(rawData){
			for(let i=0; i<indexCount; i+=3){
				indexData.set([rawData[i], rawData[i+1], rawData[i+1], rawData[i+2], rawData[i+2], rawData[i]], i << 1);
			}
		}else{
			for(let i=0; i<indexCount; i+=3){
				indexData.set([i, i+1, i+1, i+2, i+2, i], i << 1);
			}
		}
		mesh.wireframeIndexCount = indexData.length;
		return Vulkan.createBufferMapped(GPUBufferUsage.INDEX, indexData);
	});
	return mesh;
}
