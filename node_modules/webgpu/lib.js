'use strict';

const ObjectCache = require('utils/ObjectCache');
const DisplayObject = require('./DisplayObject');
const DisplayObject2D = require('./DisplayObject2D');
const DisplayObject3D = require('./DisplayObject3D');
const traverseTree = require('utils/traverseTree');
const BitmapQueue = require('opengl/renderers/BitmapQueue');
//const {createMeshIndices} = require('utils/geometry');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');
const overrideMethod = require('utils/function/overrideMethod');
const {loadData} = require('utils/loader');
const {createFetch} = require('utils/cache');
require('bluetooth/Buffer');
const {parse} = require('mu/bmd');
const imageUtil = require('fileformats/images');
const Matrix2D = require('opengl/math/Matrix2D');
const Filter2D = require('./filter2Ds/Filter2D');
const FilterSwapChain = require('./filter2Ds/FilterSwapChain');

const {Texture2D} = require('opengl/textures');
const Mat3x4 = require('./mat3x4');
//const collectAllTypes = require('utils/class/collectAllTypes');
const ArrayValueMap = require('ds/ArrayValueMap');
const BoneObject = require('opengl/3d/BoneObject');

const Render2D = require('./render2d');
const VertexBufferManager = require('./managers/VertexBufferManager');

overrideMethod(GPUTexture.prototype, 'createView', oldFn => function(descriptor){
	let view = oldFn.call(this, descriptor);
	view.width = this.width;
	view.height = this.height;
	return view;
});

const Vulkan = require('./Vulkan');
Vulkan.fetchTexture = createFetch(function(name, callback){
	const {device} = this;
	if(name.endsWith('.tga')){
		loadData(name, 'arraybuffer').then(data => {
			let image = imageUtil.decode(name, data);
			const texture = device.createTexture({
				size: [image.width, image.height, 1],
				format: 'rgba8unorm',
				usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
			});
			texture.transparent = true;
			texture.name = name;
			texture.width = image.width;
			texture.height = image.height;
			createImageBitmap(
				new ImageData(new Uint8ClampedArray(image.data), image.width, image.height)
			).then(imageBitmap => {
				device.defaultQueue.copyImageBitmapToTexture(
					{imageBitmap},
					{texture, mipLevel: 0, origin: [0, 0, 0]},
					[image.width, image.height, 1]
				);
				callback(texture);
			});
		});
	}else{
		this.loadTexture(this.device, name).then(callback);
	}
});
Vulkan.loadModel = async path => parse(new Uint8Array(await loadData(path, 'arraybuffer')));
Vulkan.loadTexture = async (device, path) => {
	const imageBitmap = await createImageBitmap(await Vulkan.loadImage(path));
	const texture = device.createTexture({
		size: [imageBitmap.width, imageBitmap.height, 1],
		format: 'rgba8unorm',
		usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST,
	});
	device.defaultQueue.copyImageBitmapToTexture(
		{imageBitmap, origin:[0, 0]},
		{texture, mipLevel: 0, origin: [0, 0, 0]},
		[imageBitmap.width, imageBitmap.height, 1]
	);
	texture.transparent = false;
	texture.name = path;
	texture.width = imageBitmap.width;
	texture.height = imageBitmap.height;
	return texture;
};

Object.defineProperties(Vulkan, {
	swapChainFormat: {value: 'bgra8unorm'},
	init:{value(device, canvas){
		this.device = device;
		this.canvas = canvas;
		this.swapChain = canvas.getContext('gpupresent').configureSwapChain({
			device,
			format: this.swapChainFormat,
			usage: GPUTextureUsage.OUTPUT_ATTACHMENT
		});
		this.mgrList = [];
		this.filterSwapChain = new FilterSwapChain();
		this.render2D = new Render2D();
		Filter2D.Init();
		this.onInit();
	}},
	
	pushRenderPass:{value(desc, colorAttachments, depthStencilAttachment){
		if(colorAttachments)colorAttachments.forEach((v, i) => desc.colorAttachments[i].attachment = v);
		if(desc.depthStencilAttachment)desc.depthStencilAttachment.attachment = depthStencilAttachment;
		return this.renderPassEncoder = this.commandEncoder.beginRenderPass(desc);
	}},
});
