'use strict';

class Vector3D
{
	static Interpolate(a, b, f, result){
		result.x = a.x + (b.x - a.x) * f;
		result.y = a.y + (b.y - a.y) * f;
		result.z = a.z + (b.z - a.z) * f;
		return result;
	}

	constructor(x=0, y=0, z=0){
		this.x = x;
		this.y = y;
		this.z = z;
	}

	clone(){
		return new this.constructor(this.x, this.y, this.z);
	}

	identity(){
		this.x = 0;
		this.y = 0;
		this.z = 0;
		return this;
	}

	get length(){
		return Math.hypot(this.x, this.y, this.z);
	}

	get lengthSquared(){
		const {x, y, z} = this;
		return x * x + y * y + z * z;
	}

	normalize(result=this){
		return this.scaleBy(1 / this.length, result);
	}

	setTo(x, y, z){
		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	}

	copyFrom(other){
		this.x = other.x;
		this.y = other.y;
		this.z = other.z;
		return this;
	}

	copyTo(other){
		other.x = this.x;
		other.y = this.y;
		other.z = this.z;
		return other;
	}

	negate(result=this){
		result.x = - this.x;
		result.y = - this.y;
		result.z = - this.z;
		return result;
	}

	scaleBy(value, result=this){
		result.x = this.x * value;
		result.y = this.y * value;
		result.z = this.z * value;
		return result;
	}

	add(other, result=this){
		result.x = this.x + other.x;
		result.y = this.y + other.y;
		result.z = this.z + other.z;
		return result;
	}

	subtract(other, result=this){
		result.x = this.x - other.x;
		result.y = this.y - other.y;
		result.z = this.z - other.z;
		return result;
	}

	interpolate(to, f, result){
		return Vector3D.Interpolate(this, to, f, result);
	}

	copyToArray(list, offset=0){
		list[offset  ] = this.x;
		list[offset+1] = this.y;
		list[offset+2] = this.z;
	}

	setFromArray(list, offset=0){
		this.x = list[offset];
		this.y = list[offset+1];
		this.z = list[offset+2];
	}

	dotProd(other){
		return (this.x * other.x) + (this.y * other.y) + (this.z * other.z);
	}

	crossProd(other, result=this){
		let {x:ax, y:ay, z:az} = this;
		let {x:bx, y:by, z:bz} = other;
		result.x = (ay * bz) - (az * by);
		result.y = (az * bx) - (ax * bz);
		result.z = (ax * by) - (ay * bx);
		return result;
	}

	crossProdAxisX(result=this){
		return result.setTo(0, this.z, -this.y);
	}

	crossProdAxisY(result=this){
		return result.setTo(-this.z, 0, this.x);
	}

	crossProdAxisZ(result=this){
		return result.setTo(this.y, -this.x, 0);
	}

	reflect(normal, result=this){
		let len = this.dotProd(normal) * 2;
		result.x = this.x - normal.x * len;
		result.y = this.y - normal.y * len;
		result.z = this.z - normal.z * len;
		return result;
	}
}

Vector3D.X_AXIS = Object.freeze(new Vector3D(1, 0, 0));
Vector3D.Y_AXIS = Object.freeze(new Vector3D(0, 1, 0));
Vector3D.Z_AXIS = Object.freeze(new Vector3D(0, 0, 1));

Vector3D.prototype.projectToPlane = function(){
	const normal = new Vector3D();
	return function(plane, result=this, isPlaneNormalized=true, scale=1){
		const [a, b, c, d] = plane;
		let value = this.dotProd(normal.setTo(a, b, c)) + d;
		if(!isPlaneNormalized){
			value /= normal.lengthSquared;
		}
		return this.subtract(normal.scaleBy(value * scale, result), result);
	}
}();

module.exports = Vector3D;