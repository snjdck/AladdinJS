'use strict';

class Vector2D
{
	constructor(x=0, y=0){
		this.x = x;
		this.y = y;
	}

	clone(){
		return new this.constructor(this.x, this.y);
	}

	identity(){
		return this.setTo(0, 0);
	}

	setTo(x, y){
		this.x = x;
		this.y = y;
		return this;
	}

	copyFrom(other){
		return this.setTo(other.x, other.y);
	}

	get length(){
		return Math.hypot(this.x, this.y);
	}

	set length(value){
		this.normalize().multiply(value);
	}

	get lengthSquared(){
		const {x, y} = this;
		return x * x + y * y;
	}

	normalize(result=this){
		if(!result){result = this.clone();}
		if(this.lengthSquared <= 0)return result.setTo(1, 0);
		return this.multiply(1 / this.length, result);
	}

	negate(result=this){
		if(!result){result = this.clone();}
		result.x = - this.x;
		result.y = - this.y;
		return result;
	}

	add(other, result=this){
		if(!result){result = this.clone();}
		result.x = this.x + other.x;
		result.y = this.y + other.y;
		return result;
	}

	subtract(other, result=this){
		if(!result){result = this.clone();}
		result.x = this.x - other.x;
		result.y = this.y - other.y;
		return result;
	}

	multiply(value, result=this){
		if(!result){result = this.clone();}
		result.x = this.x * value;
		result.y = this.y * value;
		return result;
	}

	divide(value, result=this){
		if(!result){result = this.clone();}
		result.x = this.x / value;
		result.y = this.y / value;
		return result;
	}

	copyToArray(list, offset=0){
		list[offset  ] = this.x;
		list[offset+1] = this.y;
		return this;
	}

	setFromArray(list, offset=0){
		this.x = list[offset];
		this.y = list[offset+1];
		return this;
	}

	dotProd(other){
		return (this.x * other.x) + (this.y * other.y);
	}

	crossProd(other){
		return (this.x * other.y) - (this.y * other.x);
	}

	crossProdAxisX(){
		return -this.y;
	}

	crossProdAxisY(){
		return this.x;
	}

	equals(other){
		return this.x == other.x && this.y == other.y;
	}

	get perp(){
		return new this.constructor(-this.y, this.x);
	}

	get angle(){
		return Math.atan2(this.y, this.x);
	}

	set angle(value){
		const d = this.length;
		this.x = d * Math.cos(value);
		this.y = d * Math.sin(value);
	}

	truncate(value){
		if(this.lengthSquared > value * value){
			this.length = value;
		}
		return this;
	}
}

Vector2D.X_AXIS = Object.freeze(new Vector2D(1, 0));
Vector2D.Y_AXIS = Object.freeze(new Vector2D(0, 1));
Vector2D.ZERO = Object.freeze(new Vector2D(0, 0));
Vector2D.ONE = Object.freeze(new Vector2D(1, 1));

Vector2D.prototype.scaleBy = Vector2D.prototype.multiply;

Vector2D.prototype.distance = function(){
	const temp = new Vector2D();
	return function(other){
		return this.subtract(other, temp).length;
	}
}();

/**
 * 坐标轴: x向右, y向下, 原点为坐标为this
 * @param pta a点坐标
 * @param ptb b点坐标
 * @return 如果 ptb-this 在 pta-this 的顺时针方向,则返回值大于0, 逆时针方向则返回值小于0, 返回值0表示三点共线
 */		
Vector2D.prototype.clockwise = function(){
	const ta = new Vector2D();
	const tb = new Vector2D();
	return function(pa, pb){
		pa.subtract(this, ta);
		pb.subtract(this, tb);
		return ta.crossProd(tb);
	}
}();

Vector2D.Polar = function(length, angle){
	return new this(length * Math.cos(angle), length * Math.sin(angle));
}

Vector2D.Interpolate = function(a, b, f, result){
	result.x = a.x + (b.x - a.x) * f;
	result.y = a.y + (b.y - a.y) * f;
	return result;
}

Vector2D.AngleBetween = (a, b) => Math.acos(a.dotProd(b) / (a.length * b.length));

/**
 * 返回两条直线的交点
 * @param dirA 直线A的方向
 * @param posA 直线A经过的点
 * @param dirB 直线B的方向
 * @param posB 直线B经过的点
 * @return 两条直线的交点,如果没有交点,返回null
 */
Vector2D.Intersection = function(dirA, posA, dirB, posB, result){
	const divisor = dirA.crossProd(dirB);
	if(divisor == 0)return false;
	result.x = ((dirA.x * dirB.y * posB.x) - (dirA.y * dirB.x * posA.x) + (dirA.x * dirB.x * (posA.y - posB.y))) / divisor;
	result.y = ((dirA.x * dirB.y * posA.y) - (dirA.y * dirB.x * posB.y) + (dirA.y * dirB.y * (posB.x - posA.x))) / divisor;
	return true;
}

module.exports = Vector2D;