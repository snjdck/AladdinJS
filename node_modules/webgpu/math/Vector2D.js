'use strict';

class Vector2D
{
	static Interpolate(a, b, f, result){
		result.x = a.x + (b.x - a.x) * f;
		result.y = a.y + (b.y - a.y) * f;
		return result;
	}

	constructor(x=0, y=0){
		this.x = x;
		this.y = y;
	}

	clone(){
		return new this.constructor(this.x, this.y);
	}

	identity(){
		this.x = 0;
		this.y = 0;
		return this;
	}

	get length(){
		return Math.hypot(this.x, this.y);
	}

	get lengthSquared(){
		const {x, y} = this;
		return x * x + y * y;
	}

	normalize(result=this){
		return this.scaleBy(1 / this.length, result);
	}

	setTo(x, y){
		this.x = x;
		this.y = y;
	}

	copyFrom(other){
		this.x = other.x;
		this.y = other.y;
	}

	negate(result=this){
		result.x = - this.x;
		result.y = - this.y;
		return result;
	}

	scaleBy(value, result=this){
		result.x = this.x * value;
		result.y = this.y * value;
		return result;
	}

	add(other, result=this){
		result.x = this.x + other.x;
		result.y = this.y + other.y;
		return result;
	}

	subtract(other, result=this){
		result.x = this.x - other.x;
		result.y = this.y - other.y;
		return result;
	}

	copyToArray(list, offset=0){
		list[offset  ] = this.x;
		list[offset+1] = this.y;
	}

	setFromArray(list, offset=0){
		this.x = list[offset];
		this.y = list[offset+1];
	}

	dotProd(other){
		return (this.x * other.x) + (this.y * other.y);
	}

	crossProd(other){
		return (this.x * other.y) - (this.y * other.x);
	}

	crossProdAxisX(){
		return -this.y;
	}

	crossProdAxisY(){
		return this.x;
	}
}

Vector2D.X_AXIS = Object.freeze(new Vector2D(1, 0));
Vector2D.Y_AXIS = Object.freeze(new Vector2D(0, 1));

module.exports = Vector2D;