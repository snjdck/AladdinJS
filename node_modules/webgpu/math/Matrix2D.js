"use strict";

/*
[a , b , 0]
[c , d , 0]
[tx, ty, 1]

rotate
[cos , sin, 0]
[-sin, cos, 0]
[0   ,   0, 1]

scale
[sx, 0 , 0]
[0 , sy, 0]
[0 , 0 , 1]

translate
[1 , 0 , 0]
[0 , 1 , 0]
[tx, ty, 1]
*/

class Matrix2D
{
	static compose(matrix, scaleX=1, scaleY=1, rotation=0, tx=0, ty=0)
	{
		matrix.tx = tx;
		matrix.ty = ty;
		if(0 === rotation){
			matrix.a = scaleX;
			matrix.d = scaleY;
			matrix.b = matrix.c = 0;
		}else{
			const cos = Math.cos(rotation);
			const sin = Math.sin(rotation);
			matrix.a = scaleX * cos;
			matrix.c = scaleY * -sin;
			matrix.b = scaleX * sin;
			matrix.d = scaleY * cos;
		}
		return matrix;
	}

	static concat(left, right, output)
	{
		let {a:a1, b:b1, c:c1, d:d1, tx:tx1, ty:ty1} = left;
		let {a:a2, b:b2, c:c2, d:d2, tx:tx2, ty:ty2} = right;
		
		output.a	= a1 * a2 + b1 * c2;
		output.b	= a1 * b2 + b1 * d2;
		
		output.c	= c1 * a2 + d1 * c2;
		output.d	= c1 * b2 + d1 * d2;
		
		output.tx	= tx1 * a2 + ty1 * c2 + tx2;
		output.ty	= tx1 * b2 + ty1 * d2 + ty2;
	}

	static invert(matrix, output)
	{
		let {a, b, c, d, tx, ty} = matrix;
		let factor = a * d - b * c;
		
		if(0 == factor){
			output.a = output.d = 1;
			output.b = output.c = output.tx = output.ty = 0;
			return;
		}
		
		if(0 == c && 0 == b){//rotation == 0
			output.b = output.c = 0;
			output.a = 1 / a;
			output.d = 1 / d;
			output.tx = output.a * -tx;
			output.ty = output.d * -ty;
			return;
		}
		
		factor = 1 / factor;
		
		output.a = d * factor;
		output.d = a * factor;
		output.b = b * -factor;
		output.c = c * -factor;
		output.tx = -(tx * output.a + ty * output.c);
		output.ty = -(tx * output.b + ty * output.d);
	}

	constructor(){
		this.identity();
	}

	identity(){
		this.a = this.d = 1.0;
		this.c = this.b = 0.0;
		this.tx = this.ty = 0.0;
		return this;
	}

	append(other, result=this){
		Matrix2D.concat(this, other, result);
		return result;
	}

	prepend(other, result=this){
		Matrix2D.concat(other, this, result);
		return result;
	}

	invert(result=this){
		Matrix2D.invert(this, result);
	}

	rotate(angle){
		let sin = Math.sin(angle);
		let cos = Math.cos(angle);
		let {a, b, c, d, tx, ty} = this;
		
		this.a  = a  * cos - b  * sin;
		this.c  = c  * cos - d  * sin;
		this.tx = tx * cos - ty * sin;
		
		this.b  = a  * sin + b  * cos;
		this.d  = c  * sin + d  * cos;
		this.ty = tx * sin + ty * cos;
	}

	scale(sx, sy){
		this.a  *= sx;
		this.c  *= sx;
		this.tx *= sx;
		
		this.b  *= sy;
		this.d  *= sy;
		this.ty *= sy;
	}

	translate(dx, dy){
		this.tx += dx;
		this.ty += dy;
	}

	transformCoords(x, y, output){
		output.x = (this.a * x) + (this.c * y) + this.tx;
		output.y = (this.b * x) + (this.d * y) + this.ty;
	}

	transformCoordsDelta(x, y, output){
		output.x = (this.a * x) + (this.c * y);
		output.y = (this.b * x) + (this.d * y);
	}

	transformCoordsInv(x, y, output){
		const {a, b, c, d, tx, ty} = this;
		const factor = a * d - b * c;
		
		if(0 == factor){
			output.x = x;
			output.y = y;
			return;
		}
		
		if(0 == c && 0 == b){//rotation == 0
			output.x = (x - tx) / a;
			output.y = (y - ty) / d;
			return;
		}
		
		const dx = x - tx;
		const dy = y - ty;
		
		output.x = (d * dx - c * dy) / factor;
		output.y = (a * dy - b * dx) / factor;
	}

	transformCoordsDeltaInv(x, y, output){
		let {a, b, c, d, tx, ty} = this;
		let factor = a * d - b * c;
		
		if(0 == factor){
			output.x = x;
			output.y = y;
			return;
		}
		
		if(0 == c && 0 == b){//rotation == 0
			output.x = x / a;
			output.y = y / d;
			return;
		}
		
		factor = 1 / factor;
		
		output.x = factor * (d * x - c * y);
		output.y = factor * (a * y - b * x);
	}

	copyFrom(other){
		if(other == this)return this;
		this.a = other.a;
		this.b = other.b;
		this.c = other.c;
		this.d = other.d;
		this.tx = other.tx;
		this.ty = other.ty;
		return this;
	}

	setTo(a, b, c, d, tx, ty){
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
		this.tx = tx;
		this.ty = ty;
	}

	clone(){
		var matrix = new Matrix2D();
		matrix.copyFrom(this);
		return matrix;
	}

	copyToArray(dest, offset=0, stride=4){
		dest[offset  ] = this.a;
		dest[offset+1] = this.c;
		dest[offset+2] = this.tx;
		offset += stride;
		dest[offset  ] = this.b;
		dest[offset+1] = this.d;
		dest[offset+2] = this.ty;
	}

	prependRotation(angle){
		let sin = Math.sin(angle);
		let cos = Math.cos(angle);
		let {a, b, c, d} = this;
		
		this.a = a * cos + c * sin;
		this.b = b * cos + d * sin;
		this.c = c * cos - a * sin;
		this.d = d * cos - b * sin;
	}

	prependScale(sx, sy){
		this.a *= sx;
		this.b *= sx;
		this.c *= sy;
		this.d *= sy;
	}

	prependTranslation(dx, dy){
		this.tx += (this.a * dx) + (this.c * dy);
		this.ty += (this.b * dx) + (this.d * dy);
	}

	prependSkew(skewX, skewY){
		let sinX = Math.sin(skewX);
		let cosX = Math.cos(skewX);
		let sinY = Math.sin(skewY);
		let cosY = Math.cos(skewY);
		let {a, b, c, d, tx, ty} = this;
		
		this.a = a * cosY + c * sinY;
		this.b = b * cosY + d * sinY;
		this.c = c * cosX + a * sinX;
		this.d = d * cosX + b * sinX;
	}

	decompose(result={}){
		//a =  cos * sx
		//c = -sin * sy
		//b =  sin * sx
		//d =  cos * sy
		let {a, b, c, d, tx, ty} = this;
		result.x = tx;
		result.y = ty;

		let isScaleX0 = 0 == a && 0 == b;
		let isScaleY0 = 0 == c && 0 == d;
		let isCos0 = 0 == a && 0 == d;
		let isSin0 = 0 == c && 0 == b;

		if(isScaleX0 || isScaleY0){
			result.scaleX = result.scaleY = result.rotation = 0;
		}else if(isSin0){
			if(a < 0 && d < 0){
				result.scaleX = -a;
				result.scaleY = -d;
				result.rotation = 180;
			}else{
				result.scaleX = a;
				result.scaleY = d;
				result.rotation = 0;
			}
		}else if(isCos0){
			if(b < 0 && c > 0){
				result.scaleX = -b;
				result.scaleY =  c;
				result.rotation = -90;
			}else{
				result.scaleX =  b;
				result.scaleY = -c;
				result.rotation = 90;
			}
		}else{
			result.scaleX = Math.hypot(a, b);
			result.scaleY = Math.hypot(c, d) * Math.sign(a * d);
			result.rotation = Math.atan2(b, a);
		}
	}

	transformBound(source, result=source){
		const {x:sourceMinX, y:sourceMinY} = source;
		const sourceMaxX = sourceMinX + source.width;
		const sourceMaxY = sourceMinY + source.height;

		let {tx:minX, ty:minY} = this;
		let factor, maxX = minX, maxY = minY;
		
		if((factor = this.a) > 0){
			minX += factor * sourceMinX;
			maxX += factor * sourceMaxX;
		}else{
			minX += factor * sourceMaxX;
			maxX += factor * sourceMinX;
		}
		if((factor = this.c) > 0){
			minX += factor * sourceMinY;
			maxX += factor * sourceMaxY;
		}else{
			minX += factor * sourceMaxY;
			maxX += factor * sourceMinY;
		}
		if((factor = this.b) > 0){
			minY += factor * sourceMinX;
			maxY += factor * sourceMaxX;
		}else{
			minY += factor * sourceMaxX;
			maxY += factor * sourceMinX;
		}
		if((factor = this.d) > 0){
			minY += factor * sourceMinY;
			maxY += factor * sourceMaxY;
		}else{
			minY += factor * sourceMaxY;
			maxY += factor * sourceMinY;
		}
		
		result.x = minX;
		result.y = minY;
		result.width  = maxX - minX;
		result.height = maxY - minY;

		return result;
	}
}

module.exports = Matrix2D;