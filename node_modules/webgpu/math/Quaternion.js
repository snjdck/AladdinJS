"use strict";

class Quaternion{
	static Slerp(a, b, percent, result){
		let {x:x1, y:y1, z:z1, w:w1} = a;
		let {x:x2, y:y2, z:z2, w:w2} = b;
		let dot = x1*x2 + y1*y2 + z1*z2 + w1*w2;
		
		if(dot < 0){
			dot = -dot;
			x2 = -x2;
			y2 = -y2;
			z2 = -z2;
			w2 = -w2;
		}
		
		if(dot < 0.95){//正常插值
			let angle = Math.acos(dot);
			let s = 1 / Math.sin(angle);
			let s1 = s * Math.sin(angle * (1 - percent));
			let s2 = s * Math.sin(angle * percent);
			
			result.x = x1*s1 + x2*s2;
			result.y = y1*s1 + y2*s2;
			result.z = z1*s1 + z2*s2;
			result.w = w1*s1 + w2*s2;
		}else{//线性插值
			result.x = x1 + (x2-x1) * percent;
			result.y = y1 + (y2-y1) * percent;
			result.z = z1 + (z2-z1) * percent;
			result.w = w1 + (w2-w1) * percent;
			
			result.normalize();
		}
	}

	constructor(x=0, y=0, z=0, w=1){
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}

	identity(){
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.w = 1;
		return this;
	}

	setTo(x, y, z, w){
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	}

	copyFrom(other){
		this.x = other.x;
		this.y = other.y;
		this.z = other.z;
		this.w = other.w;
		return this;
	}

	normalize(){
		let {x, y, z, w} = this;
		let factor = 1 / Math.hypot(x, y, z, w);
		this.x *= factor;
		this.y *= factor;
		this.z *= factor;
		this.w *= factor;
		return this;
	}

	negate(result=this){
		if(result != this){
			result.w = this.w;
		}
		result.x = -this.x;
		result.y = -this.y;
		result.z = -this.z;
		return result;
	}

	fromEulerAngles(pitch, yaw, roll){
		var halfX = 0.5 * pitch;
		var halfY = 0.5 * yaw;
		var halfZ = 0.5 * roll;
		var sinX = Math.sin(halfX);
		var cosX = Math.cos(halfX);
		var sinY = Math.sin(halfY);
		var cosY = Math.cos(halfY);
		var sinZ = Math.sin(halfZ);
		var cosZ = Math.cos(halfZ);
		this.x = sinX*cosY*cosZ - cosX*sinY*sinZ;
		this.y = sinY*cosZ*cosX + cosY*sinZ*sinX;
		this.z = sinZ*cosX*cosY - cosZ*sinX*sinY;
		this.w = cosX*cosY*cosZ + sinX*sinY*sinZ;
		return this;
	}

	toEulerAngles(result){
		const {x, y, z, w} = this;
		result.x = Math.atan2(2*(w*x+y*z), 1-2*(x*x+y*y));
		result.y = Math.asin( 2*(w*y-x*z));
		result.z = Math.atan2(2*(w*z+y*x), 1-2*(z*z+y*y));
		return result;
	}

	fromAxisAngle(axis, angle){
		let halfAngle = angle * 0.5;
		let sin = Math.sin(halfAngle);
		this.x = axis.x * sin;
		this.y = axis.y * sin;
		this.z = axis.z * sin;
		this.w = Math.cos(halfAngle);
		return this;
	}

	toAxisAngle(result){
		if(1 == w){
			result.x = 1;
			result.y = result.z = result.w = 0;
			return;
		}
		let halfAngle = Math.acos(this.w);
		let factor = 1 / Math.sin(halfAngle);
		result.x = this.x * factor;
		result.y = this.y * factor;
		result.z = this.z * factor;
		result.w = 2 * halfAngle;
	}

	prepend(other, result=this){
		let {x, y, z, w} = this;
		let {x:tx, y:ty, z:tz, w:tw} = other;
		
		result.x = (w * tx) + (x * tw) + (y * tz) - (z * ty);
		result.y = (w * ty) - (x * tz) + (y * tw) + (z * tx);
		result.z = (w * tz) + (x * ty) - (y * tx) + (z * tw);
		result.w = (w * tw) - (x * tx) - (y * ty) - (z * tz);

		return result;
	}

	copyToArray(list, offset=0){
		list[offset  ] = this.x;
		list[offset+1] = this.y;
		list[offset+2] = this.z;
		list[offset+3] = this.w;
	}

	setFromArray(list, offset=0){
		this.x = list[offset];
		this.y = list[offset+1];
		this.z = list[offset+2];
		this.w = list[offset+3];
	}

	rotateVector(v, result=v){
		const {x, y, z, w} = this;
		const {x:vx, y:vy, z:vz} = v;

		const xx = x*x;
		const yy = y*y;
		const zz = z*z;
		const ww = w*w;
		
		const xy = x*y;
		const yz = y*z;
		const zx = z*x;
		const xw = x*w;
		const yw = y*w;
		const zw = z*w;
		
		result.x = vx * (xx + ww - yy - zz) + (vy * (xy - zw) + vz * (zx + yw)) * 2;
		result.y = vy * (yy + ww - zz - xx) + (vz * (yz - xw) + vx * (xy + zw)) * 2;
		result.z = vz * (zz + ww - xx - yy) + (vx * (zx - yw) + vy * (yz + xw)) * 2;
	}

	toMatrix(result, translation){
		//复制区域--begin
		const {x, y, z, w} = this;
		
		const xx = x*x;
		const yy = y*y;
		const zz = z*z;
		const ww = w*w;
		
		const xy = x*y;
		const yz = y*z;
		const zx = z*x;
		const xw = x*w;
		const yw = y*w;
		const zw = z*w;
		//复制区域--end
		
		result[0]  = xx + ww - yy - zz;
		result[1]  = (xy - zw) * 2;
		result[2]  = (zx + yw) * 2;
		
		result[4]  = (xy + zw) * 2;
		result[5]  = yy + ww - zz - xx;
		result[6]  = (yz - xw) * 2;
		
		result[8]  = (zx - yw) * 2;
		result[9]  = (yz + xw) * 2;
		result[10] = zz + ww - xx - yy;
		
		result[3] = translation.x;
		result[7] = translation.y;
		result[11] = translation.z;
		
		result[12] = result[13] = result[14] = 0;
		result[15] = 1;
	}
/*
	rotateAxisX(angle, result=this){
		let halfAngle = angle * 0.5;
		let x = Math.sin(halfAngle);
		let w = Math.cos(halfAngle);

		let {x:tx, y:ty, z:tz, w:tw} = this;
		
		result.x = (w * tx) + (x * tw);
		result.y = (w * ty) - (x * tz);
		result.z = (w * tz) + (x * ty);
		result.w = (w * tw) - (x * tx);
	}

	rotateAxisY(angle, result=this){
		let halfAngle = angle * 0.5;
		let y = Math.sin(halfAngle);
		let w = Math.cos(halfAngle);

		let {x:tx, y:ty, z:tz, w:tw} = this;
		
		result.x = (w * tx) + (y * tz);
		result.y = (w * ty) + (y * tw);
		result.z = (w * tz) - (y * tx);
		result.w = (w * tw) - (y * ty);
	}

	rotateAxisZ(angle, result=this){
		let halfAngle = angle * 0.5;
		let z = Math.sin(halfAngle);
		let w = Math.cos(halfAngle);

		let {x:tx, y:ty, z:tz, w:tw} = this;
		
		result.x = (w * tx) - (z * ty);
		result.y = (w * ty) + (z * tx);
		result.z = (w * tz) + (z * tw);
		result.w = (w * tw) - (z * tz);
	}
*/
}

module.exports = Quaternion;