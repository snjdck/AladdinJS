'use strict';

const {traverseTree} = require('utils/traverseTree');

class DisplayObject
{
	constructor(addPropTransform, matrixType){
		this._parent = null;
		this._children = [];

		this._localMatrixInvert = new matrixType();
		this._worldMatrix = new matrixType();
		this._worldMatrixInvert = new matrixType();

		this.visible = true;
		this.mouseEnabled = false;
		this.mouseChildren = true;
		this.type = '';

		this.isTransformStatic = false;

		addPropTransform(this, new matrixType(), onTransformChanged);
	}

	get parent(){
		return this._parent;
	}

	get children(){
		return this._children;
	}

	get numChildren(){
		return this.children.length;
	}

	get worldTransform(){
		if(this._isWorldMatrixDirty){
			this._isWorldMatrixDirty = false;
			if(this.parent){
				this.transform.append(this.parent.worldTransform, this._worldMatrix);
			}else{
				this._worldMatrix.copyFrom(this.transform);
			}
		}
		return this._worldMatrix;
	}

	get transformInvert(){
		if(this._isLocalMatrixInvertDirty){
			this._isLocalMatrixInvertDirty = false;
			this.transform.invert(this._localMatrixInvert);
		}
		return this._localMatrixInvert;
	}

	get worldTransformInvert(){
		if(this._isWorldMatrixInvertDirty){
			this._isWorldMatrixInvertDirty = false;
			this.worldTransform.invert(this._worldMatrixInvert);
		}
		return this._worldMatrixInvert;
	}

	addChild(child){
		child._parent = this;
		markWorldMatrixDirty(child);
		return child;
	}

	removeChild(child){
		child._parent = null;
		markWorldMatrixDirty(child);
		return child;
	}

	hasChild(child){
		return child != null && child.parent == this;
	}

	contains(target){
		while(target != null){
			if(target == this)
				return true;
			target = target.parent;
		}
		return false;
	}
	
	get root(){
		let target = this;
		while(target.parent)
			target = target.parent;
		return target;
	}

	get scene(){
		return this.root._scene;
	}

	set parent(value){
		if(this.parent == value)return;
		if(!value)return this.parent.removeChild(this);
		value.addChild(this);
	}

	removeFromParent(){
		this.parent?.removeChild(this);
	}

	removeAllChildren(){
		const {children} = this;
		while(children.length > 0){
			this.removeChild(children.pop());
		}
	}

	calculateRelativeTransform(target, result){
		if(target === this){
			return result.identity();
		}
		if(target === this.parent){
			return result.copyFrom(this.transform);
		}
		if(target.parent === this){
			return result.copyFrom(target.transformInvert);
		}
		return this.worldTransform.append(target.worldTransformInvert, result);
	}
}
/*
DisplayObject.updateWorldTransform = collectTree(function(item){
	if(!item.isTransformStatic){
		if(this.length > 0){
			item.transform.append(this[this.length-1], item.worldTransform);
		}else{
			item.worldTransform.copyFrom(item.transform);
		}
	}
	this.push(item.worldTransform);
	return this.pop;
});

DisplayObject.updateTree = (onUpdate => root => traverseTree(root, onUpdate))(item => item.visible && item.onUpdate?.());
*/

function onTransformChanged(){
	this._isLocalMatrixInvertDirty = true;
	markWorldMatrixDirty(this);
}

const markWorldMatrixDirty = function(){
	function onUpdate(item){
		if(item._isWorldMatrixDirty)return true;
		item._isWorldMatrixDirty = true;
		item._isWorldMatrixInvertDirty = true;
	}
	return root => traverseTree(root, onUpdate);
}();

module.exports = DisplayObject;
