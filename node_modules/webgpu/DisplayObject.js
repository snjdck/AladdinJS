'use strict';

class DisplayObject
{
	constructor(matrixType){
		this._parent = null;
		this._children = [];

		this._localMatrix = new matrixType();
		this._worldMatrix = new matrixType();

		this.visible = true;
		this.mouseEnabled = false;
		this.mouseChildren = true;
		this.type = '';
	}

	get parent(){
		return this._parent;
	}

	get children(){
		return this._children;
	}

	get numChildren(){
		return this.children.length;
	}

	get transform(){
		return this._localMatrix;
	}

	get worldTransform(){
		return this._worldMatrix;
	}

	hasChild(child){
		return child && child.parent == this;
	}

	contains(target){
		while(target != null){
			if(target == this)
				return true;
			target = target.parent;
		}
		return false;
	}
	
	get root(){
		let target = this;
		while(target.parent)
			target = target.parent;
		return target;
	}

	get scene(){
		return this.root._scene;
	}

	removeFromParent(){
		this.parent?.removeChild(this);
	}

	removeAllChildren(){
		const {children} = this;
		while(children.length > 0){
			this.removeChild(children.pop());
		}
	}

	calculateRelativeTransform(target, result){
		if(target == null){
			result.copyFrom(this.worldTransform);
			return;
		}
		if(target == this){
			result.identity();
			return;
		}
		if(target == this.parent){
			result.copyFrom(this.transform);
			return;
		}
		if(target.parent == this){
			result.copyFrom(target.transform);
			result.invert();
			return;
		}
		if(this.contains(target)){
			target.calculateRelativeTransform(this, result);
			result.invert();
			return;
		}
		if(target.contains(this)){
			result.identity();
			let node = this;
			while(node != target){
				result.append(node.transform);
				node = node.parent;
			}
			return;
		}
		target.worldTransform.invert(result);
		result.prepend(this.worldTransform);
	}
}

module.exports = DisplayObject;
