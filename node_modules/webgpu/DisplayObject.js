'use strict';

const {walkTree} = require('utils/traverseTree');

class DisplayObject
{
	constructor(matrixType){
		this._parent = null;
		this._children = [];

		this._localMatrix = new matrixType();
		this._localMatrixInvert = new matrixType();
		this._worldMatrix = new matrixType();
		this._worldMatrixInvert = new matrixType();

		this.visible = true;
		this.mouseEnabled = false;
		this.mouseChildren = true;
		this.type = '';

		this.isTransformStatic = false;
	}

	get parent(){
		return this._parent;
	}

	get children(){
		return this._children;
	}

	get numChildren(){
		return this.children.length;
	}

	get worldTransform(){
		if(this._isWorldMatrixDirty){
			this._isWorldMatrixDirty = false;
			if(this.parent){
				this.transform.append(this.parent.worldTransform, this._worldMatrix);
			}else{
				this._worldMatrix.copyFrom(this.transform);
			}
		}
		return this._worldMatrix;
	}

	get transformInvert(){
		if(this._isLocalMatrixInvertDirty){
			this._isLocalMatrixInvertDirty = false;
			this.transform.invert(this._localMatrixInvert);
		}
		return this._localMatrixInvert;
	}

	get worldTransformInvert(){
		if(this._isWorldMatrixInvertDirty){
			this._isWorldMatrixInvertDirty = false;
			this.worldTransform.invert(this._worldMatrixInvert);
		}
		return this._worldMatrixInvert;
	}

	addChild(child){
		child._parent = this;
		markWorldMatrixDirty(child);
		return child;
	}

	removeChild(child){
		child._parent = null;
		markWorldMatrixDirty(child);
		return child;
	}

	hasChild(child){
		return child != null && child.parent == this;
	}

	contains(target){
		while(target != null){
			if(target == this)
				return true;
			target = target.parent;
		}
		return false;
	}
	
	get root(){
		let target = this;
		while(target.parent)
			target = target.parent;
		return target;
	}

	get scene(){
		return this.root._scene;
	}

	set parent(value){
		if(this.parent == value)return;
		if(!value)return this.parent.removeChild(this);
		value.addChild(this);
	}

	removeFromParent(){
		this.parent?.removeChild(this);
	}

	removeAllChildren(){
		const {children} = this;
		while(children.length > 0){
			this.removeChild(children.pop());
		}
	}

	calculateRelativeTransform(target, result){
		if(target === this){
			return result.identity();
		}
		if(target === this.parent){
			return result.copyFrom(this.transform);
		}
		if(target.parent === this){
			return result.copyFrom(target.transformInvert);
		}
		return this.worldTransform.append(target.worldTransformInvert, result);
	}

	onTransformChanged(){
		this._isLocalMatrixDirty = true;
		this._isLocalMatrixInvertDirty = true;
		markWorldMatrixDirty(this);
	}

	$addAttributeNumber(key, value){
		Object.defineProperty(this, key, {get:()=>value, set(v){
			if(value === v)return;
			value = v;
			this.onTransformChanged();
		}});
	}

	$addAttributeObject(key, value){
		Object.defineProperty(this, key, {get:()=>value, set(v){
			if(v)value.copyFrom(v);else value.identity();
			this.onTransformChanged();
		}});
	}

	$addAttributeTransform(composeFn){
		const value = this._localMatrix;
		Object.defineProperty(this, 'transform', {get(){
			if(this._isLocalMatrixDirty){
				this._isLocalMatrixDirty = false;
				composeFn(value);
			}
			return value;
		}, set(v){
			if(v)value.copyFrom(v);else value.identity();
			this.onTransformChanged();
		}});
	}
}

/*
DisplayObject.updateWorldTransform = collectTree(function(item){
	if(!item.isTransformStatic){
		if(this.length > 0){
			item.transform.append(this[this.length-1], item.worldTransform);
		}else{
			item.worldTransform.copyFrom(item.transform);
		}
	}
	this.push(item.worldTransform);
	return this.pop;
});

DisplayObject.updateTree = (onUpdate => root => traverseTree(root, onUpdate))(item => item.visible && item.onUpdate?.());
*/

const markWorldMatrixDirty = walkTree(function(item){
	if(item._isWorldMatrixDirty)return true;
	item._isWorldMatrixDirty = true;
	item._isWorldMatrixInvertDirty = true;
	item._isWorldBoundDirty = true;
});

module.exports = DisplayObject;
