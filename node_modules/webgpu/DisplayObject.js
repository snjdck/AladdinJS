'use strict';

const {traverseTree} = require('utils/traverseTree');

class DisplayObject
{
	constructor(addPropTransform, matrixType){
		this._parent = null;
		this._children = [];

		this._worldMatrix = new matrixType();

		this.visible = true;
		this.mouseEnabled = false;
		this.mouseChildren = true;
		this.type = '';

		this.isTransformStatic = false;
		this._isWorldMatrixDirty = true;

		addPropTransform(this, new matrixType(), this.markWorldMatrixDirty);
	}

	get parent(){
		return this._parent;
	}

	get children(){
		return this._children;
	}

	get numChildren(){
		return this.children.length;
	}

	get worldTransform(){
		if(this._isWorldMatrixDirty){
			this._isWorldMatrixDirty = false;
			if(this.parent){
				this.transform.append(this.parent.worldTransform, this._worldMatrix);
			}else{
				this._worldMatrix.copyFrom(this.transform);
			}
		}
		return this._worldMatrix;
	}

	addChild(child){
		child._parent = this;
		child.markWorldMatrixDirty();
		return child;
	}

	removeChild(child){
		child._parent = null;
		child.markWorldMatrixDirty();
		return child;
	}

	hasChild(child){
		return child != null && child.parent == this;
	}

	contains(target){
		while(target != null){
			if(target == this)
				return true;
			target = target.parent;
		}
		return false;
	}
	
	get root(){
		let target = this;
		while(target.parent)
			target = target.parent;
		return target;
	}

	get scene(){
		return this.root._scene;
	}

	set parent(value){
		if(this.parent == value)return;
		if(!value)return this.parent.removeChild(this);
		value.addChild(this);
	}

	removeFromParent(){
		this.parent?.removeChild(this);
	}

	removeAllChildren(){
		const {children} = this;
		while(children.length > 0){
			this.removeChild(children.pop());
		}
	}

	calculateRelativeTransform(target, result){
		if(target == null){
			result.copyFrom(this.worldTransform);
			return;
		}
		if(target == this){
			result.identity();
			return;
		}
		if(target == this.parent){
			result.copyFrom(this.transform);
			return;
		}
		if(target.parent == this){
			result.copyFrom(target.transform);
			result.invert();
			return;
		}
		if(this.contains(target)){
			target.calculateRelativeTransform(this, result);
			result.invert();
			return;
		}
		if(target.contains(this)){
			result.identity();
			let node = this;
			while(node != target){
				result.append(node.transform);
				node = node.parent;
			}
			return;
		}
		target.worldTransform.invert(result);
		result.prepend(this.worldTransform);
	}
}
/*
DisplayObject.updateWorldTransform = collectTree(function(item){
	if(!item.isTransformStatic){
		if(this.length > 0){
			item.transform.append(this[this.length-1], item.worldTransform);
		}else{
			item.worldTransform.copyFrom(item.transform);
		}
	}
	this.push(item.worldTransform);
	return this.pop;
});

DisplayObject.updateTree = (onUpdate => root => traverseTree(root, onUpdate))(item => item.visible && item.onUpdate?.());
*/
DisplayObject.prototype.markWorldMatrixDirty = function(){
	function onUpdate(item){
		if(item._isWorldMatrixDirty)return true;
		item._isWorldMatrixDirty = true;
	}
	return function(){
		traverseTree(this, onUpdate);
	}
}();

module.exports = DisplayObject;
