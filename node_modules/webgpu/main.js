'use strict';

require('bluetooth/Buffer');
const Clock = require('./helper/Clock');
const Texture2D = require('./2d/Texture2D');
const {RADIAN} = require('./math');
const Vector3D = require('./math/Vector3D');
const Quaternion = require('./math/Quaternion');
const DisplayObject2D = require('./DisplayObject2D');
const terrain = require('./terrain');
const world1objects = require('mu/world1objects');
const readMapObj = require('mu/readMapObj');
const mapTileList = require('mu/mapTileList');
const {tickByFrame} = require('webonly/timer');
const KeyCode = require('./const/KeyCode');
const {playMP3} = require('webonly/audio');
const {supportDrag} = require('webonly');
const {createTextureArray, requestDevice, requestSwapChain} = require('webonly/utils_gpu');
const {fetchArrayBuffer, loadImage} = require('webonly/utils');
/*
const shader_2d = require('./shaders/2d');
const shader_3d = require('./shaders/3d');
const shader_filter = require('./shaders/filter');
const shader_terrain = require('./shaders/terrain');
const shader_cull = require('./shaders/cull');
const shader_bound = require('./shaders/bound');
const shader_billboard = require('./shaders/billboard');
*/
const {Bitmap, Bitmap3D} = require('./DisplayObject2DFactory');
const View3D = require('./view3d');
const Lens = require('./cameras/Lens');
const Camera3D = require('./cameras/Camera3D');
const Camera2D = require('./cameras/Camera2D');
require('./lib');
const {parse} = require('mu/bmd');
const parse_gltf = require('fileformats/gltf');
const Vulkan = require('./Vulkan');
const MeshEntity = require('./3d/MeshEntity');
//const Material = require('./materials/Material')
const TextureMaterial = require('./materials/TextureMaterial')
const WingTextureMaterial = require('./materials/WingTextureMaterial')
const BillboardMaterial = require('./materials/BillboardMaterial')
const ColorMaterial = require('./materials/ColorMaterial')
const BoundMaterial = require('./materials/BoundMaterial')
const TerrainMaterial = require('./materials/TerrainMaterial')
const WireframeMaterial = require('./materials/WireframeMaterial')

const BlurFilter = require('./materials/BlurFilter');

const AABB = require('./bounds/AABB');
const regHotKey = require('webonly/hotkey');
const parseItemInfo = require('mu/parseItemInfo');
const createStateMachine = require('mu/playerAniState');

const {showDetailFactory, average} = require('utils/stats');
const showDetail = showDetailFactory(average(
	v => document.getElementById('text_fps').textContent = `fps: ${Math.round(v)}`
));




const {runAction, ActionBuilder, Sequence, Spawn, Delay, Repeat, CallFunc, nearestRotation} = require('game/engine/action/Action');

async function init(){
	//playMP3('./assets/Music/MuTheme.mp3');
	let dragTotalCount = 0;
	let lastDragItem;
	supportDrag(function({files}){
		Array.from(files).map(v => {
			let reader = new FileReader();
			reader.onload = () => {
				let mesh = parse(new Uint8Array(reader.result));
				console.log(mesh)
				let entity = view3d.scene3d.addChild(new MeshEntity(mesh));
				entity.addMaterial(new TextureMaterial());
				entity.moveTo(500, 300, 100);
				Clock.on("enterFrame", () => {
					entity.rotation = entity.rotation.prepend(new Quaternion().fromEulerAngles(0, 0, 0.5 * RADIAN));
				});
				if(lastDragItem){
					view3d.scene3d.removeChild(lastDragItem);
				}
				lastDragItem = entity;
				return
				entity.addMaterial(new TextureMaterial());
				entity.moveTo(dragTotalCount * 500, 300, 100);
				dragTotalCount++;
			};
			reader.readAsArrayBuffer(v);
		})
	})
	const terrainMesh = await terrain();

	//Vulkan.shader_filter = shader_filter
	//Vulkan.shader_2d = shader_2d;
	//Vulkan.shader_3d = shader_3d;
	//Vulkan.shader_3d_color = {vertexCode:shader_3d.vertexCode, fragmentCode:shader_3d.fragment3DColorCode};
	//Vulkan.shader_terrain = shader_terrain;
	//Vulkan.shader_cull = glsl_compiler.compute(shader_cull);
	//Vulkan.shader_bound = shader_bound;
	//Vulkan.shader_billboard = shader_billboard;

	//Vulkan.registerShaderModule('compute_cull', Vulkan.shader_cull);
	//Vulkan.registerShaderModule(`fragment_wireframe`, shader_bound.wireframeGLSL);

	//for(let key of ['3d']){
	//	Vulkan.registerShaderModule(`vertex_${key}`, Vulkan[`shader_`+key].vertexCode);
	//	Vulkan.registerShaderModule(`fragment_${key}`, Vulkan[`shader_`+key].fragmentCode);
	//}
	/*
	const canvas = document.createElement('canvas');
	canvas.width = 1000;
	canvas.height = 600;
	document.body.appendChild(canvas);
	*/
	const canvas = document.getElementById('canvas');

	void function(){
		const canvas = document.createElement('canvas');
		canvas.style = 'position:absolute; left:0; top:0; pointer-events:none; background-color: rgba(0, 0, 0, 0);'
		canvas.width = 1000;
		canvas.height = 600;
		document.body.appendChild(canvas);
		Vulkan.canvas2d = canvas;
	}()
	
	if(!navigator.gpu)return;
	const device = await requestDevice();
	Vulkan.swapChain = requestSwapChain(canvas, device);
	Vulkan.init(device, canvas);

	let gltfData = await fetch('test/Xbot.glb').then(response => response.arrayBuffer());
	const gltfInfo = parse_gltf(new Uint8Array(gltfData));
	let objRoot = gltfInfo.scene.nodes[0];
	let subMeshList = objRoot.children.slice(0, 2);
	for(let subMesh of subMeshList){

	}
	console.log(objRoot, subMeshList)
	//return

	async function loadWingFiles(dict, type){
		let nameList = Object.keys(dict);
		let fileList = await Promise.all(nameList.map(v => Vulkan.loadModel(`./assets/${type}/${v}.bmd`)));
		fileList.forEach((v, i) => dict[nameList[i]].mesh = v);
	}

	await loadWingFiles(wingDict, 'Wing');
	console.log(wingDict)
	await loadWingFiles(helperDict, 'Wing');
	await loadWingFiles(itemExtra, 'Item');
	await loadWingFiles(skillExtra, 'Skill');

	
	let fileList = await Promise.all(monsterNameList.map(v => Vulkan.loadModel(`./assets/Monster/${v}.bmd`)));
	fileList.forEach((v, i) => {
		if(!monsterDict[monsterNameList[i]]){
			monsterDict[monsterNameList[i]] = {name:monsterNameList[i]};
		}
		monsterDict[monsterNameList[i]].mesh = v
	});
	console.log(monsterDict)

	const playerMesh = await Vulkan.loadModel('./player.bmd');
	playerMesh.animationList[146].copyFirstFrameToEnd();
	console.log(playerMesh)
	const weaponData = await Vulkan.loadModel('./assets/Item/Spear10.bmd');
	const monster03Data = await Vulkan.loadModel('./Monster03.bmd');
	
	const texture = await Vulkan.loadTexture('./1.png')
	const texture2 = await Vulkan.loadTexture('./2.jpg')

	const view3d = new View3D();
	tickByFrame(timeElapsed => {
		showDetail(1000 / timeElapsed);
		view3d.render();
	});
	Vulkan.view3d = view3d;

	view3d.scene2d.camera = new Camera2D(canvas);

	const cameraWorldRot = new Quaternion().fromEulerAngles(120 * RADIAN, 0, -45 * RADIAN);
	const cameraWorldPos = new Vector3D(0,0);

	view3d.scene3d.camera = new Camera3D(new Lens.Perspective(Math.PI / 6, canvas.height / canvas.width, -1500, 5000, -2000));
	//view3d.scene3d.camera = new Camera3D(new Lens.Ortho(canvas.width, canvas.height, -5000, 5000));
	view3d.scene3d.camera.cullEnabled = true;
	view3d.scene3d.camera.rotation = new Quaternion().fromEulerAngles(120 * RADIAN, 0, -45 * RADIAN);
	//view3d.scene3d.camera.x = 400;
	//view3d.scene3d.camera.y = 600;
	//view3d.scene3d.camera.worldTransformInvert.compose(cameraWorldRot, cameraWorldPos).invert();

	let terrainTexture = await createTextureArray(Vulkan.device, await Promise.all(mapTileList.map(v => loadImage(`./assets/World1/${v}.jpg`))));
	const meshTerrain = view3d.scene3d.root.addChild(new MeshEntity(terrainMesh).addMaterial(new TerrainMaterial(terrainTexture)));

	const mesh1 = view3d.scene3d.root.addChild(new MeshEntity(weaponData));
	const mesh2 = view3d.scene3d.root.addChild(new MeshEntity(weaponData));
	const mesh3 = view3d.scene3d.root.addChild(new MeshEntity(weaponData));
	const mesh4 = view3d.scene3d.root.addChild(new MeshEntity(weaponData));

	console.log("--", monster03Data, '??');
	let hero;
	let monsterMesh = Object.create(new MeshEntity(monster03Data), {
		moveTargetTo: {value(...args){
			//return moveTargetTo(this, ...args);
		}},
		foundEnemy: {value(){
			if(!hero)return false;
			//console.log('check found enemy',this.x, this.y, hero.x, hero.y,Math.hypot(this.x - hero.x, this.y - hero.y));
			if(Math.hypot(400 - hero.x, 400 - hero.y) < 500){
				this.targetEnemyFind = hero;
				return true;
			}
			this.targetEnemyFind = null;
			
			return false;
		}},
		getEnemy:{value(){
			const {targetEnemyFind} = this;
			return targetEnemyFind && Math.hypot(this.x - targetEnemyFind.x, this.y - targetEnemyFind.y) < 100;
		}},
		enemyDead:{value(){
			return false;
		}},
		bloodToLess:{value(){
			return false;
		}},
	});
	monsterMesh.stateMachine = createStateMachine(monsterMesh);
	view3d.scene3d.root.addChild(monsterMesh)
	monsterMesh.stateMachine.update();
	//Clock.on('enterFrame', () => monsterMesh.stateMachine.update())
	//mesh1.visible = mesh2.visible = mesh3.visible = monsterMesh.visible = meshTerrain.visible = false;

	mesh1.addMaterial(new TextureMaterial());
	mesh2.addMaterial(new ColorMaterial([0, 1, 0, 1]));
	mesh3.addMaterial(new ColorMaterial([0, 0, 1, 1]));
	mesh4.addMaterial(new ColorMaterial([1, 1, 0, 1]));
	monsterMesh.addMaterial(new TextureMaterial())
	.addMaterial(new BoundMaterial(new AABB().setMinMax(0,0,0,100,100,200)))
	.addMaterial(new WireframeMaterial());
	monsterMesh.bound = new AABB().setMinMax(0,0,0,100,100,200);

	const rot = new Quaternion()//.fromEulerAngles(0, -90 * RADIAN, -90 * RADIAN);

	mesh1.moveTo(300, 300, 100);
	mesh2.moveTo(300, 600, 100);
	mesh3.moveTo(300, 800, 100);
	mesh4.moveTo(300, 1000, 100);
	monsterMesh.moveTo(400, 400, 0);
/*
	mesh1.onTransformChanged();
	mesh2.onTransformChanged();
	mesh3.onTransformChanged();
	monsterMesh.onTransformChanged();
*/
	
	void async function(){
		const meshData = await Vulkan.loadModel('./assets/Skill/Magic02.bmd');
		let entity = new MeshEntity(meshData).addMaterial(new WingTextureMaterial());
		
		Clock.on('enterFrame', function(){
			entity.moveTo(0, performance.now() % 900,0);
		})
		//view3d.scene3d.addChild(entity);
		let playerEntity = await createPlayer(view3d.scene3d, playerMesh, 1);
		playerEntity.animation = playerEntity.animationList[146];
		//Vulkan.animationMgr.register(playerEntity);

		playerEntity.addChild(entity);
	}();

	showSkill(view3d, playerMesh, 'Ice01', 500, entity => entity.moveTo(0,100,0))
	showSkill(view3d, playerMesh, 'Poison01', 1000, entity => entity.moveTo(0,100,0))
	showSkill(view3d, playerMesh, 'Protect01', 1500, entity => (entity, t) => entity.rotation = entity.rotation.prepend(new Quaternion().fromEulerAngles(0,0,0.1)))
	showSkill(view3d, playerMesh, 'Protect02', 2000, entity => (entity, t) => entity.rotation = entity.rotation.prepend(new Quaternion().fromEulerAngles(0,0,0.1)))
	showSkill(view3d, playerMesh, 'Inferno01', 3000, entity => (entity, t) => entity.rotation = entity.rotation.prepend(new Quaternion().fromEulerAngles(0,0,0.1)))
	showSkill(view3d, playerMesh, 'WaveForce', 3000, entity => (entity, t) => entity.rotation = entity.rotation.prepend(new Quaternion().fromEulerAngles(0,0,0.1)))
	showSkill(view3d, playerMesh, 'Storm01', 2500, entity => {
		entity.moveTo(0,100,0)
		return (entity, t) => entity.rotation = entity.rotation.prepend(new Quaternion().fromEulerAngles(0,0,0.1))
	})
	showSkill(view3d, playerMesh, 'Blast01', 3500, entity => {
		entity.moveTo(0,100,0)
		return (entity, t) => entity.moveTo(0,100,900 - t % 900)
	});
	showSkill(view3d, playerMesh, 'Circle01', 4000)
	showSkill(view3d, playerMesh, 'Circle02', 4000)
	
	
	for(let [i, j] of Object.entries([1,2,3,4,5,6,201,202,203,206,301,302,303,304,305,306])){
		let playerEntity = await createPlayer(view3d.scene3d, playerMesh, j);
		playerEntity.moveTo(i * 300, 500);
		//playerEntity.bindObjectToBone("Bone05", new MeshEntity(weaponData).addMaterial(new TextureMaterial()));
		
	}

	for(let [i,info] of Object.entries(Object.values(wingDict))){
		let playerEntity = await createPlayer(view3d.scene3d, playerMesh, 1);
		playerEntity.moveTo(i * 300, 1000);
		playerEntity.bindObjectToBone("Bone05", new MeshEntity(info.mesh).addMaterial(new TextureMaterial()));
		
	}

	for(let [i,info] of Object.entries(Object.values(helperDict))){
		let playerEntity = new MeshEntity(info.mesh).addMaterial(new TextureMaterial())
		view3d.scene3d.addChild(playerEntity);
		playerEntity.moveTo(i * 300, 1500);
	}

	for(let [i,info] of Object.entries(Object.values(itemExtra))){
		let playerEntity = new MeshEntity(info.mesh).addMaterial(new TextureMaterial())
		view3d.scene3d.addChild(playerEntity);
		playerEntity.moveTo(i * 300 + 2000, 1500);
	}

	for(let [i,info] of Object.entries(Object.values(skillExtra))){
		let playerEntity = new MeshEntity(info.mesh).addMaterial(new TextureMaterial())
		view3d.scene3d.addChild(playerEntity);
		playerEntity.moveTo(i * 300 + 4000, 1500);
	}
/*
	for(let [i,info] of Object.entries(Object.values(monsterDict))){
		let playerEntity = new MeshEntity(info.mesh).addMaterial(new TextureMaterial())
		view3d.scene3d.addChild(playerEntity);
		playerEntity.moveTo((i% 10) * 300, 2000 + Math.floor(i / 10) * 500);
	}
*/
	
	
	void async function(){
		let playerEntity = await createPlayer(view3d.scene3d, playerMesh, 1, 0xff, false);
		playerEntity.moveTo(400, 600);
		Vulkan.mouseMgr.mouseDownSignal.add(pt => {
			playerEntity.faceAndMove(pt)
		})
		hero = playerEntity;
		void function(index=0){
			regHotKey('ctrl+1', function(){
				playerEntity.playAnimationByIndex(++index);
				//playerEntity.animation = playerEntity.animationList[++index];
				console.log('ani', index)
			})
			regHotKey('ctrl+2', function(){
				playerEntity.playAnimationByIndex(--index);
				//playerEntity.animation = playerEntity.animationList[--index];
				console.log('ani', index)
			})
		}()
		
	}()
/*
	let clothCount = 0;
	for(let [name, info] of Object.entries(clothDict)){
		const layerMaxCount = 10;
		const gapW = 500, gapH = 300;
		let playerEntity = await createPlayer(view3d.scene3d, playerMesh, info.defaultModel || 1, info.useFlag || 0);
		playerEntity.transform.moveTo(clothCount % layerMaxCount * gapW, 2000 + Math.floor(clothCount / layerMaxCount) * gapH, 0);
		let wingInfo = wingDict[wingNameList[clothCount % wingList.length]];
		playerEntity.bindObjectToBone("Bone05", new MeshEntity(wingInfo.mesh).addMaterial(new (wingInfo.material || TextureMaterial)()));

		++clothCount;

		for(let prefix of clothPrefix){
			if(prefix == 'Helm' && info.noHelm)continue;
			const fullName = name.includes('$') ? name.replace('$', prefix) : (prefix + name);
			let mesh = await Vulkan.loadModel("./assets/Player/" + fullName + ".bmd");
			let meshEntity = new MeshEntity(mesh, false);
			meshEntity.addMaterial(new TextureMaterial());
			meshEntity.shareSkeletonWith(playerEntity);
			playerEntity.addChild(meshEntity);
		}
	}
//*/
	showWeaponModel(view3d.scene3d, playerMesh, 'knife_gdf', 'Staff', new Array(12).fill(0).map((v, i) => i + 1), 1, i =>  [2,3,4,5,8,9].includes(i) ? 'staff' : 'axe', 1000, function(i){
		if(i == 7 || i == 9){
			return WingTextureMaterial
		}
		if(i == 8){
			this.addMaterial(new WingTextureMaterial(0x2));
			this.addMaterial(new TextureMaterial(~0x2));
			return
		}
		if(i == 12){
			this.addMaterial(new WingTextureMaterial(0x1));
			this.addMaterial(new TextureMaterial(~0x1));
			return
		}
		return TextureMaterial
	});
	showWeaponModel(view3d.scene3d, playerMesh, 'knife_gdf', 'Spear', new Array(11).fill(0).map((v, i) => i + 1), 2, i => 'spear', 1600, function(i){
		if(i == 1 || i == 11){
			this.addMaterial(new WingTextureMaterial(0x2));
			this.addMaterial(new TextureMaterial(~0x2));
			return
		}
		//return WireframeMaterial
		return TextureMaterial
	});
	showWeaponModel(view3d.scene3d, playerMesh, 'knife_gdf', 'Sword', new Array(32).fill(0).map((v, i) => i + 1).filter(v => ![23,24,25,26,30,31].includes(v)), 2, function(i, index, weaponMesh, materialType){
		let singleSword = [1,2,3,4,5,6,7,8,9,14,15,17,19,21];
		if(singleSword.includes(i)){
			if(i == 6 || i == 14 || i == 15){
				this.bindObjectToBone('hand_bofdgne01', new MeshEntity(weaponMesh)
					.addMaterial(new WingTextureMaterial(0x2))
					.addMaterial(new TextureMaterial(~0x2))
				);
			}else{
				this.bindObjectToBone('hand_bofdgne01', new MeshEntity(weaponMesh).addMaterial(new materialType()));
			}
			this.info.hasWeaponInLeftHand = true;
			return 'axe';
		}
		return 'sword';
	}, 2200, function(i){
		if(i == 6 || i == 11 || i == 14 || i == 15){
			this.addMaterial(new WingTextureMaterial(0x2));
			this.addMaterial(new TextureMaterial(~0x2));
			return;
		}
		/*switch(i){
			case 11:
			case 27:
				return WingTextureMaterial
				
		}*/
		return TextureMaterial
	});
	showWeaponModel(view3d.scene3d, playerMesh, 'knife_gdf', 'Mace', new Array(18).fill(0).map((v, i) => i + 1).filter(v => v < 15 || v > 16), 2, i => i < 3 ?'axe' : 'sword', 4000, function(i){
		if(i == 17){
			this.addMaterial(new WingTextureMaterial(~0x1));
			this.addMaterial(new TextureMaterial(0x1));
			return
		}
		if(i == 5 || i == 7){
			this.addMaterial(new WingTextureMaterial(0x2));
			this.addMaterial(new TextureMaterial(~0x2));
			return
		}
		if(i == 6){
			return WingTextureMaterial;
		}
		return TextureMaterial
	});
	showWeaponModel(view3d.scene3d, playerMesh, 'hand_bofdgne01', 'Shield', new Array(21).fill(0).map((v, i) => i + 1), 2, i => 'axe', 3100, i => {
		switch(i){
			case 11:
			case 27:
				return WingTextureMaterial
				
		}
		return TextureMaterial
	});
	const bow07 = await Vulkan.loadModel('./assets/Item/Bow07.bmd');
	console.log(bow07);
	
	const Arrows02 = await Vulkan.loadModel('./assets/Item/Arrows02.bmd');
	showWeaponModel(view3d.scene3d, playerMesh, 'hand_bofdgne01', 'Bow', [1,2,3,4,5,6,7,18,19,20,24], 3, function(_, i){
		let entity = new MeshEntity(Arrows02).addMaterial(new TextureMaterial());
		entity.x = -10;
		entity.y = -10;
		entity.rotation = new Quaternion().fromEulerAngles(-90 * RADIAN, 0, 90 * RADIAN)
		this.bindObjectToBone('Bone05', entity);
		return 'bow'
	}, 4600, function(i){
		if(i == 7){
			Vulkan.loadTexture('Shiny02.jpg').then(texture => {
				let material = new BillboardMaterial(texture, 32, 64);
				this.bindObjectToBone('light', new MeshEntity(null, false).addMaterial(material));
				this.bindObjectToBone('light01', new MeshEntity(null, false).addMaterial(material));
				this.bindObjectToBone('light02', new MeshEntity(null, false).addMaterial(material));
				this.bindObjectToBone('light03', new MeshEntity(null, false).addMaterial(material));
				this.bindObjectToBone('light05', new MeshEntity(null, false).addMaterial(material));
				this.bindObjectToBone('light06', new MeshEntity(null, false).addMaterial(material));
			});
		}
		switch(i){
			case 7:
			case 11:
			case 27:
				return WingTextureMaterial
				
		}
		return TextureMaterial
	});
	const Arrows01 = await Vulkan.loadModel('./assets/Item/Arrows01.bmd');
	showWeaponModel(view3d.scene3d, playerMesh, 'knife_gdf', 'CrossBow', [1,2,3,4,5,6,7,17,20], 3, function(_, i){
		let entity = new MeshEntity(Arrows01).addMaterial(new TextureMaterial());
		entity.x = 10;
		entity.y = -10;
		entity.rotation = new Quaternion().fromEulerAngles(-90 * RADIAN, 0, 90 * RADIAN)
		this.bindObjectToBone('Bone05', entity);
		return 'crossbow'
	}, 5200, i => {
		switch(i){
			case 11:
			case 27:
				return WingTextureMaterial
				
		}
		return TextureMaterial
	});
	showWeaponModel(view3d.scene3d, playerMesh, 'knife_gdf', 'Axe', [1,2,3,4,5,6,7,8,9], 2, i => i<5?'axe':'sword', 5500, i => {
		switch(i){
			case 11:
			case 27:
				return WingTextureMaterial
				
		}
		return TextureMaterial
	});
	
//*

	void function(){
		let bitmap3d = new Bitmap3D(200, 400, new Lens.Ortho(200, 400, -5000, 5000));
		bitmap3d.root3d.addChild(new MeshEntity(weaponData).addMaterial(new ColorMaterial([1, 0, 1, 1])));
		bitmap3d.root3d.rotation = new Quaternion().fromEulerAngles(0, 270 * RADIAN, 0);
		view3d.scene2d.root.addChild(bitmap3d).x = 500;
	}()
	//*/
/*
	for(let {boundList, mesh, matrix} of await readMapObj(1)){
		//console.log(mesh.name, mesh);
		//continue
		let entity = new MeshEntity(mesh).addMaterial(new TextureMaterial());
		entity.mouseEnabled = false;
		//entity.subEntityList.forEach((v, i) => v.staticBound = boundList[i]);
		//entity.transform = matrix;
		entity.rotation = matrix.rotation;
		entity.moveTo(matrix.translation.x, matrix.translation.y, matrix.translation.z);
		//entity.transform.compose(matrix.rotation, matrix.translation);
		view3d.scene3d.root.addChild(entity);
		entity.bound = boundList.reduce((a, b) => a.union(b));
		//entity.addMaterial(new BoundMaterial(entity.bound));
		
	}
//*/	

		let a = texture.createView();

		let b = texture2.createView();

		var bitmap = new Bitmap();
		bitmap.texture = new Texture2D(a);
		bitmap.texture.scale9grid = [20,20,20,20];
		//bitmap.width = bitmap.height = 500;

		var bmp2 = new Bitmap();
		bmp2.x = 250;
		bmp2.texture = new Texture2D(b);

		var bmp3 = new Bitmap();
		bmp3.x = bmp2.x;
		bmp3.y = 200;
		bmp3.texture = bitmap.texture;
		//bmp3.width = bmp3.height = 500;

		var box = new DisplayObject2D();
		//box.texture = bitmap.texture;
		box.addChild(bitmap);
		box.addChild(bmp2);
		box.addChild(bmp3);

		bitmap.filter = new BlurFilter([0,1,0,1]);
		bmp2.filter = new BlurFilter([0,0,1,1]);
		bmp3.filter = new BlurFilter([1,0,0,1]);

		var box2 = new DisplayObject2D();
		box.addChild(box2);
		//box2.filter = new BlurFilter([1,0.2,0.6,1]);

		let wrapper = new DisplayObject2D();
		wrapper.x = 170;
		wrapper.y = 170;
		wrapper.addChild(box);

		view3d.scene2d.root.addChild(wrapper);
		box.scaleX = box.scaleY = 0.5;
		//box.filter = new BlurFilter([1,2,6,1]);
		box.filter = {adjustY:false,adjustX:true,justCopyFlag:true,texture:new Texture2D(),clipRect:{x:100,y:-100,width:10000,height:10000}};

		Clock.on("enterFrame", function(){
		box.rotation += 0.5;
		bmp2.rotation -= 1;

		const moveStep = 20;

		if(Vulkan.keyboardMgr.isKeyDown(KeyCode.ARROW_LEFT)){//left
			cameraWorldPos.x -= moveStep;
		}else if(Vulkan.keyboardMgr.isKeyDown(KeyCode.ARROW_RIGHT)){//right
			cameraWorldPos.x += moveStep;
		}
		if(Vulkan.keyboardMgr.isKeyDown(KeyCode.ARROW_UP)){//up
			cameraWorldPos.y -= moveStep;
		}else if(Vulkan.keyboardMgr.isKeyDown(KeyCode.ARROW_DOWN)){//down
			cameraWorldPos.y += moveStep;
		}
		let scaleRatio = 1;
		view3d.scene3d.camera.moveTo(cameraWorldPos.x, cameraWorldPos.y);
		//view3d.scene3d.camera.worldTransformInvert.compose(cameraWorldRot, cameraWorldPos).invert().appendScale(scaleRatio,scaleRatio,scaleRatio);
		})

		void async function(){
			const menu01 = await Vulkan.loadTexture('assets/Interface/menu01_new.jpg');
			const menu02 = await Vulkan.loadTexture('assets/Interface/Menu02.jpg');
			const menu03 = await Vulkan.loadTexture('assets/Interface/Menu03_new.jpg');
			const Menu_Red = await Vulkan.loadTexture('assets/Interface/Menu_Red.jpg');
			const Menu_Blue = await Vulkan.loadTexture('assets/Interface/Menu_Blue.jpg');
			const Menu_Character = await Vulkan.loadTexture('assets/Interface/Menu_Character.jpg');
			const Menu_Inventory = await Vulkan.loadTexture('assets/Interface/Menu_Inventory.jpg');
			const Item_Back01 = await Vulkan.loadTexture('assets/Interface/Item_Back01.jpg');
			const Item_Back02 = await Vulkan.loadTexture('assets/Interface/Item_Back02.jpg');
			const Level_box = await Vulkan.loadTexture('assets/Interface/Level_box.jpg');
			const level_01 = await Vulkan.loadTexture('assets/Interface/level_01.jpg');

			const Item_Fairy = await Vulkan.loadTexture('assets/Interface/Item_Fairy.jpg');
			const Item_Cap = await Vulkan.loadTexture('assets/Interface/Item_Cap.jpg');
			const Item_Wing = await Vulkan.loadTexture('assets/Interface/Item_Wing.jpg');
			const Item_Weapon01 = await Vulkan.loadTexture('assets/Interface/Item_Weapon01.jpg');
			const Item_NeckLace = await Vulkan.loadTexture('assets/Interface/Item_NeckLace.jpg');
			const Item_Upper = await Vulkan.loadTexture('assets/Interface/Item_Upper.jpg');
			const Item_Weapon02 = await Vulkan.loadTexture('assets/Interface/Item_Weapon02.jpg');
			const Item_Gloves = await Vulkan.loadTexture('assets/Interface/Item_Gloves.jpg');
			const Item_Ring = await Vulkan.loadTexture('assets/Interface/Item_Ring.jpg');
			const Item_Lower = await Vulkan.loadTexture('assets/Interface/Item_Lower.jpg');
			const Item_Boots = await Vulkan.loadTexture('assets/Interface/Item_Boots.jpg');
			const Item_box = await Vulkan.loadTexture('assets/Interface/Item_box.jpg');
			const Item_Money = await Vulkan.loadTexture('assets/Interface/Item_Money.jpg');
			const exit_01 = await Vulkan.loadTexture('assets/Interface/exit_01.jpg');
			const exit_02 = await Vulkan.loadTexture('assets/Interface/exit_02.jpg');
			const repair_01 = await Vulkan.loadTexture('assets/Interface/repair_01.jpg');

			let wrapper = new DisplayObject2D();
			let bottomBox = new DisplayObject2D();
			bottomBox.y = 480 - menu01.height;
			bottomBox.addChild(new Bitmap(new Texture2D(menu01.createView())))
			bottomBox.addChild(new Bitmap(new Texture2D(menu02.createView()))).x = 256;
			bottomBox.addChild(new Bitmap(new Texture2D(menu03.createView()))).x = 384;
			//let btnBox = new DisplayObject2D();
			bottomBox.addChild(new Bitmap(new Texture2D(Menu_Red.createView()))).x = 98;
			bottomBox.addChild(new Bitmap(new Texture2D(Menu_Blue.createView()))).x = 489;

			let miniBtn = new DisplayObject2D();
			miniBtn.y = 20;
			let CharacterBtn = createMuBtn(miniBtn, Menu_Character, flag => {
				panel1.visible = flag;
				sound.currentTime = 0;
				sound.play();
			}, 'C');
			let InventoryBtn = createMuBtn(miniBtn, Menu_Inventory, flag => {
				panel2.visible = flag;
				sound.currentTime = 0;
				sound.play();
			}, 'I');

			const panelScaleRatio = canvas.height / 480;
			
			CharacterBtn.x = 379;
			InventoryBtn.x = 410;
			CharacterBtn.mouseEnabled = InventoryBtn.mouseEnabled = true
			wrapper.addChild(bottomBox);
			//wrapper.addChild(btnBox);
			bottomBox.addChild(miniBtn);
			view3d.scene2d.root.addChild(wrapper);
			wrapper.scale = panelScaleRatio;
			let sound = document.getElementById('iCreateWindow');

			let panelBox = new DisplayObject2D();
			wrapper.addChild(panelBox);

			let panel1 = new DisplayObject2D();
			panel1.addChild(new Bitmap(new Texture2D(Item_Back01.createView())))
			panel1.addChild(new Bitmap(new Texture2D(Item_Back02.createView()))).y = Item_Back01.height;

			Object.assign(
				panel1.addChild(new Bitmap(new Texture2D(Level_box.createView()))),
				{x:13,y:60}
			)
			Object.assign(
				panel1.addChild(new Bitmap(new Texture2D(level_01.createView()))),
				{x:120,y:60}
			)

			panel1.visible = false;

			let panel2 = new DisplayObject2D();
			panel2.x = Item_Back01.width
			panel2.addChild(new Bitmap(new Texture2D(Item_Back01.createView())))
			panel2.addChild(new Bitmap(new Texture2D(Item_Back02.createView()))).y = Item_Back01.height;
			panel2.visible = false;

			let itemSlots = new DisplayObject2D();
			let gap = 4;
			Object.assign(
				itemSlots,
				{x:20,y:60}
			);
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Fairy.createView()))),
				{x:0,y:0}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Cap.createView()))),
				{x:60,y:0}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Wing.createView()))),
				{x:100,y:0}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Weapon01.createView()))),
				{x:0,y:40+gap}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_NeckLace.createView()))),
				{x:40,y:40+gap}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Upper.createView()))),
				{x:60,y:40+gap}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Weapon02.createView()))),
				{x:120,y:40+gap}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Gloves.createView()))),
				{x:0,y:100+gap*2}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Ring.createView()))),
				{x:40,y:100+gap*2}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Lower.createView()))),
				{x:60,y:100+gap*2}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Ring.createView()))),
				{x:100,y:100+gap*2}
			)
			Object.assign(
				itemSlots.addChild(new Bitmap(new Texture2D(Item_Boots.createView()))),
				{x:120,y:100+gap*2}
			)

			panel2.addChild(itemSlots)

			let boxSlots = new DisplayObject2D();
			panel2.addChild(boxSlots)
			Object.assign(
				boxSlots,
				{x:20,y:itemSlots.y + 140+gap*3}
			);
			let boxTexture = new Texture2D(Item_box.createView())
			for(let i=0; i<8; ++i){
				for(let j=0; j<8; ++j){
					Object.assign(
						boxSlots.addChild(new Bitmap(boxTexture)),
						{x:20*i,y:20*j,width:20,height:20}
					)
				}
			}

			Object.assign(
				panel2.addChild(new Bitmap(new Texture2D(Item_Money.createView()))),
				{x:20,y:boxSlots.y+160+gap}
			)

			let exitBtn = createMuBtn2(panel2, exit_01, exit_02)

			Object.assign(
				exitBtn,
				{x:20,y:boxSlots.y+186}
			)

			let bitmap3d = new Bitmap3D(40*panelScaleRatio, 80*panelScaleRatio, new Lens.Ortho(200, 400, -5000, 5000));
			//bitmap3d.filter = new BlurFilter([1,0,0,1]);
			let weaponEntity = bitmap3d.root3d.addChild(new MeshEntity(weaponData).addMaterial(new TextureMaterial()));
			bitmap3d.root3d.rotation = new Quaternion().fromEulerAngles(0, 90 * RADIAN, 20 * RADIAN);
			bitmap3d.root3d.x += 30;
			bitmap3d.root3d.y -= 10;
			bitmap3d.scale = 1 / panelScaleRatio;
			boxSlots.addChild(bitmap3d);

			bitmap3d.mouseEnabled = true
			bitmap3d.mouseOverSignal.add(() => {
				function onEnterFrame(){
					weaponEntity.rotation = weaponEntity.rotation.prepend(new Quaternion().fromEulerAngles(0, 5 * RADIAN, 0));
				}
				Clock.on("enterFrame", onEnterFrame);
				bitmap3d.mouseOutSignal.add(() => {
					weaponEntity.rotation = weaponEntity.rotation.identity()
					Clock.off("enterFrame", onEnterFrame);
				})
			});
			//enableDrag(bitmap3d, undefined, putItemFn);
			bitmap3d.mouseDownSignal.add(({x, y}) => {
				bitmap3d.startDrag(x, y);
				window.addEventListener('mouseup', ({x, y}) => {
					bitmap3d.stopDrag(x, y, putItemFn);
				}, {once:true})
			});
			


			panelBox.addChild(panel1)
			panelBox.addChild(panel2);

			let itemDataRaw = await fetchArrayBuffer('assets/icons/item.bmd');
			console.log(parseItemInfo(new Uint8Array(itemDataRaw)))
		}()

		
	
}

function putItemFn(x, y){
	this.x = Math.round(x / 20) * 20;
	this.y = Math.round(y / 20) * 20;
}

function createMuBtn(parent, texture, callback, key){
	let btn = new DisplayObject2D();
	btn.type = 'button';
	let icon = btn.addChild(new Bitmap(new Texture2D(texture.createView())));
	btn.width = texture.width;
	btn.height = texture.height;
	icon.visible = false;
	const handler = () => callback(icon.visible = !icon.visible, btn);
	btn.mouseDownSignal.add(handler);
	regHotKey(`ctrl+${key}`, handler);
	return parent.addChild(btn);
}

function createMuBtn2(parent, textureUp, textureDown){
	let btn = new DisplayObject2D();
	let up = btn.addChild(new Bitmap(new Texture2D(textureUp.createView())));
	let down = btn.addChild(new Bitmap(new Texture2D(textureDown.createView())));
	down.visible = false;
	btn.mouseDownSignal.add(() => {
		up.visible = false;
		down.visible = true;
	});
	btn.mouseUpSignal.add(() => {
		up.visible = true;
		down.visible = false;
	});
	up.mouseEnabled = down.mouseEnabled = true;
	return parent.addChild(btn);
}


const clothPrefix = ["Helm", "Armor", "Pant", "Glove", "Boot"];
const createPlayer = function(){
	const prefixList = clothPrefix.map(v => v+ 'Class');
	return async function(scene3d, playerMesh, id=0, filter=0xFF, autoRot=true){
		const playerEntity = new MeshEntity(playerMesh);
		scene3d.addChild(playerEntity);
		if(autoRot){
			Clock.on("enterFrame", () => {
				playerEntity.rotation = playerEntity.rotation.prepend(new Quaternion().fromEulerAngles(0, 0, 0.5 * RADIAN));
			});
		}
		if(id > 0){
			const fileList = prefixList.filter((v, i) => filter & 1 << (4 - i)).map(v => v + id.toString().padStart(2, '0'));
			const meshList = await Promise.all(fileList.map(v => Vulkan.loadModel("./assets/Player/Class/" + v + ".bmd")));
			if(id == 3){
				meshList.forEach(mesh => mesh.subMeshList[0].texture = 'skin_archer_01.jpg')
			}
			for(let mesh of meshList){
				let meshEntity = new MeshEntity(mesh, false);
				meshEntity.addMaterial(new TextureMaterial());
				meshEntity.shareSkeletonWith(playerEntity);
				playerEntity.addChild(meshEntity);
			}
		}
		return playerEntity;
	}
}();

async function showWeaponModel(scene3d, playerMesh, boneName, prefix, itemIDs, charID, animationID, offsetY, materialFn){
	const layerMaxCount = 10;
	const gapW = 500, gapH = 300;
	let totalCount = 0;
	for(const i of itemIDs){
		const playerEntity = await createPlayer(scene3d, playerMesh, charID);
//*
		void function(index){
			window.addEventListener('click', function(){
				playerEntity.animation = playerEntity.animationList[++index];
				console.log('ani', index)
			})
		}//(0);//*/
		playerEntity.moveTo(
			500 + totalCount % layerMaxCount * gapW,
			1000 + offsetY + Math.floor(totalCount / layerMaxCount) * gapH,
			0
		);
		
		const weaponMesh = await Vulkan.loadModel(`./assets/Item/${prefix + i.toString().padStart(2, '0')}.bmd`);
		const weaponEntity = new MeshEntity(weaponMesh);
		const materialType = materialFn.call(weaponEntity, i);
		if(materialType){
			weaponEntity.addMaterial(Reflect.construct(materialType, []))
		}
		playerEntity.bindObjectToBone(boneName, weaponEntity);
		
		playerEntity.info.weapon = animationID.call(playerEntity, i, totalCount, weaponMesh, materialType)
		playerEntity.info.role = charID == 1 ? 'sorcerer' : charID == 2?'warrior':'archer'
		//playerEntity.playAnimationWithAction('attack')
		runAction(playerEntity, Repeat(Sequence([
			CallFunc(target => target.playAnimationWithAction('stand')),
			Delay(3000),
			CallFunc(target => target.playAnimationWithAction('walk')),
			Delay(3000),
			CallFunc(target => target.playAnimationWithAction('run')),
			Delay(3000),
			CallFunc(target => target.playAnimationWithAction('attack')),
			Delay(10000),
		])))
		++totalCount;
	}
}

async function showSkill(view3d, playerMesh, skillName, posX, skillFn){
	const meshData = await Vulkan.loadModel(`./assets/Skill/${skillName}.bmd`);
	const entity = new MeshEntity(meshData).addMaterial(new WingTextureMaterial());

	const updateFn = skillFn?.(entity);
	if(updateFn instanceof Function){
		Clock.on('enterFrame', () => updateFn(entity, performance.now()));
	}

	let playerEntity = await createPlayer(view3d.scene3d, playerMesh, 1);
	playerEntity.playAnimationByIndex(146);
	//Vulkan.animationMgr.register(playerEntity);

	playerEntity.addChild(entity);
	playerEntity.moveTo(posX,0,0);
}


window.addEventListener('DOMContentLoaded', init);

const aniNameList = ['站立']

const clothDict = {
"Elf01":{useFlag:0x10,name:'藤',defaultModel:3},
"Elf02":{useFlag:0x10,name:'天蚕',defaultModel:3},
"Elf03":{useFlag:0x10,name:'风之',defaultModel:3},
"Elf04":{useFlag:0x10,name:'精灵之',defaultModel:3},
"Elf05":{name:'女神之',defaultModel:3},
"Elfc01":{useFlag:0x10,name:'藤',defaultModel:3},
"Elfc02":{useFlag:0x10,name:'天蚕',defaultModel:3},
"Male01":{name:'青铜',defaultModel:2},
"Male02":{name:'龙王之',defaultModel:2},
"Male03":{useFlag:0x10,name:'革',defaultModel:1},
"Male04":{name:'传说之',defaultModel:1},
"Male05":{name:'骷髅',defaultModel:1},
"Male06":{name:'皮',defaultModel:2}, 
"Male07":{name:'翡翠',defaultModel:2}, 
"Male08":{name:'魔王',defaultModel:1}, 
"Male09":{name:'黄金',defaultModel:2}, 
"Male10":{name:'白金',defaultModel:2},
"Male16":{noHelm:true,name:'亚特兰蒂斯之',useFlag:0x10,defaultModel:4}, 
"Male17":{name:'黑龙王之',defaultModel:2}, "Male18":{name:'黑凤凰之',defaultModel:2}, "Male19":{name:'火麒麟之'},
"Male20":{name:'圣灵之'}, "Male21":{name:'奔雷之',noHelm:true,useFlag:0x10,defaultModel:4}, "Male22":{name:'龙炎之',}, "Male23":{name:'黑炎之'}, "Male24":{name:'魔神之',noHelm:true,useFlag:0x10,defaultModel:4}, "Male25":{name:'红羽之'},
"Male26":{name:'圣元之'}, "Male27":{name:'圣魂之'}, "Male28":{name:'神圣之'}, "Male29":{name:'至尊之'}, 
"Male40":{name:'飓风之'}, "Male41":{name:'红翼之'}, "Male42":{name:'远古之'}, "Male43":{name:'魔灵之'}, "Male44":{name:'风影之'}, "Male45":{name:'恒翼之'}, 
"Male46":{name:'泰坦之'}, "Male47":{name:'勇气之'}, "Male48":{name:'巨石之',useFlag:0x10,defaultModel:4}, "Male49":{name:'破灭之',noHelm:true,useFlag:0x10,defaultModel:4},
"Male50":{name:'恐惧之'},"Male51":{name:'灵光之'}, 
"Male52":{name:'霸王之'}, "Male53":{name:'冥王之'}, "Male54":{name:'决胜之'},
"CW_$Male01":{name:'暴风之'},
"CW_$Male02":{name:'幻月之'},
"CW_$Male03":{name:'碧影之'},
"CW_$Male04":{name:'烈火之',noHelm:true,useFlag:0x10,defaultModel:4},
"CW_$Male05":{name:'圣光之'},
"hdk_$Male01":{name:'暗黑斗神之'},
"hdk_$Male02":{name:'法魂玄灵之'},
"hdk_$Male03":{name:'紫灵之'},
"hdk_$Male04":{name:'天魔斗神之',noHelm:true,useFlag:0x10,defaultModel:4},
"hdk_$Male05":{name:'宙斯之'},
};
const wingDict = {
	"Wing01":{material:WingTextureMaterial}, "Wing02":{}, "Wing03":{}, 
	"Wing04":{material:WingTextureMaterial}, "Wing05":{}, "Wing06":{material:WingTextureMaterial}, "Wing07":{}, 
	"Wing08":{}, "Wing09":{}, "Wing10":{}, "Wing11":{}, 
	"Wing42":{}, "Wing43":{}, "Wing44":{},
	'DarkLordRobe':{},
	'darklordrobe02':{},
}
const helperDict = {
	'Angel':{},
	'Helper01':{},
	'Helper02':{},
	'Helper03':{},
	'Helper04':{},
}
const itemExtra = {
	'Jewel01':{},
	'Jewel02':{},
	'Jewel03':{},
	'Jewel15':{},
	'Jewel22':{},
}
const skillExtra = {
	'Skeleton01':{},
	'Skeleton02':{},
	'Skeleton03':{},
	'Rider01':{},
	'Rider02':{},
	'DarkHorse':{},
}
const monsterDict = {}

const monsterNameList = [

	"monster(1)","monster",
	"Monster01","Monster02","Monster03","Monster04","Monster05","Monster06","Monster07","Monster08","Monster09","Monster10",
	"Monster11","Monster12","Monster13","Monster14","Monster15","Monster16","Monster17","Monster18","Monster19","Monster20",
	"Monster21","Monster22","Monster23","Monster24","Monster25","Monster26","Monster27","Monster28","Monster29","Monster30",
	"Monster31","Monster32","Monster33","Monster34","Monster35","Monster36","Monster37","Monster38","Monster39","Monster40",
	"Monster41","Monster42","Monster43","Monster44","Monster45","Monster46","Monster47","Monster48",
	"Monster63",
	"monster77", "monster78",
	/*"Monster49",
	"Monster51","Monster52","Monster53","Monster54","Monster55","Monster56","Monster57","Monster58","Monster59",
	"Monster60","Monster61","Monster62",
	
	"Monster64","monster65","Monster66","Monster67","monster68","monster69","Monster70",
	"Monster71","Monster72","Monster73","Monster74","monster75", 
	
	"monster79","monster80",
	"monster82","monster83","monster84","monster85","monster86","monster87","monster88","monster90",
	"monster91","monster92","monster93","monster94","monster95","monster96","monster97","monster98","monster99",
	"monster100","monster101","monster102","monster103","monster104","monster105","monster106","Monster107","monster108","monster109","monster110",
	"monster111","monster112","Monster113","Monster114","Monster115","Monster116","Monster117","monster118","monster119","monster120",
	"monster122","monster123","monster124","monster125","monster126","monster127","monster128","monster129",
	"monster130","monster131","monster132","monster133","monster134","monster135","monster136","monster137","monster138","monster139",
	"monster140","monster141","monster142","monster143","monster144","monster145","monster146","monster147","monster148","monster149",
	"monster150","monster151","monster152","monster153","monster154","monster155","monster156","monster157","MONSTER158","MONSTER159",
	"MONSTER160","MONSTER161","MONSTER162","MONSTER163","MONSTER164","Monster165","Monster166","Monster167","Monster168","monster169",
	"Monster170","Monster171","monster172","monster173","Monster174","Monster175","Monster176","Monster177","monster178","Monster179",
	"monster180","monster181","monster182","monster184","monster185","monster186","monster187","monster188",
	"monster190","monster191","monster192",
		"arrowstusk",
	"assassin_dieg",
	"assassin_dier",
	"Boss_Karane_sword_left01",
	"Boss_Karane_sword_left02",
	"Boss_Karane_sword_main01",
	"Boss_Karane_sword_right01",
	"Boss_Karane_sword_right02",
	"cd71a","cd71b","cd71c","cd71d","cd71e","cd71f","cd71g","cd71h",
	"cundun_gone","deasther_boomerang","icegiantpart_1","icegiantpart_2",
	"icegiantpart_3","icegiantpart_4","icegiantpart_5","icegiantpart_6",
	"Karanebos","Karane_sword_left01","Karane_sword_left02",
	"Karane_sword_main01","Karane_sword_right01","Karane_sword_right02",
	"pk_manhead_green","pk_manhead_red",
	"shadow_knight_7_ankle_left",
	"shadow_knight_7_ankle_right",
	"shadow_knight_7_belt",
	"shadow_knight_7_chest",
	"shadow_knight_7_helmet",
	"shadow_knight_7_knee_left",
	"shadow_knight_7_knee_right",
	"shadow_knight_7_wrist_left",
	"shadow_knight_7_wrist_right",
	"shadow_pawn_7_ankle_left",
	"shadow_pawn_7_ankle_right",
	"shadow_pawn_7_belt","shadow_pawn_7_chest",
	"shadow_pawn_7_helmet","shadow_pawn_7_knee_left",
	"shadow_pawn_7_knee_right","shadow_pawn_7_wrist_left",
	"shadow_pawn_7_wrist_right","shadow_rock_7_ankle_left",
	"shadow_rock_7_ankle_right","shadow_rock_7_belt",
	"shadow_rock_7_chest","shadow_rock_7_helmet","shadow_rock_7_knee_left",
	"shadow_rock_7_knee_right","shadow_rock_7_wrist_left","shadow_rock_7_wrist_right",
	"sulbeksulki","sulcandy","sulgold","sulgreengochu","sulpeg","sulpega","sulredgochu","sulyutnulre","totembody","totemhead","totemleft","totemleg","totemleg2","totemright",
	"umbrella_eyes_object","umbrella_light","weapon64"
//*/
	];


//monsterNameList.splice(monsterNameList.indexOf("monster151"), 1);
/*
GPUDevice.prototype.copyImageBitmapToTexture = function(source, destination, copySize){
	const {imageBitmap} = source;
	const {width, height} = imageBitmap;

	const canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;

	const ctx = canvas.getContext('2d');
	ctx.drawImage(imageBitmap, 0, 0);
	const imageData = ctx.getImageData(0, 0, width, height);
	this.copyImageDataToTexture(imageData, destination, copySize);
}

GPUDevice.prototype.copyImageDataToTexture = function(imageData, destination, copySize){
	const pitchSize = 64;
	const bytePerPixel = 4;

	const {width, height} = imageData;

	const rowPitch = Math.ceil(width / pitchSize) * pitchSize * bytePerPixel;//mulitimes of 256

	let bufferData;

	if(width % pitchSize == 0){
		bufferData = imageData.data;
	}else{
		bufferData = new Uint8Array(rowPitch * height);
		const data = imageData.data;
		for(let y=0; y<height; ++y){
			for(let x=0; x<width; ++x){
				let i = y * rowPitch + x * bytePerPixel;
				let j = (y * width + x) * bytePerPixel;
				bufferData[i  ] = data[j];
				bufferData[i+1] = data[j+1];
				bufferData[i+2] = data[j+2];
				bufferData[i+3] = data[j+3];
			}
		}
	}

	const buffer = this.createBuffer({
		size: bufferData.length,
		usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
	});
	buffer.setSubData(0, bufferData);

	const commandEncoder = this.createCommandEncoder();
	commandEncoder.copyBufferToTexture({
		buffer,
		rowPitch,
		imageHeight: height,
		offset: 0
	}, destination, copySize);
	this.defaultQueue.submit([commandEncoder.finish()]);

	buffer.destroy();
}
//*/
/*

https://gpuweb.github.io/gpuweb/
https://gpuweb.github.io/WSL/
https://github.com/gpuweb/gpuweb
https://www.khronos.org/opengl/wiki/Compute_Shader

const renderBundleEncoder = device.createRenderBundleEncoder({
	colorFormats:[swapChainFormat],
	depthStencilFormat: 'depth24plus-stencil8'
});
renderPassEncoder.executeBundles([renderBundleEncoder.finish()]);

const computePassEncoder = commandEncoder.beginComputePass();
const computePipeline = device.createComputePipeline({
	layout: pipelineLayout,
	computeStage: {
		module: device.createShaderModule({
			code: '',
		}),
		entryPoint: 'main'
	}
});

interface GPUComputePassEncoder {
	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
                      optional sequence<unsigned long> dynamicOffsets = []);

    void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      unsigned long long dynamicOffsetsDataStart,
                      unsigned long long dynamicOffsetsDataLength);

    void setPipeline(GPUComputePipeline pipeline);
    void dispatch(unsigned long x, optional unsigned long y = 1, optional unsigned long z = 1);
    void dispatchIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);

    void endPass();
};

interface GPUCommandEncoder {
	void copyBufferToBuffer(
		GPUBuffer source,
		GPUBufferSize sourceOffset,
		GPUBuffer destination,
		GPUBufferSize destinationOffset,
		GPUBufferSize size);

	void copyBufferToTexture(
		GPUBufferCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);

	void copyTextureToBuffer(
		GPUTextureCopyView source,
		GPUBufferCopyView destination,
		GPUExtent3D copySize);

	void copyTextureToTexture(
		GPUTextureCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);
};

interface RenderBase {
	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
					  optional sequence<unsigned long> dynamicOffsets = []);

	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
					  Uint32Array dynamicOffsetsData,
					  unsigned long long dynamicOffsetsDataStart,
					  unsigned long long dynamicOffsetsDataLength);

	void setPipeline(GPURenderPipeline pipeline);

	void setIndexBuffer(GPUBuffer buffer, optional GPUBufferSize offset = 0);
	void setVertexBuffer(unsigned long slot, GPUBuffer buffer, optional GPUBufferSize offset = 0);

	void draw(unsigned long vertexCount, unsigned long instanceCount,
			  unsigned long firstVertex, unsigned long firstInstance);
	void drawIndexed(unsigned long indexCount, unsigned long instanceCount,
					 unsigned long firstIndex, long baseVertex, unsigned long firstInstance);

	void drawIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
	void drawIndexedIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
};

interface GPURenderPassEncoder extends RenderBase {
	void setViewport(float x, float y,
					 float width, float height,
					 float minDepth, float maxDepth);

	void setScissorRect(unsigned long x, unsigned long y, unsigned long width, unsigned long height);

	void setBlendColor(GPUColor color);
	void setStencilReference(unsigned long reference);

	void executeBundles(sequence<GPURenderBundle> bundles);
	void endPass();
};

interface GPURenderBundleEncoder extends RenderBase {
	GPURenderBundle finish();
};

enum GPUVertexFormat {
	"uchar2",
	"uchar4",
	"char2",
	"char4",
	"uchar2norm",
	"uchar4norm",
	"char2norm",
	"char4norm",
	"ushort2",
	"ushort4",
	"short2",
	"short4",
	"ushort2norm",
	"ushort4norm",
	"short2norm",
	"short4norm",
	"half2",
	"half4",
	"float",
	"float2",
	"float3",
	"float4",
	"uint",
	"uint2",
	"uint3",
	"uint4",
	"int",
	"int2",
	"int3",
	"int4"
};

enum GPUIndexFormat {
	"uint16",
	"uint32"
};

enum GPUInputStepMode {
	"vertex",
	"instance"
};

enum GPUPrimitiveTopology {
	"point-list",
	"line-list",
	"line-strip",
	"triangle-list",
	"triangle-strip"
};

dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
	required GPUBindGroupLayout layout;
	required sequence<GPUBindGroupBinding> bindings;
};
typedef (GPUSampler or GPUTextureView or GPUBufferBinding) GPUBindingResource;

dictionary GPUBindGroupBinding {
	required unsigned long binding;
	required GPUBindingResource resource;
};
dictionary GPUBufferBinding {
	required GPUBuffer buffer;
	GPUBufferSize offset = 0;
	GPUBufferSize size;
};

enum GPUBindingType {
	"uniform-buffer",
	"storage-buffer",
	"readonly-storage-buffer",
	"sampler",
	"comparison-sampler",
	"sampled-texture",
	"readonly-storage-texture",
	"writeonly-storage-texture",
	// TODO: other binding types
};

interface GPUShaderStage {
	const GPUShaderStageFlags VERTEX   = 0x1;
	const GPUShaderStageFlags FRAGMENT = 0x2;
	const GPUShaderStageFlags COMPUTE  = 0x4;
};

interface GPUBufferUsage {
	const GPUBufferUsageFlags MAP_READ  = 0x0001;
	const GPUBufferUsageFlags MAP_WRITE = 0x0002;
	const GPUBufferUsageFlags COPY_SRC  = 0x0004;
	const GPUBufferUsageFlags COPY_DST  = 0x0008;
	const GPUBufferUsageFlags INDEX     = 0x0010;
	const GPUBufferUsageFlags VERTEX    = 0x0020;
	const GPUBufferUsageFlags UNIFORM   = 0x0040;
	const GPUBufferUsageFlags STORAGE   = 0x0080;
	const GPUBufferUsageFlags INDIRECT  = 0x0100;
	const GPUBufferUsageFlags QUERY_RESOLVE = 0x0200;
};

interface GPUTextureUsage {
	const GPUTextureUsageFlags COPY_SRC          = 0x01;
	const GPUTextureUsageFlags COPY_DST          = 0x02;
	const GPUTextureUsageFlags SAMPLED           = 0x04;
	const GPUTextureUsageFlags STORAGE           = 0x08;
	const GPUTextureUsageFlags OUTPUT_ATTACHMENT = 0x10;
};

enum GPUTextureFormat {
	// 8-bit formats
	"r8unorm",
	"r8snorm",
	"r8uint",
	"r8sint",

	// 16-bit formats
	"r16uint",
	"r16sint",
	"r16float",
	"rg8unorm",
	"rg8snorm",
	"rg8uint",
	"rg8sint",

	// 32-bit formats
	"r32uint",
	"r32sint",
	"r32float",
	"rg16uint",
	"rg16sint",
	"rg16float",
	"rgba8unorm",
	"rgba8unorm-srgb",
	"rgba8snorm",
	"rgba8uint",
	"rgba8sint",
	"bgra8unorm",
	"bgra8unorm-srgb",
	// Packed 32-bit formats
	"rgb10a2unorm",
	"rg11b10float",

	// 64-bit formats
	"rg32uint",
	"rg32sint",
	"rg32float",
	"rgba16uint",
	"rgba16sint",
	"rgba16float",

	// 128-bit formats
	"rgba32uint",
	"rgba32sint",
	"rgba32float",

	// Depth and stencil formats
	"depth32float",
	"depth24plus",
	"depth24plus-stencil8"
};

dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
	GPUAddressMode addressModeU = "clamp-to-edge";
	GPUAddressMode addressModeV = "clamp-to-edge";
	GPUAddressMode addressModeW = "clamp-to-edge";
	GPUFilterMode magFilter = "nearest";
	GPUFilterMode minFilter = "nearest";
	GPUFilterMode mipmapFilter = "nearest";
	float lodMinClamp = 0;
	float lodMaxClamp = 0xffffffff; // TODO: What should this be? Was Number.MAX_VALUE.
	GPUCompareFunction compare = "never";
};
enum GPUAddressMode {
	"clamp-to-edge",
	"repeat",
	"mirror-repeat"
};
enum GPUFilterMode {
	"nearest",
	"linear"
};
enum GPUCompareFunction {
	"never",
	"less",
	"equal",
	"less-equal",
	"greater",
	"not-equal",
	"greater-equal",
	"always"
};

*/