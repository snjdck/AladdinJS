'use strict';

const Clock = require('opengl/Clock');
const {Texture2D} = require('opengl/textures');
const DisplayObject2D = require('opengl/DisplayObject2D');

const vertexShaderGLSL = `#version 450

layout(binding=0)
uniform _ {
	vec2 screenWH;
};

//layout(location=0)in mat2x3 worldMatrix;

layout(location=0)
in vec3 worldMatrixX;

layout(location=1)
in vec3 worldMatrixY;

layout(location=2)
in vec4 textureMul;

layout(location=3)
in vec4 textureAdd;

layout(location=4)
in vec4 rectSize;//w,rw,h,rh

layout(location=5)
in vec4 scale9grid;//lm,rm,tm,bm

layout(location = 0)
out vec2 uv;

void main() {
	mat2x3 worldMatrix = mat2x3(worldMatrixX, worldMatrixY);
	vec2 inputPosition = vec2(gl_VertexIndex >> 1 & 1, gl_VertexIndex >> 3);
	vec4 inputMargin = vec4(equal(
		ivec2(gl_VertexIndex & 3, gl_VertexIndex >> 2).xxyy,
		ivec2(1, 2).xyxy
	));
	inputMargin.yw = -inputMargin.yw;
	vec4 margin = inputMargin * scale9grid;
	margin = margin.xxzz + margin.yyww;

	vec4 xyuv = fma(inputPosition.xxyy, rectSize, margin);
	xyuv.yw /= rectSize.yw;
	xyuv = fma(xyuv.xzyw, textureMul, textureAdd);

	xyuv.xy = vec3(xyuv.xy, 1) * worldMatrix;
	xyuv.xy = fma(xyuv.xy, screenWH, vec2(-1, 1));

	gl_Position = vec4(xyuv.xy, 0, 1);
	uv = xyuv.zw;
}
`;

const fragmentShaderGLSL = `#version 450
	layout(binding=1)uniform sampler mySampler;
	layout(set=1, binding=0)uniform texture2D myTexture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		vec4 temp = texture(sampler2D(myTexture, mySampler), uv);
		outColor = temp;
	}
`;

const filterVertexShaderGLSL = `#version 450

layout(binding=0)
uniform _ {
	vec4 sourceRect;
	vec4 destRect;
};
//vec4 sourceRect = vec4(0, 0, 1, 1);
//vec4 destRect = vec4(-1, -1, 2, 2);

layout(location = 0)
out vec2 uv;

void main() {
	vec2 vertex = vec2(gl_VertexIndex >> 1, gl_VertexIndex & 1);
	//gl_Position = vec4(fma(vertex, vec2(2), vec2(-1)), 0, 1);
	//uv = vertex;
	gl_Position = vec4(fma(vertex, destRect.zw, destRect.xy), 0, 1);
	uv = fma(vertex, sourceRect.zw, sourceRect.xy);
}
`;
const filterFragmentShaderGLSL = `#version 450
	layout(binding=1)uniform sampler _sampler;
	layout(binding=2)uniform texture2D _texture;

	layout(binding=3)
	uniform _ {
		vec4 mixColor;
	};

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		float s = dFdx(uv.x);
		float t = dFdy(uv.y);

		vec2 tc0 = uv + vec2(-s, -t);
		vec2 tc1 = uv + vec2( 0, -t);
		vec2 tc2 = uv + vec2( s, -t);
		vec2 tc3 = uv + vec2(-s,  0);
		vec2 tc4 = uv;
		vec2 tc5 = uv + vec2( s,  0);
		vec2 tc6 = uv + vec2(-s,  t);
		vec2 tc7 = uv + vec2( 0,  t);
		vec2 tc8 = uv + vec2( s,  t);

		vec4 col0 = texture(sampler2D(_texture, _sampler), tc0);
		vec4 col1 = texture(sampler2D(_texture, _sampler), tc1);
		vec4 col2 = texture(sampler2D(_texture, _sampler), tc2);
		vec4 col3 = texture(sampler2D(_texture, _sampler), tc3);
		vec4 col4 = texture(sampler2D(_texture, _sampler), tc4);
		vec4 col5 = texture(sampler2D(_texture, _sampler), tc5);
		vec4 col6 = texture(sampler2D(_texture, _sampler), tc6);
		vec4 col7 = texture(sampler2D(_texture, _sampler), tc7);
		vec4 col8 = texture(sampler2D(_texture, _sampler), tc8);

		vec4 sum = (
			1.0 * col0 + 2.0 * col1 + 1.0 * col2 +
			2.0 * col3 + 4.0 * col4 + 2.0 * col5 +
			1.0 * col6 + 2.0 * col7 + 1.0 * col8
		) / 16.0;

		outColor = sum * mixColor;
	}
`;

const vertex3DShaderGLSL = `#version 450

vec4 concat(vec4 a, vec4 b)
{
	vec4 t0 = b.w * a;
	vec4 t1 = b.x * a.wzyx;
	vec4 t2 = b.y * a.zwxy;
	vec4 t3 = b.z * a.yxwz;
	t1.yw = -t1.yw;
	t2.zw = -t2.zw;
	t3.xw = -t3.xw;
	return t0 + t1 + t2 + t3;
}

vec3 rotate(vec4 quaternion, vec3 point)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 result = (t0 - t1.zxy) * point.yzx + (t0.zxy + t1.yzx) * point.zxy;
	result += result;
	result += point * (t2.xyz + t2.www - t2.yzx - t2.zxy);
	return result;
}

vec3 transform2(vec4 quaternion, vec4 translation, vec3 point)
{
	return rotate(quaternion, point * translation.w) + translation.xyz;
}

mat4 cast2mat(vec4 quaternion, vec4 translation)
{
	vec3 t0 = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	vec3 t1 = quaternion.xyz * quaternion.www;	//xw,yw,zw
	vec4 t2 = quaternion * quaternion;			//xx,yy,zz,ww

	vec3 a = t2.xyz + t2.www - t2.yzx - t2.zxy;
	vec3 b = (t0     - t1.zxy) * 2.0;
	vec3 c = (t0.zxy + t1.yzx) * 2.0;

	return mat4(
		vec4(a.x, c.y, b.z, 0),
		vec4(b.x, a.y, c.z, 0),
		vec4(c.x, b.y, a.z, 0),
		vec4(translation.xyz, 1)
	);
}

layout(binding=0)
uniform MVP_BLOCK {
	mat4 screenMatrix;
	vec4 cameraMatrix[2];
	vec4 viewportXYWH;
};

layout(set=1, binding=0)
uniform BONE_BLOCK {
	vec4 boneList[2];
};

layout(location=0)
in vec3 inputPosition;

layout(location=1)
in vec3 inputNormal;

layout(location=2)
in vec2 inputUV;

//layout(location=3)
//in ivec4 boneIndex;

layout(location = 0)
out vec2 uv;

const vec3 pos[3] = vec3[](
	vec3(-100.0, 100.0, 0),
	vec3(100.0, 100.0, 0),
	vec3(0, -100.0, 0)
);

void main()
{
	vec3 worldPosition = vec3(0);
	for(int i=0; i<1; ++i){
		int index = (0 + 1 * gl_InstanceIndex) << 1;//every bone use two registers
		worldPosition += transform2(boneList[index], boneList[index+1], inputPosition) * 1.0;
	}
	//Position = worldPosition;
	vec3 cameraPosition = transform2(cameraMatrix[0], cameraMatrix[1], worldPosition);
	vec4 screenPosition = screenMatrix * vec4(cameraPosition, 1);

	//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;

	gl_Position = screenPosition;
	uv = inputUV;
}
`;

const fragment3DShaderGLSL = `#version 450

	layout(binding=1)uniform sampler _sampler;
	layout(set=2, binding=0)uniform texture2D _texture;

	layout(location=0)out vec4 outColor;
	layout(location=0)in vec2 uv;

	void main() {
		outColor = texture(sampler2D(_texture, _sampler), uv);
	}
`;

const {View3D, Vulkan, Bitmap, BlurFilter, ColorMatrixFilter, MeshEntity} = require('./lib');

async function init(){
	const glslangModule = await import('https://unpkg.com/@webgpu/glslang@0.0.7/web/glslang.js');
	const glslang = await glslangModule.default();
	
	const canvas = document.createElement('canvas');
	canvas.width = 550;
	canvas.height = 400;
	document.body.appendChild(canvas);
	
	if(!navigator.gpu)return;
	const adapter = await navigator.gpu.requestAdapter();
	const device = await adapter.requestDevice();

	Vulkan.init(device, canvas);

	const weaponData = await Vulkan.loadModel('./Spear10.bmd');
	
	const texture = await Vulkan.loadTexture(device, './1.png')
	const texture2 = await Vulkan.loadTexture(device, './2.jpg')

	Vulkan.filterVertexCode = glslang.compileGLSL(filterVertexShaderGLSL, "vertex");
	Vulkan.filterFragmentCode = glslang.compileGLSL(filterFragmentShaderGLSL, "fragment");

	Vulkan.vertexCode = glslang.compileGLSL(vertexShaderGLSL, "vertex");
	Vulkan.fragmentCode = glslang.compileGLSL(fragmentShaderGLSL, "fragment");

	Vulkan.vertex3DCode = glslang.compileGLSL(vertex3DShaderGLSL, "vertex");
	Vulkan.fragment3DCode = glslang.compileGLSL(fragment3DShaderGLSL, "fragment");

	const view3d = new View3D();

	view3d.scene3d.root.addChild(new MeshEntity(weaponData));
	
		let a = texture.createView();

		let b = texture2.createView();

		var bitmap = new Bitmap();
		bitmap.texture = new Texture2D(a);
		bitmap.texture.scale9grid = [20,20,20,20];
		bitmap.width = bitmap.height = 500;

		var bmp2 = new Bitmap();
		bmp2.x = 480;
		bmp2.texture = new Texture2D(b);

		var bmp3 = new Bitmap();
		bmp3.x = 480;
		bmp3.y = 300;
		bmp3.texture = bmp2.texture;

		var box = new DisplayObject2D();
		box.addChild(bitmap);
		box.addChild(bmp2);
		box.addChild(bmp3);

		bmp2.filter = new BlurFilter();

		view3d.scene2d.root.addChild(box);
		box.scale = 0.2;
		box.filter = new ColorMatrixFilter();

		Clock.on("enterFrame", function(){
		box.rotation += 0.5;
		bmp2.rotation -= 1;
		})
	
}

window.addEventListener('DOMContentLoaded', init);

GPUDevice.prototype.copyImageBitmapToTexture = function(source, destination, copySize){
	const {imageBitmap} = source;
	const {width, height} = imageBitmap;

	const canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;

	const ctx = canvas.getContext('2d');
	ctx.drawImage(imageBitmap, 0, 0);
	const imageData = ctx.getImageData(0, 0, width, height);
	this.copyImageDataToTexture(imageData, destination, copySize);
}

GPUDevice.prototype.copyImageDataToTexture = function(imageData, destination, copySize){
	const pitchSize = 64;
	const bytePerPixel = 4;

	const {width, height} = imageData;

	const rowPitch = Math.ceil(width / pitchSize) * pitchSize * bytePerPixel;//mulitimes of 256

	let bufferData;

	if(width % pitchSize == 0){
		bufferData = imageData.data;
	}else{
		bufferData = new Uint8Array(rowPitch * height);
		const data = imageData.data;
		for(let y=0; y<height; ++y){
			for(let x=0; x<width; ++x){
				let i = y * rowPitch + x * bytePerPixel;
				let j = (y * width + x) * bytePerPixel;
				bufferData[i  ] = data[j];
				bufferData[i+1] = data[j+1];
				bufferData[i+2] = data[j+2];
				bufferData[i+3] = data[j+3];
			}
		}
	}

	const buffer = this.createBuffer({
		size: bufferData.length,
		usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
	});
	buffer.setSubData(0, bufferData);

	const commandEncoder = this.createCommandEncoder();
	commandEncoder.copyBufferToTexture({
		buffer,
		rowPitch,
		imageHeight: height,
		offset: 0
	}, destination, copySize);
	this.defaultQueue.submit([commandEncoder.finish()]);

	buffer.destroy();
}

/*

https://gpuweb.github.io/gpuweb/
https://gpuweb.github.io/WSL/
https://github.com/gpuweb/gpuweb
https://www.khronos.org/opengl/wiki/Compute_Shader

const renderBundleEncoder = device.createRenderBundleEncoder({
	colorFormats:[swapChainFormat],
	depthStencilFormat: 'depth24plus-stencil8'
});
renderPassEncoder.executeBundles([renderBundleEncoder.finish()]);

const computePassEncoder = commandEncoder.beginComputePass();
const computePipeline = device.createComputePipeline({
	layout: pipelineLayout,
	computeStage: {
		module: device.createShaderModule({
			code: '',
		}),
		entryPoint: 'main'
	}
});

interface GPUComputePassEncoder {
	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
                      optional sequence<unsigned long> dynamicOffsets = []);

    void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      unsigned long long dynamicOffsetsDataStart,
                      unsigned long long dynamicOffsetsDataLength);

    void setPipeline(GPUComputePipeline pipeline);
    void dispatch(unsigned long x, optional unsigned long y = 1, optional unsigned long z = 1);
    void dispatchIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);

    void endPass();
};

interface GPUCommandEncoder {
	void copyBufferToBuffer(
		GPUBuffer source,
		GPUBufferSize sourceOffset,
		GPUBuffer destination,
		GPUBufferSize destinationOffset,
		GPUBufferSize size);

	void copyBufferToTexture(
		GPUBufferCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);

	void copyTextureToBuffer(
		GPUTextureCopyView source,
		GPUBufferCopyView destination,
		GPUExtent3D copySize);

	void copyTextureToTexture(
		GPUTextureCopyView source,
		GPUTextureCopyView destination,
		GPUExtent3D copySize);
};

interface RenderBase {
	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
					  optional sequence<unsigned long> dynamicOffsets = []);

	void setBindGroup(unsigned long index, GPUBindGroup bindGroup,
					  Uint32Array dynamicOffsetsData,
					  unsigned long long dynamicOffsetsDataStart,
					  unsigned long long dynamicOffsetsDataLength);

	void setPipeline(GPURenderPipeline pipeline);

	void setIndexBuffer(GPUBuffer buffer, optional GPUBufferSize offset = 0);
	void setVertexBuffer(unsigned long slot, GPUBuffer buffer, optional GPUBufferSize offset = 0);

	void draw(unsigned long vertexCount, unsigned long instanceCount,
			  unsigned long firstVertex, unsigned long firstInstance);
	void drawIndexed(unsigned long indexCount, unsigned long instanceCount,
					 unsigned long firstIndex, long baseVertex, unsigned long firstInstance);

	void drawIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
	void drawIndexedIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
};

interface GPURenderPassEncoder extends RenderBase {
	void setViewport(float x, float y,
					 float width, float height,
					 float minDepth, float maxDepth);

	void setScissorRect(unsigned long x, unsigned long y, unsigned long width, unsigned long height);

	void setBlendColor(GPUColor color);
	void setStencilReference(unsigned long reference);

	void executeBundles(sequence<GPURenderBundle> bundles);
	void endPass();
};

interface GPURenderBundleEncoder extends RenderBase {
	GPURenderBundle finish();
};

enum GPUVertexFormat {
	"uchar2",
	"uchar4",
	"char2",
	"char4",
	"uchar2norm",
	"uchar4norm",
	"char2norm",
	"char4norm",
	"ushort2",
	"ushort4",
	"short2",
	"short4",
	"ushort2norm",
	"ushort4norm",
	"short2norm",
	"short4norm",
	"half2",
	"half4",
	"float",
	"float2",
	"float3",
	"float4",
	"uint",
	"uint2",
	"uint3",
	"uint4",
	"int",
	"int2",
	"int3",
	"int4"
};

enum GPUIndexFormat {
	"uint16",
	"uint32"
};

enum GPUInputStepMode {
	"vertex",
	"instance"
};

enum GPUPrimitiveTopology {
	"point-list",
	"line-list",
	"line-strip",
	"triangle-list",
	"triangle-strip"
};

dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
	required GPUBindGroupLayout layout;
	required sequence<GPUBindGroupBinding> bindings;
};
typedef (GPUSampler or GPUTextureView or GPUBufferBinding) GPUBindingResource;

dictionary GPUBindGroupBinding {
	required unsigned long binding;
	required GPUBindingResource resource;
};
dictionary GPUBufferBinding {
	required GPUBuffer buffer;
	GPUBufferSize offset = 0;
	GPUBufferSize size;
};

enum GPUBindingType {
	"uniform-buffer",
	"storage-buffer",
	"readonly-storage-buffer",
	"sampler",
	"sampled-texture",
	"storage-texture"
	// TODO: other binding types
};

interface GPUShaderStage {
	const GPUShaderStageFlags VERTEX   = 0x1;
	const GPUShaderStageFlags FRAGMENT = 0x2;
	const GPUShaderStageFlags COMPUTE  = 0x4;
};

interface GPUBufferUsage {
	const GPUBufferUsageFlags MAP_READ  = 0x0001;
	const GPUBufferUsageFlags MAP_WRITE = 0x0002;
	const GPUBufferUsageFlags COPY_SRC  = 0x0004;
	const GPUBufferUsageFlags COPY_DST  = 0x0008;
	const GPUBufferUsageFlags INDEX     = 0x0010;
	const GPUBufferUsageFlags VERTEX    = 0x0020;
	const GPUBufferUsageFlags UNIFORM   = 0x0040;
	const GPUBufferUsageFlags STORAGE   = 0x0080;
	const GPUBufferUsageFlags INDIRECT  = 0x0100;
};

interface GPUTextureUsage {
	const GPUTextureUsageFlags COPY_SRC          = 0x01;
	const GPUTextureUsageFlags COPY_DST          = 0x02;
	const GPUTextureUsageFlags SAMPLED           = 0x04;
	const GPUTextureUsageFlags STORAGE           = 0x08;
	const GPUTextureUsageFlags OUTPUT_ATTACHMENT = 0x10;
};

enum GPUTextureFormat {
	// 8-bit formats
	"r8unorm",
	"r8snorm",
	"r8uint",
	"r8sint",

	// 16-bit formats
	"r16uint",
	"r16sint",
	"r16float",
	"rg8unorm",
	"rg8snorm",
	"rg8uint",
	"rg8sint",

	// 32-bit formats
	"r32uint",
	"r32sint",
	"r32float",
	"rg16uint",
	"rg16sint",
	"rg16float",
	"rgba8unorm",
	"rgba8unorm-srgb",
	"rgba8snorm",
	"rgba8uint",
	"rgba8sint",
	"bgra8unorm",
	"bgra8unorm-srgb",
	// Packed 32-bit formats
	"rgb10a2unorm",
	"rg11b10float",

	// 64-bit formats
	"rg32uint",
	"rg32sint",
	"rg32float",
	"rgba16uint",
	"rgba16sint",
	"rgba16float",

	// 128-bit formats
	"rgba32uint",
	"rgba32sint",
	"rgba32float",

	// Depth and stencil formats
	"depth32float",
	"depth24plus",
	"depth24plus-stencil8"
};

dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
	GPUAddressMode addressModeU = "clamp-to-edge";
	GPUAddressMode addressModeV = "clamp-to-edge";
	GPUAddressMode addressModeW = "clamp-to-edge";
	GPUFilterMode magFilter = "nearest";
	GPUFilterMode minFilter = "nearest";
	GPUFilterMode mipmapFilter = "nearest";
	float lodMinClamp = 0;
	float lodMaxClamp = 0xffffffff; // TODO: What should this be? Was Number.MAX_VALUE.
	GPUCompareFunction compare = "never";
};
enum GPUAddressMode {
	"clamp-to-edge",
	"repeat",
	"mirror-repeat"
};
enum GPUFilterMode {
	"nearest",
	"linear"
};
enum GPUCompareFunction {
	"never",
	"less",
	"equal",
	"less-equal",
	"greater",
	"not-equal",
	"greater-equal",
	"always"
};

*/