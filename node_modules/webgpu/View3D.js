'use strict';

const Vulkan = require('./Vulkan');
const DisplayObject = require('./DisplayObject');
const DisplayObject2D = require('./DisplayObject2D');
const DisplayObject3D = require('./DisplayObject3D');
const traverseTree = require('utils/traverseTree');

class View3D
{
	constructor(){
		this.scene3d = new DisplayObject3D();
		this.scene2d = new DisplayObject2D();
		frameDo(this.onTick.bind(this));

		const {device, canvas} = Vulkan;
		this.depthTexture = Vulkan.createDepthTexture(canvas.width, canvas.height);

		this.fence = device.defaultQueue.createFence();
	}

	onTick(){
		console.log('-------');
		Vulkan.resetManagers();
		this.updateScene();
		this.drawScene();
		Vulkan.updateManagers();
	}

	updateScene(){
		DisplayObject.updateWorldTransform(this.scene3d);
		DisplayObject.updateWorldTransform(this.scene2d);
		DisplayObject.updateTree(this.scene3d);
		DisplayObject.updateTree(this.scene2d);
	}

	drawScene(){
		const {device, swapChain} = Vulkan;
		const {depthTexture} = this;

		const mainColorTexture = swapChain.getCurrentTexture().createView();
		const mainDepthStencil = depthTexture.createView();

		const commandEncoder = device.createCommandEncoder();

		Vulkan.commandEncoder = commandEncoder;
		Vulkan.mainColorTexture = mainColorTexture;
		Vulkan.mainDepthStencil = mainDepthStencil;
		//Vulkan.copyDataCommandEncoder = device.createCommandEncoder();

		drawScene3D(this.scene3d);
		drawScene2D(this.scene2d);

		device.defaultQueue.submit([
			//Vulkan.copyDataCommandEncoder.finish(),
			commandEncoder.finish()
		]);

		//while(Vulkan.destroyList.length > 0){
		//	Vulkan.destroyList.pop().destroy();
		//}
		//console.log('submit', performance.now());
		//device.defaultQueue.signal(this.fence, 0);
		/*console.log('signal begin', performance.now());
		this.fence.onCompletion(23).then(() => {
			console.log('fence complete', performance.now(), this.fence.getCompletedValue())
		});
		console.log('signal end', performance.now());
		//*/
	}
}

const frameDo = fn => requestAnimationFrame(function loop(){
	requestAnimationFrame(loop);
	fn();
});

const drawScene2D = function(){
	const renderPassDesc = {
		colorAttachments: [{
			attachment: null,
			loadValue: 'load'
		}]
	};
	function onDraw(item){
		if(!item.visible)return true;
		const {filter} = item;
		if(filter){
			Vulkan.bitmapQueue.add(filter);
			return true;
		}
		Vulkan.render2D.draw(item);
	}
	return function(root){
		const {mainColorTexture, bitmapQueue} = Vulkan;

		Vulkan.collectBitmap3Ds(root);
		Vulkan.collectFilter2Ds(root);

		traverseTree(root, onDraw);
		
		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture]);
		Vulkan.prepareDraw2D();
		Vulkan.drawBitmapQueue();
		renderPassEncoder.endPass();
	}
}();

const drawScene3D = function(){
	const renderPassDesc = {
		colorAttachments: [{
			attachment: null,
			loadValue: [0,0,0,1]
		}],
		depthStencilAttachment: {
			attachment: null,
			depthLoadValue: 1.0,
			depthStoreOp: 'store',
			depthReadOnly: true,//default false, optional
			stencilLoadValue: 0,
			stencilStoreOp: 'store',
			stencilReadOnly: true,//default false, optional
		}
	};
	return function(root){
		const {mainColorTexture, mainDepthStencil, camera3DGPUResourceMgr} = Vulkan;
		const camera = root.camera;

		camera._gpuAsset = camera3DGPUResourceMgr.getOut();

		if(camera.cullEnabled){
			Vulkan.directBufferMgr.prepareCull(camera);
		}

		const renderPassEncoder = Vulkan.pushRenderPass(renderPassDesc, [mainColorTexture], mainDepthStencil);
		
		camera.draw(root);

		renderPassEncoder.endPass();

		if(camera.cullEnabled){
			Vulkan.directBufferMgr.setDispatchValue();
		}
	}
}();

module.exports = View3D;
