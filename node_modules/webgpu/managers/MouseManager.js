'use strict';

const Vulkan = require('../Vulkan');
const ViewFrustum = require('../cameras/ViewFrustum');

const viewFrustum = new ViewFrustum();

class MouseManager
{
	constructor(){
		const mouseEventHandler = this.onMouseEvent.bind(this);
		const {canvas} = Vulkan;
		for(let evtType of ["mousedown", "mouseup", "mousemove"]){
			canvas.addEventListener(evtType, mouseEventHandler);
		}
		listen(canvas);
	}

	onMouseEvent(evt){
		this.requestPick = true;
		this.mouseEvent = evt;
		this.mouseX = evt.x;
		this.mouseY = evt.y;
	}

	onFrameEnd(){
		return
		if(!this.requestPick)return;
		this.requestPick = false;
		const {canvas, view3d} = Vulkan;
		const camera = view3d.scene3d.camera;

		if(this.mouseEvent.type != 'mousedown'){
			return
		}
		
		const x = this.mouseX * 2 / canvas.width - 1;
		const y = 1 - this.mouseY * 2 / canvas.height;
		const ray = camera.lens.screenToCamera(x, y);
		ray.cameraToWorld(camera.worldTransform);
		//const entitySet = new Set(Array.from(view3d.scene3d.collectDrawUnits(camera), drawUnit => drawUnit.entity));
		for(const entity of view3d.scene3d.collectEntities(camera)){
			const {bound} = entity;
			if(!bound)continue;
			if(ray.hitTestAABB(bound)){
				console.log('hit', entity.mesh.name);
			}
		}
	}
}

function onMouseDown(moveHandler, upHandler, downHandler){
	return function(evt){
		const {target, pageX:startX, pageY:startY} = evt;
		let endX = startX;
		let endY = startY;
		let moveFlag = false;
		function onMouseMove(evt){
			const {pageX:nowX, pageY:nowY} = evt;
			if(endX === nowX && endY === nowY)return;
			endX = nowX;
			endY = nowY;
			moveFlag = true;
			const {left, top} = target.getBoundingClientRect();
			const {scrollLeft, scrollTop} = document.body;
			const x = scrollLeft + left;
			const y = scrollTop + top;
			const l = Math.min(startX, endX) - x;
			const t = Math.min(startY, endY) - y;
			const r = Math.max(startX, endX) - x;
			const b = Math.max(startY, endY) - y;
			moveHandler?.(l, t, r, b);
		}
		function onMouseUp(){
			document.removeEventListener('mousemove', onMouseMove);
			document.removeEventListener('mouseup', onMouseUp);
			if(moveFlag)upHandler?.();
		}
		downHandler?.();
		document.addEventListener('mousemove', onMouseMove);
		document.addEventListener('mouseup', onMouseUp);
	}
}

function listen(target){
	//const ctx = target.getContext('2d');
	//ctx.strokeStyle = "#ff0000";
	target.addEventListener('mousedown', onMouseDown((l, t, r, b) => {
		//ctx.clearRect(0, 0, target.width, target.height);
		//ctx.strokeRect(l, t, r - l, b - t);
		const {canvas, view3d} = Vulkan;
		const camera = view3d.scene3d.camera;
		l = l * 2 / canvas.width - 1;
		r = r * 2 / canvas.width - 1;
		t = 1 - t * 2 / canvas.height;
		b = 1 - b * 2 / canvas.height;
		viewFrustum.update(camera, l, b, r, t);
		const entitySet = new Set(Array.from(view3d.scene3d.collectDrawUnits(camera), drawUnit => drawUnit.entity));
		for(const entity of entitySet){
			const {bound} = entity;
			if(!bound)continue;
			if(!viewFrustum.canCull(bound)){
				console.log('viewFrustum hit', entity.mesh.name);
			}
		}
	}, () => {
		console.log('mouse up');
	}, () => {
		//ctx.clearRect(0, 0, target.width, target.height);
	}));
}

module.exports = MouseManager;
