'use strict';

const Vulkan = require('../Vulkan');
const Vector3D = require('../math/Vector3D');
const SelectionFrustum = require('../cameras/SelectionFrustum');
const {nextFrameDo} = require('webonly/deferDo');

const selectionFrustum = new SelectionFrustum();
const Signal = require('mvc/node_modules/signal');

class MouseManager
{
	constructor(){
		const {canvas} = Vulkan;
		canvas.addEventListener('mousemove', nextFrameDo(list => this.onMouseMove(Array.from(list).pop())));
		canvas.addEventListener('mousedown', evt => this.onMouseDown(evt));
		canvas.addEventListener('mouseup', evt => this.onMouseUp(evt));
		canvas.addEventListener('click', evt => this.onMouseClick(evt));
		//this.events = new EventTarget();
		//listen(canvas);
		this.hitInfo2D = {};
		this.mouseDownSignal = new Signal();
	}

	onMouseDown(evt){
		if(!Vulkan.view3d?.scene2d)return;
		this.mouseX = evt.x;
		this.mouseY = evt.y;
		const {hitInfo2D} = this;
		hitInfo2D.prev = hitInfo2D.curr;
		hitInfo2D.curr = null;
		pickTree.call(this, Vulkan.view3d.scene2d, onHit2D);
		let target = this.hitInfo2D.curr;
		while(target){
			target.mouseDownSignal.notify(evt);
			target = target.parent;
		}
	}

	onMouseUp(evt){
		if(!Vulkan.view3d?.scene2d)return;
		let target = this.hitInfo2D.curr;
		while(target){
			target.mouseUpSignal.notify(evt);
			target = target.parent;
		}
	}

	onMouseMove(evt){
		if(!Vulkan.view3d?.scene2d)return;
		if(evt.buttons & 1){
			let target = this.hitInfo2D.curr;
			while(target){
				target.mouseMoveSignal.notify(evt);
				target = target.parent;
			}
			return;
		}
		this.mouseX = evt.x;
		this.mouseY = evt.y;
		const {hitInfo2D} = this;
		hitInfo2D.prev = hitInfo2D.curr;
		hitInfo2D.curr = null;
		pickTree.call(this, Vulkan.view3d.scene2d, onHit2D);

		let target = this.hitInfo2D.curr;
		while(target){
			target.mouseMoveSignal.notify(evt);
			target = target.parent;
		}
		if(this.hitInfo2D.curr === this.hitInfo2D.prev)return;
		target = this.hitInfo2D.prev;
		while(target && !target.contains(this.hitInfo2D.curr)){
			target.mouseOutSignal.notify();
			target = target.parent;
		}
		const shareParent = target;
		target = this.hitInfo2D.curr;
		while(target != shareParent){
			target.mouseOverSignal.notify();
			target = target.parent;
		}
	}

	onMouseClick(evt){
		if(this.hitInfo2D.curr)return;
		const {canvas, view3d} = Vulkan;
		const camera = view3d.scene3d.camera;
		const x = evt.x * 2 / canvas.width - 1;
		const y = 1 - evt.y * 2 / canvas.height;
		const ray = camera.lens.screenToCamera(x, y);
		ray.cameraToWorld(camera.worldTransform);
		const groundPosition = new Vector3D();
		ray.direction.scaleBy(ray.origin.z / ray.direction.z, groundPosition);
		ray.origin.subtract(groundPosition, groundPosition);
		this.mouseDownSignal.notify(groundPosition);
		return;
		//const entitySet = new Set(Array.from(view3d.scene3d.collectDrawUnits(camera), drawUnit => drawUnit.entity));
		for(const entity of view3d.scene3d.collectEntities(camera)){
			const {bound} = entity;
			if(!bound)continue;
			if(ray.hitTestAABB(bound)){
				console.log('hit', entity.mesh.name);
			}
		}
	}
}

function pickTree(item, handler){
	const children = item._children;
	if(item.mouseChildren){
		for(let i=children.length-1; i>=0; --i){
			let child = children[i];
			if(!child.visible)continue;
			if(pickTree.call(this, child, handler) === true)return true;
		}
	}
	if(item.mouseEnabled && item.type)return handler.call(this, item);
}

const onHit2D = function(){
	const pt = {};
	return function(item){
		//console.log('onHit2D',item)
		item.worldTransformInvert.transformCoords(this.mouseX, this.mouseY, pt);
		let value = 0 <= pt.x && pt.x <= item.width && 0 <= pt.y && pt.y <= item.height;
		//console.log(this.mouseX, this.mouseY, pt, value, item._texture?.rawTexture.name)
		if(value){
			this.hitInfo2D.curr = item;
			return true;
		}
	}
}();


function onMouseDown(moveHandler, upHandler, downHandler){
	return function(evt){
		const {target, pageX:startX, pageY:startY} = evt;
		let endX = startX;
		let endY = startY;
		let moveFlag = false;
		function onMouseMove(evt){
			const {pageX:nowX, pageY:nowY} = evt;
			if(endX === nowX && endY === nowY)return;
			endX = nowX;
			endY = nowY;
			moveFlag = true;
			const {left, top} = target.getBoundingClientRect();
			const {scrollLeft, scrollTop} = document.body;
			const x = scrollLeft + left;
			const y = scrollTop + top;
			const l = Math.min(startX, endX) - x;
			const t = Math.min(startY, endY) - y;
			const r = Math.max(startX, endX) - x;
			const b = Math.max(startY, endY) - y;
			moveHandler?.(l, t, r, b);
		}
		function onMouseUp(){
			document.removeEventListener('mousemove', onMouseMove);
			document.removeEventListener('mouseup', onMouseUp);
			if(moveFlag)upHandler?.();
		}
		downHandler?.();
		document.addEventListener('mousemove', onMouseMove);
		document.addEventListener('mouseup', onMouseUp);
	}
}

function listen(target){
	const ctx = Vulkan.canvas2d.getContext('2d');
	ctx.strokeStyle = "#ff0000";
	target.addEventListener('mousedown', onMouseDown((l, t, r, b) => {
		ctx.clearRect(0, 0, target.width, target.height);
		ctx.strokeRect(l, t, r - l, b - t);
		const {canvas, view3d} = Vulkan;
		const camera = view3d.scene3d.camera;
		l = l * 2 / canvas.width - 1;
		r = r * 2 / canvas.width - 1;
		t = 1 - t * 2 / canvas.height;
		b = 1 - b * 2 / canvas.height;
		selectionFrustum.update(camera, l, b, r, t);
		//const entitySet = new Set(Array.from(view3d.scene3d.collectDrawUnits(camera), drawUnit => drawUnit.entity));
		for(const entity of view3d.scene3d.collectEntities(camera)){
			const {bound} = entity;
			if(!bound)continue;
			if(!selectionFrustum.canCull(bound)){
				console.log('selectionFrustum hit', entity.mesh.name);
			}
		}
	}, () => {
		console.log('mouse up');
	}, () => {
		ctx.clearRect(0, 0, target.width, target.height);
		//console.clear();
	}));
}

module.exports = MouseManager;
