'use strict';

const Vulkan = require('../Vulkan');
const SelectionFrustum = require('../cameras/SelectionFrustum');

const selectionFrustum = new SelectionFrustum();

class MouseManager
{
	constructor(){
		const mouseEventHandler = this.onMouseEvent.bind(this);
		const {canvas} = Vulkan;
		for(let evtType of ["mousedown", "mouseup", "mousemove"]){
			canvas.addEventListener(evtType, mouseEventHandler);
		}
		//this.events = new EventTarget();
		//listen(canvas);
	}

	onMouseEvent(evt){
		this.requestPick = true;
		this.mouseEvent = evt;
		this.mouseX = evt.x;
		this.mouseY = evt.y;
	}

	onFrameEnd(){
		//return
		if(!this.requestPick)return;
		this.requestPick = false;
		const {canvas, view3d} = Vulkan;
		const camera = view3d.scene3d.camera;

		const evtType = this.mouseEvent.type;

		if(evtType == 'mouseup' && this.hitItem2D){
			let target = this.hitItem2D;
			while(target){
				target.mouseUpSignal.notify(this.hitItem2D);
				target = target.parent;
			}
			this.hitItem2D = null;
			return
		}

		if(evtType == 'mousemove')return;

		this.hitItem2D = null
		pickTree.call(this, view3d.scene2d, onHit2D, false);
		//console.log(this.mouseX, this.mouseY, this.hitItem2D?._texture?.rawTexture.name);
		//if(this.hitItem2D){
			let target = this.hitItem2D;
			while(target){
				target.mouseDownSignal.notify(this.hitItem2D);
				target = target.parent;
			}
		//}
		
		const x = this.mouseX * 2 / canvas.width - 1;
		const y = 1 - this.mouseY * 2 / canvas.height;
		const ray = camera.lens.screenToCamera(x, y);
		ray.cameraToWorld(camera.worldTransform);
		//const entitySet = new Set(Array.from(view3d.scene3d.collectDrawUnits(camera), drawUnit => drawUnit.entity));
		for(const entity of view3d.scene3d.collectEntities(camera)){
			const {bound} = entity;
			if(!bound)continue;
			if(ray.hitTestAABB(bound)){
				console.log('hit', entity.mesh.name);
			}
		}
	}
}

function pickTree(item, handler){
	const children = item._children;
	for(let i=children.length-1; i>=0; --i){
		let child = children[i];
		if(!child.visible)continue;
		if(pickTree.call(this, child, handler) === true)return true;
	}
	if(item.type)return handler.call(this, item);
}

const onHit2D = function(){
	const pt = {};
	return function(item){
		//console.log('onHit2D',item)
		item.worldTransformInvert.transformCoords(this.mouseX, this.mouseY, pt);
		let value = 0 <= pt.x && pt.x <= item.width && 0 <= pt.y && pt.y <= item.height;
		//console.log(this.mouseX, this.mouseY, pt, value, item._texture?.rawTexture.name)
		if(value){
			this.hitItem2D = item;
			return true;
		}
	}
}();


function onMouseDown(moveHandler, upHandler, downHandler){
	return function(evt){
		const {target, pageX:startX, pageY:startY} = evt;
		let endX = startX;
		let endY = startY;
		let moveFlag = false;
		function onMouseMove(evt){
			const {pageX:nowX, pageY:nowY} = evt;
			if(endX === nowX && endY === nowY)return;
			endX = nowX;
			endY = nowY;
			moveFlag = true;
			const {left, top} = target.getBoundingClientRect();
			const {scrollLeft, scrollTop} = document.body;
			const x = scrollLeft + left;
			const y = scrollTop + top;
			const l = Math.min(startX, endX) - x;
			const t = Math.min(startY, endY) - y;
			const r = Math.max(startX, endX) - x;
			const b = Math.max(startY, endY) - y;
			moveHandler?.(l, t, r, b);
		}
		function onMouseUp(){
			document.removeEventListener('mousemove', onMouseMove);
			document.removeEventListener('mouseup', onMouseUp);
			if(moveFlag)upHandler?.();
		}
		downHandler?.();
		document.addEventListener('mousemove', onMouseMove);
		document.addEventListener('mouseup', onMouseUp);
	}
}

function listen(target){
	const ctx = Vulkan.canvas2d.getContext('2d');
	ctx.strokeStyle = "#ff0000";
	target.addEventListener('mousedown', onMouseDown((l, t, r, b) => {
		ctx.clearRect(0, 0, target.width, target.height);
		ctx.strokeRect(l, t, r - l, b - t);
		const {canvas, view3d} = Vulkan;
		const camera = view3d.scene3d.camera;
		l = l * 2 / canvas.width - 1;
		r = r * 2 / canvas.width - 1;
		t = 1 - t * 2 / canvas.height;
		b = 1 - b * 2 / canvas.height;
		selectionFrustum.update(camera, l, b, r, t);
		//const entitySet = new Set(Array.from(view3d.scene3d.collectDrawUnits(camera), drawUnit => drawUnit.entity));
		for(const entity of view3d.scene3d.collectEntities(camera)){
			const {bound} = entity;
			if(!bound)continue;
			if(!selectionFrustum.canCull(bound)){
				console.log('selectionFrustum hit', entity.mesh.name);
			}
		}
	}, () => {
		console.log('mouse up');
	}, () => {
		ctx.clearRect(0, 0, target.width, target.height);
		//console.clear();
	}));
}

module.exports = MouseManager;
