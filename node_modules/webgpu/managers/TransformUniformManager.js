'use strict';

const Vulkan = require('../Vulkan');


class TransformUniformManager
{
	constructor(){
		this.transformUniformCache = Vulkan.createUniformBufferListCache(
			Vulkan.bindGroupLayoutDict.bindGroupLayout2
		);
		this.boneDataCache = Vulkan.createUniformBufferListCache(
			Vulkan.bindGroupLayoutDict.bindGroupLayout2
		);
		this.alloter = new Alloter();
	}

	onFrameBegin(){
		this.alloter.reset();
	}

	register(instanceList, offset, instanceCount){
		const info = this.alloter.add(instanceCount);
		info[2] = instanceCount;
		const {currentMaterial} = Vulkan;
		for(let i=0; i<instanceCount; ++i){
			let instance = instanceList[offset+i];
			currentMaterial.onUpdateBuffer?.(instance, i, info);
			//objectBuffer3D.set(instance.worldTransform.rawData);
			instance.skeleton.rootBone?.copyToBuffer(objectBuffer3D);
			this.transformUniformCache(info[0], 48 * (info[1] + i), instance.worldTransform.rawData);
			this.boneDataCache(info[0], objectBuffer3D.byteLength * (info[1] + i), objectBuffer3D);
		}
		return info;
	}
}

class Alloter
{
	constructor(){
		this.index = 0;
		this.maxCount = 4;
		this.waitList = [];
	}

	reset(){
		this.index = 0;
		this.waitList.length = 0;
	}

	add(count){
		const {maxCount, waitList} = this;
		if(count > maxCount)return;
		if(count < maxCount){
			for(let i=0, n=waitList.length; i<n; ++i){
				const info = waitList[i];
				const [index, offset] = info;
				const newOffset = offset + count;
				if(newOffset > maxCount)continue;
				if(newOffset == maxCount){
					waitList.splice(i, 1);
				}else{
					waitList[i] = [index, newOffset];
				}
				return info;
			}
			waitList.push([this.index, count]);
		}
		return [this.index++, 0];
	}
}

const objectBuffer3D = new Float32Array(256*4);

module.exports = TransformUniformManager;
