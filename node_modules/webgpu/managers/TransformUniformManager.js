'use strict';

const Vulkan = require('../Vulkan');
const Slot = require('../helper/Slot');

class TransformUniformManager
{
	constructor(){
		this.transformUniformCache = Vulkan.createUniformBufferListCache(
			Vulkan.bindGroupLayoutDict.bindGroupLayout2
		);
		this.boneDataCache = Vulkan.createUniformBufferListCache(
			Vulkan.bindGroupLayoutDict.bindGroupLayout2
		);
		this.alloter = new Slot(1);
	}

	onFrameBegin(){
		this.alloter.clear();
	}

	register(instanceList){
		const infoList = Array.from(this.alloter.add(instanceList.length));
		const {currentMaterial} = Vulkan;
		let offset = 0;
		for(const info of infoList){
			const instanceCount = info[2];
			for(let i=0; i<instanceCount; ++i){
				let instance = instanceList[offset+i];
				currentMaterial.onUpdateBuffer?.(instance, i, info);
				instance.skeleton.rootBone?.copyToBuffer(objectBuffer3D);
				this.transformUniformCache(info[0], 48 * (info[1] + i), instance.worldTransform.rawData);
				this.boneDataCache(info[0], objectBuffer3D.byteLength * (info[1] + i), objectBuffer3D);
			}
			offset += instanceCount;
		}
		return infoList;
	}
/*
	register(instanceList, offset, instanceCount){
		const info = Array.from(this.alloter.add(instanceCount))[0];
		const {currentMaterial} = Vulkan;
		for(let i=0; i<instanceCount; ++i){
			let instance = instanceList[offset+i];
			currentMaterial.onUpdateBuffer?.(instance, i, info);
			//objectBuffer3D.set(instance.worldTransform.rawData);
			instance.skeleton.rootBone?.copyToBuffer(objectBuffer3D);
			this.transformUniformCache(info[0], 48 * (info[1] + i), instance.worldTransform.rawData);
			this.boneDataCache(info[0], objectBuffer3D.byteLength * (info[1] + i), objectBuffer3D);
		}
		return info;
	}
*/
}

const objectBuffer3D = new Float32Array(256*4);

module.exports = TransformUniformManager;
