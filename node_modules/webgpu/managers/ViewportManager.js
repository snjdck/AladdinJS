'use strict';

const Vulkan = require('../Vulkan');
const Material2D = require('../materials/Material2D');
const {walkTree} = require('utils/traverseTree');
const defineConstGetter = require('utils/object/defineConstGetter');

const float32List = new Float32Array(12);
const bytePerInstance = float32List.byteLength;
const maxCameraCount = 256;

class ViewportManager
{
	constructor(){
		defineConstGetter(this, 'buffer', () => Vulkan.device.createBuffer({usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, size: bytePerInstance * maxCameraCount}));
		this.drawUnitBucket = [];
	}

	addViewPort(index, frameRect, drawRect, rootMatrix){
		this.viewportIndex = index;
		float32List[0] =  2 / frameRect.width;
		float32List[1] = -2 / frameRect.height;

		if(drawRect){
			float32List[2] = 2 * drawRect.x / frameRect.width - 1;
			float32List[3] = 1 - 2 * drawRect.y / frameRect.height;
		}else{
			float32List[2] = -1;
			float32List[3] =  1;
		}

		if(rootMatrix){
			rootMatrix.copyToArray(float32List, 4);
		}else{
			float32List[4] = float32List[9] = 1;
			float32List[5] = float32List[6] = float32List[7] = 
			float32List[8] = float32List[10] = float32List[11] = 0;
		}

		const offset = bytePerInstance * this.viewportIndex;
		Vulkan.device.queue.writeBuffer(this.buffer, offset, float32List);
	}

	collectDrawUnits(root, forceDrawFlag=false){
		if(forceDrawFlag)this._addToBucketWithCheck(root);
		_collectDrawUnits.call(this, root, !forceDrawFlag);
	}

	draw(bindGroupIndex=0, useDepthStencilFlag=false){
		const {drawUnitBucket} = this;
		if(drawUnitBucket.length <= 0)return;
		
		Material2D.setBindGroup(bindGroupIndex, [{buffer:this.buffer}, Vulkan.getSampler(Vulkan.sampler.linear_clamp)]);
		Material2D.draw(drawUnitBucket, useDepthStencilFlag);
		drawUnitBucket.length = 0;
	}

	_addToBucket(item, texture){
		const drawUnit = Object.create(item);
		drawUnit.viewportIndex = this.viewportIndex;
		if(texture){
			drawUnit.texture = texture;
			drawUnit.width = texture.width;
			drawUnit.height = texture.height;
		}
		this.drawUnitBucket.push(drawUnit);
	}

	_addToBucketWithCheck(item){
		if(item.type == 'bitmap' || item.type == 'bitmap3d'){
			if(!item.texture)return;
			this._addToBucket(item);
		}else if(item.type == 'label2d'){
			if(!item._text)return;
			const {worldTransform, fontSize} = item;
			for(let bitmap of Vulkan.textMgr.getTextBitmap(worldTransform, item._text, fontSize)){
				this._addToBucket(bitmap);
			}
		}
	}
}

const _collectDrawUnits = walkTree(function(item){
	if(!item.visible)return true;
	if(item.filter){
		this._addToBucket(item, item.filter.texture);
		return true;
	}
	this._addToBucketWithCheck(item);
});

module.exports = ViewportManager;
