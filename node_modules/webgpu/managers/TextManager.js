'use strict';

const Vulkan = require('../Vulkan');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');

const MAX_W = 4096;
const MAX_H = 4096;

class TextManager
{
	constructor(){
		const {device} = Vulkan;
		this.rectPack = new MaxRectsBinPack(MAX_W, MAX_H);
		this.fontDict = new Map();
		this.context = Vulkan.createCanvasContext(MAX_W, MAX_H);
		this.rawTexture = device.createTexture({
			size: [MAX_W, MAX_H, 1],
			format: 'rgba8unorm',
			usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
		});
		this.dirtyRectList = [];
	}

	getCharTexture2D(char, fontSize){
		const {rawTexture, fontDict, rectPack, context, dirtyRectList} = this;
		if(!fontDict.has(fontSize)){
			fontDict.set(fontSize, new Map());
		}
		const charDict = fontDict.get(fontSize);
		if(!charDict.has(char)){
			const textRect = calcTextRect(context, char);
			const packRect = rectPack.insert(textRect.width, textRect.height);
			const texture = new Texture2D(rawTexture.createView());
			texture.setUV(MAX_W, MAX_H, packRect, false);
			texture.xyuvAdd[1] = fontSize - textRect.y;
			charDict.set(char, texture);
			context.fillText(char, packRect.x + textRect.x, packRect.y + textRect.y);
			dirtyRectList.push(packRect);
		}
		return charDict.get(char);
	}

	needUpdate(text, fontSize){
		let list = text.split('').filter(v => /\S/.test(v));
		if(list.length <= 0)return false;
		const {fontDict} = this;
		if(!fontDict.has(fontSize))return true;
		const charDict = fontDict.get(fontSize);
		return !list.every(v => charDict.has(v));
	}

	*getTextBitmap(matrix, text, fontSize){
		const {context, dirtyRectList} = this;
		context.font = `${fontSize}px 微软雅黑`;
		let offset = 0;
		for(let i=0; i<text.length; ++i){
			let char = text.charAt(i);
			const texture = this.getCharTexture2D(char, fontSize);
			let worldTransform = matrix.clone();
			worldTransform.translate(offset, 0);
			offset += texture.width;
			yield {
				width: texture.width,
				height: texture.height,
				worldTransform, texture
			};
		}
		if(dirtyRectList.length > 0){
			const {device} = Vulkan;
			const area = Rect.Merge(dirtyRectList);
			createImageBitmap(context.canvas, area.x, area.y, area.width, area.height).then(imageBitmap => {
				device.queue.copyExternalImageToTexture(
					{source: imageBitmap},
					{texture:this.rawTexture, origin: [area.x, area.y, 0]},
					[area.width, area.height, 1]
				);
			});
			dirtyRectList.length = 0;
		}
	}
}

function calcTextRect(context, char){
	let metrics = context.measureText(char);
	return {
		x: metrics.actualBoundingBoxLeft,
		y: metrics.actualBoundingBoxAscent,
		width: metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight,
		height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
	};
}

module.exports = TextManager;
