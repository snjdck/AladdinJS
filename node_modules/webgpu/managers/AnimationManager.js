'use strict';

//const Vulkan = require('../Vulkan');

class AnimationManager
{
	constructor(){
		this.entitySet = new Set();
	}

	register(entity){
		this.entitySet.add(entity);
	}

	unregister(entity){
		this.entitySet.delete(entity);
	}

	onFrameBegin(){
		for(const entity of this.entitySet){
			if(!entity.animation)continue;
			entity.animationTime += 0.16;
			if(entity.animationTime > entity.animation.duration){
				entity.animationTime = 0;
			}
			entity.rootBone?.updateBone(entity);
		}
	}
}

/*
MeshEntity
	onUpdate(){
		const {animation, animationTime} = this;
		if(animation){
			let timeElapsed = 1000 / 60;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(this.attachmentDict){
			for(const [attachment] of this.attachmentDict){
				//DisplayObject.updateWorldTransform(attachment);
				DisplayObject.updateTree(attachment);
			}
		}
		if(!this._skeleton){
			this.rootBone?.updateBone(this);
		}
	}

*/

module.exports = AnimationManager;
