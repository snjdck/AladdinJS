'use strict';

const Vulkan = require('../Vulkan');
const BufferBindGroup = require('../helper/BufferBindGroup');
const DrawUnitBucket = require('../DrawUnitBucket');
const {traverseTree} = require('utils/traverseTree');

const drawUnitBucket = new DrawUnitBucket();
const bytePerInstance = 8 * 4 * 4;
const maxCameraCount = 100;

class CameraManager
{
	constructor(){
		this.bufferBindGroup = new BufferBindGroup([
			[GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, bytePerInstance * maxCameraCount],
		], buffer => [
			['0', {buffer}, Vulkan.getSampler('linear_repeat')],
			['2', {buffer}],
		]);
	}

	onFrameBegin(){
		this.cameraIndex = 0;
	}

	collectDrawUnits(camera, root){
		const uniformBuffer = this.bufferBindGroup.getBuffer();
		const offset = bytePerInstance * this.cameraIndex;
		
		Vulkan.copyDataToBuffer(uniformBuffer, camera.lens, offset);
		Vulkan.copyDataToBuffer(uniformBuffer, camera.worldTransformInvert.rawData, offset + 64);
		Vulkan.copyDataToBuffer(uniformBuffer, camera.viewportRect, offset + 112);

		drawUnitBucket.cameraIndex = this.cameraIndex++;

		if(camera.cullEnabled){
			camera.viewFrustum.update(camera);
		}
		traverseTree.call(camera, root, onCollect);
	}

	draw(bindGroupIndex=0){
		if(drawUnitBucket.length <= 0)return;
		Vulkan.renderPassEncoder.setBindGroup(bindGroupIndex, this.bufferBindGroup.getBindGroup());
		drawUnitBucket.draw().clear();
	}
}

function onCollect(element){
	if(!element.visible)return true;
	if(!(this.layerFlagFilter & element.layerFlag))return true;
	if(element.onCull)return element.onCull(this);
	if(!(this.cullEnabled && this.canCull(element))){
		element.onCollectDrawUnits?.(drawUnitBucket);
	}
}

module.exports = CameraManager;
