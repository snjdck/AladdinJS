'use strict';

const Vulkan = require('../Vulkan');


class DirectBufferManager
{
	constructor(){
		const {device} = Vulkan;
		this.totalIndex = 0;
		this.buffer = device.createBuffer({
			size: 0x10000,
			usage: GPUBufferUsage.INDIRECT | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
		});
		this.bindGroup = Vulkan.createBindGroup(
			Vulkan.layout_cull, [
			{buffer: this.buffer}
		]);

		this.boundBuffer = device.createBuffer({
			size: 0x4000,
			usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
		});
		this.boundBindGroup = Vulkan.createBindGroup(
			Vulkan.layout_2, [
			{buffer: this.boundBuffer}
		]);

		this.dispatchBuffer = device.createBuffer({
			size: 12,
			usage: GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_DST
		});
	}

	onFrameBegin(){
		this.totalIndex = 0;
	}

	draw(subMesh, vertexCount, instanceCount, baseVertex, baseInstance){
		const {renderPassEncoder, currentCamera} = Vulkan;

		if(!currentCamera.cullEnabled){
			renderPassEncoder.draw(vertexCount, instanceCount, baseVertex, baseInstance);
			return;
		}

		const {buffer, boundBuffer} = this;
		const elementSize = 16;
		let offset = this.totalIndex * elementSize;

		for(let i=0; i<instanceCount; ++i){
			Vulkan.copyDataToBuffer(boundBuffer, new Float32Array([
				500,500,500,0,
				-500,-500,-500,0
			]), (this.totalIndex + i) * 32);
			Vulkan.copyDataToBuffer(buffer, new Uint32Array([vertexCount, 0, baseVertex, baseInstance+i]), offset);
			renderPassEncoder.drawIndirect(buffer, offset);
			offset += elementSize;
		}

		this.totalIndex += instanceCount;
	}
/*
	getCommandBuffer(){
		const {device} = Vulkan;
		const commandEncoder = device.createCommandEncoder();
		const computePassEncoder = commandEncoder.beginComputePass();
		computePassEncoder.setPipeline(Vulkan.pipelineDict.pipelineCull);
		computePassEncoder.setBindGroup(0, this.bindGroup);
		computePassEncoder.dispatch(this.totalIndex);
		computePassEncoder.endPass();
		return commandEncoder.finish();
	}
*/
	prepareCull(camera){
		const {commandEncoder, transformUniformMgr:{transformUniformCache}} = Vulkan;
		const computePassEncoder = commandEncoder.beginComputePass();
		computePassEncoder.setPipeline(Vulkan.pipelineDict.pipelineCull);
		computePassEncoder.setBindGroup(1, transformUniformCache(0));
		computePassEncoder.setBindGroup(0, this.bindGroup);
		computePassEncoder.setBindGroup(2, camera._gpuAsset.cullBindGroup);
		computePassEncoder.setBindGroup(3, this.boundBindGroup);
		computePassEncoder.dispatchIndirect(this.dispatchBuffer, 0);
		computePassEncoder.endPass();
	}

	setDispatchValue(){
		Vulkan.copyDataToBuffer(this.dispatchBuffer, new Uint32Array([this.totalIndex, 1, 1]));
	}
}



module.exports = DirectBufferManager;
