'use strict';

const Vulkan = require('../Vulkan');
const BufferBindGroup = require('../helper/BufferBindGroup');

const pipelineDesc = {
	layout: ['cull', '2', '2', '2'],//direct buffer, world matrix, camera, bound
	compute: {module: 'compute_cull'}
};

class DirectBufferManager
{
	constructor(){
		this.totalIndex = 0;

		this.group = new BufferBindGroup([[GPUBufferUsage.INDIRECT | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, 0x10000]], buffer => [['cull', {buffer}]]);
		this.boundGroup = new BufferBindGroup([[GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, 0x4000]], buffer => [['2', {buffer}]]);
		this.dispatchBuffer = Vulkan.createBuffer(GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_DST, 12);

		Vulkan.bindComputePipeline(this, pipelineDesc);
	}

	onFrameBegin(){
		this.totalIndex = 0;
	}

	draw(subMesh, vertexCount, instanceCount, baseVertex, baseInstance){
		const {renderPassEncoder, currentCamera} = Vulkan;

		if(!currentCamera.cullEnabled){
			renderPassEncoder.draw(vertexCount, instanceCount, baseVertex, baseInstance);
			return;
		}

		const {group, boundGroup} = this;
		const elementSize = 16;
		let offset = this.totalIndex * elementSize;

		for(let i=0; i<instanceCount; ++i){
			Vulkan.copyDataToBuffer(boundGroup.getBuffer(), new Float32Array([
				500,500,500,0,
				-500,-500,-500,0
			]), (this.totalIndex + i) * 32);
			Vulkan.copyDataToBuffer(group.getBuffer(), new Uint32Array([vertexCount, 0, baseVertex, baseInstance+i]), offset);
			renderPassEncoder.drawIndirect(group.getBuffer(), offset);
			offset += elementSize;
		}

		this.totalIndex += instanceCount;
	}
/*
	getCommandBuffer(){
		const {device} = Vulkan;
		const commandEncoder = device.createCommandEncoder();
		const computePassEncoder = commandEncoder.beginComputePass();
		computePassEncoder.setPipeline(Vulkan.pipelineDict.pipelineCull);
		computePassEncoder.setBindGroup(0, this.bindGroup);
		computePassEncoder.dispatch(this.totalIndex);
		computePassEncoder.endPass();
		return commandEncoder.finish();
	}
*/
	prepareCull(camera){
		const {commandEncoder, transformUniformMgr:{transformUniformCache}} = Vulkan;
		const computePassEncoder = commandEncoder.beginComputePass();
		computePassEncoder.setPipeline(this.pipeline);
		computePassEncoder.setBindGroup(1, transformUniformCache(0));
		computePassEncoder.setBindGroup(0, this.group.getBindGroup());
		computePassEncoder.setBindGroup(2, camera._gpuAsset.cullBindGroup);
		computePassEncoder.setBindGroup(3, this.boundGroup.getBindGroup());
		computePassEncoder.dispatchIndirect(this.dispatchBuffer, 0);
		computePassEncoder.endPass();
	}

	setDispatchValue(){
		Vulkan.copyDataToBuffer(this.dispatchBuffer, new Uint32Array([this.totalIndex, 1, 1]));
	}
}



module.exports = DirectBufferManager;
