'use strict';

const Vulkan = require('../Vulkan');
const VertexBufferSlotCache = require('../helper/VertexBufferSlotCache');

class VertexBufferManager
{
	constructor(){
		this.slot = new VertexBufferSlotCache(100, vertexData.byteLength, valueFn);
	}

	onFrameBegin(){
		this.slot.clear();
	}

	draw(instanceList){
		const {renderPassEncoder} = Vulkan;
		const {slot} = this;
		for(const [batchIndex, bufferOffset, instanceCount] of slot.add(instanceList)){
			//slot.active(0, batchIndex, 0);
			//renderPassEncoder.draw(triangleCount, instanceCount, 0, bufferOffset);
			slot.active(0, batchIndex, bufferOffset);
			renderPassEncoder.draw(54, instanceCount);//total 9 rect, exery rect has 2 triangle, every triangle has 3 index.
		}
	}
}

function valueFn(instance){
	const {worldTransform, texture, width, height, fgColor} = instance;
	worldTransform.copyToArray(tempList, 0, 3);
	vertexData.set(tempList);
	if(texture){
		vertexData.set(texture.xyuvMul, 6);
		vertexData.set(texture.xyuvAdd, 10);
		vertexData.set(texture.scale9grid, 18);
		vertexData[14] = width;
		vertexData[15] = texture.width;
		vertexData[16] = height;
		vertexData[17] = texture.height;
	}else{
		vertexData.set(allOne, 6);
		vertexData.set(allZero, 10);
		vertexData.set(allZero, 18);
		vertexData[14] = width;
		vertexData[15] = width;
		vertexData[16] = height;
		vertexData[17] = height;
	}
	return vertexData;
}

const tempList = new Array(6);
const allZero = new Float32Array(4);
const allOne = new Float32Array(4).fill(1);
const vertexData = new Float32Array(22);

module.exports = VertexBufferManager;
