'use strict';

const Vulkan = require('../Vulkan');
const Slot = require('../helper/Slot');

class VertexBufferManager
{
	constructor(){
		this.slot = new Slot(100);
		this.vertexBufferListCache = createVertexBufferListCache(instanceFloatCount * 100);
	}

	onFrameBegin(){
		this.slot.clear();
	}

	draw(instanceList){
		const {renderPassEncoder} = Vulkan;
		const {vertexBufferListCache} = this;
		let instanceOffset = 0;
		for(const [bufferIndex, bufferOffset, instanceCount] of this.slot.add(instanceList.length)){
			for(let i=0; i<instanceCount; ++i){
				const {worldTransform, texture, width, height, fgColor} = instanceList[instanceOffset++];
				worldTransform.copyToArray(tempList, 0, 3);
				vertexData.set(tempList);
				if(texture){
					vertexData.set(texture.xyuvMul, 6);
					vertexData.set(texture.xyuvAdd, 10);
					vertexData.set(texture.scale9grid, 18);
					vertexData[14] = width;
					vertexData[15] = texture.width;
					vertexData[16] = height;
					vertexData[17] = texture.height;
				}else{
					vertexData.set(allOne, 6);
					vertexData.set(allZero, 10);
					vertexData.set(allZero, 18);
					vertexData[14] = width;
					vertexData[15] = width;
					vertexData[16] = height;
					vertexData[17] = height;
				}
				vertexBufferListCache(bufferIndex, instanceByteSize * (i + bufferOffset), vertexData);
			}
			renderPassEncoder.setVertexBuffer(0, vertexBufferListCache(bufferIndex));
			renderPassEncoder.draw(triangleCount, instanceCount, 0, bufferOffset);
		}
	}
}

function createVertexBufferListCache(size=0x10000){
	const bufferList = [];
	return function(batchIndex, offset, value){
		const {device} = Vulkan;
		let buffer = bufferList[batchIndex];
		if(buffer == null){
			buffer = bufferList[batchIndex] = device.createBuffer({
				size,
				usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
			});
		}
		if(!value)return buffer;
		Vulkan.copyDataToBuffer(buffer, value, offset);
	}
}


const tempList = new Array(6);
const allZero = new Float32Array(4);
const allOne = new Float32Array(4).fill(1);

const instanceFloatCount = 22;
const instanceByteSize = instanceFloatCount << 2;

const vertexCountX = 4;
const vertexCountY = 4;
const triangleCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.

const vertexData = new Float32Array(instanceFloatCount);

module.exports = VertexBufferManager;
