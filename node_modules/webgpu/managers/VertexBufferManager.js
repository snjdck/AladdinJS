'use strict';

const Vulkan = require('../Vulkan');

class VertexBufferManager
{
	constructor(){
		this.totalIndex = 0;
		this.maxCountPerBatch = 100;
		this.vertexBufferListCache = createVertexBufferListCache(instanceFloatCount * 100);
	}

	reset(){
		this.totalIndex = 0;
	}

	draw(instanceList){
		const {renderPassEncoder} = Vulkan;
		const {vertexBufferListCache} = this;
		let instanceOffset = 0;
		for(const [bufferIndex, bufferOffset, instanceCount] of this.add(instanceList.length)){
			for(let i=0; i<instanceCount; ++i){
				const {worldTransform, texture, width, height, fgColor} = instanceList[instanceOffset++];
				worldTransform.copyToArray(tempList, 0, 3);
				vertexData.set(tempList);
				if(texture){
					vertexData.set(texture.xyuvMul, 6);
					vertexData.set(texture.xyuvAdd, 10);
					vertexData.set(texture.scale9grid, 18);
					vertexData[14] = width;
					vertexData[15] = texture.width;
					vertexData[16] = height;
					vertexData[17] = texture.height;
				}else{
					vertexData.set(allOne, 6);
					vertexData.set(allZero, 10);
					vertexData.set(allZero, 18);
					vertexData[14] = width;
					vertexData[15] = width;
					vertexData[16] = height;
					vertexData[17] = height;
				}
				vertexBufferListCache(bufferIndex, instanceByteSize * (i + bufferOffset), vertexData);
			}
			renderPassEncoder.setVertexBuffer(0, vertexBufferListCache(bufferIndex));
			//renderPassEncoder.drawIndexed(triangleCount, instanceCount, 0, 0, bufferOffset);
			renderPassEncoder.draw(triangleCount, instanceCount, 0, bufferOffset);
		}
	}

	*add(totalInstanceCount){
		if(totalInstanceCount == 0)return;
		const {maxCountPerBatch, totalIndex} = this;
		const willRemain = totalInstanceCount % maxCountPerBatch;
		const selfRemain = totalIndex % maxCountPerBatch;
		const flag = selfRemain == 0 || willRemain == 0 || willRemain > maxCountPerBatch - selfRemain;
		let baseIndex;
		if(flag){
			baseIndex = Math.ceil(totalIndex / maxCountPerBatch);
		}else{
			baseIndex = Math.floor(totalIndex / maxCountPerBatch);
			yield [baseIndex++, selfRemain, willRemain];
			if(totalInstanceCount == willRemain){
				this.totalIndex += willRemain;
				return;
			}
			totalInstanceCount -= willRemain;
		}
		this.totalIndex = baseIndex * maxCountPerBatch + totalInstanceCount;
		let instanceIndex = 0;
		while(instanceIndex < totalInstanceCount){
			const instanceCount = Math.min(maxCountPerBatch, totalInstanceCount - instanceIndex);
			yield [baseIndex++, 0, instanceCount];
			instanceIndex += instanceCount;
		}
	}
}

function createVertexBufferListCache(size=0x10000){
	const bufferList = [];
	return function(batchIndex, offset, value){
		const {device} = Vulkan;
		let buffer = bufferList[batchIndex];
		if(buffer == null){
			buffer = bufferList[batchIndex] = device.createBuffer({
				size,
				usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
			});
		}
		if(!value)return buffer;
		Vulkan.copyDataToBuffer(buffer, value, offset);
	}
}


const tempList = new Array(6);
const allZero = new Float32Array(4);
const allOne = new Float32Array(4).fill(1);

const instanceFloatCount = 22;
const instanceByteSize = instanceFloatCount << 2;

const vertexCountX = 4;
const vertexCountY = 4;
const triangleCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.

const vertexData = new Float32Array(instanceFloatCount);

VertexBufferManager.instanceFloatCount = instanceFloatCount;

module.exports = VertexBufferManager;
