'use strict';

require('bluetooth/Buffer');
const Texture2D = require('./2d/Texture2D');
const {RADIAN} = require('./math');
const Vector3D = require('./math/Vector3D');
const Quaternion = require('./math/Quaternion');
const DisplayObject2D = require('./DisplayObject2D');
const terrain = require('./terrain');
const world1objects = require('mu/world1objects');
const readMapObj = require('mu/readMapObj');
const mapTileList = require('mu/mapTileList');
const KeyCode = require('./const/KeyCode');
const {playMP3} = require('webonly/audio');
const {supportDrag} = require('webonly');
const {createTextureArray, requestDevice} = require('webonly/utils_gpu');
const {fetchArrayBuffer, loadImage} = require('webonly/utils');
const Pipeline = require('./materials/Pipeline');
const {Bitmap, Bitmap3D} = require('./DisplayObject2DFactory');
const View3D = require('./view3d');
const Lens = require('./cameras/Lens');
const Camera3D = require('./cameras/Camera3D');
const Camera2D = require('./cameras/Camera2D');
require('./lib');
const {parse} = require('mu/bmd');
const parse_gltf = require('fileformats/gltf');
const Vulkan = require('./Vulkan');
const {createCube} = require('./helper/geom');
const MeshEntity = require('./3d/MeshEntity');
const DirectionLight3D = require('./lights/DirectionLight3D')
const PointLight3D = require('./lights/PointLight3D')
const TextureMaterial = require('./materials/TextureMaterial')
const TextureMaterialDeferred = require('./materials/TextureMaterialDeferred')
const AlphaTextureMaterial = require('./materials/AlphaTextureMaterial')
const GlowTextureMaterial = require('./materials/GlowTextureMaterial')
const BillboardMaterial = require('./materials/BillboardMaterial')
const ColorMaterial = require('./materials/ColorMaterial')
const BoundMaterial = require('./materials/BoundMaterial')
const TerrainMaterial = require('./materials/TerrainMaterial')
const MirrorMaterial = require('./materials/MirrorMaterial')
const {createPlane} = require('./helper/geom')
const {CommandEncoder} = require('./helper/CommandEncoder');
const BlurFilter = require('./materials/BlurFilter');

const AABB = require('./bounds/AABB');
const regHotKey = require('webonly/hotkey');
const parseItemInfo = require('mu/parseItemInfo');
const createStateMachine = require('mu/playerAniState');
const {mainLoop} = require('./helper/ResourcePool');

const {showDetailFactory, average} = require('utils/stats');
const showDetail = showDetailFactory(average(
	v => document.getElementById('text_fps').textContent = `fps: ${Math.round(v)}`
));

const {runAction, ActionBuilder, Sequence, Spawn, Delay, Repeat, CallFunc, nearestRotation} = require('game/engine/action/Action');

const RotateEntityZ = function(){
	let temp = new Quaternion();
	return function*(target){
		for(;;){
			target.rotation = target.rotation.prepend(temp.fromEulerAngles(0, 0, 0.5 * RADIAN));
			yield;
		}
	}
}();

const RotateEntityY = function(){
	let temp = new Quaternion();
	return function*(target){
		for(;;){
			target.rotation = target.rotation.prepend(temp.fromEulerAngles(0, 5 * RADIAN, 0));
			yield;
		}
	}
}();

async function init(){
	playMP3('./assets/Music/MuTheme.mp3');

	const canvas = document.getElementById('canvas');

	void function(){
		const canvas = document.createElement('canvas');
		canvas.style = 'position:absolute; left:0; top:0; pointer-events:none; background-color: rgba(0, 0, 0, 0);'
		canvas.width = 1000;
		canvas.height = 600;
		document.body.appendChild(canvas);
		Vulkan.canvas2d = canvas;
	}()
	
	if(!navigator.gpu)return;
	const device = await requestDevice();
	Vulkan.init(device, canvas);

	const swapChain = requestSwapChain(canvas, device);

	for(let commandEncoder of CommandEncoder(Vulkan.device)){
		for(let renderPassEncoder of commandEncoder.beginRenderPass('[0,0,0,0]+store', swapChain.getCurrentTexture().createView())){
			drawPath.call({renderPassEncoder, viewport:{width:1200, height:900}},[
				...createFillRectPath(700,500,100,100, [1,1,0,1]),
				...createStrokeRectPath(700,500,100,100, [1,0,0,0.3]),
				...createFillArcPath(0,0,800,0,90),
			]);
		}
	}

	mainLoop(timeElapsed => {
		showDetail(1000 / timeElapsed);
	});
}
function requestSwapChain(canvas, device){
	const swapChain = canvas.getContext('webgpu');
	swapChain.configure({
		device,
		format: 'bgra8unorm',
		usage: GPUTextureUsage.RENDER_ATTACHMENT,
		alphaMode: 'opaque',//premultiplied
		colorSpace: 'srgb',//display-p3
	});
	return swapChain;
}
window.addEventListener('DOMContentLoaded', init);

function createFillRectPath(x, y, width, height, color){
	return insertColor([
		x      , y       ,//0
		x+width, y       ,//1
		x      , y+height,//2
		x      , y+height,//2
		x+width, y       ,//1
		x+width, y+height,//3
	], color);
}

function createStrokeRectPath(x, y, width, height, color, lineWidth=4){
	const half = lineWidth * 0.5;
	return insertColor([
		//top
		x-half      , y-half       ,//0
		x+half      , y+half       ,//1
		x+half+width, y-half       ,//2
		x+half+width, y-half       ,//2
		x+half      , y+half       ,//1
		x-half+width, y+half       ,//3
		//bottom
		x+half      , y-half+height,//0
		x-half      , y+half+height,//1
		x-half+width, y-half+height,//2
		x-half+width, y-half+height,//2
		x-half      , y+half+height,//1
		x+half+width, y+half+height,//3
		//left
		x+half      , y+half       ,
		x-half      , y-half       ,
		x+half      , y-half+height,
		x+half      , y-half+height,
		x-half      , y-half       ,
		x-half      , y+half+height,
		//right
		x+half+width, y-half       ,
		x-half+width, y+half       ,
		x+half+width, y+half+height,
		x+half+width, y+half+height,
		x-half+width, y+half       ,
		x-half+width, y-half+height,
	], color);
}

function createFillArcPath(x, y, radius, startAngle=0, endAngle=360, counterclockwise=false){
	let angle = 0;
	let step = Math.PI / 180;
	let result = [];
	let color = [0,1,0,1]
	for(let i=startAngle; i<endAngle; ++i){
		result.push(
			x, y,
			x+radius*Math.cos(i*step),y+radius*Math.sin(i*step),
			x+radius*Math.cos((i+1)*step),y+radius*Math.sin((i+1)*step),
		);
	}
	return insertColor(result, color);
}

function insertColor(list, color){
	const result = [];
	for(let i=0, n=list.length; i<n; i+=2){
		result.push(list[i], list[i+1], ...color);
	}
	return result;
}

const drawPath = function(){
	const vertexCode = `
		struct Output {
			@builtin(position) position: vec4<f32>,
			@location(0) color: vec4<f32>,
		}
		@vertex Output {
			return Output(vec4(fma(position, viewport.xy, viewport.zw), 0, 1), color);
		}
	`;
	const fragmentCode = `@fragment{return color;}`;
	const pipeline = new Pipeline({
		groups:[[{name:'viewport', type:'vec4<f32>', buffer:{}}]],
		vertex: {code:vertexCode, buffers:[{
			name: 'pointList',
			stepMode: 'vertex',
			attributes: [
				{format: 'float32x2', name:'position'},
				{format: 'float32x4', name:'color'},
			]}
		]},
		fragment: {code:fragmentCode, targets:[{blend: 'src-alpha add one-minus-src-alpha'}]}
	});
	const viewportBuffer = new Float32Array(4);
	return function(pointList){
		const {renderPassEncoder, viewport} = this;
		viewportBuffer.set([2 / viewport.width, -2 / viewport.height, -1, 1]);
		pipeline.setPipeline(renderPassEncoder);
		pipeline.setResources(renderPassEncoder, {viewport:{buffer:viewportBuffer}, pointList:new Float32Array(pointList)});
		renderPassEncoder.draw(pointList.length / 6);
	};
}();

