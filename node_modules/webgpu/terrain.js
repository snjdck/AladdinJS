'use strict';

const Vulkan = require('./Vulkan');
const {decodeBmp} = require('fileformats/images');
const {loadData} = require('utils/loader');
const {createMeshIndices} = require('utils/geometry');

module.exports = async function(){
	const {data:lightData} = await Vulkan.getImageJpegData('./assets/World1/TerrainLight.jpg');
	const {data:heightData} = decodeBmp(await loadData('./assets/World1/TerrainHeight.bmp', 'arraybuffer'));
	const mapData = new Uint8Array(await loadData('./assets/World1/Terrain.map', 'arraybuffer'));

	const vertexData = new Uint8Array(vertexDataLength);
	for(let j=0; j<vertexCountY; ++j){
		for(let i=0; i<vertexCountX; ++i){
			let offset = j * vertexCountX + i;
			const vertexOffset = offset * bytePerVertex;
			vertexData[vertexOffset + 5] = heightData[offset];
			for(let k=0; k<4; ++k){
				vertexData[vertexOffset + 8 + k] = lightData[offset * 4 + k];
			}
			offset = (vertexCountY - j - 1) * vertexCountX + i;
			vertexData[vertexOffset] = mapData[offset];
			vertexData[vertexOffset + 1] = mapData[offset + 65536];
			vertexData[vertexOffset + 4] = mapData[offset + 65536 * 2];
		}
	}

	const indexData = new Uint16Array(createMeshIndices(vertexCountX, vertexCountY));

	const mesh = {
		name: 'terrain',
		subMeshList: [
			{vertexCount, vertexOffset:0}
		],
		boneList: [],
		boneCount: 0,
		vertexData,
		vertexCount,
		indexData,
		indexCount,
	};
	return Vulkan.addMeshBufferGetter(mesh);
}

const bytePerVertex = 12;
const vertexCountX = 256;
const vertexCountY = 256;
const vertexCount = vertexCountX * vertexCountY;
const indexCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.
const vertexDataLength = vertexCount * bytePerVertex;
