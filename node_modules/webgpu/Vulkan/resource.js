
const {TexturePool, BufferPool, LRUCache} = require('../helper/ResourcePool');
const {createBufferWith, createTexture, createDepthTexture} = require('webonly/utils_gpu');

const fetchBuffer = function(){
	const map = new Map();
	return (size, usage, device) => {
		if(!map.has(usage)){
			map.set(usage, BufferPool(size => device.createBuffer({usage, size})));
		}
		return map.get(usage)(size);
	}
}();

const bufferCache = LRUCache((data, usage, device) => createBufferWith(device, usage, data));

const colorTextureCache = LRUCache((color, device) => {
	const texture = createTexture(device, 1, 1, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST);//bgra
	device.queue.writeTexture(
		{texture, origin:[0,0,0], mipLevel:0, aspect:'all'},
		new Uint8Array([color[2] * 255, color[1] * 255, color[0] * 255, color[3] * 255]),//& 0xFF auto
		{offset:0, bytesPerRow:undefined, rowsPerImage:undefined},
		[1, 1, 1]
	);
	return {
		texture,
		view: texture.createView(),
		destroy(){
			texture.destroy();
			console.log('colorTextureCache destroy');
		}
	};
});

const fetchTextures = TexturePool(({width, height}, device) => {
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST
	const size = [width, height];
	const colorTexture = device.createTexture({format: 'bgra8unorm', size, usage});
	//const positionTexture = device.createTexture({format: 'rgba32float', size, usage});
	const normalTexture = device.createTexture({format: 'rgba16float', size, usage});
	const emissiveTexture = device.createTexture({format: 'rgba16float', size, usage/*, mipLevelCount:2*/});
	const depthTexture = device.createTexture({format: 'depth24plus-stencil8', size, usage});
	const lightTexture = device.createTexture({format: 'bgra8unorm', size, usage});
	return {
		width, height,
		colorTexture, normalTexture, depthTexture, lightTexture,emissiveTexture,
		colorView: colorTexture.createView(),
		//emissiveView0: emissiveTexture.createView({mipLevelCount:1}),
		emissiveView: emissiveTexture.createView(),
		//positionView: positionTexture.createView(),
		normalView: normalTexture.createView(),
		depthStencilView:depthTexture.createView(),
		depthView:depthTexture.createView({aspect:'depth-only'}),
		lightView: lightTexture.createView(),
		destroy(){
			console.log('destroy textures',width, height);
			colorTexture.destroy();
			emissiveTexture.destroy();
			normalTexture.destroy();
			depthTexture.destroy();
			lightTexture.destroy();
		}
	};
}, false);

const fetchBloomTexture = TexturePool(({width, height}, device) => {
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST;
	const size = [width>>1, height>>1];
	const mipLevelCount = Math.floor(Math.log2(Math.max(...size))) + 1;

	const texture0 = device.createTexture({format: 'rgba16float', size, usage, mipLevelCount});
	const texture1 = device.createTexture({format: 'rgba16float', size, usage, mipLevelCount});

	return {
		width, height,
		texture0,
		texture1,
		destroy(){
			texture0.destroy();
			texture1.destroy();
		}
	};
}, false);

const fetchCubeDepth = TexturePool(({width, height}, device) => {
	console.log('new view3d',width, height);
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
	const size = [width, height];

	//const colorTexture = Vulkan.device.createTexture({format: 'r32float', size, usage});
	const depthTexture = device.createTexture({
		size: [width, height, 6],
		format: 'depth32float',
		usage
	});
	return {
		width, height,
		//colorTexture,
		//colorView:colorTexture.createView(),
		depthStencilView:Array.from({length:6}, (_, i) => depthTexture.createView({dimension:'2d', baseArrayLayer:i})),
		depthView:depthTexture.createView({aspect:'depth-only',dimension:'cube'}),
		destroy(){
			console.log('destroy view3d',width, height);
			//colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchAnimationTexture = LRUCache((mesh, device) => {
	const width = Math.max(...mesh.animationList.map(v => v.keyFrameTimes.length)) * 2;
	const height = mesh.boneList.at(-1).id + 1;
	const depthOrArrayLayers = mesh.animationList.length;
	const size = [width, height, depthOrArrayLayers];
	const data = new Float32Array(width * height * depthOrArrayLayers * 4);
	for(let k=0; k<depthOrArrayLayers; ++k){
		const animation = mesh.animationList[k];
		for(let j=0; j<height; ++j){
			const matrixList = animation.trackDict[j];
			if(!matrixList)continue;
			const parentBoneID = mesh.boneList.find(v => v.id == j).parent?.id ?? -1;
			for(let i=0; i<width; i+=2){
				const matrix = matrixList[i >> 1];
				if(!matrix)continue;
				const {rotation, translation} = matrix;
				const offset = (width * (height * k + j) + i) * 4;
				data[offset  ] = rotation.x;
				data[offset+1] = rotation.y;
				data[offset+2] = rotation.z;
				data[offset+3] = rotation.w;
				data[offset+4] = translation.x;
				data[offset+5] = translation.y;
				data[offset+6] = translation.z;
				data[offset+7] = parentBoneID;
			}
		}
	}
	const texture = device.createTexture({size, format: 'rgba32float', usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST});
	device.queue.writeTexture({texture}, data, {bytesPerRow:width*16, rowsPerImage:height}, size);
	return {
		textureView: texture.createView({dimension:'2d-array'}),
		destroy(){
			texture.destroy();
		}
	};
});

const fetchViewForDepth = TexturePool(({width, height}, device) => {
	console.log('new view3d',width, height);
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
	const size = [width, height, 1];

	//const colorTexture = Vulkan.device.createTexture({format: 'r32float', size, usage});
	const depthTexture = device.createTexture({
		size,
		format: 'depth32float',
		usage
	});
	return {
		width, height,
		//colorTexture,
		//colorView:colorTexture.createView(),
		depthStencilView:depthTexture.createView(),
		depthView:depthTexture.createView({aspect:'depth-only'}),
		destroy(){
			console.log('destroy view3d',width, height);
			//colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchPickTexture = TexturePool(({width, height}, device) => {
	const size = [width, height, 1];
	const texture = device.createTexture({
		size,
		format: 'r32uint',
		usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT
	});
	const depthTexture = device.createTexture({
		size,
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.RENDER_ATTACHMENT
	});
	return {
		width, height,
		texture,
		depthStencilView:depthTexture.createView(),
		view:texture.createView(),
		destroy(){
			texture.destroy();
			depthTexture.destroy();
		}
	};
}, false);

const fetchView3D = TexturePool(({width, height}, device) => {
	console.log('new view3d',width, height);
	let colorTexture = createTexture(device, width, height, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT);
	let depthTexture = createDepthTexture(device, width, height);
	return {
		width, height,
		colorView:colorTexture.createView(),
		depthView:depthTexture.createView(),
		destroy(){
			console.log('destroy view3d',width, height);
			colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchView2D = TexturePool(({width, height}, device) => {
	console.log('new filter',width, height);
	let texture = createTexture(device, width, height, 2, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST);
	return {
		width, height,
		view0:texture.createView({dimension:'2d', baseArrayLayer:0, arrayLayerCount:1}),
		view1:texture.createView({dimension:'2d', baseArrayLayer:1, arrayLayerCount:1}),
		destroy(){
			texture.destroy();
			console.log('delete filter',width, height)
		},
		copyTexture(commandEncoder, sx, sy, width, height){
			commandEncoder.copyTextureToTexture(
				{texture, origin: [sx, sy, 0]},
				{texture, origin: [0, 0, 1]},
				[width, height, 1]
			);
		}
	};
});

exports.fetchBuffer = fetchBuffer;
exports.bufferCache = bufferCache;
exports.fetchView3D = fetchView3D;
exports.fetchView2D = fetchView2D;
exports.fetchTextures = fetchTextures;
exports.colorTextureCache = colorTextureCache;
exports.fetchViewForDepth = fetchViewForDepth;
exports.fetchCubeDepth = fetchCubeDepth;
exports.fetchAnimationTexture = fetchAnimationTexture;
exports.fetchPickTexture = fetchPickTexture;
exports.fetchBloomTexture = fetchBloomTexture;
