
const {TexturePool} = require('../helper/ResourcePool');
const {createTexture} = require('webonly/utils_gpu');


const fetchTextures = TexturePool(({width, height}, device) => {
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST
	const size = [width, height];
	const colorTexture = device.createTexture({format: 'bgra8unorm', size, usage});
	//const positionTexture = device.createTexture({format: 'rgba32float', size, usage});
	const normalTexture = device.createTexture({format: 'rgba16float', size, usage});
	const emissiveTexture = device.createTexture({format: 'rgba16float', size, usage/*, mipLevelCount:2*/});
	const depthTexture = device.createTexture({format: 'depth24plus-stencil8', size, usage});
	const lightTexture = device.createTexture({format: 'bgra8unorm', size, usage});
	return {
		width, height,
		colorTexture, normalTexture, depthTexture, lightTexture,emissiveTexture,
		colorView: colorTexture.createView(),
		//emissiveView0: emissiveTexture.createView({mipLevelCount:1}),
		emissiveView: emissiveTexture.createView(),
		//positionView: positionTexture.createView(),
		normalView: normalTexture.createView(),
		depthStencilView:depthTexture.createView(),
		depthView:depthTexture.createView({aspect:'depth-only'}),
		lightView: lightTexture.createView(),
		destroy(){
			console.log('destroy textures',width, height);
			colorTexture.destroy();
			emissiveTexture.destroy();
			normalTexture.destroy();
			depthTexture.destroy();
			lightTexture.destroy();
		}
	};
}, false);

const fetchBloomTexture = TexturePool(({width, height}, device) => {
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST;
	const size = [width>>1, height>>1];
	const mipLevelCount = Math.floor(Math.log2(Math.max(...size))) + 1;

	const texture0 = device.createTexture({format: 'rgba16float', size, usage, mipLevelCount});
	const texture1 = device.createTexture({format: 'rgba16float', size, usage, mipLevelCount});

	return {
		width, height,
		texture0,
		texture1,
		destroy(){
			texture0.destroy();
			texture1.destroy();
		}
	};
}, false);

const fetchCubeDepth = TexturePool(({width, height}, device) => {
	console.log('new view3d',width, height);
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
	const size = [width, height];

	//const colorTexture = Vulkan.device.createTexture({format: 'r32float', size, usage});
	const depthTexture = device.createTexture({
		size: [width, height, 6],
		format: 'depth32float',
		usage
	});
	return {
		width, height,
		//colorTexture,
		//colorView:colorTexture.createView(),
		depthStencilView:Array.from({length:6}, (_, i) => depthTexture.createView({dimension:'2d', baseArrayLayer:i})),
		depthView:depthTexture.createView({aspect:'depth-only',dimension:'cube'}),
		destroy(){
			console.log('destroy view3d',width, height);
			//colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchViewForDepth = TexturePool(({width, height}, device) => {
	console.log('new view3d',width, height);
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
	const size = [width, height, 1];

	//const colorTexture = Vulkan.device.createTexture({format: 'r32float', size, usage});
	const depthTexture = device.createTexture({
		size,
		format: 'depth32float',
		usage
	});
	return {
		width, height,
		//colorTexture,
		//colorView:colorTexture.createView(),
		depthStencilView:depthTexture.createView(),
		depthView:depthTexture.createView({aspect:'depth-only'}),
		destroy(){
			console.log('destroy view3d',width, height);
			//colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchPickTexture = TexturePool(({width, height}, device) => {
	const size = [width, height, 1];
	const texture = device.createTexture({
		size,
		format: 'r32uint',
		usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT
	});
	const depthTexture = device.createTexture({
		size,
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.RENDER_ATTACHMENT
	});
	return {
		width, height,
		texture,
		depthStencilView:depthTexture.createView(),
		view:texture.createView(),
		destroy(){
			texture.destroy();
			depthTexture.destroy();
		}
	};
}, false);

const fetchView3D = TexturePool(({width, height}, device) => {
	console.log('new view3d',width, height);
	let colorTexture = createTexture(device, width, height, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT);
	let depthTexture = device.createTexture({
		size: [width, height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.RENDER_ATTACHMENT
	});
	return {
		width, height,
		colorView:colorTexture.createView(),
		depthView:depthTexture.createView(),
		destroy(){
			console.log('destroy view3d',width, height);
			colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchView2D = TexturePool(({width, height}, device) => {
	console.log('new filter',width, height);
	let texture = createTexture(device, width, height, 2, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST);
	return {
		width, height,
		view0:texture.createView({dimension:'2d', baseArrayLayer:0, arrayLayerCount:1}),
		view1:texture.createView({dimension:'2d', baseArrayLayer:1, arrayLayerCount:1}),
		destroy(){
			texture.destroy();
			console.log('delete filter',width, height)
		},
		copyTexture(commandEncoder, sx, sy, width, height){
			commandEncoder.copyTextureToTexture(
				{texture, origin: [sx, sy, 0]},
				{texture, origin: [0, 0, 1]},
				[width, height, 1]
			);
		}
	};
});

exports.fetchView3D = fetchView3D;
exports.fetchView2D = fetchView2D;
exports.fetchTextures = fetchTextures;
exports.fetchViewForDepth = fetchViewForDepth;
exports.fetchCubeDepth = fetchCubeDepth;
exports.fetchPickTexture = fetchPickTexture;
exports.fetchBloomTexture = fetchBloomTexture;
