const Vulkan = require('./index');
const {TexturePool, BufferPool, LRUCache} = require('../helper/ResourcePool');
const {createBufferWith, createTexture, createDepthTexture} = require('webonly/utils_gpu');

const fetchBuffer = function(){
	const map = new Map();
	return (size, usage) => {
		if(!map.has(usage)){
			map.set(usage, BufferPool(size => Vulkan.device.createBuffer({usage, size})));
		}
		return map.get(usage)(size);
	}
}();

const bufferCache = LRUCache((data, usage) => createBufferWith(Vulkan.device, usage, data));

const colorTextureCache = LRUCache(color => {
	const texture = createTexture(Vulkan.device, 1, 1, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST);//bgra
	Vulkan.device.queue.writeTexture(
		{texture, origin:[0,0,0], mipLevel:0, aspect:'all'},
		new Uint8Array([color[2] * 255, color[1] * 255, color[0] * 255, color[3] * 255]),//& 0xFF auto
		{offset:0, bytesPerRow:undefined, rowsPerImage:undefined},
		[1, 1, 1]
	);
	return {
		texture,
		view: texture.createView(),
		destroy(){
			texture.destroy();
			console.log('colorTextureCache destroy');
		}
	};
});

const fetchTextures = TexturePool((width, height) => {
	const {device} = Vulkan;
	
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST
	const size = [width, height];

	const colorTexture = device.createTexture({format: 'bgra8unorm', size, usage});
	//const positionTexture = device.createTexture({format: 'rgba32float', size, usage});
	const normalTexture = device.createTexture({format: 'rg32float', size, usage});
	const depthTexture = device.createTexture({format: 'depth24plus-stencil8', size, usage});
	const lightTexture = device.createTexture({format: 'bgra8unorm', size, usage});
	return {
		colorTexture, normalTexture, depthTexture, lightTexture,
		colorView: colorTexture.createView(),
		//positionView: positionTexture.createView(),
		normalView: normalTexture.createView(),
		depthStencilView:depthTexture.createView(),
		depthView:depthTexture.createView({aspect:'depth-only'}), 
		lightView: lightTexture.createView(),
		destroy(){
			console.log('destroy textures',width, height);
			colorTexture.destroy();
			//positionTexture.destroy();
			normalTexture.destroy();
			depthTexture.destroy();
			lightTexture.destroy();
		}
	};
});

const fetchCubeDepth = TexturePool((width, height) => {
	console.log('new view3d',width, height);
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
	const size = [width, height];

	//const colorTexture = Vulkan.device.createTexture({format: 'r32float', size, usage});
	const depthTexture = Vulkan.device.createTexture({
		size: [width, height, 6],
		format: 'depth32float',
		usage
	});
	return {
		//colorTexture,
		//colorView:colorTexture.createView(),
		depthStencilView:Array.from({length:6}, (_, i) => depthTexture.createView({dimension:'2d', baseArrayLayer:i})),
		depthView:depthTexture.createView({aspect:'depth-only',dimension:'cube'}),
		destroy(){
			console.log('destroy view3d',width, height);
			//colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchViewForDepth = TexturePool((width, height) => {
	console.log('new view3d',width, height);
	const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
	const size = [width, height];

	//const colorTexture = Vulkan.device.createTexture({format: 'r32float', size, usage});
	const depthTexture = Vulkan.device.createTexture({
		size: [width, height, 1],
		format: 'depth32float',
		usage
	});
	return {
		//colorTexture,
		//colorView:colorTexture.createView(),
		depthStencilView:depthTexture.createView(),
		depthView:depthTexture.createView({aspect:'depth-only'}),
		destroy(){
			console.log('destroy view3d',width, height);
			//colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchView3D = TexturePool((width, height) => {
	console.log('new view3d',width, height);
	let colorTexture = createTexture(Vulkan.device, width, height, 1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT);
	let depthTexture = createDepthTexture(Vulkan.device, width, height);
	return {
		colorView:colorTexture.createView(),
		depthView:depthTexture.createView(),
		destroy(){
			console.log('destroy view3d',width, height);
			colorTexture.destroy();
			depthTexture.destroy();
		}
	};
});

const fetchView2D = TexturePool((width, height) => {
	console.log('new filter',width, height);
	let texture = createTexture(Vulkan.device, width, height, 2, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST);
	return {
		view0:texture.createView({dimension:'2d', baseArrayLayer:0, arrayLayerCount:1}),
		view1:texture.createView({dimension:'2d', baseArrayLayer:1, arrayLayerCount:1}),
		destroy(){
			texture.destroy();
			console.log('delete filter',width, height)
		},
		copyTexture(commandEncoder, sx, sy, width, height){
			commandEncoder.copyTextureToTexture(
				{texture, origin: [sx, sy, 0]},
				{texture, origin: [0, 0, 1]},
				[width, height, 1]
			);
		}
	};
});

exports.fetchBuffer = fetchBuffer;
exports.bufferCache = bufferCache;
exports.fetchView3D = fetchView3D;
exports.fetchView2D = fetchView2D;
exports.fetchTextures = fetchTextures;
exports.colorTextureCache = colorTextureCache;
exports.fetchViewForDepth = fetchViewForDepth;
exports.fetchCubeDepth = fetchCubeDepth;
