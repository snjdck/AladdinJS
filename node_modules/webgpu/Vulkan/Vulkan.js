'use strict';

const defineConstGetter = require('utils/object/defineConstGetter');
const {deferDo, everyCall} = require('webonly/deferDo');
const {createGetter, createListGetter} = require('utils/cache');

const Vulkan = module.exports = {
	//swapChainFormat: 'bgra8unorm',
	_managerFactoryDict: {},
	//_managerList: [],
	//events: new EventTarget(),
};

Vulkan.init = function(device, canvas){
	this.device = device;
	this.canvas = canvas;

	device.lost.then(info => console.log('device lost', info));

	
/*
	this.registerSampler('linear_mirror', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('linear_repeat', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('linear_clamp',  {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});
	this.registerSampler('nearest_mirror',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('nearest_repeat',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('nearest_clamp', {magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});
*/
	
	Object.entries(this._managerFactoryDict).forEach(([name, factory]) => this.registerManager(name, new factory()));
}
/*
Vulkan.sampler = {
	linear_repeat: {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'},
	linear_clamp:  {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'}
};
Vulkan.getSampler = createGetter(desc => Vulkan.device.createSampler(desc), calcSamplerSign);

void function(samplers){
	Vulkan.registerSampler = function(name, descriptor){
		defineConstGetter(samplers, name, () => Vulkan.device.createSampler(descriptor));
	}
	Vulkan.getSampler = name => samplers[name];
}({});
*/
void function(slots){
	Vulkan.registerMaterialSlot = function(name, slot){
		slots[name] = slot;
		slot.name = name;
	}
	Vulkan.bindMaterialSlots = function(target, bindGroupSlots){
		//defineConstGetter(target, 'slotList', () => Object.entries(bindGroupSlots).map(([name, bindIndex]) => slots[name].bind(target, bindIndex)));
	}
	Vulkan.resetMaterialSlots = function(){
		/*
		for(let k in slots){
			slots[k].reset();
		}
		*/
	}
}

Vulkan.registerManagerFactory = function(name, factory){
	this._managerFactoryDict[name] = factory;
}

Vulkan.registerManager = function(name, value){
	this[name] = value;
	//this._managerList.push(value);
}

/*
//Vulkan.loadData = fetchArrayBuffer;
//Vulkan.loadImage = loadImage;

Vulkan.createBuffer = bindFirstArg(createBuffer, () => Vulkan.device);
Vulkan.createBufferMapped = bindFirstArg(createBufferWith, () => Vulkan.device);
//Vulkan.createDepthTexture = bindFirstArg(createDepthTexture, () => Vulkan.device);
//Vulkan.setViewport = bindFirstArg(setViewport, () => Vulkan.renderPassEncoder);

Vulkan.now = () => performance.now();

Vulkan.requestDestroy = deferDo(everyCall('destroy'));
Vulkan.requestReset = deferDo(everyCall('reset'));

Vulkan.render = function(view3d){
	this.resetMaterialSlots();
	view3d.render();
}
*/