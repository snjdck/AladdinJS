'use strict';

const {delayNew} = require('utils/cache');

const Vulkan = module.exports = {
	swapChainFormat: 'bgra8unorm',
	_managerFactoryDict: {},
	_managerList: [],
	events: new EventTarget(),
};

Vulkan.init = function(device, canvas){
	this.device = device;
	this.canvas = canvas;

	this.registerSampler('linear_mirror', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('linear_repeat', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('linear_clamp',  {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});
	this.registerSampler('nearest_mirror',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('nearest_repeat',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('nearest_clamp', {magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});

	Object.entries(this._managerFactoryDict).forEach(([name, factory]) => this.registerManager(name, new factory()));
}

Vulkan.defineProperty = function(name, fn){
	Object.defineProperty(this, name, {
		configurable: false, enumerable: true,
		get: delayNew(fn)
	});
}

Vulkan.registerSampler = function(name, descriptor){
	this.defineProperty(`sampler_${name}`, () => this.device.createSampler(descriptor));
}

Vulkan.registerComputePipeline = function(name, descriptor){
	this.defineProperty(`pipeline_compute_${name}`, () => this.createComputePipeline(descriptor));
}

Vulkan.createComputePipeline = function(descriptor){
	const {layout, compute} = descriptor;
	return this.device.createComputePipeline({
		layout: this.createPipelineLayout(layout),
		computeStage: {module: this[`shader_${compute.module}`], entryPoint: compute.entryPoint || 'main'}
	});
}

Vulkan.registerRenderPipeline = function(name, descriptor){
	this.defineProperty(`pipeline_${name}`, () => this.createRenderPipeline(descriptor));
}

Vulkan.createRenderPipelineGetter = descriptor => delayNew(() => Vulkan.createRenderPipeline(descriptor));
Vulkan.bindRenderPipeline = (target, descriptor, name='pipeline') => Object.defineProperty(target, name, {get: Vulkan.createRenderPipelineGetter(descriptor)});

Vulkan.createRenderPipeline = function(descriptor){
	const {layout, vertex, fragment, ...rest} = descriptor;
	return this.device.createRenderPipeline({
		layout: this.createPipelineLayout(layout),
		/*
		vertex: {module: this[`shader_${vertex.module}`], entryPoint: vertex.entryPoint || 'main', buffers: vertex.buffers},
		fragment: {module: this[`shader_${fragment.module}`], entryPoint: fragment.entryPoint || 'main', targets: fragment.targets},
		...rest
		//*/
		vertexStage: {module: this[`shader_${vertex.module}`], entryPoint: vertex.entryPoint || 'main'},
		fragmentStage: {module: this[`shader_${fragment.module}`], entryPoint: fragment.entryPoint || 'main'},
		primitiveTopology: rest.primitive?.topology ?? 'triangle-list',
		vertexState: {vertexBuffers: vertex.buffers, indexFormat: rest.primitive?.stripIndexFormat},
		colorStates: fragment.targets.map(({format, blend:{color, alpha}}) => ({format, colorBlend:color, alphaBlend:alpha})),
		depthStencilState: rest.depthStencil,
		//rasterizationState: {frontFace: 'ccw', cullMode: 'none'},
	});
}

Vulkan.registerShaderModule = function(name, code){
	this.defineProperty(`shader_${name}`, () => this.device.createShaderModule({code}));
}

Vulkan.createPipelineLayout = function(bindGroupLayouts){
	bindGroupLayouts = bindGroupLayouts.map(name => this[`layout_${name}`]);
	return this.device.createPipelineLayout({bindGroupLayouts});
}

Vulkan.registerBindGroupLayout = function(name, entryList){
	this.defineProperty(`layout_${name}`, () => this.createBindGroupLayout(entryList));
}

Vulkan.createBindGroupLayout = function(entryList){
	const entries = entryList.map(([visibility, k, v={}], binding) => ({binding, visibility, [k]:v}));
	return this.device.createBindGroupLayout({entries});
}

Vulkan.createBindGroup = function(layout, resourceList){
	const entries = resourceList.map((resource, binding) => ({binding, resource}));
	return this.device.createBindGroup({layout, entries});
}

Vulkan.registerManagerFactory = function(name, factory){
	this._managerFactoryDict[name] = factory;
}

Vulkan.registerManager = function(name, value){
	this[name] = value;
	this._managerList.push(value);
}

Vulkan.updateManagers = function(method){
	this._managerList.forEach(v => v[method]?.());
}

function loadDataWeb(url, type){
	return new Promise(function(resolve, reject){
		const xmlhttp = new XMLHttpRequest();
		xmlhttp.responseType = type;
		xmlhttp.onload = function(){
			if(xmlhttp.status == 200){
				resolve(xmlhttp.response);
			}else{
				reject(xmlhttp.statusText);
			}
		};
		xmlhttp.open('GET', url, true);
		xmlhttp.send();
	});
}

Vulkan.loadImage = async path => {
	const image = new Image();
	//image.src = path;
	image.src = URL.createObjectURL(await loadDataWeb(path, 'blob'));
	await image.decode();
	URL.revokeObjectURL(image.src);
	return image;
}

Vulkan.getImageJpegData = function(){
	let canvas = document.createElement('canvas');
	let context = canvas.getContext('2d');
	return async path => {
		let image = await Vulkan.loadImage(path);
		let {naturalWidth:width, naturalHeight:height} = image;

		if(canvas.width != width){
			canvas.width = width;
		}
		if(canvas.height != height){
			canvas.height = height;
		}
		context.drawImage(image, 0, 0);
		return context.getImageData(0, 0, width, height);
	}
}()

Vulkan.createBuffer = (usage, size, mappedAtCreation=false) => Vulkan.device.createBuffer({usage, size, mappedAtCreation});

Vulkan.createBufferMapped = function(usage, data){
	const buffer = this.createBuffer(usage, data.byteLength, true);
	const mapping = buffer.getMappedRange();
	new data.constructor(mapping).set(data);
	buffer.unmap();
	return buffer;
}

Vulkan.copyDataToBuffer = function(buffer, data, offset=0){
	const queue = Vulkan.device.queue;
	queue.writeBuffer(buffer, offset, data.buffer);
	return;
	const commandEncoder = Vulkan.copyDataCommandEncoder;
	const copyBuffer = createBufferMapped(GPUBufferUsage.COPY_SRC, data);
	commandEncoder.copyBufferToBuffer(copyBuffer, 0, buffer, offset, data.byteLength);
	Vulkan.destroyList.push(copyBuffer);
	//copyBuffer.destroy();
	return copyBuffer;
}

Vulkan.createCanvasContext = function(width, height){
	let canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;
	let context = canvas.getContext('2d');
	context.fillStyle = '#FFFFFF';
	context.strokeStyle = 'green';
	context.textBaseline = 'ideographic';//bottom,top
	/*
	canvas.setAttribute('style', 'position: absolute;left: 0;');
	document.body.appendChild(canvas)
	context.fillText("你好,world", 100, 30);
	//*/
	return context;
}

Vulkan.createDepthTexture = function(width, height){
	const {device} = Vulkan;
	return device.createTexture({
		size: [width, height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.RENDER_ATTACHMENT
	});
}
