'use strict';

const {delayNew} = require('utils/cache');
const {deferDo, everyCall} = require('webonly/deferDo');
const {fetchArrayBuffer, loadImage} = require('webonly/utils');
const bindFirstArg = require('utils/function/bindFirstArg');
const {createDepthTexture, setViewport, createBuffer, createBufferWith} = require('webonly/utils_gpu');
const {attributes, blend} = require('../helper/pipeline');

const Vulkan = module.exports = {
	//swapChainFormat: 'bgra8unorm',
	_managerFactoryDict: {},
	//_managerList: [],
	//events: new EventTarget(),
};

Vulkan.init = function(device, canvas){
	this.device = device;
	this.canvas = canvas;

	device.lost.then(info => console.log('device lost', info));

	this.registerSampler('linear_mirror', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('linear_repeat', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('linear_clamp',  {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});
	this.registerSampler('nearest_mirror',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('nearest_repeat',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('nearest_clamp', {magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});

	Object.entries(this._managerFactoryDict).forEach(([name, factory]) => this.registerManager(name, new factory()));
}

Vulkan.defineConstGetter = function(target, name, fn){
	Object.defineProperty(target, name, {
		configurable: false, enumerable: true,
		get: delayNew(fn)
	});
}

void function(samplers){
	Vulkan.registerSampler = function(name, descriptor){
		Vulkan.defineConstGetter(samplers, name, () => Vulkan.device.createSampler(descriptor));
	}
	Vulkan.getSampler = name => samplers[name];
}({});

void function(slots){
	Vulkan.registerMaterialSlot = (name, slot) => slots[name] = slot;
	Vulkan.bindMaterialSlots = function(target, bindGroupSlots){
		Vulkan.defineConstGetter(target, 'slotList', () => Object.entries(bindGroupSlots).map(([name, bindIndex]) => slots[name].bind(bindIndex)));
	}
	Vulkan.resetMaterialSlots = function(){
		for(let k in slots){
			slots[k].reset();
		}
	}
}({});

const createPipelineLayout = function(bindGroupLayouts){
	Vulkan.registerBindGroupLayout = function(name, entryList){
		const entries = entryList.map(([visibility, k, v={}], binding) => ({binding, visibility, [k]:v}));
		Vulkan.defineConstGetter(bindGroupLayouts, name, () => Vulkan.device.createBindGroupLayout({entries}));
	}
	Vulkan.createBindGroup = function(name, ...resourceList){
		const entries = resourceList.map((resource, binding) => ({binding, resource}));
		return Vulkan.device.createBindGroup({layout: bindGroupLayouts[name], entries});
	}
	return value => Vulkan.device.createPipelineLayout({bindGroupLayouts: value.map(v => bindGroupLayouts[v])});
}({});

void function(shaderModules){
	function createStage({module, entryPoint='main', ...rest}){
		rest.buffers?.forEach(v => v.attributes = attributes(v.attributes));
		rest.targets?.forEach(v => v.blend = blend(v.blend));
		return {module: shaderModules[module], entryPoint, ...rest};
	}
	function createRenderPipeline({layout, vertex, fragment, ...rest}){
		return Vulkan.device.createRenderPipeline({
			layout: createPipelineLayout(layout),
			vertex: createStage(vertex),
			fragment: createStage(fragment),
			...rest
		});
	}
	function createComputePipeline({layout, compute}){
		return Vulkan.device.createComputePipeline({
			layout: createPipelineLayout(layout),
			compute: createStage(compute),
		});
	}
	Vulkan.registerShaderModule = function(name, code){
		Vulkan.defineConstGetter(shaderModules, name, () => Vulkan.device.createShaderModule({code}));
	}
	Vulkan.bindRenderPipeline = function(target, descriptor, name='pipeline'){
		Vulkan.defineConstGetter(target, name, () => createRenderPipeline(descriptor));
	}
	Vulkan.bindComputePipeline = function(target, descriptor, name='pipeline'){
		Vulkan.defineConstGetter(target, name, () => createComputePipeline(descriptor));
	}
}({});

Vulkan.registerManagerFactory = function(name, factory){
	this._managerFactoryDict[name] = factory;
}

Vulkan.registerManager = function(name, value){
	this[name] = value;
	//this._managerList.push(value);
}


Vulkan.loadData = fetchArrayBuffer;
Vulkan.loadImage = loadImage;

Vulkan.createBuffer = bindFirstArg(createBuffer, () => Vulkan.device);
Vulkan.createBufferMapped = bindFirstArg(createBufferWith, () => Vulkan.device);
Vulkan.createDepthTexture = bindFirstArg(createDepthTexture, () => Vulkan.device);
Vulkan.setViewport = bindFirstArg(setViewport, () => Vulkan.renderPassEncoder);

Vulkan.now = () => performance.now();

Vulkan.requestDestroy = deferDo(everyCall('destroy'));
Vulkan.requestReset = deferDo(everyCall('reset'));

Vulkan.render = function(view3d){
	this.resetMaterialSlots();
	view3d.render();
}
