'use strict';

const Vulkan = module.exports = {
	swapChainFormat: 'bgra8unorm',
	_managerFactoryDict: {},
	_managerList: [],
	events: new EventTarget(),
};

Vulkan.init = function(device, canvas){
	this.device = device;
	this.canvas = canvas;
	Object.entries(this._managerFactoryDict).forEach(([name, factory]) => this.registerManager(name, new factory()));
}

Vulkan.registerManagerFactory = function(name, factory){
	this._managerFactoryDict[name] = factory;
}

Vulkan.registerManager = function(name, value){
	this[name] = value;
	this._managerList.push(value);
}

Vulkan.updateManagers = function(method){
	this._managerList.forEach(v => v[method]?.());
}

function loadDataWeb(url, type){
	return new Promise(function(resolve, reject){
		const xmlhttp = new XMLHttpRequest();
		xmlhttp.responseType = type;
		xmlhttp.onload = function(){
			if(xmlhttp.status == 200){
				resolve(xmlhttp.response);
			}else{
				reject(xmlhttp.statusText);
			}
		};
		xmlhttp.open('GET', url, true);
		xmlhttp.send();
	});
}

Vulkan.loadImage = async path => {
	const image = new Image();
	//image.src = path;
	image.src = URL.createObjectURL(await loadDataWeb(path, 'blob'));
	await image.decode();
	URL.revokeObjectURL(image.src);
	return image;
}

Vulkan.getImageJpegData = function(){
	let canvas = document.createElement('canvas');
	let context = canvas.getContext('2d');
	return async path => {
		let image = await Vulkan.loadImage(path);
		let {naturalWidth:width, naturalHeight:height} = image;

		if(canvas.width != width){
			canvas.width = width;
		}
		if(canvas.height != height){
			canvas.height = height;
		}
		context.drawImage(image, 0, 0);
		return context.getImageData(0, 0, width, height);
	}
}()

Vulkan.createBufferMapped = function(usage, data){
	const {device} = Vulkan;
	const buffer = device.createBuffer({usage, size: data.byteLength, mappedAtCreation:true});
	const mapping = buffer.getMappedRange();
	new data.constructor(mapping).set(data);
	buffer.unmap();
	return buffer;
}

Vulkan.copyDataToBuffer = function(buffer, data, offset=0){
	const queue = Vulkan.device.queue;
	queue.writeBuffer(buffer, offset, data.buffer);
	return;
	const commandEncoder = Vulkan.copyDataCommandEncoder;
	const copyBuffer = createBufferMapped(GPUBufferUsage.COPY_SRC, data);
	commandEncoder.copyBufferToBuffer(copyBuffer, 0, buffer, offset, data.byteLength);
	Vulkan.destroyList.push(copyBuffer);
	//copyBuffer.destroy();
	return copyBuffer;
}

Vulkan.createCanvasContext = function(width, height){
	let canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;
	let context = canvas.getContext('2d');
	context.fillStyle = '#FFFFFF';
	context.strokeStyle = 'green';
	context.textBaseline = 'ideographic';//bottom,top
	/*
	canvas.setAttribute('style', 'position: absolute;left: 0;');
	document.body.appendChild(canvas)
	context.fillText("你好,world", 100, 30);
	//*/
	return context;
}

Vulkan.createDepthTexture = function(width, height){
	const {device} = Vulkan;
	return device.createTexture({
		size: [width, height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.OUTPUT_ATTACHMENT
	});
}
