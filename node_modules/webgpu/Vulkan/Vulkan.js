'use strict';

const {delayNew} = require('utils/cache');
const {idleDo} = require('webonly/deferDo');
const {attributes, blend} = require('../helper/pipeline');

const Vulkan = module.exports = {
	swapChainFormat: 'bgra8unorm',
	_managerFactoryDict: {},
	_managerList: [],
	events: new EventTarget(),
};

Vulkan.init = function(device, canvas){
	this.device = device;
	this.canvas = canvas;

	device.lost.then(info => console.log('device lost', info));

	this.registerSampler('linear_mirror', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('linear_repeat', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('linear_clamp',  {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});
	this.registerSampler('nearest_mirror',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('nearest_repeat',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('nearest_clamp', {magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});

	Object.entries(this._managerFactoryDict).forEach(([name, factory]) => this.registerManager(name, new factory()));
}

Vulkan.defineConstGetter = function(target, name, fn){
	Object.defineProperty(target, name, {
		configurable: false, enumerable: true,
		get: delayNew(fn)
	});
}

void function(samplers){
	Vulkan.registerSampler = function(name, descriptor){
		Vulkan.defineConstGetter(samplers, name, () => Vulkan.device.createSampler(descriptor));
	}
	Vulkan.getSampler = name => samplers[name];
}({});

const createPipelineLayout = function(bindGroupLayouts){
	Vulkan.registerBindGroupLayout = function(name, entryList){
		const entries = entryList.map(([visibility, k, v={}], binding) => ({binding, visibility, [k]:v}));
		Vulkan.defineConstGetter(bindGroupLayouts, name, () => Vulkan.device.createBindGroupLayout({entries}));
	}
	Vulkan.createBindGroup = function(name, ...resourceList){
		const entries = resourceList.map((resource, binding) => ({binding, resource}));
		return Vulkan.device.createBindGroup({layout: bindGroupLayouts[name], entries});
	}
	return value => Vulkan.device.createPipelineLayout({bindGroupLayouts: value.map(v => bindGroupLayouts[v])});
}({});

void function(shaderModules){
	function createStage({module, entryPoint='main', ...rest}){
		rest.buffers?.forEach(v => v.attributes = attributes(v.attributes));
		rest.targets?.forEach(v => v.blend = blend(v.blend));
		return {module: shaderModules[module], entryPoint, ...rest};
	}
	function createRenderPipeline({layout, vertex, fragment, ...rest}){
		return Vulkan.device.createRenderPipeline({
			layout: createPipelineLayout(layout),
			vertex: createStage(vertex),
			fragment: createStage(fragment),
			...rest
		});
	}
	function createComputePipeline({layout, compute}){
		return Vulkan.device.createComputePipeline({
			layout: createPipelineLayout(layout),
			compute: createStage(compute),
		});
	}
	Vulkan.registerShaderModule = function(name, code){
		Vulkan.defineConstGetter(shaderModules, name, () => Vulkan.device.createShaderModule({code}));
	}
	Vulkan.bindRenderPipeline = function(target, descriptor, name='pipeline'){
		Vulkan.defineConstGetter(target, name, () => createRenderPipeline(descriptor));
	}
	Vulkan.bindComputePipeline = function(target, descriptor, name='pipeline'){
		Vulkan.defineConstGetter(target, name, () => createComputePipeline(descriptor));
	}
}({});

Vulkan.registerManagerFactory = function(name, factory){
	this._managerFactoryDict[name] = factory;
}

Vulkan.registerManager = function(name, value){
	this[name] = value;
	this._managerList.push(value);
}

Vulkan.updateManagers = function(method){
	this._managerList.forEach(v => v[method]?.());
}

function loadDataWeb(url, type){
	return new Promise(function(resolve, reject){
		const xmlhttp = new XMLHttpRequest();
		xmlhttp.responseType = type;
		xmlhttp.onload = function(){
			if(xmlhttp.status == 200){
				resolve(xmlhttp.response);
			}else{
				reject(xmlhttp.statusText);
			}
		};
		xmlhttp.open('GET', url, true);
		xmlhttp.send();
	});
}

Vulkan.loadData = loadDataWeb;

Vulkan.loadImage = async path => {
	const image = new Image();
	image.src = path;
	//image.src = URL.createObjectURL(await loadDataWeb(path, 'blob'));
	await image.decode();
	//URL.revokeObjectURL(image.src);
	return image;
}

Vulkan.getImageJpegData = function(){
	let canvas = document.createElement('canvas');
	let context = canvas.getContext('2d');
	return async path => {
		let image = await Vulkan.loadImage(path);
		let {naturalWidth:width, naturalHeight:height} = image;

		if(canvas.width != width){
			canvas.width = width;
		}
		if(canvas.height != height){
			canvas.height = height;
		}
		context.drawImage(image, 0, 0);
		return context.getImageData(0, 0, width, height);
	}
}()

Vulkan.createBuffer = (usage, size, mappedAtCreation=false) => Vulkan.device.createBuffer({usage, size, mappedAtCreation});

Vulkan.createBufferMapped = function(usage, data){
	const buffer = this.createBuffer(usage, data.byteLength, true);
	const mapping = buffer.getMappedRange();
	new data.constructor(mapping).set(data);
	buffer.unmap();
	return buffer;
}

Vulkan.copyDataToBuffer = function(buffer, data, offset=0){
	const queue = Vulkan.device.queue;
	queue.writeBuffer(buffer, offset, data.buffer);
	return;
	const commandEncoder = Vulkan.copyDataCommandEncoder;
	const copyBuffer = createBufferMapped(GPUBufferUsage.COPY_SRC, data);
	commandEncoder.copyBufferToBuffer(copyBuffer, 0, buffer, offset, data.byteLength);
	Vulkan.destroyList.push(copyBuffer);
	//copyBuffer.destroy();
	return copyBuffer;
}

Vulkan.createCanvasContext = function(width, height){
	let canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;
	let context = canvas.getContext('2d');
	context.fillStyle = '#FFFFFF';
	context.strokeStyle = 'green';
	context.textBaseline = 'ideographic';//bottom,top
	/*
	canvas.setAttribute('style', 'position: absolute;left: 0;');
	document.body.appendChild(canvas)
	context.fillText("你好,world", 100, 30);
	//*/
	return context;
}

Vulkan.createDepthTexture = function(width, height){
	const {device} = Vulkan;
	return device.createTexture({
		size: [width, height, 1],
		format: 'depth24plus-stencil8',
		usage: GPUTextureUsage.RENDER_ATTACHMENT
	});
}

Vulkan.now = function(){
	return performance.now();
}

Vulkan.setViewport = function(rect, minDepth=0, maxDepth=1){
	Vulkan.renderPassEncoder.setViewport(rect.x, rect.y, rect.width, rect.height, minDepth, maxDepth);
}

Vulkan.requestDestroy = function(){
	let fn = idleDo(resourceSet => {
		for(let resource of resourceSet){
			resource.destroy();
		}
	})
	return function(resource){
		if(!resource)return;
		fn(resource);
	}
}();
