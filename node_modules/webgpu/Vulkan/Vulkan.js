'use strict';

const defineConstGetter = require('utils/object/defineConstGetter');
const {deferDo, everyCall} = require('webonly/deferDo');
const {createGetter, createListGetter} = require('utils/cache');
const {fetchArrayBuffer, loadImage} = require('webonly/utils');
const {createDepthTexture, setViewport, createBuffer, createBufferWith, calcSamplerSign} = require('webonly/utils_gpu');
const bindFirstArg = require('utils/function/bindFirstArg');

const Vulkan = module.exports = {
	//swapChainFormat: 'bgra8unorm',
	_managerFactoryDict: {},
	//_managerList: [],
	//events: new EventTarget(),
};

Vulkan.init = function(device, canvas){
	this.device = device;
	this.canvas = canvas;

	device.lost.then(info => console.log('device lost', info));

	
/*
	this.registerSampler('linear_mirror', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('linear_repeat', {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('linear_clamp',  {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});
	this.registerSampler('nearest_mirror',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'mirror-repeat', addressModeV: 'mirror-repeat', addressModeW: 'mirror-repeat'});
	this.registerSampler('nearest_repeat',{magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'});
	this.registerSampler('nearest_clamp', {magFilter: 'nearest', minFilter: 'nearest', addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'});
*/
	
	Object.entries(this._managerFactoryDict).forEach(([name, factory]) => this.registerManager(name, new factory()));
}

Vulkan.sampler = {
	linear_repeat: {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'repeat',		  addressModeV: 'repeat',		 addressModeW: 'repeat'},
	linear_clamp:  {magFilter: 'linear',  minFilter: 'linear',  addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge', addressModeW: 'clamp-to-edge'}
};
Vulkan.getSampler = createGetter(desc => Vulkan.device.createSampler(desc), calcSamplerSign);
/*
void function(samplers){
	Vulkan.registerSampler = function(name, descriptor){
		defineConstGetter(samplers, name, () => Vulkan.device.createSampler(descriptor));
	}
	Vulkan.getSampler = name => samplers[name];
}({});
*/
void function(slots){
	Vulkan.registerMaterialSlot = (name, slot) => slots[name] = slot;
	Vulkan.bindMaterialSlots = function(target, bindGroupSlots){
		defineConstGetter(target, 'slotList', () => Object.entries(bindGroupSlots).map(([name, bindIndex]) => slots[name].bind(target, bindIndex)));
	}
	Vulkan.resetMaterialSlots = function(){
		for(let k in slots){
			slots[k].reset();
		}
	}
}({});
/*
void function(bindGroupLayouts){
	const createBindGroupLayout = function(){
		const fn = (entry, binding) => entry ? {binding, visibility: entry[0], [entry[1]]: entry[2] ?? {}} : [];
		return (device, entries) => device.createBindGroupLayout({entries: entries.flatMap(fn)});
	}();
	Vulkan.registerBindGroupLayout = function(name, entryList){
		defineConstGetter(bindGroupLayouts, name, () => createBindGroupLayout(Vulkan.device, entryList));
	}
	Vulkan.createBindGroup = function(name, ...resourceList){
		return createBindGroup(Vulkan.device, bindGroupLayouts[name], resourceList);
	}
}({});

void function(){
	const shaderCache = createListGetter(code => Vulkan.device.createShaderModule({code}), Object.create(null));
	const bindGroupLayoutCache = createGetter(entries => Vulkan.device.createBindGroupLayout({entries}), calcBindGroupLayoutSign);
	const pipelineLayoutCache = createGetter(layouts => Vulkan.device.createPipelineLayout({bindGroupLayouts: layouts.map(bindGroupLayoutCache)}), calcPipelineLayoutSign);
	function createRenderPipeline(desc){
		const {vertex, fragment} = desc;
		if(!desc.layout){
			desc.layout = pipelineLayoutCache(desc.groups)
		}
		if(!vertex.module){
			vertex.module = shaderCache(vertex.code);
		}
		if(!fragment.module){
			fragment.module = shaderCache(fragment.code);
		}
		return Vulkan.device.createRenderPipeline(desc);
	}
	Vulkan.createBindGroupNew = function(name, resources){
		return createBindGroup(Vulkan.device, bindGroupLayoutCache(name), resources);
	}
	
	function createComputePipeline({layout, compute}){
		return Vulkan.device.createComputePipeline({
			layout: createPipelineLayout(layout),
			compute: createStage(compute),
		});
	}
	
	Vulkan.bindRenderPipeline = function(target, descriptor, name){
		defineConstGetter(target, name, () => createRenderPipeline(descriptor));
	}
	
	Vulkan.bindComputePipeline = function(target, descriptor, name='pipeline'){
		defineConstGetter(target, name, () => createComputePipeline(descriptor));
	}
}
*/
Vulkan.registerManagerFactory = function(name, factory){
	this._managerFactoryDict[name] = factory;
}

Vulkan.registerManager = function(name, value){
	this[name] = value;
	//this._managerList.push(value);
}


Vulkan.loadData = fetchArrayBuffer;
Vulkan.loadImage = loadImage;

Vulkan.createBuffer = bindFirstArg(createBuffer, () => Vulkan.device);
Vulkan.createBufferMapped = bindFirstArg(createBufferWith, () => Vulkan.device);
Vulkan.createDepthTexture = bindFirstArg(createDepthTexture, () => Vulkan.device);
Vulkan.setViewport = bindFirstArg(setViewport, () => Vulkan.renderPassEncoder);

Vulkan.now = () => performance.now();

Vulkan.requestDestroy = deferDo(everyCall('destroy'));
Vulkan.requestReset = deferDo(everyCall('reset'));

Vulkan.render = function(view3d){
	this.resetMaterialSlots();
	view3d.render();
}
