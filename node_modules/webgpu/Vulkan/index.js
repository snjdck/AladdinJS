'use strict';

const Vulkan = require('./Vulkan');

module.exports = Vulkan;

const TextManager = require('../managers/TextManager');

//const DirectBufferManager = require('../managers/DirectBufferManager');
const MouseManager = require('../managers/MouseManager');
const KeyBoardManager = require('../managers/KeyBoardManager');
/*
Vulkan.registerBindGroupLayout('0', [
	[GPUShaderStage.VERTEX, 'buffer'],
	[GPUShaderStage.FRAGMENT, 'sampler'],
]);

Vulkan.registerBindGroupLayout('2', [
	[GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE, 'buffer'],
]);

Vulkan.registerBindGroupLayout('2_dynamic', [
	[GPUShaderStage.VERTEX, 'buffer', {hasDynamicOffset: true}],
]);

Vulkan.registerBindGroupLayout('3', [
	[GPUShaderStage.FRAGMENT, 'texture'],
]);

Vulkan.registerBindGroupLayout('4', [
	[GPUShaderStage.FRAGMENT, 'buffer', {hasDynamicOffset: true}],
]);

Vulkan.registerBindGroupLayout('5', [
	[GPUShaderStage.FRAGMENT, 'texture', {viewDimension: '2d-array'}],
]);

Vulkan.registerBindGroupLayout('cull', [
	[GPUShaderStage.COMPUTE, 'buffer', {type: 'storage'}],
]);

Vulkan.registerBindGroupLayout('filter2D', [
	[GPUShaderStage.FRAGMENT, 'sampler'],
	[GPUShaderStage.FRAGMENT, 'texture'],
]);
*/

//Vulkan.registerManagerFactory('render2D', Render2D);

Vulkan.registerManagerFactory('textMgr', TextManager);

//Vulkan.registerManagerFactory('vertexBufferMgr', VertexBufferManager);
//Vulkan.registerManagerFactory('directBufferMgr', DirectBufferManager);
Vulkan.registerManagerFactory('mouseMgr', MouseManager);
Vulkan.registerManagerFactory('keyboardMgr', KeyBoardManager);

const {VertexBufferSlot, UniformBufferSlot} = require('../helper/Slot');

Vulkan.registerMaterialSlot('transform', UniformBufferSlot(64, 256, function(){
	const buffer = new Float32Array(13);
	return drawUnit => {
		buffer.set(drawUnit.entity.worldTransform.rawData)
		//buffer[12] = drawUnit.cameraIndex;
		return buffer;
	}
}()));

Vulkan.registerMaterialSlot('filter', VertexBufferSlot(100, 16, function(){
	const vertexData = new Float32Array(4);
	return function({frameRect:{width, height}, drawRect}){
		vertexData[0] = drawRect.x / width;
		vertexData[1] = drawRect.y / height;
		vertexData[2] = drawRect.width / width;
		vertexData[3] = drawRect.height / height;
		return vertexData;
	}
}()));

Vulkan.registerMaterialSlot('color', UniformBufferSlot(64, 256, ({material}) => new Float32Array(material.color)));

Vulkan.registerMaterialSlot('bound', UniformBufferSlot(64, 256, function(){
	const buffer = new Float32Array(7);
	return drawUnit => {
		const {bound} = drawUnit.material;
		buffer[0] = bound.minX;
		buffer[1] = bound.minY;
		buffer[2] = bound.minZ;
		buffer[3] = drawUnit.cameraIndex;
		buffer[4] = bound.maxX;
		buffer[5] = bound.maxY;
		buffer[6] = bound.maxZ;
		return buffer;
	}
}()));
Vulkan.registerMaterialSlot('bone', UniformBufferSlot(4, 4096, function(){
	const objectBuffer3D = new Float32Array(256*4);
	return drawUnit => {
		drawUnit.entity.copyBoneStateToBuffer(objectBuffer3D);
		return objectBuffer3D;
	}
}()));

Vulkan.registerMaterialSlot('2d', VertexBufferSlot(100, 24 << 2, function(){
	const vertexData = new Float32Array(24);
	const allZero = new Float32Array(4);
	const allOne = new Float32Array(4).fill(1);
	return function(instance){
		const {worldTransform, texture, width, height, fgColor, viewportIndex} = instance;
		worldTransform.copyToArray(vertexData);
		vertexData[3] = 0;//viewportIndex;
		if(texture){
			vertexData.set(texture.xyuvMul, 8);
			vertexData.set(texture.xyuvAdd, 12);
			vertexData.set(texture.scale9grid, 20);
			vertexData[16] = width;
			vertexData[17] = texture.width;
			vertexData[18] = height;
			vertexData[19] = texture.height;
		}else{
			vertexData.set(allOne, 8);
			vertexData.set(allZero, 12);
			vertexData.set(allZero, 20);
			vertexData[16] = width;
			vertexData[17] = width;
			vertexData[18] = height;
			vertexData[19] = height;
		}
		return vertexData;
	}
}()));
