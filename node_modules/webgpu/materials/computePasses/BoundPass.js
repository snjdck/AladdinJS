'use strict';

const Pipeline = require('../Pipeline');
const Vulkan = require('../../Vulkan');
const {fetchBuffer} = require('../../Vulkan/resource');
const {CommandEncoder, ComputePass} = require('../../helper/CommandEncoder');
const maxCountPerDraw = 100;
/*
  4---5
 /|  /|
6---7 |
| 0-|-1
|/  |/
2---3

min = 0, max = 7
*/

const pipeline = new Pipeline({
	groups: [[
		{binding:0, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}, temp:{array:new Float32Array(8 * maxCountPerDraw), stride:8, mapFn: bound => [bound.minX, bound.minY, bound.minZ, 0, bound.maxX, bound.maxY, bound.maxZ,0]}},
		{binding:1, visibility:GPUShaderStage.COMPUTE, buffer:{type:'storage'}},
		{binding:2, visibility:GPUShaderStage.COMPUTE, buffer:{type:'storage'}},
	]],
	compute: {
		entryPoint: 'main',
		code: `
			var<private> planeList : array<vec4<u32>, 6> = array<vec4<u32>, 6>(
				vec4<u32>(0,1,2,3),
				vec4<u32>(6,7,4,5),
				vec4<u32>(5,7,1,3),
				vec4<u32>(6,4,2,0),
				vec4<u32>(4,5,0,1),
				vec4<u32>(7,6,3,2),
			);

			var<private> normalList : array<vec3<f32>, 6> = array<vec3<f32>, 6>(
				vec3<f32>(0,0,-1),
				vec3<f32>(0,0, 1),
				vec3<f32>( 1,0,0),
				vec3<f32>(-1,0,0),
				vec3<f32>(0,-1,0),
				vec3<f32>(0, 1,0),
			);

			struct Input {
				@builtin(workgroup_id) wgid: vec3<u32>,
				@builtin(local_invocation_id) liid: vec3<u32>,
			}

			@group(0) @binding(0) var<storage, read> boundList: array<vec3<f32>>;
			@group(0) @binding(1) var<storage, read_write> vertexList: array<vec3<f32>>;
			@group(0) @binding(2) var<storage, read_write> out_normalList: array<vec3<f32>>;

			@compute @workgroup_size(6)
			fn main(input: Input){
				let planeIndex: u32 = input.liid.x;
				let instenceIndex: u32 = input.wgid.x;

				var vertex_list: array<vec3<f32>, 4>;

				for(var i=0; i<4; i++){
					let vertexID: u32 = planeList[planeIndex][i];
					let xyz: vec3<u32> = vec3<u32>(vertexID & 1, (vertexID >> 1) & 1, vertexID >> 2);
					vertex_list[i] = select(boundList[instenceIndex << 1], boundList[(instenceIndex << 1) | 1], vec3<bool>(xyz));
				}

				let offset = (instenceIndex * 6 + planeIndex) * 6;
				vertexList[offset] = vertex_list[0];
				vertexList[offset+1] = vertex_list[1];
				vertexList[offset+2] = vertex_list[2];
				vertexList[offset+3] = vertex_list[3];
				vertexList[offset+4] = vertex_list[2];
				vertexList[offset+5] = vertex_list[1];

				out_normalList[offset  ] = normalList[planeIndex];
				out_normalList[offset+1] = normalList[planeIndex];
				out_normalList[offset+2] = normalList[planeIndex];
				out_normalList[offset+3] = normalList[planeIndex];
				out_normalList[offset+4] = normalList[planeIndex];
				out_normalList[offset+5] = normalList[planeIndex];
			}
		`
	}
});

const boundByteSize = 36 << 4;

function genBoundBuffer(boundList){
	const position = fetchBuffer(boundList.length * boundByteSize, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	const normal = fetchBuffer(boundList.length * boundByteSize, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	for(let commandEncoder of CommandEncoder(Vulkan.device)){
		for(let computePassEncoder of ComputePass(commandEncoder)){
			pipeline.setPipeline(computePassEncoder);
			pipeline.setBindGroup(computePassEncoder, 0, [
				{binding:0, resource:{buffer:boundList, usage:GPUBufferUsage.STORAGE}},
				{binding:1, resource:{buffer:position}},
				{binding:2, resource:{buffer:normal}},
			]);
			computePassEncoder.dispatchWorkgroups(boundList.length);
		}
	}
	return {position, normal};
}
/*
exports.genBoundBuffer = genBoundBuffer;
exports.boundByteSize = boundByteSize;
exports.boundVertexCount = 36;
*/