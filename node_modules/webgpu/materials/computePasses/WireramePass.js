'use strict';

const Pipeline = require('../Pipeline');
const Vulkan = require('../../Vulkan');
const {fetchBuffer, bufferCache} = require('../../Vulkan/resource');
const {CommandEncoder, ComputePass} = require('../../helper/CommandEncoder');

const pipeline = new Pipeline({
	groups: [[
		{binding:1, visibility:GPUShaderStage.COMPUTE, buffer:{type:'storage'}},
	]],
	compute: {
		entryPoint: 'main',
		code: `
			struct Input {
				@builtin(workgroup_id) wgid: vec3<u32>,
				@builtin(local_invocation_id) liid: vec3<u32>,
				@builtin(num_workgroups) numwg: vec3<u32>,
			}

			@group(0) @binding(0) var<storage,read> _from: array<u32>;
			@group(0) @binding(1) var<storage,read_write> _to: array<u32>;

			@compute @workgroup_size(3)
			fn main(input: Input){
				let trigCount: u32 = input.numwg.x;
				let instanceIndex: u32 = input.wgid.y;

				var offset: u32 = input.liid.x;
				var source: u32 = input.wgid.x * 3;// + instanceIndex * trigCount * 3;//trig index
				
				var dest: u32 = input.wgid.x * 6 + offset * 2 + instanceIndex * trigCount * 6;

				_to[dest] = source + offset;
				_to[dest+1] = source + (offset + 1) % 3;
			}

			@compute @workgroup_size(3)
			fn mainIndexed(input: Input){
				var offset: u32 = input.liid.x;
				var source: u32 = input.wgid.x * 3;
				var dest: u32 = input.wgid.x * 6 + offset * 2;

				_to[dest] = _from[source + offset];
				_to[dest+1] = _from[source + (offset + 1) % 3];
			}
		`
	}
});

const pipelineIndexed = new Pipeline({
	groups: [[
		{binding:0, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}},//read-only-storage, uniform
		{binding:1, visibility:GPUShaderStage.COMPUTE, buffer:{type:'storage'}},
	]],
	compute: {
		entryPoint: 'mainIndexed',
		code: pipeline.desc.compute.code
	}
});
/*
mesh = {
	subMeshList:[{
		vertexCount
		attributes:{index}
	}]
}
*/
function genWireframeBuffer(subMeshList, instanceCount=1){
	const indexBufferList = [];
	for(let commandEncoder of CommandEncoder(Vulkan.device)){
		for(let subMesh of subMeshList){
			const buffer = fetchBuffer(subMesh.vertexCount * 2 * 4 * instanceCount, GPUBufferUsage.INDEX | GPUBufferUsage.STORAGE);
			indexBufferList.push(buffer);
			for(let computePassEncoder of ComputePass(commandEncoder)){
				if(subMesh.attributes?.index){
					const indexData = bufferCache(subMesh.attributes.index, GPUBufferUsage.STORAGE);
					pipelineIndexed.setPipeline(computePassEncoder);
					pipelineIndexed.setBindGroup(computePassEncoder, 0, [
						{binding:0, resource:{buffer:indexData}},
						{binding:1, resource:{buffer}},
					]);
				}else{
					pipeline.setPipeline(computePassEncoder);
					pipeline.setBindGroup(computePassEncoder, 0, [
						{binding:1, resource:{buffer}},
					]);
				}
				computePassEncoder.dispatchWorkgroups(subMesh.vertexCount / 3, instanceCount);
			}
		}
	}
	return indexBufferList;
}
/*
exports.genWireframeBuffer = genWireframeBuffer;
*/