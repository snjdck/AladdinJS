'use strict';

const Pipeline = require('../Pipeline');
const Vulkan = require('../../Vulkan');
const {fetchBuffer, bufferCache} = require('../../Vulkan/resource');
const {CommandEncoder, ComputePass} = require('../../helper/CommandEncoder');
const maxCountPerDraw = 4;
const maxBoneCount = 128;

const pipelineDynamic = new Pipeline({
	groups: [[
		{binding:0, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}},
		{binding:1, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}},
		{binding:2, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}},
		{binding:3, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}, temp:{array: new Float32Array(16 * maxCountPerDraw), stride: 16, mapFn: v => v.entity.worldTransform.rawData}},
		{binding:4, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}, temp:{array: new Float32Array(8 * maxBoneCount * maxCountPerDraw), stride: 8 * maxBoneCount, mapFn: ({entity}) => entity.copyBoneStateToTempBuffer().subarray(0, entity.skeleton.boneCount << 3)}},
		{binding:5, visibility:GPUShaderStage.COMPUTE, buffer:{type:'storage'}},
		{binding:6, visibility:GPUShaderStage.COMPUTE, buffer:{type:'storage'}},
	]],
	compute: {
		entryPoint: 'mainDynamic',
		code: `
			fn cast2mat(quaternion: vec4<f32>) -> mat3x3<f32> {
				let t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
				let t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
				let t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

				let a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
				let b: vec3<f32> = (t0     - t1.zxy) * 2.0;
				let c: vec3<f32> = (t0.zxy + t1.yzx) * 2.0;

				return mat3x3<f32>(
					a.x, b.x, c.x,
					c.y, a.y, b.y,
					b.z, c.z, a.z
				);
			}

			@group(0) @binding(0) var<storage, read> positionList: array<vec3<f32>>;
			@group(0) @binding(1) var<storage, read> normalList: array<vec3<f32>>;
			@group(0) @binding(2) var<storage, read> boneIndexList: array<u32>;
			@group(0) @binding(3) var<storage, read> worldMatrix: array<mat3x4<f32>>;
			@group(0) @binding(4) var<storage, read> boneState: array<vec4<f32>>;
			@group(0) @binding(5) var<storage, read_write> out_positionList: array<vec3<f32>>;
			@group(0) @binding(6) var<storage, read_write> out_normalList: array<vec3<f32>>;

			@compute @workgroup_size(1)
			fn mainDynamic(
				@builtin(workgroup_id) wgid: vec3<u32>,
				@builtin(num_workgroups) numwg: vec3<u32>,
			){
				let vertexIndex: u32 = wgid.x;
				let instanceIndex: u32 = wgid.y;
				let vertexCount: u32 = numwg.x;

				let index: u32 = boneIndexList[vertexIndex] << 1;//every object use 256 registers, every bone use two registers
				let boneMatrix: mat3x3<f32> = cast2mat(boneState[instanceIndex * ${maxBoneCount * 2} + index]);
				let worldPosition: vec3<f32> = (positionList[vertexIndex] * boneMatrix + boneState[index+1].xyz) * 1.0;//boneWeight
				let worldNormal: vec3<f32> = (normalList[vertexIndex] * boneMatrix) * 1.0;

				let mat = worldMatrix[instanceIndex];

				let outIndex = instanceIndex * vertexCount + vertexIndex;
				out_positionList[outIndex] = vec4<f32>(worldPosition, 1.0) * mat;
				out_normalList[outIndex] = worldNormal * mat3x3(mat[0].xyz, mat[1].xyz, mat[2].xyz);
			}

			@compute @workgroup_size(1)
			fn mainStatic(
				@builtin(workgroup_id) wgid: vec3<u32>,
				@builtin(num_workgroups) numwg: vec3<u32>,
			){
				let vertexIndex: u32 = wgid.x;
				let instanceIndex: u32 = wgid.y;
				let vertexCount: u32 = numwg.x;

				let worldPosition: vec3<f32> = positionList[vertexIndex];
				let worldNormal: vec3<f32> = normalList[vertexIndex];

				let mat = worldMatrix[instanceIndex];

				let outIndex = instanceIndex * vertexCount + vertexIndex;
				out_positionList[outIndex] = vec4<f32>(worldPosition, 1.0) * mat;
				out_normalList[outIndex] = worldNormal * mat3x3(mat[0].xyz, mat[1].xyz, mat[2].xyz);
			}
		`
	}
});

const pipelineStatic = new Pipeline({
	groups: [pipelineDynamic.desc.groups[0].filter(v => [0,1,3,5,6].includes(v.binding))],
	compute: {
		...pipelineDynamic.desc.compute,
		entryPoint: 'mainStatic'
	}
});

function genVertexBuffer(subMeshList, drawUnitList){
	const result = [];
	for(let commandEncoder of CommandEncoder(Vulkan.device)){
		for(let subMesh of subMeshList){
			const byteSize = subMesh.attributes.position.byteLength * drawUnitList.length;
			const position = fetchBuffer(byteSize, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
			const normal = fetchBuffer(byteSize, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
			const uv = fetchBuffer(byteSize >> 1, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
			if(subMesh.attributes.uv){
				const uvData = bufferCache(subMesh.attributes.uv, GPUBufferUsage.COPY_SRC);
				for(let i=0; i<drawUnitList.length; ++i){
					commandEncoder.copyBufferToBuffer(uvData, 0, uv, i * uvData.size, uvData.size);
				}
			}
			result.push({position, normal, uv});
			for(let computePassEncoder of ComputePass(commandEncoder)){
				if(false && subMesh.attributes?.index){
				}else{
					pipelineDynamic.setPipeline(computePassEncoder);
					pipelineDynamic.setBindGroup(computePassEncoder, 0, [
						{binding:0, resource:{buffer:bufferCache(subMesh.attributes.position, GPUBufferUsage.STORAGE)}},
						{binding:1, resource:{buffer:bufferCache(subMesh.attributes.normal, GPUBufferUsage.STORAGE)}},
						{binding:2, resource:{buffer:bufferCache(subMesh.attributes.boneIndex, GPUBufferUsage.STORAGE)}},
						{binding:3, resource:{buffer:drawUnitList, usage:GPUBufferUsage.STORAGE}},
						{binding:4, resource:{buffer:drawUnitList, usage:GPUBufferUsage.STORAGE}},
						{binding:5, resource:{buffer:position}},
						{binding:6, resource:{buffer:normal}},
					]);
				}
				computePassEncoder.dispatchWorkgroups(subMesh.vertexCount, drawUnitList.length);
			}
		}
	}
	return result;
}

function genVertexBufferStatic(subMeshList, drawUnitList){
	const result = [];
	for(let commandEncoder of CommandEncoder(Vulkan.device)){
		for(let subMesh of subMeshList){
			//const byteSize = subMesh.attributes.position.byteLength * drawUnitList.length;
			const byteSize = (subMesh.attributes.position instanceof GPUBuffer
							? subMesh.attributes.position.size
							: subMesh.attributes.position.byteLength) * drawUnitList.length;
			const position = fetchBuffer(byteSize, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
			const normal = fetchBuffer(byteSize, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
			const uv = fetchBuffer(byteSize >> 1, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
			if(subMesh.attributes.uv){
				const uvData = bufferCache(subMesh.attributes.uv, GPUBufferUsage.COPY_SRC);
				for(let i=0; i<drawUnitList.length; ++i){
					commandEncoder.copyBufferToBuffer(uvData, 0, uv, i * uvData.size, uvData.size);
				}
			}
			result.push({position, normal, uv});
			for(let computePassEncoder of ComputePass(commandEncoder)){
				if(false && subMesh.attributes?.index){
				}else{
					pipelineStatic.setPipeline(computePassEncoder);
					pipelineStatic.setBindGroup(computePassEncoder, 0, [
						{binding:0, resource:{buffer:
							subMesh.attributes.position instanceof GPUBuffer
							? subMesh.attributes.position
							: bufferCache(subMesh.attributes.position, GPUBufferUsage.STORAGE)
						}},
						{binding:1, resource:{buffer:
							subMesh.attributes.normal instanceof GPUBuffer
							? subMesh.attributes.normal
							: bufferCache(subMesh.attributes.normal, GPUBufferUsage.STORAGE)
						}},
						{binding:3, resource:{buffer:drawUnitList, usage:GPUBufferUsage.STORAGE}},
						{binding:5, resource:{buffer:position}},
						{binding:6, resource:{buffer:normal}},
					]);
				}
				computePassEncoder.dispatchWorkgroups(subMesh.vertexCount, drawUnitList.length);
			}
		}
	}
	return result;
}
/*
exports.genVertexBuffer = genVertexBuffer;
exports.genVertexBufferStatic = genVertexBufferStatic;
*/