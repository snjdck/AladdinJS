'use strict';

const Pipeline = require('../Pipeline');
const Vulkan = require('../../Vulkan');
const {fetchBuffer, bufferCache} = require('../../Vulkan/resource');
const {CommandEncoder, ComputePass} = require('../../helper/CommandEncoder');
const maxCountPerDraw = 4;
const maxBoneCount = 128;

const pipeline = new Pipeline({
	groups: [[
		{binding:0, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}},
		{binding:1, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}},
		{binding:2, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}},
		{binding:3, visibility:GPUShaderStage.COMPUTE, buffer:{type:'read-only-storage'}, temp:{array: new Float32Array(8 * maxBoneCount * maxCountPerDraw), stride: 8 * maxBoneCount, mapFn: entity => entity.copyBoneStateToTempBuffer().subarray(0, entity.skeleton.boneCount << 3)}},
		{binding:4, visibility:GPUShaderStage.COMPUTE, buffer:{type:'storage'}},
		{binding:5, visibility:GPUShaderStage.COMPUTE, buffer:{type:'storage'}},
	]],
	compute: {
		entryPoint: 'main',
		code: `
			fn cast2mat(quaternion: vec4<f32>) -> mat3x3<f32> {
				let t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
				let t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
				let t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

				let a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
				let b: vec3<f32> = (t0     - t1.zxy) * 2.0;
				let c: vec3<f32> = (t0.zxy + t1.yzx) * 2.0;

				return mat3x3<f32>(
					a.x, b.x, c.x,
					c.y, a.y, b.y,
					b.z, c.z, a.z
				);
			}

			@group(0) @binding(0) var<storage, read> positionList: array<vec3<f32>>;
			@group(0) @binding(1) var<storage, read> normalList: array<vec3<f32>>;
			@group(0) @binding(2) var<storage, read> boneIndexList: array<u32>;
			@group(0) @binding(3) var<storage, read> boneState: array<vec4<f32>>;
			@group(0) @binding(4) var<storage, read_write> out_positionList: array<vec3<f32>>;
			@group(0) @binding(5) var<storage, read_write> out_normalList: array<vec3<f32>>;

			@compute @workgroup_size(1)
			fn main(
				@builtin(workgroup_id) wgid: vec3<u32>
			){
				let vertexIndex: u32 = wgid.x;

				let index: u32 = boneIndexList[vertexIndex] << 1;//every object use 256 registers, every bone use two registers
				let boneMatrix: mat3x3<f32> = cast2mat(boneState[index]);
				let worldPosition: vec3<f32> = (positionList[vertexIndex] * boneMatrix + boneState[index+1].xyz) * 1.0;//boneWeight
				let worldNormal: vec3<f32> = (normalList[vertexIndex] * boneMatrix) * 1.0;

				out_positionList[vertexIndex] = worldPosition;
				out_normalList[vertexIndex] = worldNormal;
			}
		`
	}
});

function genVertexBuffer(subMeshList, entity){
	const result = [];
	for(let commandEncoder of CommandEncoder(Vulkan.device)){
		for(let subMesh of subMeshList){
			const position = fetchBuffer(subMesh.attributes.position.byteLength, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
			const normal = fetchBuffer(subMesh.attributes.normal.byteLength, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
			result.push({position, normal});
			for(let computePassEncoder of ComputePass(commandEncoder)){
				if(false && subMesh.attributes?.index){
					/*
					const indexData = bufferCache(subMesh.attributes.index, GPUBufferUsage.STORAGE);
					pipelineIndexed.setPipeline(computePassEncoder);
					pipelineIndexed.setBindGroup(computePassEncoder, 0, [
						{binding:0, resource:{buffer:indexData}},
						{binding:1, resource:{buffer}},
					]);*/
				}else{
					pipeline.setPipeline(computePassEncoder);
					pipeline.setBindGroup(computePassEncoder, 0, [
						{binding:0, resource:{buffer:bufferCache(subMesh.attributes.position, GPUBufferUsage.STORAGE)}},
						{binding:1, resource:{buffer:bufferCache(subMesh.attributes.normal, GPUBufferUsage.STORAGE)}},
						{binding:2, resource:{buffer:bufferCache(subMesh.attributes.boneIndex, GPUBufferUsage.STORAGE)}},
						{binding:3, resource:{buffer:[entity], usage:GPUBufferUsage.STORAGE}},
						{binding:4, resource:{buffer:position}},
						{binding:5, resource:{buffer:normal}},
					]);
				}
				computePassEncoder.dispatchWorkgroups(subMesh.vertexCount);
			}
		}
	}
	return result;
}

exports.genVertexBuffer = genVertexBuffer;
