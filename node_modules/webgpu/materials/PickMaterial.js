'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const TextureMaterial = require('./TextureMaterial');
const groupDraw = require('../helper/groupDraw');
const {fetchAnimationTexture} = require('../Vulkan/resource');

const maxCountPerDrawStatic = 100;

const pipeline = {
	groups: [TextureMaterial.pipelineDesc.groups[0].slice(0, 1), TextureMaterial.pipelineDesc.groups[1]],
	vertex: {
		buffers: [
			TextureMaterial.pipelineDesc.vertex.buffers[0],
			TextureMaterial.pipelineDesc.vertex.buffers[3],
		{
			name: 'meshId',
			arrayStride: 1 << 2,
			stepMode: 'instance',
			attributes: [{shaderLocation:1, offset: 0, format:'uint32'}],
			temp:{array: new Uint32Array(maxCountPerDrawStatic), stride: 1, mapFn: v => [v.id]}
		}],
		entryPoint: 'mainPick',
		code: TextureMaterial.pipelineDesc.vertex.code
	},
	fragment: {
		targets:[{
			format: 'r32uint',
		}],
		entryPoint: 'main',
		code: `
			@fragment
			fn main(@location(0) @interpolate(flat) id: u32) -> @location(0) u32 {
				return id;
			}
		`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: false,
		depthCompare: 'equal',
	},
};

class PickMaterial extends Material.Subclass(pipeline, []){
	static maxCountPerDraw = maxCountPerDrawStatic;
	static itemDict = new Map();
	static onDraw(drawUnitList, renderPassEncoder){
		for(let i=0; i<drawUnitList.length; ++i){
			drawUnitList[i].id = i+1;
			this.itemDict.set(i+1, drawUnitList[i]);
		}
		for(let [{subMeshList}, itemList] of Material.Utils.groupMesh(drawUnitList)){
			const {textureView} = fetchAnimationTexture(itemList[0].entity.skeleton.mesh);
			this.setResources(renderPassEncoder, {
				'worldMatrixList': {buffer:itemList},
				'animationTexture':textureView,
				'animationTextureInfo':{buffer:itemList.map(v => v.entity.skeleton)},
				'meshId':itemList
			});
			for(let i=0, n=subMeshList.length; i<n; ++i){
				const subMesh = subMeshList[i];
				const {position, boneIndex} = subMesh.buffers;
				this.setResources(renderPassEncoder, {position, boneIndex});
				const subMeshFilter = 1 << i;
				for(let [offset, count] of groupDraw(v => itemList[v].material.subMeshFilter & subMeshFilter, itemList.length)){
					subMesh.draw(renderPassEncoder, count, offset);
				}
			}
		}
	}

	constructor(subMeshFilter=0xFFFFFFFF){
		super();
		this.subMeshFilter = subMeshFilter;
	}
}

module.exports = PickMaterial;
