'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');

class ColorMaterial extends Material
{
	static get pipeline(){
		return Vulkan.pipelineDict.pipelineColor;
	}
	static onInit(){
		class T{
			constructor(){
				this.uniformCache = Vulkan.createUniformBufferListCache(
					Vulkan.bindGroupLayoutDict.bindGroupLayout4,
					10 * 4 * 4
				);
				this.dict = new Map();
			}

			onFrameBegin(){
				this.dict.clear();
			}

			call(index, offset, value){
				const {dict, uniformCache} = this;
				if(!dict.has(index)){
					dict.set(index, dict.size);
				}
				return uniformCache(dict.get(index), offset, value);
			}
		}
		Vulkan.registerManager('colorDataMgr', new T());
	}
	static onDraw(infoList){
		const {transformUniformCache, boneDataCache} = Vulkan.transformUniformMgr;
		const {renderPassEncoder, currentMesh} = Vulkan;
		for(const [index, offset, count] of infoList){
			renderPassEncoder.setBindGroup(3, Vulkan.colorDataMgr.call(index));
			renderPassEncoder.setBindGroup(1, transformUniformCache(index));
			renderPassEncoder.setBindGroup(2, boneDataCache(index), [0]);
			if(Vulkan.currentCamera.cullEnabled){
				for(const subMesh of currentMesh.subMeshList){
					const {vertexCount, vertexOffset} = subMesh;
					renderPassEncoder.draw(vertexCount, count, vertexOffset, offset);
				}
			}else{
				renderPassEncoder.draw(currentMesh.vertexCount, count, 0, offset);
			}
		}
	}

	static onUpdateBuffer(instance, i, [index, offset]){
		Vulkan.colorDataMgr.call(index, 16 * (offset + i), new Float32Array(instance.getMaterial(this).color));
	}
	
	constructor(color){
		super();
		this.color = color;
	}
}

module.exports = ColorMaterial;
