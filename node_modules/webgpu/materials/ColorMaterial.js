'use strict';

const TextureMaterial = require('./TextureMaterial');
const {maxCountPerDraw} = TextureMaterial;

const pipeline = {
	...TextureMaterial.pipelineDesc,
	groups: [TextureMaterial.pipelineDesc.groups[0], [
		...TextureMaterial.pipelineDesc.groups[1],
		{binding:2, visibility:GPUShaderStage.FRAGMENT, buffer:{}, temp:{array: new Float32Array(4 * maxCountPerDraw), stride: 4, mapFn: v => v.material.color}}
	]],
	fragment: {
		...TextureMaterial.pipelineDesc.fragment,
		code: `
			struct COLOR_BLOCK {
				colorList: array<vec4<f32>, ${maxCountPerDraw}>,
			};

			@group(1) @binding(2) var<uniform> colorBlock: COLOR_BLOCK;

			struct Input {
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
				@location(2) normal: vec3<f32>,
			};

			struct Output {
				@location(0) color: vec4<f32>,
			};

			@fragment
			fn main(input: Input) -> Output {
				var base: f32 = 0.0;
				var factor: f32 = dot(normalize(vec3<f32>(1.0, 0.0, 1.0)), normalize(input.normal));
				factor = base + (1.0 - base) * max(factor, 0.0);
				var baseColor: vec4<f32> = colorBlock.colorList[input.instanceIndex];
				var output: Output;
				output.color = vec4<f32>(baseColor.rgb * factor, baseColor.a);
				return output;
			}
		`
	},
};

class ColorMaterial extends TextureMaterial.Subclass(pipeline){
	static onDraw(drawUnitList, {subMeshList}, renderPassEncoder){
		this.setBindGroup(renderPassEncoder, 1, [
			{binding:0, resource:{buffer:drawUnitList}},
			{binding:1, resource:{buffer:drawUnitList}},
			{binding:2, resource:{buffer:drawUnitList}},
		]);
		for(let i=0, n=subMeshList.length; i<n; ++i){
			//if((this.subMeshFilter & 1 << i) == 0)continue;
			const subMesh = subMeshList[i];
			subMesh.setBuffers(renderPassEncoder, this.vertexBuffers);
			subMesh.draw(renderPassEncoder, drawUnitList.length);
		}
	}
	constructor(color){
		super();
		this.color = color;
	}
}

module.exports = ColorMaterial;
