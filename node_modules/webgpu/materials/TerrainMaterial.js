'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const {classifyTexture} = require('./helper');
const {createWeakMapGetter} = require('utils/cache');

const pipelineDesc = {
	groups: [[
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}}
	], [
		{binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{viewDimension: '2d-array'}}
	], [
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{hasDynamicOffset:true}, name:'transform'}
	]],
	vertex: {
		buffers: [{
			name: 'layer0',
			arrayStride: 12,
			stepMode: 'vertex',
			attributes: [
				{shaderLocation: 0, offset:0, format:'uint8x2'},
				{shaderLocation: 1, offset:4, format:'unorm8x2'},
				{shaderLocation: 2, offset:8, format:'unorm8x4'}
			]
		}],
		entryPoint: 'main',
		code: `
			const height_scale: f32 = 0.0;//400.0
			const tileSize: f32 = 100.0;
			const uvScale: f32 = 0.78125;//100 / 128
			const vertexCount: vec2<u32> = vec2<u32>(256u, 256u);

			struct MVP {
				screenMatrix: mat4x4<f32>,
				cameraMatrix: mat3x4<f32>,
				viewportXYWH: vec4<f32>,
			};

			struct MVP_BLOCK {
				cameraList: array<MVP, 100>,
			};

			struct TRANSFORM_BLOCK {
				matrixList: array<mat4x4<f32>, 256>,
			};

			@binding(0) @group(0) var<uniform> mvp: MVP_BLOCK;
			@binding(0) @group(2) var<uniform> worldMatrix: TRANSFORM_BLOCK;

			struct Input {
				@location(0) map_layer: vec2<u32>,
				@location(1) map_layermix_height: vec2<f32>,//mix, z-height
				@location(2) map_light: vec4<f32>,
				@builtin(vertex_index) vertexIndex: u32,
				@builtin(instance_index) instanceIndex: u32,
			};

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) layer: vec3<f32>,
				@location(2) light: vec4<f32>,
			};

			@vertex
			fn main(input: Input) -> Output {
				var cameraIndex: u32 = u32(worldMatrix.matrixList[input.instanceIndex << 2u][3][0]);

				var vertexXY: vec2<f32> = vec2<f32>(f32(input.vertexIndex % vertexCount.x), f32(input.vertexIndex / vertexCount.x));
				var worldPosition: vec3<f32> = vec3<f32>(vertexXY * tileSize, input.map_layermix_height.y * height_scale);
				var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraList[cameraIndex].cameraMatrix;
				var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.cameraList[cameraIndex].screenMatrix;

				var viewportXYWH: vec4<f32> = mvp.cameraList[cameraIndex].viewportXYWH;
				//screenPosition.xy = screenPosition.xy * viewportXYWH.zw + viewportXYWH.xy;
				var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);
				screenPosition.x = t.x;
				screenPosition.y = t.y;
				//screenPosition.xy = t;

				var output: Output;
				output.position = screenPosition;
				output.uv = vertexXY * uvScale;
				output.layer = vec3<f32>(vec2<f32>(input.map_layer), input.map_layermix_height.x);
				output.light = input.map_light;
				return output;
			}
		`
	},
	fragment: {
		targets:[{
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}],
		entryPoint: 'main',
		code: `
			@binding(1) @group(0) var g_sampler: sampler;
			@binding(0) @group(1) var g_texture: texture_2d_array<f32>;

			struct Input {
				@location(0) uv: vec2<f32>,
				@location(1) layer: vec3<f32>,
				@location(2) light: vec4<f32>,
			};

			struct Output {
				@location(0) color: vec4<f32>,
			};

			@fragment
			fn main(input: Input) -> Output {
				var output: Output;
				output.color = mix(
					textureSample(g_texture, g_sampler, vec2<f32>(input.uv), i32(input.layer.x)),
					textureSample(g_texture, g_sampler, vec2<f32>(input.uv), i32(input.layer.y)),
					input.layer.zzzz
				) * input.light;
				return output;
			}
		`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: true,
		depthCompare: 'less-equal',
	}
};

const bindGroupCache = createWeakMapGetter((texture, material) => material.createBindGroupWith(texture.createView({dimension: '2d-array'})));

class TerrainMaterial extends Material.Subclass(
	{pipeline: pipelineDesc},
	{transform:2}
){
	static *calcDrawIterator(entityList, mesh){
		for(const [texture, subEntityList] of classifyTexture(entityList)){
			Vulkan.renderPassEncoder.setBindGroup(1, bindGroupCache(texture, this));
			yield * super.calcDrawIterator(subEntityList);
		}
	}
	constructor(texture){
		super();
		this.texture = texture;
	}
}

module.exports = TerrainMaterial;
