'use strict';

const Material = require('./Material');
const TextureMaterial = require('./TextureMaterial');

const pipeline = TextureMaterial.pipeline.clone({
	groups: v => [v[0], [{name:'baseTexture', texture:{viewDimension: '2d-array'}}]],
	vertex: {
		buffers: [{
			name: 'layer0',
			arrayStride: 12,
			stepMode: 'vertex',
			attributes: [
				{shaderLocation: 0, offset:0, format:'uint8x2', name:'map_layer'},
				{shaderLocation: 1, offset:4, format:'unorm8x2', name:'map_layermix_height'},
				{shaderLocation: 2, offset:8, format:'unorm8x4', name:'map_light'}
			]
		}],
		code: `
			const height_scale: f32 = 0.0;//400.0
			const tileSize: f32 = 100.0;
			const uvScale: f32 = 0.78125;//100 / 128
			const vertexCount: vec2<u32> = vec2<u32>(256u, 256u);

			#include<transform>

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) layer: vec3<f32>,
				@location(2) light: vec4<f32>,
				@location(3) normal: vec3<f32>,
				//@location(4) world_position: vec3<f32>,
			};

			@vertex -> Output {
				var vertexXY: vec2<f32> = vec2<f32>(f32(vertexIndex % vertexCount.x), f32(vertexIndex / vertexCount.x));
				var worldPosition: vec3<f32> = vec3<f32>(vertexXY * tileSize, map_layermix_height.y * height_scale);
				var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * vpMatrix.cameraMatrix;
				var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * vpMatrix.screenMatrix;

				var output: Output;
				output.position = screenPosition;
				output.uv = vertexXY * uvScale;
				output.layer = vec3<f32>(vec2<f32>(map_layer), map_layermix_height.x);
				output.light = map_light;
				//output.world_position = worldPosition;
				output.normal = vec3<f32>(0,0,1);
				return output;
			}
		`
	},
	fragment: {
		targets:[{format: 'bgra8unorm'}, {writeMask:7,format: 'rgba16float'},{format: 'rgba16float'}],
		code: `
			struct Input {
				@location(0) uv: vec2<f32>,
				@location(1) layer: vec3<f32>,
				@location(2) light: vec4<f32>,
				@location(3) normal: vec3<f32>,
				//@location(4) position: vec3<f32>,
			}

			struct Output {
				@location(0) color: vec4<f32>,
				@location(1) normal: vec4<f32>,
				@location(2) emissive: vec4<f32>,
			}

			@fragment
			fn main(input: Input) -> Output {
				var output: Output;
				output.color = mix(
					textureSample(baseTexture, g_sampler, vec2<f32>(input.uv), i32(input.layer.x)),
					textureSample(baseTexture, g_sampler, vec2<f32>(input.uv), i32(input.layer.y)),
					input.layer.zzzz
				) * input.light;
				output.normal = vec4<f32>(input.normal, 1.0);
				//output.position = vec4<f32>(input.position, 1.0);
				return output;
			}
		`
	}
});

class TerrainMaterial extends Material.Subclass(pipeline, []){
	static onDraw(drawUnitList, renderPassEncoder){
		const [{entity, material}] = drawUnitList;
		this.setResources(renderPassEncoder, {
			'worldMatrixList': {buffer:drawUnitList},
			'baseTexture': material.texture.createView({dimension: '2d-array'}),
		});
		for(let subMesh of entity.mesh.subMeshList){
			const {layer0, index} = subMesh.attributes;
			this.setResources(renderPassEncoder, {layer0, index});
			renderPassEncoder.drawIndexed(index.length);
		}
	}
	constructor(texture){
		super();
		this.texture = texture;
	}
}

module.exports = TerrainMaterial;
