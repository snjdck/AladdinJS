'use strict';

const Material = require('./Material');
const Pipeline = require('./Pipeline');

const pipeline = new Pipeline({
	groups: [[{name:'vpMatrix', type:'MVP', buffer:{}}], [
		{name:'g_sampler', sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat'}},
		{name:'baseTexture', texture:{viewDimension: '2d-array'}},
		{name:'lightTexture', texture:{}},
		{name:'heightTexture', texture:{}},
		{name:'mapTexture', texture:{viewDimension: '2d-array', sampleType:'uint'}},
	]],
	vertex: {
		code: `
			const height_scale: f32 = 0;//400.0
			const tileSize: f32 = 100;
			const vertexCount: u32 = 256;

			#include<transform>

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) layer: vec3<f32>,
				@location(2) light: vec4<f32>,
			}

			@vertex Output {
				let vertex = vec2(vertexIndex % vertexCount, u32(vertexIndex / vertexCount));
				let height = textureLoad(heightTexture, vertex, 0).x;
				let uv = vec2<f32>(vertex);
				return Output(
					positionWorldToScreen(vec3(uv * tileSize, height * height_scale), vpMatrix),
					uv,
					vec3(
						f32(textureLoad(mapTexture, vertex, 0, 0).x),
						f32(textureLoad(mapTexture, vertex, 1, 0).x),
						f32(textureLoad(mapTexture, vertex, 2, 0).x) / 255
					),
					textureLoad(lightTexture, vertex, 0)
				);
			}
		`
	},
	fragment: {
		targets:[{format: 'bgra8unorm'}, {writeMask:7,format: 'rgba16float'},{format: 'rgba16float'}],
		code: `
			@fragment {
				return Output(
					mix(
						textureSample(baseTexture, g_sampler, uv, i32(layer.x)),
						textureSample(baseTexture, g_sampler, uv, i32(layer.y)),
						vec4(layer.z)
					) * light,
					vec4<f32>(0,0,1,1),
					vec4<f32>()
				);
			}
		`
	},
	depthStencil: {}
});

class TerrainMaterial extends Material.Subclass(pipeline){
	static onDraw(drawUnitList, renderPassEncoder){
		const [{entity, material}] = drawUnitList;
		const lightTexture = renderPassEncoder.loadTexture('assets/World1/TerrainLight.jpg', false);
		const heightTexture = renderPassEncoder.loadTexture('assets/World1/TerrainHeight.bmp', false);
		const mapTexture = renderPassEncoder.loadTexture('assets/World1/Terrain.map', false);
		if(!(lightTexture && heightTexture && mapTexture))return;
		renderPassEncoder.setResources({
			'worldMatrixList': {buffer:drawUnitList},
			'baseTexture': renderPassEncoder.fetchTextureView(material.texture, '2d-array'),
			'lightTexture': renderPassEncoder.fetchTextureView(lightTexture),
			'heightTexture': renderPassEncoder.fetchTextureView(heightTexture),
			'mapTexture': renderPassEncoder.fetchTextureView(mapTexture, '2d-array'),
		});
		for(let subMesh of entity.mesh.subMeshList){
			const {index} = subMesh.attributes;
			renderPassEncoder.setResources({index});
			renderPassEncoder.drawIndexedAuto();
		}
	}
	constructor(texture){
		super();
		this.texture = texture;
	}

	get pick(){
		return new PickMaterial();
	}
}

const pickPipeline = Pipeline.Pick(
	[[{name:'heightTexture', texture:{}}]], [], `
	const height_scale: f32 = 0;//400.0
	const tileSize: f32 = 100;
	const vertexCount: u32 = 256;

	#include<transform>

	@vertex Output {
		let vertex = vec2(vertexIndex % vertexCount, u32(vertexIndex / vertexCount));
		let height = textureLoad(heightTexture, vertex, 0).x;
		let uv = vec2<f32>(vertex);
		let worldPosition = vec3(uv * tileSize, height * height_scale);
		return Output(
			positionWorldToScreen(worldPosition, vpMatrix),
			worldPosition,
			meshId
		);
	}
`);

class PickMaterial extends Material.Subclass(pickPipeline){
	static onDraw(drawUnitList, renderPassEncoder){
		const [{entity, material}] = drawUnitList;
		const heightTexture = renderPassEncoder.loadTexture('assets/World1/TerrainHeight.bmp', false);
		if(!heightTexture)return;
		renderPassEncoder.setResources({
			'worldMatrixList': {buffer:drawUnitList},
			'heightTexture': renderPassEncoder.fetchTextureView(heightTexture),
			'meshId':drawUnitList
		});
		for(let subMesh of entity.mesh.subMeshList){
			const {index} = subMesh.attributes;
			renderPassEncoder.setResources({index});
			renderPassEncoder.drawIndexedAuto();
		}
	}
}

module.exports = TerrainMaterial;
