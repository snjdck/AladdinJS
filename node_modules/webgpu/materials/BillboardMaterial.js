'use strict';

const Material = require('./Material');
const Pipeline = require('./Pipeline');

const maxCountPerDraw = 100;

const pipeline = new Pipeline({
	groups: [[
		{name:'vpMatrix', type:'MVP', buffer:{}},
		{name:'worldMatrixList', type:`array<mat3x4<f32>>`, buffer:{type:'read-only-storage'}, visibility:GPUShaderStage.VERTEX},
		{name:'boneStateTexture', storageTexture:{viewDimension:'2d-array', format:'rgba32float', access:'read-only'}, visibility:GPUShaderStage.VERTEX}
	],[
		{name:'baseTexture', texture:{}},
		{name:'g_sampler', sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}},
		{name:'pointSize', type:'array<vec4<f32>, 1>', buffer:{}}
	]],
	vertex:{buffers:[
		{name: 'info', stepMode: 'instance', attributes: [{format:'uint32'}], temp:{type:Uint32Array, mapFn: v => [v.entity.$id_world]}}
		],code:`
		#include<transform>
		struct OutputForward {
			@builtin(position) position: vec4<f32>,
			@location(0) uv: vec2<f32>,
		}
		@vertex OutputForward {
			let vertex = vec2<f32>(vec2(vertexIndex >> 1, vertexIndex & 1));
			let xyDiff = (vertex * 2 - 1) * pointSize[0].xy;
			
			let worldMatrix = worldMatrixList[info];
			let worldPosition = vec4<f32>(worldMatrix[0].w, worldMatrix[1].w, worldMatrix[2].w, 1);
			var cameraPosition = worldPosition * vpMatrix.cameraMatrix;

			cameraPosition.x = cameraPosition.x + xyDiff.x;
			cameraPosition.y = cameraPosition.y + xyDiff.y;

			let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * vpMatrix.screenMatrix;

			return OutputForward(screenPosition, vertex);
		}
	`
	},
	fragment:{
		targets:[{blend: 'one add one-minus-src;src-alpha add one-minus-src-alpha'}],
		code:`@fragment{return textureSample(baseTexture, g_sampler, uv);}`
	},
	depthStencil: {depthWriteEnabled: false},
	primitive: {topology: 'triangle-strip'}
});

class BillboardMaterial extends Material.Subclass(pipeline){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(drawUnitList, renderPassEncoder){
		for(let [textureName, itemList] of Map.groupBy(drawUnitList, fn)){
			let texture = renderPassEncoder.loadTexture(textureName, false);
			if(!texture)continue;
			renderPassEncoder.setResources({
				'baseTexture': renderPassEncoder.fetchTextureView(texture),
				'pointSize': {buffer:pointSize},
				'info':itemList
			});
			renderPassEncoder.draw(4, itemList.length);
		}
	}
	constructor(texture, width, height){
		super();
		this.texture = texture;
	}
}

const fn = v => v.material.texture;
const pointSize = new Float32Array([16, 32]);

module.exports = BillboardMaterial;
