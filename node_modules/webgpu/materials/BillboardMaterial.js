'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');

const maxCountPerDraw = 100;

const pipeline = {
	groups: [[
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}}
	], [
		{binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{}}
	]],
	vertex: {
		buffers: [{
			arrayStride: 12 << 2,
			stepMode: 'instance',
			attributes: [
				{shaderLocation:0, offset: 0, format:'float32x4'},
				{shaderLocation:1, offset: 4 << 2, format:'float32x4'},
				{shaderLocation:2, offset: 8 << 2, format:'float32x4'}
			],
			temp:{array:new Float32Array(12 * maxCountPerDraw), stride:12, mapFn: v => v.entity.worldTransform.rawData}
		}],
		entryPoint: 'main',
		code: `
			struct MVP {
				screenMatrix: mat4x4<f32>,
				cameraMatrix: mat3x4<f32>,
				viewportXYWH: vec4<f32>,
			};

			struct MVP_BLOCK {
				cameraList: array<MVP, 1>,
			};

			struct TRANSFORM_BLOCK {
				matrixList: array<mat4x4<f32>, 256>,
			};

			@binding(0) @group(0) var<uniform> mvp: MVP_BLOCK;
			//@binding(0) @group(1) var<uniform> worldMatrixBlock: TRANSFORM_BLOCK;

			struct Input {
				@builtin(vertex_index) vertexIndex: u32,
				@builtin(instance_index) instanceIndex: u32,
				@location(0) row0: vec4<f32>,
				@location(1) row1: vec4<f32>,
				@location(2) row2: vec4<f32>,
			};

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
			};

			@vertex
			fn main(input: Input) -> Output {
				var vertex: vec2<f32>;
				vertex.x = f32(input.vertexIndex >> 1u);
				vertex.y = f32(input.vertexIndex & 1u);
				var xyDiff: vec2<f32> = vertex * 2.0 - vec2<f32>(1.0, 1.0);
				xyDiff = xyDiff * vec2<f32>(16.0, 32.0);

				
				//var worldMatrix: mat4x4<f32> = worldMatrixBlock.matrixList[input.instanceIndex << 2u];
				//let worldMatrix = mat3x4<f32>(input.row0, input.row1, input.row2);
				var cameraIndex: u32 = 0u;
				var worldPosition: vec4<f32> = vec4<f32>(input.row0.w, input.row1.w, input.row2.w, 1.0);
				var cameraPosition: vec3<f32> = worldPosition * mvp.cameraList[cameraIndex].cameraMatrix;

				cameraPosition.x = cameraPosition.x + xyDiff.x;
				cameraPosition.y = cameraPosition.y + xyDiff.y;

				var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.cameraList[cameraIndex].screenMatrix;

				var viewportXYWH: vec4<f32> = mvp.cameraList[cameraIndex].viewportXYWH;
				var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy);
				screenPosition.x = t.x;
				screenPosition.y = t.y;

				var output: Output;
				output.position = screenPosition;
				output.uv = vertex;
				return output;
			}
		`
	},
	fragment: {
		targets:[{
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'one', dstFactor: 'one-minus-src', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}],
		entryPoint: 'main',
		code: `
			@binding(1) @group(0) var mySampler: sampler;
			@binding(0) @group(1) var myTexture: texture_2d<f32>;

			@fragment
			fn main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
				return textureSample(myTexture, mySampler, uv);
			}
		`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: false,
		depthCompare: 'less-equal',
	},
	primitive: {
		topology: 'triangle-strip',
		stripIndexFormat: 'uint16',
	}
};

class BillboardMaterial extends Material.Subclass({pipeline}, [Material.Utils.groupTexture]){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(drawUnitList, texture){
		this.setBindGroup(1, [{binding:0, resource:texture.createView()}]);
		this.setVertexBuffer(0, drawUnitList);
		Vulkan.renderPassEncoder.draw(4, drawUnitList.length);
	}
	constructor(texture, width, height){
		super();
		this.texture = texture;
	}
}

module.exports = BillboardMaterial;
