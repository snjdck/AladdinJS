'use strict';

const Material = require('./Material');
const TextureMaterial = require('./TextureMaterial');

const maxCountPerDraw = 100;

const pipeline = TextureMaterial.pipeline.clone({
	groups: v => [
		v[0],
		[v[1][0]],
		[v[2][0], {name:'pointSize', binding:1, visibility:GPUShaderStage.VERTEX, buffer:{}}]
	],
	vertex:{entryPoint: 'mainBillboard'},
	fragment:{
		targets:[{
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'one', dstFactor: 'one-minus-src', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}]
	},
	depthStencil: {depthWriteEnabled: false},
	primitive: {topology: 'triangle-strip'}
});

class BillboardMaterial extends Material.Subclass(pipeline){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(drawUnitList, renderPassEncoder){
		for(let [texture, itemList] of Map.groupBy(drawUnitList, fn)){
			this.setResources(renderPassEncoder, {
				'baseTexture': texture.createView(),
				'pointSize': {buffer:pointSize},
			});
			for(let v of Material.Utils.cut(maxCountPerDraw, itemList)){
				this.setResources(renderPassEncoder, {'worldMatrixList': {buffer:v}});
				renderPassEncoder.draw(4, v.length);
			}
		}
	}
	constructor(texture, width, height){
		super();
		this.texture = texture;
	}
}

const fn = v => v.material.texture;
const pointSize = new Float32Array([16, 32]);

module.exports = BillboardMaterial;
