'use strict';

const Material = require('./Material');
const TextureMaterial = require('./TextureMaterial');
const {fetchAnimationTexture} = require('../Vulkan/resource');

const pipeline = TextureMaterial.pipeline.clone({
	groups: v => v.slice(0, 2),
	buffers: v => [v[0], v[3]],
	vertex:{entryPoint: 'mainDepth'},
	fragment:null,
	depthStencil: {format: 'depth32float'}
});

class DepthMaterial extends TextureMaterial.Subclass(pipeline){
	static onDraw(list, renderPassEncoder){
		for(let [mesh, itemList] of Material.Utils.groupMesh(list)){
			for(let drawUnitList of Material.Utils.cut(100, itemList)){
				const {textureView} = fetchAnimationTexture(drawUnitList[0].entity.skeleton.mesh);
				this.setResources(renderPassEncoder, {
					'worldMatrixList': {buffer:drawUnitList},
					'animationTexture':textureView,
					'animationTextureInfo':{buffer:drawUnitList.map(v => v.entity.skeleton)}
				});
				for(let i=0; i<mesh.subMeshList.length; ++i){
					const subMesh = mesh.subMeshList[i];
					const {position, boneIndex} = subMesh.buffers;
					this.setResources(renderPassEncoder, {position, boneIndex});
					subMesh.draw(renderPassEncoder, drawUnitList.length);
				}
			}
		}
	}
}

const CubeDepthMaterial = DepthMaterial.Subclass(DepthMaterial.pipeline.clone({
	vertex:{entryPoint: 'mainCubeDepth'},
}));

exports.DepthMaterial = DepthMaterial;
exports.CubeDepthMaterial = CubeDepthMaterial;
