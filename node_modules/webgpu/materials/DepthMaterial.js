'use strict';

const TextureMaterial = require('./TextureMaterial');
const Material = require('./Material');

const maxCountPerDraw = 4;
const maxCountPerDrawStatic = 100;
const maxBoneCount = 128;
const pipeline = {
	...TextureMaterial.pipelineDesc,
	groups: TextureMaterial.pipelineDesc.groups.slice(0, 2),
	vertex: {
		buffers: [
			TextureMaterial.pipelineDesc.vertex.buffers[0],
			TextureMaterial.pipelineDesc.vertex.buffers[3],
		],
		entryPoint: 'mainDynamic',
		code: `
			fn cast2mat(quaternion: vec4<f32>) -> mat3x3<f32> {
				let t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
				let t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
				let t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

				let a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
				let b: vec3<f32> = (t0     - t1.zxy) * 2.0;
				let c: vec3<f32> = (t0.zxy + t1.yzx) * 2.0;

				return mat3x3<f32>(
					a.x, b.x, c.x,
					c.y, a.y, b.y,
					b.z, c.z, a.z
				);
			}

			fn positionWorldToScreen(worldPosition: vec3<f32>) -> vec4<f32> {
				let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1) * mvp.cameraMatrix;
				let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * mvp.screenMatrix;
				return screenPosition;
			}
			
			struct MVP {
				screenMatrix: mat4x4<f32>,
				cameraMatrix: mat3x4<f32>,
			}

			@group(0) @binding(0) var<uniform> mvp: MVP;
			@group(1) @binding(0) var<uniform> worldMatrixList: array<mat3x4<f32>, ${maxCountPerDrawStatic}>;
			@group(1) @binding(1) var<uniform> boneStateList: array<vec4<f32>, ${2 * maxBoneCount * maxCountPerDraw}>;

			struct OutputForward {
				@builtin(position) position: vec4<f32>,
				@location(0) depth: f32,
			}

			@vertex
			fn mainDynamic(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(3) boneIndex: u32,
			) -> OutputForward {
				let index: u32 = boneIndex << 1;//every object use 256 registers, every bone use two registers
				let boneMatrix: mat3x3<f32> = cast2mat(boneStateList[instanceIndex * ${maxBoneCount * 2} + index]);
				var worldPosition: vec3<f32> = (position * boneMatrix + boneStateList[index+1].xyz) * 1.0;//boneWeight

				let mat = worldMatrixList[instanceIndex];

				worldPosition = vec4<f32>(worldPosition, 1.0) * mat;

				let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1) * mvp.cameraMatrix;
				let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * mvp.screenMatrix;

				var output: OutputForward;
				output.position = screenPosition;
				output.depth = screenPosition.z / screenPosition.w;
				return output;
			}
		`
	},
	fragment: {
		targets:[{
			writeMask: GPUColorWrite.RED,
			format: 'r32float',
		}],
		entryPoint: 'main',
		code: `
			@fragment
			fn main(@location(0) depth: f32) -> @location(0) f32 {
				return depth;
			}
		`
	},
};

class DepthMaterial extends TextureMaterial.Subclass(pipeline){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(drawUnitList, mesh, renderPassEncoder){
		this.setBindGroup(renderPassEncoder, 1, [
			{binding:0, resource:{buffer:drawUnitList}},
			{binding:1, resource:{buffer:drawUnitList}},
		]);
		for(let i=0; i<mesh.subMeshList.length; ++i){
			const subMesh = mesh.subMeshList[i];
			subMesh.setBuffers(renderPassEncoder, this.vertexBuffers);
			subMesh.draw(renderPassEncoder, drawUnitList.length);
		}
	}
}

module.exports = DepthMaterial;
