'use strict';

const Material = require('./Material');
const TextureMaterial = require('./TextureMaterial');
const {genBoundBuffer, boundByteSize, boundVertexCount} = require('./computePasses/BoundPass');
const {genWireframeBuffer} = require('./computePasses/WireramePass');
const maxCountPerDraw = 100;

const pipeline = {
	groups: [
		TextureMaterial.pipelineDesc.groups[0],
		TextureMaterial.pipelineDesc.groups[1].slice(0,1)
	],
	vertex:{
		...TextureMaterial.pipelineDesc.vertex,
		buffers: [{
			arrayStride: 4 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:0, offset: 0, format:'float32x3'}]
		}],
		entryPoint: 'mainStatic',
	},
	fragment:{
		...TextureMaterial.pipelineDesc.fragment,
		entryPoint: 'mainColor',
	},
	depthStencil: TextureMaterial.pipelineDesc.depthStencil,
	primitive: {topology: 'line-list'}
};

class BoundMaterial extends Material.Subclass(pipeline, []){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(drawUnitList, renderPassEncoder){
		const boundMap = Map.groupBy(drawUnitList, v => v.material.bound);
		const boundList = Array.from(boundMap.keys());
		const buffer = genBoundBuffer(boundList);
		const indexBuffer = genWireframeBuffer([{
			vertexCount:boundVertexCount,
		}])[0];
		for(let i=0; i<boundList.length; ++i){
			let entityList = boundMap.get(boundList[i]);
			this.setBindGroup(renderPassEncoder, 1, [
				{binding:0, resource:{buffer:entityList}}
			]);
			renderPassEncoder.setVertexBuffer(0, buffer, i * boundByteSize, boundByteSize);
			renderPassEncoder.setIndexBuffer(indexBuffer, 'uint32');
			renderPassEncoder.drawIndexed(boundVertexCount << 1, entityList.length);
		}
	}
	constructor(bound){
		super();
		this.bound = bound;
	}
}

module.exports = BoundMaterial;
