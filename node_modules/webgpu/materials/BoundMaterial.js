'use strict';

const Material = require('./Material');
const Pipeline = require('./Pipeline');
const {createCube} = require('../helper/geom');
const {initMesh} = require('../helper/MeshHelper');

const maxCountPerDraw = 100;

const pipeline = new Pipeline({
	groups: [
		[{name:'vpMatrix', type:'MVP', buffer:{}}],
		[{name:'worldMatrixList', type:`array<mat3x4<f32>>`, buffer:{type:'read-only-storage'}}]
	],
	vertex:{code:`
		#include<transform>
		@vertex{
			let mat = worldMatrixList[info];
			return positionWorldToScreen(vec4<f32>(position, 1) * mat, vpMatrix);
		}`,
		buffers: [
			{name: 'position', arrayStride: 4 << 2, attributes: [{format:'float32x3'}]},
			{name: 'info', stepMode: 'instance', attributes: [{format:'uint32'}], temp:{type:Uint32Array, mapFn: v => [v.entity.$id_world]}}
		],
	},
	fragment:{
		targets:[{blend: 'src-alpha add one-minus-src-alpha'}],
		code:`@fragment{return vec4(1, 0, 0, 1);}`
	},
	depthStencil: {},
	primitive: {topology: 'line-list'}
});

class BoundMaterial extends Material.Subclass(pipeline, []){
	static maxCountPerDraw = 1;
	static onDraw(drawUnitList, renderPassEncoder){
		renderPassEncoder.setResources({
			'worldMatrixList': {buffer:renderPassEncoder.data.worldMatrixList},
			'info':drawUnitList
		});
		const subMesh = drawUnitList[0].material.cube.subMeshList[0];
		const {position, indexWireframe} = subMesh.attributes;
		renderPassEncoder.setResources({position, index: indexWireframe});
		renderPassEncoder.drawIndexedAuto(drawUnitList.length);
	}
	constructor(bound){
		super();
		this.bound = bound;
		this.cube = initMesh(createCube(bound));
	}
}

module.exports = BoundMaterial;
