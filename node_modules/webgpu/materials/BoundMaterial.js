'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const TextureMaterial = require('./TextureMaterial');
const {createCube} = require('../helper/geom');

const maxCountPerDraw = 100;

const pipeline = TextureMaterial.pipeline.clone({
	groups: v => [v[0], v[1].slice(0,1)],
	buffers: v => v.slice(0,1),
	vertex:{code:`
		#include<transform>
		@vertex
		fn main() -> @builtin(position) vec4<f32> {
			let mat = worldMatrixList[instanceIndex];
			return positionWorldToScreen(vec4<f32>(position, 1) * mat, vpMatrix);
		}`
	},
	fragment:{code:`@fragment{return vec4<f32>(1, 0, 0, 1);}`},
	primitive: {topology: 'line-list'}
});

class BoundMaterial extends Material.Subclass(pipeline, []){
	static maxCountPerDraw = 1;
	static onDraw(drawUnitList, renderPassEncoder){
		this.setResources(renderPassEncoder, {
			'worldMatrixList': {buffer:drawUnitList},
		});
		const subMesh = drawUnitList[0].material.cube.subMeshList[0];
		const {position, indexWireframe} = subMesh.attributes;
		this.setResources(renderPassEncoder, {position, index: indexWireframe});
		renderPassEncoder.drawIndexed(indexWireframe.length, drawUnitList.length);
	}
	constructor(bound){
		super();
		this.bound = bound;
		let cube = createCube(bound);
		Vulkan.addMeshBufferGetter(cube);
		this.cube = cube;
	}
}

module.exports = BoundMaterial;
