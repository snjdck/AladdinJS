'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const Pipeline = require('./Pipeline');
const {createCube} = require('../helper/geom');
const {initMesh} = require('../helper/MeshHelper');
const {worldMatrixList} = require('./helper/DefaultGroupEntries');

const maxCountPerDraw = 100;

const pipeline = new Pipeline({
	groups: [
		[{name:'vpMatrix', type:'MVP', buffer:{}}],
		[worldMatrixList()]
	],
	vertex:{code:`
		#include<transform>
		@vertex{
			let mat = worldMatrixList[instanceIndex];
			return positionWorldToScreen(vec4<f32>(position, 1) * mat, vpMatrix);
		}`,
		buffers: [{name: 'position', arrayStride: 4 << 2, attributes: [{format:'float32x3'}]}],
	},
	fragment:{
		targets:[{blend: 'src-alpha add one-minus-src-alpha'}],
		code:`@fragment{return vec4(1, 0, 0, 1);}`
	},
	depthStencil: {},
	primitive: {topology: 'line-list'}
});

class BoundMaterial extends Material.Subclass(pipeline, []){
	static maxCountPerDraw = 1;
	static onDraw(drawUnitList, renderPassEncoder){
		renderPassEncoder.setResources({
			'worldMatrixList': {buffer:drawUnitList},
		});
		const subMesh = drawUnitList[0].material.cube.subMeshList[0];
		const {position, indexWireframe} = subMesh.attributes;
		renderPassEncoder.setResources({position, index: indexWireframe});
		renderPassEncoder.drawIndexedAuto(drawUnitList.length);
	}
	constructor(bound){
		super();
		this.bound = bound;
		this.cube = initMesh(createCube(bound));
	}
}

module.exports = BoundMaterial;
