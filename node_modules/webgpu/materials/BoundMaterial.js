'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const UniformBufferSlotCache = require('../helper/UniformBufferSlotCache');
const {delayNew} = require('utils/cache');
const transformSlot = require('./slots/transformSlot');

class BoundMaterial extends Material
{
	static useMeshFlag = false;
	static get pipeline(){
		return Vulkan.pipelineDict.pipelineBound;
	}
	static bindGroupSlots = delayNew(() => [transformSlot(), boundSlot()]);
	static bindIndexList = [1,2];
	static doDraw(instanceCount){
		const {renderPassEncoder} = Vulkan;
		renderPassEncoder.draw(24, instanceCount);
	}
	constructor(bound){
		super();
		this.bound = bound;
	}
}

const boundSlot = delayNew(() => {
	const buffer = new Float32Array(7);
	const slot = new UniformBufferSlotCache(
		Vulkan.bindGroupLayoutDict.bindGroupLayout2Dynamic,
		256,
		instance => {
			const {bound} = instance.getMaterial(BoundMaterial);
			buffer[0] = bound.minX;
			buffer[1] = bound.minY;
			buffer[2] = bound.minZ;
			buffer[4] = bound.maxX;
			buffer[5] = bound.maxY;
			buffer[6] = bound.maxZ;
			return buffer;
		}
	);
	Vulkan.events.addEventListener('update', () => slot.clear());
	return slot;
});

module.exports = BoundMaterial;
