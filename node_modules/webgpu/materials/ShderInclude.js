const {removeNestComments} = require('utils/text/removeComments');

const dict = {};

dict.quaternion = `
fn cast2mat(quaternion: vec4<f32>) -> mat3x3<f32> {
	let t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	let t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
	let t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

	let a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
	let b: vec3<f32> = (t0     - t1.zxy) * 2.0;
	let c: vec3<f32> = (t0.zxy + t1.yzx) * 2.0;

	return mat3x3<f32>(
		a.x, b.x, c.x,
		c.y, a.y, b.y,
		b.z, c.z, a.z
	);
}

fn cast2mat3x4(quaternion: vec4<f32>, offset: vec4<f32>) -> mat3x4<f32> {
	let t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	let t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
	let t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

	let a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
	let b: vec3<f32> = (t0     - t1.zxy) * 2;
	let c: vec3<f32> = (t0.zxy + t1.yzx) * 2;

	return mat3x4<f32>(
		a.x, b.x, c.x, offset.x,
		c.y, a.y, b.y, offset.y,
		b.z, c.z, a.z, offset.z
	);
}

fn cast2mat4x4(quaternion: vec4<f32>, offset: vec4<f32>) -> mat4x4<f32> {
	let t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
	let t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
	let t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

	let a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
	let b: vec3<f32> = (t0     - t1.zxy) * 2;
	let c: vec3<f32> = (t0.zxy + t1.yzx) * 2;

	return mat4x4<f32>(
		a.x, b.x, c.x, offset.x,
		c.y, a.y, b.y, offset.y,
		b.z, c.z, a.z, offset.z,
		0, 0, 0, 1
	);
}

fn slerp(a: vec4<f32>, vb: vec4<f32>, ratio: f32) -> vec4<f32> {
	var b = vb;
	var d = dot(a, b);
	if(d < 0){
		b = -b;
		d = -d;
	}
	if(d < 0.95){
		let angle = acos(d);
		let s1 = sin(angle * (1 - ratio));
		let s2 = sin(angle * ratio);
		return (a * s1 + b * s2) / sin(angle);
	}
	return normalize(mix(a, b, ratio));
}
`

dict.skeleton = `
#include<quaternion>

fn getBoneMatrix(boneStateTexture:texture_storage_2d_array<rgba32float,read>, boneJoints:vec4<u32>, boneWeights:vec4<f32>, instanceIndex:u32) -> mat3x4<f32> {
	var result:mat3x4<f32>;
	for(var i=0; i<4; i++){
		let weight = boneWeights[i];
		if weight <= 0 {continue;}
		let coords = vec2(boneJoints[i], instanceIndex);
		result += weight * mat3x4<f32>(
			textureLoad(boneStateTexture, coords, 0),
			textureLoad(boneStateTexture, coords, 1),
			textureLoad(boneStateTexture, coords, 2)
		);
	}
	return result;
}
`
/*
dict.skeleton = `
#include<quaternion>

fn getValue(ani_texture:texture_2d_array<f32>, time: f32, boneIndex: u32, animationIndex: u32, parentID: ptr<function,i32>) -> mat4x4<f32> {
	let fract_and_whole = modf(time);
	let u = u32(fract_and_whole.whole) << 1;
	let ratio = fract_and_whole.fract;
	
	let ar = textureLoad(ani_texture, vec2(u    , boneIndex), animationIndex, 0);
	let at = textureLoad(ani_texture, vec2(u + 1, boneIndex), animationIndex, 0);
	let br = textureLoad(ani_texture, vec2(u + 2, boneIndex), animationIndex, 0);
	let bt = textureLoad(ani_texture, vec2(u + 3, boneIndex), animationIndex, 0);

	*parentID = i32(at.w);

	return cast2mat4x4(slerp(ar, br, ratio), mix(at, bt, ratio));
}

fn getBoneMatrix(ani_texture:texture_2d_array<f32>, boneIndex: u32, info:vec4<f32>) -> mat3x4<f32> {
	var matrix = mat4x4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
	var boneID = boneIndex;
	var parentID: i32;
	loop {
		matrix *= getValue(ani_texture, info.x, boneID, u32(info.y), &parentID);
		continuing {
			boneID = u32(parentID);
			break if parentID < 0;
		}
	}
	return mat3x4<f32>(matrix[0], matrix[1], matrix[2]);
}
`
*/
dict.cast = `
fn m44tom33(m: mat4x4<f32>) -> mat3x3<f32> {return mat3x3<f32>(m[0].xyz, m[1].xyz, m[2].xyz);}
fn m34tom33(m: mat3x4<f32>) -> mat3x3<f32> {return mat3x3<f32>(m[0].xyz, m[1].xyz, m[2].xyz);}
fn m44tom34(m: mat4x4<f32>) -> mat3x4<f32> {return mat3x4<f32>(m[0], m[1], m[2]);}
`

dict.transform = `
fn positionWorldToScreen(worldPosition: vec3<f32>, vpMatrix:MVP) -> vec4<f32> {
	let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1) * vpMatrix.cameraMatrix;
	let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * vpMatrix.screenMatrix;
	return screenPosition;
}

struct MVP {
	screenMatrix: mat4x4<f32>,
	cameraMatrix: mat3x4<f32>,
}
`

dict.shadow = `
const shadow_bias:f32 = 0.001;

fn calc_shadow_2d(texture: texture_depth_2d, sampler_depth:sampler_comparison, pos_in_light_camera: vec3<f32>, lightScreenMatrix: mat4x4<f32>) -> f32 {
	let pos_in_light_screen = vec4<f32>(pos_in_light_camera, 1) * lightScreenMatrix;
	let uv = (vec2(pos_in_light_screen.x, -pos_in_light_screen.y) / pos_in_light_screen.w + 1) * 0.5;
	let depth = pos_in_light_screen.z / pos_in_light_screen.w;
	return textureSampleCompare(texture, sampler_depth, uv, depth - shadow_bias);//depth_ref <= the sampled depth
}

fn calc_shadow_cube(texture: texture_depth_cube, sampler_depth:sampler_comparison, pos_in_light_camera: vec3<f32>, lightScreenMatrix: mat4x4<f32>) -> f32 {
	let absv = abs(pos_in_light_camera);
	let maxComp = max(absv.x, max(absv.y, absv.z));
	let pos_in_light_screen = vec4<f32>(0, 0, maxComp, 1) * lightScreenMatrix;
	let depth = pos_in_light_screen.z / pos_in_light_screen.w;
	return textureSampleCompare(texture, sampler_depth, pos_in_light_camera, depth - shadow_bias);//depth_ref <= the sampled depth
}
`

dict.hsb = `
fn rgb2hsb(color:vec3<f32>) -> vec3<f32> {
	var hsb:vec3<f32>;
	let vMax = max(color.r, max(color.g, color.b));
	let vMin = min(color.r, min(color.g, color.b));
	if(vMax > 0){
		let t = vMax - vMin;
		hsb.y = t / vMax;
		hsb.z = vMax;
		if(t > 0){
			let diff = (color.gbr - color.brg) * 60 / t;
			let flag = color == vec3(vMax);
			if(flag.x){
				hsb.x = diff.x + select(0.0, 360.0, diff.x < 0);
			}else if(flag.y){
				hsb.x = diff.y + 120;
			}else{
				hsb.x = diff.z + 240;
			}
		}
	}
	return hsb;
}

fn hsb2rgb(hsb:vec3<f32>) -> vec3<f32> {
	let vMax = hsb.z;
	let vMin = hsb.z * (1 - hsb.y);
	let t = (hsb.x - vec4<f32>(0, 120, 240, 360)) * hsb.y * hsb.z / 60;
	if(hsb.x <  60){return vec3(vMax, vMin + t.x, vMin);}
	if(hsb.x < 120){return vec3(vMin - t.y, vMax, vMin);}
	if(hsb.x < 180){return vec3(vMin, vMax, vMin + t.y);}
	if(hsb.x < 240){return vec3(vMin, vMin - t.z, vMax);}
	if(hsb.x < 300){return vec3(vMin + t.z, vMin, vMax);}
	if(hsb.x < 360){return vec3(vMax, vMin, vMin - t.w);}
	return vec3<f32>();
}
`

dict['constant'] = `
const PI:f32 = 3.14159265358;
const E :f32 = 2.71828182846;
`

dict.gauss_blur = `
#include<constant>
fn GaussWeight2D(x:f32, y:f32, sigma:f32) -> f32 {
	let sigma_2 = 2 * sigma * sigma;
	return exp(-(x*x + y*y) / sigma_2) / (PI * sigma_2);
}

fn GaussNxN(v_texture:texture_2d<f32>, v_sampler:sampler, uv:vec2<f32>, n:i32, stride:vec2<f32>, sigma:f32) -> vec3<f32> {
	let r:i32 = n >> 1;
	var color:vec3<f32>;
	var weight:f32;

	for(var i:i32=-r; i<=r; i++){
		for(var j:i32=-r; j<=r; j++){
			let w = GaussWeight2D(f32(i), f32(j), sigma);
			let coord = uv + vec2<f32>(vec2(i, j)) * stride;
			color += textureSample(v_texture, v_sampler, coord).rgb * w;
			weight += w;
		}
	}

	return color / weight;
}
`

module.exports = function(){
	for(let k in dict)dict[k]=removeNestComments(dict[k]);
	const pattern = /#include<(\w+?)>/g;
	return function(code){
		const handled = new Set();
		const replaceFn = (line, name) => {
			if(handled.has(name))return '';
			handled.add(name);
			return dict[name];
		}
		code = removeNestComments(code);
		for(;;){
			const temp = code.replace(pattern, replaceFn);
			if(temp == code)break;
			code = temp;
		}
		return code;
	}
}();