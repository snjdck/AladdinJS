'use strict';

const Vulkan = require('../Vulkan');
const Pipeline = require('./Pipeline');
const Material = require('./Material');
const groupDraw = require('../helper/groupDraw');
const {fetchAnimationTexture} = require('../Vulkan/resource');
/*

unorm = unsigned normalized
snorm = signed normalized
uint = unsigned int
sint = signed int
float = floating point
const formatSize = {
	'uint8x2': 2, 'unorm8x2': 2, 'uint16x2': 4, 'unorm16x2': 4,
	'uint8x4': 4, 'unorm8x4': 4, 'uint16x4': 8, 'unorm16x4': 8,
	'sint8x2': 2, 'snorm8x2': 2, 'sint16x2': 4, 'snorm16x2': 4,
	'sint8x4': 4, 'snorm8x4': 4, 'sint16x4': 8, 'snorm16x4': 8,
	
	'uint32': 4, 'uint32x2': 8, 'uint32x3': 12, 'uint32x4': 16,
	'sint32': 4, 'sint32x2': 8, 'sint32x3': 12, 'sint32x4': 16,
	
	'float32': 4, 'float32x2': 8, 'float32x3': 12, 'float32x4': 16,

	'float16x2': 4, 'float16x4': 8,
};
enum GPUBlendFactor {
	'zero', 'one',
	'src', 'one-minus-src', 'src-alpha', 'one-minus-src-alpha',
	'dst', 'one-minus-dst', 'dst-alpha', 'one-minus-dst-alpha',
	'constant', 'one-minus-constant',
	'src-alpha-saturated'
};
enum GPUBlendOperation {
	'add', 'subtract', 'reverse-subtract', 'min', 'max'
};
*/
const maxCountPerDraw = 4;
const maxCountPerDrawStatic = 100;
const maxBoneCount = 128;

const pipeline = new Pipeline({
	groups: [[
		{name:'vpMatrix', binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}}
	], [
		{name:'worldMatrixList', binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}, temp:{array: new Float32Array(12 * maxCountPerDrawStatic), stride: 12, mapFn: v => v.entity.worldTransform.rawData}},
		//{name:'boneStateList', binding:1, visibility:GPUShaderStage.VERTEX, buffer:{}, temp:{array: new Float32Array(8 * maxBoneCount * maxCountPerDraw), stride: 8 * maxBoneCount, mapFn: ({entity}) => entity.copyBoneStateToTempBuffer().subarray(0, entity.skeleton.boneCount << 3)}},
		{name:'animationTexture', binding:2, visibility:GPUShaderStage.VERTEX, texture:{viewDimension: '2d-array', sampleType:'unfilterable-float'}},
		{name:'animationTextureInfo',binding:3, visibility:GPUShaderStage.VERTEX, buffer:{}, temp:{array: new Float32Array(4 * maxCountPerDrawStatic), stride: 4, mapFn: v => [v.animationTime ?? 0, v.animationIndex ?? 0]}},
	], [
		{name:'baseTexture', binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{}}
	]],
	vertex: {
		buffers: [{
			name: 'position',
			arrayStride: 4 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:0, offset: 0, format:'float32x3'}]
		}, {
			name: 'normal',
			arrayStride: 4 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:1, offset: 0, format:'float32x3'}]
		}, {
			name: 'uv',
			arrayStride: 2 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:2, offset: 0, format:'float32x2'}]
		}, {
			name: 'boneIndex',
			arrayStride: 1 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:3, offset: 0, format:'uint32'}]
		}],
		entryPoint: 'mainDynamic',
		code: `
			fn cast2mat(quaternion: vec4<f32>) -> mat3x3<f32> {
				let t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
				let t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
				let t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

				let a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
				let b: vec3<f32> = (t0     - t1.zxy) * 2.0;
				let c: vec3<f32> = (t0.zxy + t1.yzx) * 2.0;

				return mat3x3<f32>(
					a.x, b.x, c.x,
					c.y, a.y, b.y,
					b.z, c.z, a.z
				);
			}

			fn cast2mat4x4(quaternion: vec4<f32>, offset: vec4<f32>) -> mat4x4<f32> {
				let t0: vec3<f32> = quaternion.xyz * quaternion.yzx;	//xy,yz,zx
				let t1: vec3<f32> = quaternion.xyz * quaternion.www;	//xw,yw,zw
				let t2: vec4<f32> = quaternion * quaternion;			//xx,yy,zz,ww

				let a: vec3<f32> = t2.xyz + t2.www - t2.yzx - t2.zxy;
				let b: vec3<f32> = (t0     - t1.zxy) * 2;
				let c: vec3<f32> = (t0.zxy + t1.yzx) * 2;

				return mat4x4<f32>(
					a.x, b.x, c.x, offset.x,
					c.y, a.y, b.y, offset.y,
					b.z, c.z, a.z, offset.z,
					0, 0, 0, 1
				);
			}

			fn slerp(a: vec4<f32>, vb: vec4<f32>, ratio: f32) -> vec4<f32> {
				var b = vb;
				var d = dot(a, b);
				if(d < 0){
					b = -b;
					d = -d;
				}
				if(d < 0.95){
					let angle = acos(d);
					let s1 = sin(angle * (1 - ratio));
					let s2 = sin(angle * ratio);
					return (a * s1 + b * s2) / sin(angle);
				}
				return normalize(mix(a, b, ratio));
			}

			fn getValue(time: f32, boneIndex: u32, animationIndex: u32, instanceIndex: u32, parentID: ptr<function,i32>) -> mat4x4<f32> {
				let fract_and_whole = modf(time);
				let u = u32(fract_and_whole.whole) << 1;
				let ratio = fract_and_whole.fract;
				
				let ar = textureLoad(ani_texture, vec2(u    , boneIndex), animationIndex, 0);
				let at = textureLoad(ani_texture, vec2(u + 1, boneIndex), animationIndex, 0);
				let br = textureLoad(ani_texture, vec2(u + 2, boneIndex), animationIndex, 0);
				let bt = textureLoad(ani_texture, vec2(u + 3, boneIndex), animationIndex, 0);

				*parentID = i32(at.w);

				return cast2mat4x4(slerp(ar, br, ratio), mix(at, bt, ratio));
			}

			fn getBoneMatrix(boneIndex: u32, instanceIndex: u32) -> mat3x4<f32> {
				var matrix = mat4x4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
				var boneID = boneIndex;
				var parentID: i32;
				loop {
					matrix *= getValue(info[instanceIndex].x, boneID, u32(info[instanceIndex].y), instanceIndex, &parentID);
					continuing {
						boneID = u32(parentID);
						break if parentID < 0;
					}
				}
				return mat3x4<f32>(matrix[0], matrix[1], matrix[2]);
			}
/*
			fn getBoneMatrix(boneIndex: u32, instanceIndex: u32) -> mat3x4<f32> {
				var parentID = boneIndex;
				var matrix = mat4x4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
				loop {
					let index = calcBoneIndex(parentID, instanceIndex);
					matrix *= cast2mat4x4(boneStateList[index], boneStateList[index+1]);
					let offset = i32(boneStateList[index+1].w);
					if(offset < 0){break;}
					parentID = u32(offset);
				}
				return mat3x4<f32>(matrix[0], matrix[1], matrix[2]);
			}
*/
			fn m44tom33(m: mat4x4<f32>) -> mat3x3<f32> {return mat3x3<f32>(m[0].xyz, m[1].xyz, m[2].xyz);}
			fn m34tom33(m: mat3x4<f32>) -> mat3x3<f32> {return mat3x3<f32>(m[0].xyz, m[1].xyz, m[2].xyz);}
			fn m44tom34(m: mat4x4<f32>) -> mat3x4<f32> {return mat3x4<f32>(m[0], m[1], m[2]);}

			fn calcBoneIndex(bindBoneIndex: u32, instanceIndex: u32) -> u32 {
				return (instanceIndex * ${maxBoneCount} + bindBoneIndex) << 1;
			}

			fn positionWorldToScreen(worldPosition: vec3<f32>) -> vec4<f32> {
				let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1) * mvp.cameraMatrix;
				let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * mvp.screenMatrix;
				return screenPosition;
			}
			
			struct MVP {
				screenMatrix: mat4x4<f32>,
				cameraMatrix: mat3x4<f32>,
			}

			@group(0) @binding(0) var<uniform> mvp: MVP;
			@group(1) @binding(0) var<uniform> worldMatrixList: array<mat3x4<f32>, ${maxCountPerDrawStatic}>;
			//@group(1) @binding(1) var<uniform> boneStateList: array<vec4<f32>, ${2 * maxBoneCount * maxCountPerDraw}>;
			@group(2) @binding(1) var<uniform> boneStateList: array<vec4<f32>, 1>;
			@group(1) @binding(2) var ani_texture: texture_2d_array<f32>;
			@group(1) @binding(3) var<uniform> info: array<vec4<f32>, ${maxCountPerDrawStatic}>;

			struct OutputForward {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
			}

			struct OutputDeferred {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
				@location(2) world_normal: vec3<f32>,
				//@location(3) world_position: vec3<f32>,
			}

			@vertex
			fn mainDynamic(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(1) normal: vec3<f32>,
				@location(2) uv: vec2<f32>,
				@location(3) boneIndex: u32,
			) -> OutputForward {
				let boneMatrix = getBoneMatrix(boneIndex, instanceIndex);
				let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;
				let modelNormal: vec3<f32> = normal * m34tom33(boneMatrix);

				let worldMatrix = worldMatrixList[instanceIndex];
				let worldPosition = vec4<f32>(modelPosition, 1) * worldMatrix;
				let worldNormal = modelNormal * m34tom33(worldMatrix);

				var output: OutputForward;
				output.position = positionWorldToScreen(worldPosition);
				output.uv = uv;
				return output;
			}

			@vertex
			fn mainStatic(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
			) -> @builtin(position) vec4<f32> {
				let mat = worldMatrixList[instanceIndex];
				return positionWorldToScreen(vec4<f32>(position, 1) * mat);
			}

			@vertex
			fn mainBillboard(
				@builtin(instance_index) instanceIndex: u32,
				@builtin(vertex_index) vertexIndex: u32,
			) -> OutputForward {
				let vertex = vec2<f32>(vec2(vertexIndex >> 1, vertexIndex & 1));
				let xyDiff = (vertex * 2 - 1) * boneStateList[0].xy;
				
				let worldMatrix = worldMatrixList[instanceIndex];
				let worldPosition = vec4<f32>(worldMatrix[0].w, worldMatrix[1].w, worldMatrix[2].w, 1);
				var cameraPosition = worldPosition * mvp.cameraMatrix;

				cameraPosition.x = cameraPosition.x + xyDiff.x;
				cameraPosition.y = cameraPosition.y + xyDiff.y;

				let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * mvp.screenMatrix;

				var output: OutputForward;
				output.position = screenPosition;
				output.uv = vertex;
				return output;
			}

			@vertex
			fn mainDepth(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(3) boneIndex: u32,
			) -> @builtin(position) vec4<f32> {
				let boneMatrix = getBoneMatrix(boneIndex, instanceIndex);
				let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;
				return positionWorldToScreen(vec4<f32>(modelPosition, 1) * worldMatrixList[instanceIndex]);
			}

			@vertex
			fn mainCubeDepth(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(3) boneIndex: u32,
			) -> @builtin(position) vec4<f32> {
				let boneMatrix = getBoneMatrix(boneIndex, instanceIndex);
				let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;
				let worldPosition = vec4<f32>(modelPosition, 1) * worldMatrixList[instanceIndex];

				let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1) * mvp.cameraMatrix;
				let depth = dot(vec4(vec3(1), 1 / length(cameraPosition)), mvp.screenMatrix[2]);
				
				return vec4<f32>(cameraPosition.xy, depth * cameraPosition.z, cameraPosition.z);
			}

			@vertex
			fn mainDeferred(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(1) normal: vec3<f32>,
				@location(2) uv: vec2<f32>,
				@location(3) boneIndex: u32,
			) -> OutputDeferred {
				let boneMatrix = getBoneMatrix(boneIndex, instanceIndex);
				let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;
				let modelNormal: vec3<f32> = normal * m34tom33(boneMatrix);

				let worldMatrix = worldMatrixList[instanceIndex];
				let worldPosition = vec4<f32>(modelPosition, 1) * worldMatrix;
				let worldNormal = modelNormal * m34tom33(worldMatrix);

				var output: OutputDeferred;
				output.position = positionWorldToScreen(worldPosition);
				output.uv = uv;
				//output.world_position = worldPosition;
				output.world_normal = worldNormal;
				output.instanceIndex = instanceIndex;
				return output;
			}

			struct OutputPick {
				@builtin(position) position: vec4<f32>,
				@location(0) @interpolate(flat) id: u32,
			}

			@vertex
			fn mainPick(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(1) meshId: u32,
				@location(3) boneIndex: u32,
			) -> OutputPick {
				let boneMatrix = getBoneMatrix(boneIndex, instanceIndex);
				let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;

				let worldMatrix = worldMatrixList[instanceIndex];
				let worldPosition = vec4<f32>(modelPosition, 1) * worldMatrix;

				return OutputPick(positionWorldToScreen(worldPosition), meshId);
			}
		`
	},
	fragment: {
		targets:[{
			writeMask: GPUColorWrite.ALL,
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}],
		entryPoint: 'main',
		code: `
			@group(0) @binding(1) var g_sampler: sampler;
			@group(2) @binding(0) var g_texture: texture_2d<f32>;

			@fragment
			fn main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
				return textureSample(g_texture, g_sampler, uv);
			}

			@fragment
			fn mainColor() -> @location(0) vec4<f32> {
				return vec4<f32>(1, 0, 0, 1);
			}
			
			//The fragment stage has fewer output components (3) than the color format (TextureFormat::RGBA32Float) component count (4).
			struct OutputDeferred {
				@location(0) color: vec4<f32>,
				@location(1) normal: vec2<f32>,
				//@location(2) position: vec4<f32>,
			}

			@fragment
			fn mainDeferred(
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
				@location(2) normal: vec3<f32>,
				//@location(3) position: vec3<f32>,
			) -> OutputDeferred {
				return OutputDeferred(textureSample(g_texture, g_sampler, uv), normalize(normal).xy);
			}
		`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: true,
		depthCompare: 'less-equal',//always, never, equal, not-equal, less, less-equal, greater, greater-equal
		stencilFront: {
			compare: 'always',
			depthFailOp: 'keep',//keep, zero, replace, invert, increment-clamp, decrement-clamp, increment-wrap, decrement-wrap
			failOp: 'keep',
			passOp: 'keep',
		},
		stencilBack: {
			compare: 'always',
			depthFailOp: 'keep',
			failOp: 'keep',
			passOp: 'keep',
		},
		stencilReadMask: 0xFFFFFFFF,
		stencilWriteMask: 0xFFFFFFFF,
		depthBias: 0,
		depthBiasSlopeScale: 0,
		depthBiasClamp: 0,
	},
	primitive: {
		cullMode: 'none',//none, back, front
		frontFace: 'ccw',//cw, ccw
		topology: 'triangle-list',//point-list, line-list, line-strip, triangle-list, triangle-strip
		stripIndexFormat: undefined,//uint16, uint32
		unclippedDepth: false
	}
});

const wireframePipeline = pipeline.clone({
	groups: v => v.slice(0, 2),
	buffers: v => [v[0], v[3]],
	vertex:{entryPoint: 'mainDepth'},
	fragment:{entryPoint:'mainColor'},
	primitive:{topology: 'line-list'}
});

class TextureMaterial extends Material.Subclass(pipeline){
	static maxCountPerDraw = maxCountPerDrawStatic;
	static onDraw(list, renderPassEncoder){
		for(let [isWireframe, list3] of Map.groupBy(list, v => v.material.wireframe)){
			(isWireframe ? wireframePipeline : this.pipeline).setPipeline(renderPassEncoder);
			for(let [skeletonMesh, list2] of Map.groupBy(list3, v => v.entity.skeleton.mesh)){
				const {textureView} = fetchAnimationTexture(skeletonMesh);
				for(let [{subMeshList}, itemList] of Map.groupBy(list2, v => v.entity.mesh)){
					for(let drawUnitList of Material.Utils.cut(maxCountPerDrawStatic, itemList)){
						this.setResources(renderPassEncoder, {
							'worldMatrixList': {buffer:drawUnitList},
							'animationTexture':textureView,
							'animationTextureInfo':{buffer:drawUnitList.map(v => v.entity.skeleton)},
						});
						for(let i=0, n=subMeshList.length; i<n; ++i){
							const subMesh = subMeshList[i];
							if(isWireframe){
								const {position, boneIndex, indexWireframe} = subMesh.attributes;
								wireframePipeline.setResources(renderPassEncoder, {position, boneIndex, index:indexWireframe});
							}else{
								const texture = this.onFetchTexture(subMesh.texture, drawUnitList[0].material);
								if(!texture)continue;
								const {position, normal, uv, boneIndex} = subMesh.attributes;
								this.setResources(renderPassEncoder, {position, normal, uv, boneIndex, 'baseTexture': texture.createView()});
							}
							const subMeshFilter = 1 << i;
							for(let [offset, count] of groupDraw(v => drawUnitList[v].material.subMeshFilter & subMeshFilter, drawUnitList.length)){
								if(isWireframe){
									const {indexWireframe} = subMesh.attributes;
									renderPassEncoder.drawIndexed(indexWireframe.length, count, 0, 0, offset);
								}else{
									renderPassEncoder.draw(subMesh.vertexCount, count, 0, offset);
								}
							}
						}
					}
				}
			}
		}
	}

	static onFetchTexture(texture){
		return Vulkan.loadTexture(texture, false);
	}

	constructor(subMeshFilter=0xFFFFFFFF){
		super();
		this.subMeshFilter = subMeshFilter;
		this.wireframe = false;
	}

	get depth(){
		return Object.assign(new DepthMaterial(), {
			subMeshFilter: this.subMeshFilter
		});
	}

	get cubeDepth(){
		return Object.assign(new CubeDepthMaterial(), {
			subMeshFilter: this.subMeshFilter
		});
	}
}

const depthPipeline = pipeline.clone({
	groups: v => v.slice(0, 2),
	buffers: v => [v[0], v[3]],
	vertex:{entryPoint: 'mainDepth'},
	fragment:null,
	depthStencil: {format: 'depth32float'}
});

const cubeDepthPipeline = depthPipeline.clone({vertex:{entryPoint: 'mainCubeDepth'}});

class DepthMaterial extends Material.Subclass(depthPipeline){
	static onDraw(list, renderPassEncoder){
		for(let [skeletonMesh, list2] of Map.groupBy(list, v => v.entity.skeleton.mesh)){
			const {textureView} = fetchAnimationTexture(skeletonMesh);
			for(let [{subMeshList}, itemList] of Map.groupBy(list2, v => v.entity.mesh)){
				for(let drawUnitList of Material.Utils.cut(maxCountPerDrawStatic, itemList)){
					this.pipeline.setResources(renderPassEncoder, {
						'worldMatrixList': {buffer:drawUnitList},
						'animationTexture':textureView,
						'animationTextureInfo':{buffer:drawUnitList.map(v => v.entity.skeleton)},
					});
					for(let i=0, n=subMeshList.length; i<n; ++i){
						const subMesh = subMeshList[i];
						const {position, boneIndex} = subMesh.attributes;
						this.pipeline.setResources(renderPassEncoder, {position, boneIndex});
						const subMeshFilter = 1 << i;
						for(let [offset, count] of groupDraw(v => drawUnitList[v].material.subMeshFilter & subMeshFilter, drawUnitList.length)){
							renderPassEncoder.draw(subMesh.vertexCount, count, 0, offset);
						}
					}
				}
			}
		}
	}
}

const CubeDepthMaterial = DepthMaterial.Subclass(cubeDepthPipeline);

module.exports = TextureMaterial;
