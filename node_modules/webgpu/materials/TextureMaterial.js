'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const groupDraw = require('../helper/groupDraw');
const {genVertexBuffer} = require('./computePasses/BonePass');
const {bufferCache} = require('../Vulkan/resource');
/*

unorm = unsigned normalized
snorm = signed normalized
uint = unsigned int
sint = signed int
float = floating point
const formatSize = {
	'uint8x2': 2, 'unorm8x2': 2, 'uint16x2': 4, 'unorm16x2': 4,
	'uint8x4': 4, 'unorm8x4': 4, 'uint16x4': 8, 'unorm16x4': 8,
	'sint8x2': 2, 'snorm8x2': 2, 'sint16x2': 4, 'snorm16x2': 4,
	'sint8x4': 4, 'snorm8x4': 4, 'sint16x4': 8, 'snorm16x4': 8,
	
	'uint32': 4, 'uint32x2': 8, 'uint32x3': 12, 'uint32x4': 16,
	'sint32': 4, 'sint32x2': 8, 'sint32x3': 12, 'sint32x4': 16,
	
	'float32': 4, 'float32x2': 8, 'float32x3': 12, 'float32x4': 16,

	'float16x2': 4, 'float16x4': 8,
};
enum GPUBlendFactor {
	'zero', 'one',
	'src', 'one-minus-src', 'src-alpha', 'one-minus-src-alpha',
	'dst', 'one-minus-dst', 'dst-alpha', 'one-minus-dst-alpha',
	'constant', 'one-minus-constant',
	'src-alpha-saturated'
};
enum GPUBlendOperation {
	'add', 'subtract', 'reverse-subtract', 'min', 'max'
};
*/
const maxCountPerDraw = 4;
const maxCountPerDrawStatic = 100;
const maxBoneCount = 128;

const pipeline = {
	groups: [[
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}}
	], [
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}, temp:{array: new Float32Array(12 * maxCountPerDrawStatic), stride: 12, mapFn: v => v.entity.worldTransform.rawData}},
	], [
		{binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{}}
	]],
	vertex: {
		buffers: [{
			name: 'position',
			arrayStride: 4 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:0, offset: 0, format:'float32x3'}]
		}, {
			name: 'normal',
			arrayStride: 4 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:1, offset: 0, format:'float32x3'}]
		}, {
			name: 'uv',
			arrayStride: 2 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:2, offset: 0, format:'float32x2'}]
		}],
		entryPoint: 'main',
		code: `
			struct MVP {
				screenMatrix: mat4x4<f32>,
				cameraMatrix: mat3x4<f32>,
			};

			struct TRANSFORM_BLOCK {
				matrixList: array<mat3x4<f32>, ${maxCountPerDrawStatic}>,
			};

			@group(0) @binding(0) var<uniform> mvp: MVP;
			@group(1) @binding(0) var<uniform> worldMatrixBlock: TRANSFORM_BLOCK;

			struct InputForward {
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(1) normal: vec3<f32>,
				@location(2) uv: vec2<f32>,
				//@location(3) boneIndex: u32,
			};

			struct InputDeferred {
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(1) normal: vec3<f32>,
				@location(2) uv: vec2<f32>,
				//@location(3) boneIndex: u32,
			};

			struct OutputForward {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
				@location(2) normal: vec3<f32>,
			};

			struct OutputDeferred {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
				@location(2) normal: vec3<f32>,
			};

			@vertex
			fn main(input: InputForward) -> OutputForward {
				var worldPosition: vec3<f32> = input.position;
				var worldNormal: vec3<f32> = input.normal;


				var worldMatrix: mat3x4<f32> = worldMatrixBlock.matrixList[input.instanceIndex];

				worldPosition = vec4<f32>(worldPosition, 1.0) * worldMatrix;
				worldNormal = worldNormal * mat3x3<f32>(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz);
				
				var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraMatrix;
				var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.screenMatrix;
/*
				var viewportXYWH: vec4<f32> = mvp.viewportXYWH;
				var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy * screenPosition.w);
				screenPosition.x = t.x;
				screenPosition.y = t.y;
*/
				var output: OutputForward;
				output.position = screenPosition;
				output.normal = worldNormal;
				output.uv = input.uv;
				output.instanceIndex = input.instanceIndex;
				return output;
			}

			@vertex
			fn mainDeferred(input: InputDeferred) -> OutputDeferred {
				var worldPosition: vec3<f32> = input.position;
				var worldNormal: vec3<f32> = input.normal;

				var worldMatrix: mat3x4<f32> = worldMatrixBlock.matrixList[input.instanceIndex];

				worldPosition = vec4<f32>(worldPosition, 1.0) * worldMatrix;
				worldNormal = worldNormal * mat3x3<f32>(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz);
				
				var cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraMatrix;
				var screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.screenMatrix;
/*
				var viewportXYWH: vec4<f32> = mvp.viewportXYWH;
				var t: vec2<f32> = fma(screenPosition.xy, viewportXYWH.zw, viewportXYWH.xy * screenPosition.w);
				screenPosition.x = t.x;
				screenPosition.y = t.y;
*/
				var output: OutputDeferred;
				output.position = screenPosition;
				output.normal = worldNormal;
				output.uv = input.uv;
				output.instanceIndex = input.instanceIndex;
				return output;
			}

			@vertex
			fn mainStatic(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
			) -> @builtin(position) vec4<f32> {
				let worldPosition: vec3<f32> = vec4<f32>(position, 1.0) * worldMatrixBlock.matrixList[instanceIndex];
				let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1.0) * mvp.cameraMatrix;
				let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1.0) * mvp.screenMatrix;

				return screenPosition;
			}
		`
	},
	fragment: {
		targets:[{
			writeMask: GPUColorWrite.ALL,
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}],
		entryPoint: 'main',
		code: `
			@group(0) @binding(1) var g_sampler: sampler;
			@group(2) @binding(0) var g_texture: texture_2d<f32>;

			struct Input {
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
				@location(2) normal: vec3<f32>,
			};

			struct Output {
				@location(0) color: vec4<f32>,
			};

			@fragment
			fn main(input: Input) -> Output {
				var output: Output;
				output.color = textureSample(g_texture, g_sampler, input.uv);
				return output;
			}

			@fragment
			fn mainColor() -> @location(0) vec4<f32> {
				return vec4<f32>(1, 0, 0, 1);
			}

			struct InputDeferred {
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
				@location(2) normal: vec3<f32>,
			};

			struct OutputDeferred {
				@location(0) color: vec4<f32>,
			};

			@fragment
			fn mainDeferred(input: InputDeferred) -> OutputDeferred {
				var output: OutputDeferred;
				output.color = textureSample(g_texture, g_sampler, input.uv);
				return output;
			}
		`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: true,
		depthCompare: 'less-equal',//always, never, equal, not-equal, less, less-equal, greater, greater-equal
		stencilFront: {
			compare: 'always',
			depthFailOp: 'keep',//keep, zero, replace, invert, increment-clamp, decrement-clamp, increment-wrap, decrement-wrap
			failOp: 'keep',
			passOp: 'keep',
		},
		stencilBack: {
			compare: 'always',
			depthFailOp: 'keep',
			failOp: 'keep',
			passOp: 'keep',
		},
		stencilReadMask: 0xFFFFFFFF,
		stencilWriteMask: 0xFFFFFFFF,
		depthBias: 0,
		depthBiasSlopeScale: 0,
		depthBiasClamp: 0,
	},
	primitive: {
		cullMode: 'none',//none, back, front
		frontFace: 'ccw',//cw, ccw
		topology: 'triangle-list',//point-list, line-list, line-strip, triangle-list, triangle-strip
		stripIndexFormat: undefined,//uint16, uint32
		unclippedDepth: false
	}
};

class TextureMaterial extends Material.Subclass(pipeline, [Material.Utils.groupMesh]){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(drawUnitList, {subMeshList}, renderPassEncoder){
		for(let drawUnit of drawUnitList){
			const bufferList = genVertexBuffer(subMeshList, drawUnit.entity);
			this.setBindGroup(renderPassEncoder, 1, [
				{binding:0, resource:{buffer:drawUnitList}},//transform
			]);
			for(let i=0, n=subMeshList.length; i<n; ++i){
				const subMesh = subMeshList[i];
				const texture = Vulkan.loadTexture(subMesh.texture, false);
				if(!texture)continue;
				this.setBindGroup(renderPassEncoder, 2, [{binding:0, resource:texture.createView()}]);
				renderPassEncoder.setVertexBuffer(0, bufferList[i].position);
				renderPassEncoder.setVertexBuffer(1, bufferList[i].normal);
				renderPassEncoder.setVertexBuffer(2, bufferCache(subMesh.attributes.uv, GPUBufferUsage.VERTEX));
				const subMeshFilter = 1 << i;
				for(let [offset, count] of groupDraw(v => drawUnitList[v].material.subMeshFilter & subMeshFilter, drawUnitList.length)){
					subMesh.draw(renderPassEncoder, count, offset);
				}
			}
		}
	}
	constructor(subMeshFilter=0xFFFFFFFF){
		super();
		this.subMeshFilter = subMeshFilter;
	}
}

module.exports = TextureMaterial;
