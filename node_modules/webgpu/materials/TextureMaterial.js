'use strict';

const Pipeline = require('./Pipeline');
const Material = require('./Material');
const groupDraw = require('../helper/groupDraw');
/*

unorm = unsigned normalized
snorm = signed normalized
uint = unsigned int
sint = signed int
float = floating point
const formatSize = {
	'uint8x2': 2, 'unorm8x2': 2, 'uint16x2': 4, 'unorm16x2': 4,
	'uint8x4': 4, 'unorm8x4': 4, 'uint16x4': 8, 'unorm16x4': 8,
	'sint8x2': 2, 'snorm8x2': 2, 'sint16x2': 4, 'snorm16x2': 4,
	'sint8x4': 4, 'snorm8x4': 4, 'sint16x4': 8, 'snorm16x4': 8,
	
	'uint32': 4, 'uint32x2': 8, 'uint32x3': 12, 'uint32x4': 16,
	'sint32': 4, 'sint32x2': 8, 'sint32x3': 12, 'sint32x4': 16,
	
	'float32': 4, 'float32x2': 8, 'float32x3': 12, 'float32x4': 16,

	'float16x2': 4, 'float16x4': 8,
};
enum GPUBlendFactor {
	'zero', 'one',
	'src', 'one-minus-src', 'src-alpha', 'one-minus-src-alpha',
	'dst', 'one-minus-dst', 'dst-alpha', 'one-minus-dst-alpha',
	'constant', 'one-minus-constant',
	'src-alpha-saturated'
};
enum GPUBlendOperation {
	'add', 'subtract', 'reverse-subtract', 'min', 'max'
};
*/
const maxCountPerDraw = 4;
const maxCountPerDrawStatic = 100;
const maxBoneCount = 128;

const pipeline = new Pipeline({
	groups: [
		[{name:'vpMatrix', type:'MVP', buffer:{}}],
		[{name:'worldMatrixList', type:`array<mat3x4<f32>>`, buffer:{type:'read-only-storage'}}, {name:'boneStateTexture', texture:{viewDimension: '2d-array', sampleType:'unfilterable-float'}}],
		[{name:'baseTexture', texture:{}}, {name:'g_sampler', sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}}]
	],
	vertex: {
		buffers: [
			{name: 'position', arrayStride: 4 << 2, attributes: [{format:'float32x3'}]},
			{name: 'normal', arrayStride: 4 << 2, attributes: [{format:'float32x3'}]},
			{name: 'uv', attributes: [{format:'float32x2'}]},
			{name: 'boneIndex', attributes: [{format:'uint32'}]},
			{name: 'info', stepMode: 'instance', attributes: [{format:'uint32x2'}], temp:{type:Uint32Array, mapFn: v => [v.entity.$id_world, v.entity.skeleton.$id_boneState]}}
		],
		code: `
			#include<skeleton>
			#include<transform>
			#include<cast>

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
			}

			@vertex Output {
				let boneMatrix = getBoneMatrix(boneStateTexture, boneIndex, info.y);
				let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;
				let modelNormal: vec3<f32> = normal * m34tom33(boneMatrix);

				let worldMatrix = worldMatrixList[info.x];
				let worldPosition = vec4<f32>(modelPosition, 1) * worldMatrix;
				let worldNormal = modelNormal * m34tom33(worldMatrix);

				return Output(positionWorldToScreen(worldPosition, vpMatrix), uv);
			}
		`
	},
	fragment: {
		targets:[{
			writeMask: GPUColorWrite.ALL,
			format: 'bgra8unorm',
			blend: 'src-alpha add one-minus-src-alpha'
		}],
		code: `
			#include<hsb>
			@fragment{
				let color = textureSample(baseTexture, g_sampler, uv);
				var hsb = rgb2hsb(color.rgb);
				hsb.z *= 1.5;
				return vec4<f32>(hsb2rgb(hsb), color.a);
			}
		`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: true,
		depthCompare: 'less-equal',//always, never, equal, not-equal, less, less-equal, greater, greater-equal
		stencilFront: {
			compare: 'always',
			depthFailOp: 'keep',//keep, zero, replace, invert, increment-clamp, decrement-clamp, increment-wrap, decrement-wrap
			failOp: 'keep',
			passOp: 'keep',
		},
		stencilBack: {
			compare: 'always',
			depthFailOp: 'keep',
			failOp: 'keep',
			passOp: 'keep',
		},
		stencilReadMask: 0xFFFFFFFF,
		stencilWriteMask: 0xFFFFFFFF,
		depthBias: 0,
		depthBiasSlopeScale: 0,
		depthBiasClamp: 0,
	},
	primitive: {
		cullMode: 'none',//none, back, front
		frontFace: 'ccw',//cw, ccw
		topology: 'triangle-list',//point-list, line-list, line-strip, triangle-list, triangle-strip
		stripIndexFormat: undefined,//uint16, uint32
		unclippedDepth: false
	}
});

const vertexPosition = `
#include<skeleton>
#include<transform>
@vertex{
	let boneMatrix = getBoneMatrix(boneStateTexture, boneIndex, info.y);
	let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;
	return positionWorldToScreen(vec4<f32>(modelPosition, 1) * worldMatrixList[info.x], vpMatrix);
}
`

const wireframePipeline = new Pipeline({
	groups: [[{name:'vpMatrix', type:'MVP', buffer:{}}], [{name:'worldMatrixList', type:`array<mat3x4<f32>>`, buffer:{type:'read-only-storage'}}, {name:'boneStateTexture', texture:{viewDimension: '2d-array', sampleType:'unfilterable-float'}}]],
	vertex:{code:vertexPosition,buffers:[
		{name: 'position', arrayStride: 4 << 2, attributes: [{format:'float32x3'}]},
		{name: 'boneIndex', attributes: [{format:'uint32'}]},
		{name: 'info', stepMode: 'instance', attributes: [{format:'uint32x2'}], temp:{type:Uint32Array, mapFn: v => [v.entity.$id_world, v.entity.skeleton.$id_boneState]}}
	]},
	fragment:{code:`@fragment{return vec4(1, 0, 0, 1);}`,targets:[{blend: 'src-alpha add one-minus-src-alpha'}]},
	depthStencil:{},
	primitive:{topology: 'line-list'}
});

class TextureMaterial extends Material.Subclass(pipeline){
	static maxCountPerDraw = maxCountPerDrawStatic;
	static onDraw(list, renderPassEncoder){
		renderPassEncoder.setResources({
			'worldMatrixList': {buffer:renderPassEncoder.data.worldMatrixList},
			'boneStateTexture': renderPassEncoder.data.boneStateTexture
		});
		for(let [isWireframe, list3] of Map.groupBy(list, v => v.material.wireframe)){
			renderPassEncoder.setPipeline(isWireframe ? wireframePipeline : this.pipeline);
			
				for(let [{subMeshList}, itemList] of Map.groupBy(list3, v => v.entity.mesh)){
					for(let drawUnitList of Material.Utils.cut(maxCountPerDrawStatic, itemList)){
						renderPassEncoder.setResources({'info':drawUnitList});
						for(let i=0, n=subMeshList.length; i<n; ++i){
							const subMesh = subMeshList[i];
							if(isWireframe){
								const {position, boneIndex, indexWireframe} = subMesh.attributes;
								renderPassEncoder.setResources({position, boneIndex, index:indexWireframe});
							}else{
								const texture = this.onFetchTexture(subMesh.texture, drawUnitList[0].material, renderPassEncoder);
								if(!texture)continue;
								const {position, normal, uv, boneIndex} = subMesh.attributes;
								renderPassEncoder.setResources({position, normal, uv, boneIndex, 'baseTexture': texture.createView()});
							}
							const subMeshFilter = 1 << i;
							for(let [offset, count] of groupDraw(v => drawUnitList[v].material.subMeshFilter & subMeshFilter, drawUnitList.length)){
								if(isWireframe){
									renderPassEncoder.drawIndexedAuto(count, offset);
								}else{
									renderPassEncoder.draw(subMesh.vertexCount, count, 0, offset);
								}
							}
						}
					}
				}
			//}
		}
	}

	static onFetchTexture(texture, material, renderPassEncoder){
		return renderPassEncoder.loadTexture(texture, false)
	}

	constructor(subMeshFilter=0xFFFFFFFF){
		super();
		this.subMeshFilter = subMeshFilter;
		this.wireframe = false;
	}

	get depth(){
		return Object.assign(new DepthMaterial(), {
			subMeshFilter: this.subMeshFilter
		});
	}

	get pick(){
		return Object.assign(new PickMaterial(), {
			subMeshFilter: this.subMeshFilter
		});
	}
}
/*
class TextureMaterial extends Material.Subclass(pipeline){
	static maxCountPerDraw = maxCountPerDrawStatic;
	static onDraw(list, renderPassEncoder){
		for(let [isWireframe, list3] of Map.groupBy(list, v => v.material.wireframe)){
			renderPassEncoder.setPipeline(isWireframe ? wireframePipeline : this.pipeline);
			for(let [skeletonMesh, list2] of Map.groupBy(list3, v => v.entity.skeleton.mesh)){
				const {textureView} = renderPassEncoder.fetchAnimationTexture(skeletonMesh);
				for(let [{subMeshList}, itemList] of Map.groupBy(list2, v => v.entity.mesh)){
					for(let drawUnitList of Material.Utils.cut(maxCountPerDrawStatic, itemList)){
						renderPassEncoder.setResources({
							'worldMatrixList': {buffer:drawUnitList},
							'animationTexture':textureView,
							'animationTextureInfo':{buffer:drawUnitList.map(v => v.entity.skeleton)},
						});
						for(let i=0, n=subMeshList.length; i<n; ++i){
							const subMesh = subMeshList[i];
							if(isWireframe){
								const {position, boneIndex, indexWireframe} = subMesh.attributes;
								renderPassEncoder.setResources({position, boneIndex, index:indexWireframe});
							}else{
								const texture = this.onFetchTexture(subMesh.texture, drawUnitList[0].material, renderPassEncoder);
								if(!texture)continue;
								const {position, normal, uv, boneIndex} = subMesh.attributes;
								renderPassEncoder.setResources({position, normal, uv, boneIndex, 'baseTexture': texture.createView()});
							}
							const subMeshFilter = 1 << i;
							for(let [offset, count] of groupDraw(v => drawUnitList[v].material.subMeshFilter & subMeshFilter, drawUnitList.length)){
								if(isWireframe){
									renderPassEncoder.drawIndexedAuto(count, offset);
								}else{
									renderPassEncoder.draw(subMesh.vertexCount, count, 0, offset);
								}
							}
						}
					}
				}
			}
		}
	}

	static onFetchTexture(texture, material, renderPassEncoder){
		return renderPassEncoder.loadTexture(texture, false)
	}

	constructor(subMeshFilter=0xFFFFFFFF){
		super();
		this.subMeshFilter = subMeshFilter;
		this.wireframe = false;
	}

	get depth(){
		return Object.assign(new DepthMaterial(), {
			subMeshFilter: this.subMeshFilter
		});
	}

	get pick(){
		return Object.assign(new PickMaterial(), {
			subMeshFilter: this.subMeshFilter
		});
	}
}
*/
const depthPipeline = new Pipeline({
	groups: [[{name:'vpMatrix', type:'MVP', buffer:{}}], [
		{name:'worldMatrixList', type:`array<mat3x4<f32>>`, buffer:{type:'read-only-storage'}},
		{name:'boneStateTexture', texture:{viewDimension: '2d-array', sampleType:'unfilterable-float'}}
	]],
	vertex:{code:vertexPosition,buffers:[
		{name: 'position', arrayStride: 4 << 2, attributes: [{format:'float32x3'}]},
		{name: 'boneIndex', attributes: [{format:'uint32'}]},
		{name: 'info', stepMode: 'instance', attributes: [{format:'uint32x2'}], temp:{type:Uint32Array, mapFn: v => [v.entity.$id_world, v.entity.skeleton.$id_boneState]}}
	]},
	depthStencil: {format: 'depth32float'}
});

class DepthMaterial extends Material.Subclass(depthPipeline){
	static onDraw(list, renderPassEncoder){
		renderPassEncoder.setResources({
			'worldMatrixList': {buffer:renderPassEncoder.data.worldMatrixList},
			'boneStateTexture': renderPassEncoder.data.boneStateTexture
		});
			for(let [{subMeshList}, itemList] of Map.groupBy(list, v => v.entity.mesh)){
				for(let drawUnitList of Material.Utils.cut(maxCountPerDrawStatic, itemList)){
					renderPassEncoder.setResources({'info':drawUnitList});
					for(let i=0, n=subMeshList.length; i<n; ++i){
						const subMesh = subMeshList[i];
						const {position, boneIndex} = subMesh.attributes;
						renderPassEncoder.setResources({position, boneIndex});
						const subMeshFilter = 1 << i;
						for(let [offset, count] of groupDraw(v => drawUnitList[v].material.subMeshFilter & subMeshFilter, drawUnitList.length)){
							renderPassEncoder.draw(subMesh.vertexCount, count, 0, offset);
						}
					}
				}
			}
		//}
	}
}

const pickPipeline = Pipeline.Pick(
	[[
		{name:'worldMatrixList', type:`array<mat3x4<f32>>`, buffer:{type:'read-only-storage'}},
		{name:'boneStateTexture', texture:{viewDimension: '2d-array', sampleType:'unfilterable-float'}}
	]],
	[
		{name: 'position', arrayStride: 4 << 2, attributes: [{format:'float32x3'}]},
		{name: 'boneIndex', attributes: [{format:'uint32'}]},
		{name: 'info', stepMode: 'instance', attributes: [{format:'uint32x2'}], temp:{type:Uint32Array, mapFn: v => [v.entity.$id_world, v.entity.skeleton.$id_boneState]}}
	],
	`
	#include<transform>
	#include<skeleton>

	@vertex Output {
		let boneMatrix = getBoneMatrix(boneStateTexture, boneIndex, info.y);
		let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;

		let worldMatrix = worldMatrixList[info.x];
		let worldPosition = vec4<f32>(modelPosition, 1) * worldMatrix;

		return Output(positionWorldToScreen(worldPosition, vpMatrix), worldPosition, meshId);
	}
`);

class PickMaterial extends Material.Subclass(pickPipeline){
	static onDraw(drawUnitList, renderPassEncoder){
		renderPassEncoder.setResources({
			'worldMatrixList': {buffer:renderPassEncoder.data.worldMatrixList},
			'boneStateTexture': renderPassEncoder.data.boneStateTexture
		});
		
		for(let [{subMeshList}, itemList] of Material.Utils.groupMesh(drawUnitList)){
			renderPassEncoder.setResources({
				'info':itemList,
				'meshId':itemList
			});
			for(let i=0, n=subMeshList.length; i<n; ++i){
				const subMesh = subMeshList[i];
				const {position, boneIndex} = subMesh.attributes;
				renderPassEncoder.setResources({position, boneIndex});
				const subMeshFilter = 1 << i;
				for(let [offset, count] of groupDraw(v => itemList[v].material.subMeshFilter & subMeshFilter, itemList.length)){
					renderPassEncoder.draw(subMesh.vertexCount, count, 0, offset);
				}
			}
		}
	}
}

module.exports = TextureMaterial;
