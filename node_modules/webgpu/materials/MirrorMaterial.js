'use strict';

const Vulkan = require('../Vulkan');
const TextureMaterial = require('./TextureMaterial');
const groupDraw = require('../helper/groupDraw');
const Camera3D = require('../cameras/Camera3D');
const Quaternion = require('../math/Quaternion');
const Lens = require('../cameras/Lens');
const Pipeline = require('./Pipeline');

const pipelineQuad = new Pipeline({
	groups: [TextureMaterial.pipelineDesc.groups[0], [
		{name:'texture', binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{}},
		{name:'uvScale', binding:1, visibility:GPUShaderStage.VERTEX, buffer:{}},
	]],
	vertex: {
		entryPoint: 'main',
		code: `
			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
			}

			@group(1) @binding(1) var<uniform> uv_scale: vec2<f32>;

			@vertex
			fn main(
				@builtin(vertex_index) vertex_index: u32,
			) -> Output {
				var vertex: vec2<f32>;
				vertex.x = f32(vertex_index >> 1);
				vertex.y = f32(vertex_index & 1);

				var position = vertex * 2 - 1;
				position.y = -position.y;

				var output: Output;
				output.position = vec4<f32>(position, 0, 1);
				output.uv = vec2(1-vertex.x, vertex.y) * uv_scale;
				return output;
			}
		`
	},
	fragment: {
		targets:[{
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'one', dstFactor: 'zero', operation: 'add'},
				alpha:{srcFactor: 'one', dstFactor: 'zero', operation: 'add'},
			}
		}],
		entryPoint: 'main',
		code: `
			@group(1) @binding(0) var texture_color: texture_2d<f32>;
			@group(0) @binding(1) var sampler_filtering: sampler;

			@fragment
			fn main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
				return textureSample(texture_color, sampler_filtering, uv);
			}
		`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: false,
		depthCompare: 'always',//always, never, equal, not-equal, less, less-equal, greater, greater-equal
		stencilFront: {compare: 'not-equal'},
		stencilBack: {compare: 'not-equal'},
	},
	primitive: {
		// (0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5)
		// 0-2-4
		// |/|/|
		// 1-3-5
		topology: 'triangle-strip',
	}
});

const pipeline = {
	groups: [TextureMaterial.pipelineDesc.groups[0], TextureMaterial.pipelineDesc.groups[1].slice(0,1)],
	vertex: {
		buffers: [{
			name: 'position',
			arrayStride: 4 << 2,
			attributes: [{shaderLocation:0, offset: 0, format:'float32x3'}]
		}],
		entryPoint: 'mainStatic',
		code:TextureMaterial.pipelineDesc.vertex.code,
	},
	fragment: {
		targets:[{
			writeMask: 0,
			format: 'bgra8unorm',
			blend: {color:{}, alpha:{}}
		}],
		entryPoint: 'main',
		code: `@fragment fn main(){}`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: true,
		depthCompare: 'less-equal',//always, never, equal, not-equal, less, less-equal, greater, greater-equal
		stencilFront: {passOp: 'increment-clamp'},
		stencilBack: {passOp: 'increment-clamp'},
	},
	primitive: {
		topology: 'triangle-strip'
	}
};

class MirrorMaterial extends TextureMaterial.Subclass(pipeline){
	static maxCountPerDraw = 1;
	static onDraw(drawUnitList, {subMeshList}, renderPassEncoder){
		const {position} = subMeshList[0].buffers;
		this.setResources(renderPassEncoder, {
			'worldMatrixList': {buffer:drawUnitList},
			position
		});
		renderPassEncoder.draw(4);

		const material = drawUnitList[0].material;
		uv_scale[0] = Vulkan.canvas.width / material.texture.width;
		uv_scale[1] = Vulkan.canvas.height / material.texture.height;

		pipelineQuad.setPipeline(renderPassEncoder);
		pipelineQuad.setResources(renderPassEncoder, {
			'texture': material.texture,
			'uvScale': {buffer:uv_scale}
		});
		renderPassEncoder.draw(4);
	}

	constructor(texture){
		super();
		let camera = new Camera3D(new Lens.Perspective(Math.PI / 6, 900 / 1200, -1500, 5000, -2000));
		camera.rotation = new Quaternion().fromEulerAngles(120 * Math.PI / 180, 0, -135 * Math.PI / 180);
		this.camera = camera;
	}
}

const uv_scale = new Float32Array(2);

module.exports = MirrorMaterial;
