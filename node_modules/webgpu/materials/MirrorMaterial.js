'use strict';

const Vulkan = require('../Vulkan');
const TextureMaterial = require('./TextureMaterial');
const groupDraw = require('../helper/groupDraw');
const Camera3D = require('../cameras/Camera3D');
const Quaternion = require('../math/Quaternion');
const Lens = require('../cameras/Lens');
const Pipeline = require('./Pipeline');
const {worldMatrixList} = require('./helper/DefaultGroupEntries');

const drawQuad = Pipeline.Blit([
	[{visibility: GPUShaderStage.VERTEX, buffer:{}}],
	[
		{name:'baseTexture', texture:{}},
		{name:'g_sampler', sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}},
		{name:'uvScale', type:'vec2<f32>', buffer:{}}
	]
], {}, `@fragment{return textureSample(baseTexture, g_sampler, vec2(1-uvxy.x, uvxy.y) * uvScale);}`, {
	depthWriteEnabled: false,
	depthCompare: 'always',//always, never, equal, not-equal, less, less-equal, greater, greater-equal
	stencilFront: {compare: 'not-equal'},
});

const pipeline = new Pipeline({
	groups: [
		[{name:'vpMatrix', type:'MVP', buffer:{}}],
		[worldMatrixList()]
	],
	vertex:{code:`
		#include<transform>
		@vertex{
			let mat = worldMatrixList[instanceIndex];
			return positionWorldToScreen(vec4<f32>(position, 1) * mat, vpMatrix);
		}`,
		buffers: [{name: 'position', arrayStride: 4 << 2, attributes: [{format:'float32x3'}]}],
	},
	fragment: {targets:[{writeMask: 0, blend: 'one add zero'}], code: `@fragment fn main(){}`},
	depthStencil: {
		stencilFront: {passOp: 'increment-clamp'},
		stencilBack: {passOp: 'increment-clamp'},
	},
	primitive: {topology: 'triangle-strip'}
});

class MirrorMaterial extends TextureMaterial.Subclass(pipeline){
	static maxCountPerDraw = 1;
	static onDraw(drawUnitList, renderPassEncoder){
		const {position} = drawUnitList[0].entity.mesh.subMeshList[0].attributes;
		renderPassEncoder.setResources({
			'worldMatrixList': {buffer:drawUnitList},
			position
		});
		renderPassEncoder.draw(4);

		const material = drawUnitList[0].material;
		uv_scale[0] = Vulkan.canvas.width / material.texture.width;
		uv_scale[1] = Vulkan.canvas.height / material.texture.height;

		drawQuad(renderPassEncoder, {
			'baseTexture': material.texture,
			'uvScale': {buffer:uv_scale}
		});
	}

	constructor(texture){
		super();
		let camera = new Camera3D(new Lens.Perspective(Math.PI / 6, 900 / 1200, -1500, 5000, -2000));
		camera.rotation = new Quaternion().fromEulerAngles(120 * Math.PI / 180, 0, -135 * Math.PI / 180);
		this.camera = camera;
	}

	get pick(){}
	get depth(){}
}

const uv_scale = new Float32Array(2);

module.exports = MirrorMaterial;
