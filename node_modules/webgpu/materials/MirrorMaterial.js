'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const groupDraw = require('../helper/groupDraw');
const Camera3D = require('../cameras/Camera3D');
const Quaternion = require('../math/Quaternion');
const Lens = require('../cameras/Lens');
const Pipeline = require('./Pipeline');

const pipelineQuad = new Pipeline({
	groups: [[
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}}
	], [
		{binding:2, visibility:GPUShaderStage.FRAGMENT, texture:{sampleType:'float'}},//depth, sint, uint, unfilterable-float
		{binding:5, visibility:GPUShaderStage.FRAGMENT, sampler:{type:'filtering'}, default:{}},
	]],
	vertex: {
		buffers: [{
			arrayStride: 2 << 2,
			stepMode: 'instance',
			attributes: [
				{shaderLocation: 0, offset: 0, format: 'float32x2'},
			]
		}],
		entryPoint: 'main',
		code: `
			struct Input {
				@builtin(vertex_index) vertex_index: u32,
				@location(0) uv_scale: vec2<f32>,
			}

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) xy: vec2<f32>,
			}

			@vertex
			fn main(input: Input) -> Output {
				var vertex: vec2<f32>;
				vertex.x = f32(input.vertex_index >> 1);
				vertex.y = f32(input.vertex_index & 1);

				var position = vertex * 2 - 1;
				position.y = -position.y;

				var output: Output;
				output.position = vec4<f32>(position, 0, 1);
				output.uv = vertex * input.uv_scale;
				output.xy = position;
				return output;
			}
		`
	},
	fragment: {
		targets:[{
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'one', dstFactor: 'zero', operation: 'add'},
				alpha:{srcFactor: 'one', dstFactor: 'zero', operation: 'add'},
			}
		}],
		entryPoint: 'main',
		code: `
			struct MVP {
				screenMatrix: mat4x4<f32>,
				@size(64) cameraMatrix: mat3x4<f32>,
			}

			@group(1) @binding(2) var texture_color: texture_2d<f32>;
			@group(1) @binding(5) var sampler_filtering: sampler;

			@fragment
			fn main(
				@location(0) uv: vec2<f32>,
				@location(1) position: vec2<f32>,
			) -> @location(0) vec4<f32> {
				let baseColor = textureSample(texture_color, sampler_filtering, uv);
				return baseColor;
			}
		`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: false,
		depthCompare: 'always',//always, never, equal, not-equal, less, less-equal, greater, greater-equal
		stencilFront: {
			compare: 'not-equal',
			depthFailOp: 'keep',//keep, zero, replace, invert, increment-clamp, decrement-clamp, increment-wrap, decrement-wrap
			failOp: 'keep',
			passOp: 'keep',
		},
		stencilBack: {
			compare: 'not-equal',
			depthFailOp: 'keep',
			failOp: 'keep',
			passOp: 'keep',
		},
		stencilReadMask: 0xFFFFFFFF,
		stencilWriteMask: 0xFFFFFFFF,
		depthBias: 0,
		depthBiasSlopeScale: 0,
		depthBiasClamp: 0,
	},
	primitive: {
		// (0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5)
		// 0-2-4
		// |/|/|
		// 1-3-5
		topology: 'triangle-strip',
	}
});

const maxCountPerDraw = 4;
const maxCountPerDrawStatic = 100;
const maxBoneCount = 128;

const pipeline = {
	groups: [[
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'repeat', addressModeV:'repeat', addressModeW:'repeat'}}
	], [
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}, temp:{array: new Float32Array(12 * maxCountPerDrawStatic), stride: 12, mapFn: v => v.entity.worldTransform.rawData}},
		//{binding:1, visibility:GPUShaderStage.VERTEX, buffer:{}, temp:{array: new Float32Array(8 * maxBoneCount * maxCountPerDraw), stride: 8 * maxBoneCount, mapFn: ({entity}) => entity.copyBoneStateToTempBuffer().subarray(0, entity.skeleton.boneCount << 3)}}
	]],
	vertex: {
		buffers: [{
			name: 'position',
			arrayStride: 4 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:0, offset: 0, format:'float32x3'}]
		}, {
			name: 'normal',
			arrayStride: 4 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:1, offset: 0, format:'float32x3'}]
		}, {
			name: 'uv',
			arrayStride: 2 << 2,
			stepMode: 'vertex',
			attributes: [{shaderLocation:2, offset: 0, format:'float32x2'}]
		}],
		entryPoint: 'mainStatic',
		code: `
			fn positionWorldToScreen(worldPosition: vec3<f32>) -> vec4<f32> {
				let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1) * mvp.cameraMatrix;
				let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * mvp.screenMatrix;
				return screenPosition;
			}
			
			struct MVP {
				screenMatrix: mat4x4<f32>,
				cameraMatrix: mat3x4<f32>,
			}

			@group(0) @binding(0) var<uniform> mvp: MVP;
			@group(1) @binding(0) var<uniform> worldMatrixList: array<mat3x4<f32>, ${maxCountPerDrawStatic}>;
			@group(1) @binding(1) var<uniform> boneStateList: array<vec4<f32>, ${2 * maxBoneCount * maxCountPerDraw}>;

			struct OutputForward {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
			}



			@vertex
			fn mainStatic(
				@builtin(instance_index) instanceIndex: u32,
				@location(0) position: vec3<f32>,
				@location(1) normal: vec3<f32>,
				@location(2) uv: vec2<f32>,
			) -> OutputForward {
				let mat = worldMatrixList[instanceIndex];
				var output: OutputForward;
				output.position = positionWorldToScreen(vec4<f32>(position, 1) * mat);
				output.uv = uv;
				return output;
			}

		`
	},
	fragment: {
		targets:[{
			writeMask: 0,
			format: 'bgra8unorm',
			blend: {color:{}, alpha:{}}
		}],
		entryPoint: 'main',
		code: `@fragment fn main(){}`
	},
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: true,
		depthCompare: 'less-equal',//always, never, equal, not-equal, less, less-equal, greater, greater-equal
		stencilFront: {
			compare: 'always',
			depthFailOp: 'keep',//keep, zero, replace, invert, increment-clamp, decrement-clamp, increment-wrap, decrement-wrap
			failOp: 'keep',
			passOp: 'increment-clamp',
		},
		stencilBack: {
			compare: 'always',
			depthFailOp: 'keep',
			failOp: 'keep',
			passOp: 'increment-clamp',
		},
		stencilReadMask: 0xFFFFFFFF,
		stencilWriteMask: 0xFFFFFFFF,
		depthBias: 0,
		depthBiasSlopeScale: 0,
		depthBiasClamp: 0,
	},
	primitive: {
		cullMode: 'none',//none, back, front
		frontFace: 'ccw',//cw, ccw
		topology: 'triangle-strip',//point-list, line-list, line-strip, triangle-list, triangle-strip
		stripIndexFormat: undefined,//uint16, uint32
		unclippedDepth: false
	}
};

class MirrorMaterial extends Material.Subclass(pipeline, [Material.Utils.groupMesh]){
	static maxCountPerDraw = 1;
	static onDraw(drawUnitList, {subMeshList}, renderPassEncoder){
		/*
		return;*/
		this.setBindGroup(renderPassEncoder, 1, [
			{binding:0, resource:{buffer:drawUnitList}},
			//{binding:1, resource:{buffer:drawUnitList}},
		]);
		for(let i=0, n=subMeshList.length; i<n; ++i){
			const subMesh = subMeshList[i];
			let texture = drawUnitList[0].material.texture;
			subMesh.setBuffers(renderPassEncoder, this.vertexBuffers);
			renderPassEncoder.draw(4);
		}

		pipelineQuad.setPipeline(renderPassEncoder);
		pipelineQuad.setBindGroup(renderPassEncoder, 1, [{binding:2, resource:drawUnitList[0].material.texture}]);
		pipelineQuad.setVertexBuffer(renderPassEncoder, 0, uv_scale);
		renderPassEncoder.draw(4);
	}

	constructor(texture){
		super();
		this.texture = texture.createView();
		let camera = new Camera3D(new Lens.Perspective(Math.PI / 6, 900 / 1200, -1500, 5000, -2000));
		camera.rotation = new Quaternion().fromEulerAngles(120 * Math.PI / 180, 0, -135 * Math.PI / 180);
		camera.lens.rawData[0] *= -1;
		this.camera = camera;
	}
}

const uv_scale = new Float32Array(2);
uv_scale[0] = 1200 / 2048;
uv_scale[1] = 900 / 1024;

module.exports = MirrorMaterial;
