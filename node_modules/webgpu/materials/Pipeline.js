'use strict';

const Vulkan = require('../Vulkan');
const {fetchBuffer} = require('../Vulkan/resource');
const {createGetter, createMapGetter} = require('utils/cache');
const {calcBindGroupLayoutSign, calcPipelineLayoutSign, calcSamplerSign, calcShaderSign, calcPipelineSign} = require('webonly/utils_gpu');

const getDevice = () => Vulkan.device;

const samplerCache = createGetter(desc => getDevice().createSampler(desc), calcSamplerSign);
const shaderCache = createGetter(code => getDevice().createShaderModule({code}));
const bindGroupLayoutCache = createGetter(entries => getDevice().createBindGroupLayout({entries}), calcBindGroupLayoutSign);
const pipelineLayoutCache = createGetter(layouts => getDevice().createPipelineLayout({bindGroupLayouts: layouts.map(bindGroupLayoutCache)}), calcPipelineLayoutSign);
const pipelineCache = createGetter(createPipeline, calcPipelineSign);
function createPipeline(desc){
	const {vertex, fragment, compute} = desc;
	if(!desc.layout){
		desc.layout = pipelineLayoutCache(desc.groups);
	}
	if(vertex && !vertex.module)vertex.module = shaderCache(calcShaderSign(vertex.code));
	if(fragment && !fragment.module)fragment.module = shaderCache(calcShaderSign(fragment.code));
	if(compute && !compute.module)compute.module = shaderCache(calcShaderSign(compute.code));
	return compute ? getDevice().createComputePipeline(desc) : getDevice().createRenderPipeline(desc);
}
const mapCacheBindGroupLayout = createMapGetter(bindGroupLayoutCache);
const mapCacheSampler = createMapGetter(samplerCache);
const mapCachePipeline = createMapGetter(pipelineCache);
const createBindGroup = function(){
	function fn(v){return v.binding == this;}
	return (desc, entries) => {
		for(let entry of entries){
			const item = desc.find(fn, entry.binding);
			if(item.buffer){
				if(entry.resource.buffer instanceof GPUBuffer)continue;
				let bufferData = entry.resource.buffer;
				let bufferDataSize;
				if(Array.isArray(bufferData)){
					const value = bufferData;
					const {array, stride, mapFn} = item.temp;
					bufferData = array;
					bufferDataSize = 0;
					//if(mapFn){
						for(let i=0, n=value.length; i<n; ++i){
							array.set(mapFn(value[i]), bufferDataSize);
							bufferDataSize += stride;
						}
					/*}else{
						for(let i=0, n=value.length; i<n; ++i){
							array.set(value[i], bufferDataSize);
							bufferDataSize += stride[i];
						}
					}*/
				}
				const bufferSize = Math.max(64, entry.resource.size ?? bufferData.byteLength);//less than 64 will warn
				const bufferType = item.buffer.type ?? 'uniform';
				const bufferUsage = bufferType == 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE;
				const buffer = fetchBuffer(bufferSize, bufferUsage | GPUBufferUsage.COPY_DST);
				getDevice().queue.writeBuffer(buffer, 0, bufferData, 0, bufferDataSize);
				entry.resource.buffer = buffer;
				if(entry.resource.size === undefined)entry.resource.size = bufferSize;
			}/*else if(item.sampler){
				//if(entry.resource instanceof GPUSampler)continue;
				entry.resource = samplerCache(entry.resource);
			}*/
		}
		if(entries.length < desc.length){
			for(let entry of desc){
				if(entries.some(fn, entry.binding))continue;
				if(entry.sampler){
					entries.push({binding:entry.binding, resource:mapCacheSampler(entry.default)});
				}
			}
		}
		return getDevice().createBindGroup({layout:mapCacheBindGroupLayout(desc), entries});
	};
}();

const isTransparent = function(){
	const testFn = v => v.blend !== undefined;
	return desc => desc.fragment?.targets?.some(testFn);
}();

class Pipeline {
	constructor(desc){
		this.desc = desc;
		this.opaque = !isTransparent(desc);
		const vertexBufferNameDict = Object.fromEntries(Array.from(desc.vertex?.buffers ?? [], (v, i) => [v.name, i]).filter(v => v[0]));
		const bindingNameDict = Object.fromEntries(desc.groups.map((v, i) => v.map(v => [v.name, [i, v.binding]])).flat().filter(v => v[0]));
		this.infoToGroupIndex = ([name]) => bindingNameDict[name]?.[0];
		this.infoToEntry = ([name, resource]) => ({binding: bindingNameDict[name][1], resource});
		this.nameToVertexBufferIndex = name => vertexBufferNameDict[name] ?? -1;
	}

	setPipeline(renderPassEncoder){
		renderPassEncoder.setPipeline(mapCachePipeline(this.desc));
	}

	setBindGroup(renderPassEncoder, index, entries){
		renderPassEncoder.setBindGroup(index, createBindGroup(this.desc.groups[index], entries));
	}

	setVertexBuffer(renderPassEncoder, index, value){
		if(value instanceof GPUBuffer){
			renderPassEncoder.setVertexBuffer(index, value);
		}else if(Array.isArray(value)){
			const {arrayStride, temp:{array, stride, mapFn}} = this.desc.vertex.buffers[index];
			for(let i=0, n=value.length; i<n; ++i)array.set(mapFn(value[i]), i * stride);
			const size = arrayStride * value.length;
			const buffer = fetchBuffer(size, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
			getDevice().queue.writeBuffer(buffer, 0, array, 0, stride * value.length);
			renderPassEncoder.setVertexBuffer(index, buffer, 0, size);
		}else{
			const buffer = fetchBuffer(value.byteLength, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);//buffer may larger than request size
			getDevice().queue.writeBuffer(buffer, 0, value);
			renderPassEncoder.setVertexBuffer(index, buffer, 0, value.byteLength);
		}
	}

	setVertexBufferByName(renderPassEncoder, name, value){
		const index = this.nameToVertexBufferIndex(name);
		if(index >= 0)this.setVertexBuffer(renderPassEncoder, index, value);
	}

	setResources(renderPassEncoder, resources){
		for(let [index, entries] of Map.groupBy(Object.entries(resources), this.infoToGroupIndex)){
			if(index === undefined){
				for(let [name, value] of entries){
					this.setVertexBufferByName(renderPassEncoder, name, value);
				}
				continue;
			}
			this.setBindGroup(renderPassEncoder, index, entries.map(this.infoToEntry));
		}
	}
}

Pipeline.prototype.clone = function(){
	const identity = v => v;
	const exclude = (value, exclude) => value && Object.fromEntries(Object.entries(value).filter(v => !exclude.includes(v[0])));
	const combine = (a, b) => b === null ? undefined : a && b ? Object.assign({}, a, b) : a ?? b;
	return function(modify){
		const {groups=identity, buffers} = modify;
		const target = this.desc;
		return new this.constructor({
			groups: groups(target.groups),
			compute: exclude(combine(target.compute, modify.compute), ['module']),
			vertex: exclude(combine(combine(target.vertex, modify.vertex), buffers && {buffers: buffers(target.vertex?.buffers)}), ['module']),
			fragment: exclude(combine(target.fragment, modify.fragment), ['module']),
			depthStencil: combine(target.depthStencil, modify.depthStencil),
			primitive: combine(target.primitive, modify.primitive),
			multisample: combine(target.multisample, modify.multisample),
		});
	}
}();

module.exports = Pipeline;
