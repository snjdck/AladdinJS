'use strict';

const Vulkan = require('../Vulkan');
const processInclude = require('./ShderInclude');
const {fetchBuffer, bufferCache} = require('../Vulkan/resource');
const {createGetter, createMapGetter} = require('utils/cache');
const {calcBindGroupLayoutSign, calcPipelineLayoutSign, calcSamplerSign, calcPipelineSign, calcResourceDefs} = require('webonly/utils_gpu');

const getDevice = () => Vulkan.device;

const samplerCache = createGetter(desc => getDevice().createSampler(desc), calcSamplerSign);
const shaderCache = createGetter(code => getDevice().createShaderModule({code}));
const bindGroupLayoutCache = createGetter(entries => getDevice().createBindGroupLayout({entries}), calcBindGroupLayoutSign);
const pipelineLayoutCache = createGetter(layouts => getDevice().createPipelineLayout({bindGroupLayouts: layouts.map(bindGroupLayoutCache)}), calcPipelineLayoutSign);
const pipelineCache = createGetter(createPipeline, calcPipelineSign);
function createPipeline(desc){
	const {vertex, fragment, compute} = desc;
	if(!desc.layout){
		desc.layout = pipelineLayoutCache(desc.groups);
	}
	if(vertex && !vertex.module)vertex.module = shaderCache(calcResourceDefs(desc.groups, GPUShaderStage.VERTEX) + vertex.code);
	if(fragment && !fragment.module)fragment.module = shaderCache(calcResourceDefs(desc.groups, GPUShaderStage.FRAGMENT) + fragment.code);
	if(compute && !compute.module)compute.module = shaderCache(calcResourceDefs(desc.groups, GPUShaderStage.COMPUTE) + compute.code);
	return compute ? getDevice().createComputePipeline(desc) : getDevice().createRenderPipeline(desc);
}
const mapCacheBindGroupLayout = createMapGetter(bindGroupLayoutCache);
const mapCacheSampler = createMapGetter(samplerCache);
const mapCachePipeline = createMapGetter(pipelineCache);
const createBindGroup = function(){
	function fn(v){return v.binding == this;}
	return (desc, entries) => {
		for(let entry of entries){
			const item = desc.find(fn, entry.binding);
			if(item.buffer){
				if(entry.resource.buffer instanceof GPUBuffer)continue;
				let bufferData = entry.resource.buffer;
				let bufferDataSize;
				if(Array.isArray(bufferData)){
					const value = bufferData;
					const {array, stride, mapFn} = item.temp;
					bufferData = array;
					bufferDataSize = 0;
					//if(mapFn){
						for(let i=0, n=value.length; i<n; ++i){
							array.set(mapFn(value[i]), bufferDataSize);
							bufferDataSize += stride;
						}
					/*}else{
						for(let i=0, n=value.length; i<n; ++i){
							array.set(value[i], bufferDataSize);
							bufferDataSize += stride[i];
						}
					}*/
				}
				const bufferSize = Math.max(64, entry.resource.size ?? bufferData.byteLength);//less than 64 will warn
				const bufferType = item.buffer.type ?? 'uniform';
				const bufferUsage = bufferType == 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE;
				const buffer = fetchBuffer(bufferSize, bufferUsage | GPUBufferUsage.COPY_DST);
				getDevice().queue.writeBuffer(buffer, 0, bufferData, 0, bufferDataSize);
				entry.resource.buffer = buffer;
				if(entry.resource.size === undefined)entry.resource.size = bufferSize;
			}/*else if(item.sampler){
				//if(entry.resource instanceof GPUSampler)continue;
				entry.resource = samplerCache(entry.resource);
			}*/
		}
		if(entries.length < desc.length){
			for(let entry of desc){
				if(entries.some(fn, entry.binding))continue;
				if(entry.sampler){
					entries.push({binding:entry.binding, resource:mapCacheSampler(entry.default)});
				}
			}
		}
		return getDevice().createBindGroup({layout:mapCacheBindGroupLayout(desc), entries});
	};
}();

const isTransparent = function(){
	const testFn = v => v.blend !== undefined;
	return desc => desc.fragment?.targets?.some(testFn);
}();

const checkStage = function(){
	const calcRegExp = v => new RegExp('^[\\x20\\t]' + v, 'gm');
	const calcMinLen = ((p, f) => v => Math.min.apply(null, v.match(p).map(f)))(calcRegExp('*(?=\\S)'), v => v.length);
	return stage => {
		if(!stage)return;
		if(!stage.entryPoint)stage.entryPoint = 'main';
		stage.code = processInclude(stage.code.replace(calcRegExp(`{${calcMinLen(stage.code)}}`), ''));
	}
}();

const checkGroups = function(){
	const hasName = (code, name) => code && new RegExp(`\\b${name}\\b`).test(code);
	return desc => {
		for(let entries of desc.groups){
			let binding = 0;
			for(let entry of entries){
				if(entry.binding === undefined){
					entry.binding = binding++;
				}else{
					binding = entry.binding + 1;
				}
				if(entry.visibility !== undefined)continue;
				let visibility = 0;
				if(hasName(desc.vertex?.code, entry.name)){
					visibility |= GPUShaderStage.VERTEX;
				}
				if(hasName(desc.fragment?.code, entry.name)){
					visibility |= GPUShaderStage.FRAGMENT;
				}
				if(hasName(desc.compute?.code, entry.name)){
					visibility |= GPUShaderStage.COMPUTE;
				}
				entry.visibility = visibility;
			}
		}
	}
}();

const checkStageFnInputs = function(){
	function findBody(text, start){
		let count = 0;
		for(let i=start, n=text.length; i<n; ++i){
			const char = text.charAt(i);
			if(char == '{'){
				++count;
			}else if(char == '}'){
				--count;
				if(count == 0)return text.slice(start, i+1);
			}
		}
	}
	
	const calcVecType = function(){
		function calcType(t){
			switch(t){
				case 'sint':return 'i32';
				case 'uint':return 'u32';
			}
			return 'f32';
		}
		return (n, t) => n > 1 ? `vec${n}<${calcType(t)}>` : calcType(t);
	}();
	const calcBufferType = function(){
		const pattern = /^([a-z]+)\d+(?:|x(\d))$/;
		return format => {
			const [_, t, n] = pattern.exec(format);
			return calcVecType(Number(n), t);
		}
	}();
	const calcFnPattern = (stage, name) => `@${stage}\\s+fn\\s+${name}\\s*\\(\\s*`;
	//const replaceFnArgs = (code, fn, args) => code.replace(fn, v => v.replace(/(?<=\()\s*(?=\))/, args.join(',')));
	const calcBuiltin = function(){
		const p1 = v => new RegExp(`\\b${v}\\b`);
		const p2 = /\b\w+(?=:)/;
		return function(fnBody, args){
			const result = [];
			for(let arg of args){
				if(p1(arg.match(p2)[0]).test(fnBody)){
					result.push(arg);
				}
			}
			return result;
		}
	}();
	const calcTargetType = function(){
		const pattern = /^([rgba]{1,4})\d+(\w+)/;
		return v => {
			const info = pattern.exec(v.format);
			return calcVecType(info[1].length, info[2]);
		}
	}();
	const calcTargetsOutput = targets => {
		return 'struct Output{' + targets.map((v, i) => `@location(${i})v${i}:` + calcTargetType(v)).join(',') + '}';
	}
	const argsVertex = ['@builtin(instance_index)instanceIndex:u32', '@builtin(vertex_index)vertexIndex:u32'];
	const argsFragment = ['@builtin(position)FragCoord:vec4<f32>'];
	return ({vertex, fragment, compute}) => {
		if(vertex){
			const info = /@vertex\s*(?=->)/.exec(vertex.code);
			if(info){
				const result = calcBuiltin(findBody(vertex.code, info.index), argsVertex);
				for(let buffer of vertex.buffers ?? []){
					for(let {name, format, shaderLocation} of buffer.attributes){
						result.push(`@location(${shaderLocation})${name ?? buffer.name}:${calcBufferType(format)}`);
					}
				}
				vertex.code = vertex.code.replace(info[0], `$& fn ${vertex.entryPoint}(${result.join(',')})`);
			}
		}
		if(fragment){
			const info = /@fragment\s*(?=\{)/.exec(fragment.code);
			if(info){
				const result = calcBuiltin(findBody(fragment.code, info.index), argsFragment);
				const vertexOutput = new RegExp(calcFnPattern('vertex', vertex.entryPoint) + `.*?\\)\\s*->\\s*(\\w+|@builtin\\(position\\)\\s*vec4<f32>)\\s*\\{`).exec(vertex.code)[1];
				if(!vertexOutput.startsWith('@')){
					const structBody = new RegExp(`\\bstruct\\s+${vertexOutput}\\s*\\{([^}]+)\\}`).exec(vertex.code)[1];
					result.push(...structBody.match(/@\w+\(\w+\)[^,]+/g).filter(v => !v.startsWith('@builtin')));
				}
				let prefix = '';
				let returnType = `@location(0)${calcTargetType(fragment.targets[0])}`;
				if(fragment.targets.length > 1){
					prefix = calcTargetsOutput(fragment.targets);
					returnType = 'Output';
				}
				fragment.code = prefix + fragment.code.replace(info[0], `$& fn ${fragment.entryPoint}(${result.join(',')})->${returnType}`);
			}
		}
	}
}();

const checkFragmentTargets = function(){
	const blendCache = function(){
		const blendComponentCache = createGetter(desc => {
			const [srcFactor, operation, dstFactor] = desc.split(' ');
			return {srcFactor, operation, dstFactor};
		});
		return createGetter(desc => {
			const [color, alpha] = desc.split(';').map(blendComponentCache);
			return {color, alpha: alpha ?? color};
		});
	}();
	function castBlend(v){
		if(typeof v.blend !== 'string')return;
		v.blend = blendCache(v.blend);
	}
	return targets => targets?.forEach(castBlend);
}();

class Pipeline {
	constructor(desc){
		this.desc = desc;
		this.opaque = !isTransparent(desc);
		checkStage(desc.vertex);
		checkStage(desc.fragment);
		checkStage(desc.compute);
		checkGroups(desc);
		checkStageFnInputs(desc);
		checkFragmentTargets(desc.fragment?.targets);
		const vertexBufferNameDict = Object.fromEntries(Array.from(desc.vertex?.buffers ?? [], (v, i) => [v.name, i]).filter(v => v[0]));
		const bindingNameDict = Object.fromEntries(desc.groups.map((v, i) => v.map(v => [v.name, [i, v.binding]])).flat().filter(v => v[0]));
		this.infoToGroupIndex = ([name]) => bindingNameDict[name]?.[0];
		this.infoToEntry = ([name, resource]) => ({binding: bindingNameDict[name][1], resource});
		this.nameToVertexBufferIndex = name => vertexBufferNameDict[name] ?? -1;
	}

	setPipeline(renderPassEncoder){
		renderPassEncoder.setPipeline(mapCachePipeline(this.desc));
	}

	setBindGroup(renderPassEncoder, index, entries){
		renderPassEncoder.setBindGroup(index, createBindGroup(this.desc.groups[index], entries));
	}

	setVertexBuffer(renderPassEncoder, index, value){
		if(value instanceof GPUBuffer){
			renderPassEncoder.setVertexBuffer(index, value);
		}else if(Array.isArray(value)){
			const {arrayStride, temp:{array, stride, mapFn}} = this.desc.vertex.buffers[index];
			for(let i=0, n=value.length; i<n; ++i)array.set(mapFn(value[i]), i * stride);
			const size = arrayStride * value.length;
			const buffer = fetchBuffer(size, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
			getDevice().queue.writeBuffer(buffer, 0, array, 0, stride * value.length);
			renderPassEncoder.setVertexBuffer(index, buffer, 0, size);
		}else{
			const {stepMode} = this.desc.vertex.buffers[index];
			if(stepMode !== 'instance'){
				renderPassEncoder.setVertexBuffer(index, bufferCache(value, GPUBufferUsage.VERTEX));
				return;
			}
			const buffer = fetchBuffer(value.byteLength, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);//buffer may larger than request size
			getDevice().queue.writeBuffer(buffer, 0, value);
			renderPassEncoder.setVertexBuffer(index, buffer, 0, value.byteLength);
		}
	}

	setVertexBufferByName(renderPassEncoder, name, value){
		const index = this.nameToVertexBufferIndex(name);
		if(index >= 0)this.setVertexBuffer(renderPassEncoder, index, value);
	}

	setResources(renderPassEncoder, resources){
		for(let [index, entries] of Map.groupBy(Object.entries(resources), this.infoToGroupIndex)){
			if(index === undefined){
				for(let [name, value] of entries){
					if(name === 'index' && value){
						const format = value instanceof Uint32Array ? 'uint32' : 'uint16';
						renderPassEncoder.setIndexBuffer(bufferCache(value, GPUBufferUsage.INDEX), format);
						continue;
					}
					this.setVertexBufferByName(renderPassEncoder, name, value);
				}
				continue;
			}
			this.setBindGroup(renderPassEncoder, index, entries.map(this.infoToEntry));
		}
	}
}

Pipeline.prototype.clone = function(){
	const identity = v => v;
	const exclude = (value, exclude) => value && Object.fromEntries(Object.entries(value).filter(v => !exclude.includes(v[0])));
	const combine = (a, b) => b === null ? undefined : a && b ? Object.assign({}, a, b) : a ?? b;
	return function(modify){
		const {groups=identity, buffers} = modify;
		const target = this.desc;
		return new this.constructor({
			groups: groups(target.groups),
			compute: exclude(combine(target.compute, modify.compute), ['module']),
			vertex: exclude(combine(combine(target.vertex, modify.vertex), buffers && {buffers: buffers(target.vertex?.buffers)}), ['module']),
			fragment: exclude(combine(target.fragment, modify.fragment), ['module']),
			depthStencil: combine(target.depthStencil, modify.depthStencil),
			primitive: combine(target.primitive, modify.primitive),
			multisample: combine(target.multisample, modify.multisample),
		});
	}
}();

module.exports = Pipeline;
