'use strict';

const Vulkan = require('../Vulkan');
const processInclude = require('./ShderInclude');
const findBody = require('utils/text/findBody');
const {fetchBuffer, bufferCache} = require('../Vulkan/resource');
const {createGetter, createMapGetter} = require('utils/cache');
const {calcBindGroupLayoutSign, calcPipelineLayoutSign, calcSamplerSign, calcPipelineSign, calcResourceDefs} = require('webonly/utils_gpu');

const getDevice = () => Vulkan.device;

const samplerCache = createGetter(desc => getDevice().createSampler(desc), calcSamplerSign);
const shaderCache = createGetter(code => getDevice().createShaderModule({code}));
const bindGroupLayoutCache = createGetter(entries => getDevice().createBindGroupLayout({entries}), calcBindGroupLayoutSign);
const pipelineLayoutCache = createGetter(layouts => getDevice().createPipelineLayout({bindGroupLayouts: layouts.map(bindGroupLayoutCache)}), calcPipelineLayoutSign);
const pipelineCache = createGetter(createPipeline, calcPipelineSign);
function createPipeline(desc){
	const {vertex, fragment, compute} = desc;
	if(!desc.layout){
		desc.layout = pipelineLayoutCache(desc.groups);
	}
	if(vertex && !vertex.module)vertex.module = shaderCache(vertex.code);
	if(fragment && !fragment.module)fragment.module = shaderCache(fragment.code);
	if(compute && !compute.module)compute.module = shaderCache(compute.code);
	return compute ? getDevice().createComputePipeline(desc) : getDevice().createRenderPipeline(desc);
}
const mapCacheBindGroupLayout = createMapGetter(bindGroupLayoutCache);
const mapCacheSampler = createMapGetter(samplerCache);
const mapCachePipeline = createMapGetter(pipelineCache);
const createBindGroup = function(){
	function fn(v){return v.binding == this;}
	return (desc, entries) => {
		for(let entry of entries){
			const item = desc.find(fn, entry.binding);
			if(item.buffer){
				if(entry.resource.buffer instanceof GPUBuffer)continue;
				let bufferData = entry.resource.buffer;
				let bufferDataSize;
				if(Array.isArray(bufferData)){
					const value = bufferData;
					const {array, stride, mapFn} = item.temp;
					bufferData = array;
					bufferDataSize = 0;
					//if(mapFn){
						for(let i=0, n=value.length; i<n; ++i){
							array.set(mapFn(value[i]), bufferDataSize);
							bufferDataSize += stride;
						}
					/*}else{
						for(let i=0, n=value.length; i<n; ++i){
							array.set(value[i], bufferDataSize);
							bufferDataSize += stride[i];
						}
					}*/
				}
				const bufferSize = Math.max(64, entry.resource.size ?? bufferData.byteLength);//less than 64 will warn
				const bufferType = item.buffer.type ?? 'uniform';
				const bufferUsage = bufferType == 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE;
				const buffer = fetchBuffer(bufferSize, bufferUsage | GPUBufferUsage.COPY_DST);
				getDevice().queue.writeBuffer(buffer, 0, bufferData, 0, bufferDataSize);
				entry.resource.buffer = buffer;
				if(entry.resource.size === undefined)entry.resource.size = bufferSize;
			}/*else if(item.sampler){
				//if(entry.resource instanceof GPUSampler)continue;
				entry.resource = samplerCache(entry.resource);
			}*/
		}
		if(entries.length < desc.length){
			for(let entry of desc){
				if(entries.some(fn, entry.binding))continue;
				if(entry.sampler){
					entries.push({binding:entry.binding, resource:mapCacheSampler(entry.default)});
				}
			}
		}
		return getDevice().createBindGroup({layout:mapCacheBindGroupLayout(desc), entries});
	};
}();

const isTransparent = function(){
	const testFn = v => v.blend !== undefined;
	return desc => desc.fragment?.targets?.some(testFn);
}();

const checkStage = function(){
	const calcRegExp = v => new RegExp('^[\\x20\\t]' + v, 'gm');
	const calcMinLen = ((p, f) => v => Math.min.apply(null, v.match(p).map(f)))(calcRegExp('*(?=\\S)'), v => v.length);
	return stage => {
		if(!stage)return;
		if(!stage.entryPoint)stage.entryPoint = 'main';
		stage.code = processInclude(stage.code.replace(calcRegExp(`{${calcMinLen(stage.code)}}`), ''));
	}
}();

const checkGroups = function(){
	const hasName = (code, name) => code && new RegExp(`\\b${name}\\b`).test(code);
	return desc => {
		for(let entries of desc.groups){
			let binding = 0;
			for(let entry of entries){
				if(entry.binding === undefined){
					entry.binding = binding++;
				}else{
					binding = entry.binding + 1;
				}
				if(entry.visibility !== undefined)continue;
				let visibility = 0;
				if(hasName(desc.vertex?.code, entry.name)){
					visibility |= GPUShaderStage.VERTEX;
				}
				if(hasName(desc.fragment?.code, entry.name)){
					visibility |= GPUShaderStage.FRAGMENT;
				}
				if(hasName(desc.compute?.code, entry.name)){
					visibility |= GPUShaderStage.COMPUTE;
				}
				entry.visibility = visibility;
			}
		}
	}
}();

function assignDefaultValue(target, value){
	if(!target)return;
	for(let k in value){
		if(target[k] !== undefined)continue;
		target[k] = value[k];
	}
}

const checkStageFnInputs = function(){
	const calcVecType = function(){
		function calcType(t){
			switch(t){
				case 'sint':return 'i32';
				case 'uint':return 'u32';
			}
			return 'f32';
		}
		return (n, t) => n > 1 ? `vec${n}<${calcType(t)}>` : calcType(t);
	}();
	const calcBuiltin = function(){
		const p1 = v => new RegExp(`\\b${v}\\b`);
		const p2 = /\b\w+(?=:)/;
		return function(fnBody, args){
			const result = [];
			for(let arg of args){
				if(p1(arg.match(p2)[0]).test(fnBody)){
					result.push(arg);
				}
			}
			return result;
		}
	}();
	const calcBufferType = function(){
		const pattern = /^([a-z]+)\d+(?:|x(\d))$/;
		return format => {
			const info = pattern.exec(format);
			return calcVecType(Number(info[2]), info[1]);
		}
	}();
	const calcTargetType = function(){
		const pattern = /^([rgba]{1,4})\d+(\w+)/;
		return v => {
			const info = pattern.exec(v.format);
			return calcVecType(info[1].length, info[2]);
		}
	}();
	const argsVertex = ['@builtin(instance_index)instanceIndex:u32', '@builtin(vertex_index)vertexIndex:u32'];
	const argsFragment = ['@builtin(position)FragCoord:vec4<f32>'];
	const argsCompute = ['@builtin(workgroup_id)wgid:vec3<u32>', '@builtin(num_workgroups)numwgs:vec3<u32>'];
	return ({groups, vertex, fragment, compute}) => {
		if(compute){
			const {entryPoint, code} = compute;
			const info = /@workgroup_size\s*\(\s*\d+(|\s*,\s*\d+(|\s*,\s*\d+))\s*\)\s*(?=\{)/.exec(code);
			if(info){
				const args = calcBuiltin(findBody(code, info.index), argsCompute);
				compute.code = calcResourceDefs(groups, GPUShaderStage.COMPUTE) + code.replace(info[0], `@compute $& fn ${entryPoint}(${args.join(',')})`);
			}
		}
		if(vertex){
			const {entryPoint, code, buffers} = vertex;
			const info = /@vertex\b\s*(\w*)\s*(?=\{)/.exec(code);
			if(info){
				const args = calcBuiltin(findBody(code, info.index), argsVertex);
				for(let buffer of buffers ?? []){
					for(let {name, format, shaderLocation} of buffer.attributes){
						args.push(`@location(${shaderLocation})${name ?? buffer.name}:${calcBufferType(format)}`);
					}
				}
				const returnType = info[1] || '@builtin(position)vec4<f32>';
				vertex.code = calcResourceDefs(groups, GPUShaderStage.VERTEX) + code.replace(info[0], `@vertex fn ${entryPoint}(${args.join(',')})->${returnType}`);
			}
		}
		if(fragment){
			const {entryPoint, code, targets} = fragment;
			const info = /@fragment\s*(?=\{)/.exec(code);
			if(info){
				const args = calcBuiltin(findBody(code, info.index), argsFragment);
				const vertexOutput = /@vertex.*?->\s*(\w+)/.exec(vertex.code);
				if(vertexOutput){
					const structBody = new RegExp(`\\bstruct\\s+${vertexOutput[1]}\\s*\\{([^}]+)\\}`).exec(vertex.code)[1];
					args.push(...structBody.match(/@location\(\d+\)[^,]+/g));
				}
				let returnType, prefix;
				if(targets.length > 1){
					returnType = 'Output';
					prefix = `struct ${returnType}{` + targets.map((v, i) => `@location(${i})v${i}:${calcTargetType(v)}`).join(',') + '}\n';
				}else{
					returnType = `@location(0)${calcTargetType(targets[0])}`;
					prefix = '';
				}
				fragment.code = calcResourceDefs(groups, GPUShaderStage.FRAGMENT) + code.replace(info[0], prefix + `@fragment fn ${entryPoint}(${args.join(',')})->${returnType}`);
			}
		}
	}
}();

const checkVertexBuffers = function(){
	const pattern = /^[a-z]+(\d+)(?:|x(\d))$/;
	return buffers => {
		if(!buffers)return;
		let shaderLocation = 0;
		for(let buffer of buffers){
			let offset = 0;
			for(let attribute of buffer.attributes){
				if(attribute.shaderLocation === undefined){
					attribute.shaderLocation = shaderLocation;
				}else{
					shaderLocation = attribute.shaderLocation;
				}
				++shaderLocation;
				if(attribute.offset === undefined){
					attribute.offset = offset;
				}else{
					offset = attribute.offset;
				}
				const info = pattern.exec(attribute.format);
				offset += info[1] * (info[2] ?? 1) >> 3;
			}
			if(buffer.arrayStride === undefined){
				buffer.arrayStride = offset;
			}
		}
	}
}();

const checkFragmentTargets = function(){
	const blendCache = function(){
		const blendComponentCache = createGetter(desc => {
			const [srcFactor, operation, dstFactor] = desc.split(' ');
			return {srcFactor, operation, dstFactor};
		});
		return createGetter(desc => {
			const [color, alpha] = desc.split(';').map(blendComponentCache);
			return {color, alpha: alpha ?? color};
		});
	}();
	function castBlend(v){
		if(typeof v.blend === 'string')v.blend = blendCache(v.blend);
		if(v.format === undefined)v.format = 'bgra8unorm';
	}
	return targets => targets?.forEach(castBlend);
}();

class Pipeline {
	constructor(desc){
		this.desc = desc;
		this.opaque = !isTransparent(desc);
		checkStage(desc.vertex);
		checkStage(desc.fragment);
		checkStage(desc.compute);
		assignDefaultValue(desc.depthStencil, {format:'depth24plus-stencil8', depthWriteEnabled:true, depthCompare:'less-equal'});
		checkGroups(desc);
		checkVertexBuffers(desc.vertex?.buffers);
		checkFragmentTargets(desc.fragment?.targets);
		checkStageFnInputs(desc);
		const vertexBufferNameDict = Object.fromEntries(Array.from(desc.vertex?.buffers ?? [], (v, i) => [v.name, i]).filter(v => v[0]));
		const bindingNameDict = Object.fromEntries(desc.groups.map((v, i) => v.map(v => [v.name, [i, v.binding]])).flat().filter(v => v[0]));
		this.infoToGroupIndex = ([name]) => bindingNameDict[name]?.[0];
		this.infoToEntry = ([name, resource]) => ({binding: bindingNameDict[name][1], resource});
		this.nameToVertexBufferIndex = name => vertexBufferNameDict[name] ?? -1;
	}

	setPipeline(renderPassEncoder){
		renderPassEncoder.setPipeline(mapCachePipeline(this.desc));
	}

	setBindGroup(renderPassEncoder, index, entries){
		renderPassEncoder.setBindGroup(index, createBindGroup(this.desc.groups[index], entries));
	}

	setVertexBuffer(renderPassEncoder, index, value){
		if(value instanceof GPUBuffer){
			renderPassEncoder.setVertexBuffer(index, value);
		}else if(Array.isArray(value)){
			const {arrayStride, temp:{array, stride, mapFn}} = this.desc.vertex.buffers[index];
			for(let i=0, n=value.length; i<n; ++i)array.set(mapFn(value[i]), i * stride);
			const size = arrayStride * value.length;
			const buffer = fetchBuffer(size, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
			getDevice().queue.writeBuffer(buffer, 0, array, 0, stride * value.length);
			renderPassEncoder.setVertexBuffer(index, buffer, 0, size);
		}else{
			const {stepMode} = this.desc.vertex.buffers[index];
			if(stepMode !== 'instance'){
				renderPassEncoder.setVertexBuffer(index, bufferCache(value, GPUBufferUsage.VERTEX));
				return;
			}
			const buffer = fetchBuffer(value.byteLength, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);//buffer may larger than request size
			getDevice().queue.writeBuffer(buffer, 0, value);
			renderPassEncoder.setVertexBuffer(index, buffer, 0, value.byteLength);
		}
	}

	setVertexBufferByName(renderPassEncoder, name, value){
		const index = this.nameToVertexBufferIndex(name);
		if(index >= 0)this.setVertexBuffer(renderPassEncoder, index, value);
	}

	setResources(renderPassEncoder, resources){
		for(let [index, entries] of Map.groupBy(Object.entries(resources), this.infoToGroupIndex)){
			if(index === undefined){
				for(let [name, value] of entries){
					if(name === 'index' && value){
						const format = value instanceof Uint32Array ? 'uint32' : 'uint16';
						renderPassEncoder.setIndexBuffer(bufferCache(value, GPUBufferUsage.INDEX), format);
						continue;
					}
					this.setVertexBufferByName(renderPassEncoder, name, value);
				}
				continue;
			}
			this.setBindGroup(renderPassEncoder, index, entries.map(this.infoToEntry));
		}
	}
}

Pipeline.prototype.clone = function(){
	const exclude = (value, exclude) => value && Object.fromEntries(Object.entries(value).filter(v => !exclude.includes(v[0])));
	const combine = (a, b) => b === null ? undefined : a && b ? Object.assign({}, a, b) : a ?? b;
	return function(modify){
		const target = this.desc;
		return new this.constructor({
			groups: modify.groups ?? target.groups,
			compute: exclude(combine(target.compute, modify.compute), ['module']),
			vertex: exclude(combine(target.vertex, modify.vertex), ['module']),
			fragment: exclude(combine(target.fragment, modify.fragment), ['module']),
			depthStencil: combine(target.depthStencil, modify.depthStencil),
			primitive: combine(target.primitive, modify.primitive),
			multisample: combine(target.multisample, modify.multisample),
		});
	}
}();

module.exports = Pipeline;
