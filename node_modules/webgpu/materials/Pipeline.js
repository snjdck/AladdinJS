'use strict';

const processInclude = require('./ShderInclude');
const findBody = require('utils/text/findBody');
const {removeNestComments} = require('utils/text/removeComments');
const {fetchBuffer, bufferCache} = require('../Vulkan/resource');
const {TypedArrayCache} = require('../helper/ResourcePool');
const {createGetter, createMapGetter} = require('utils/cache');
const {calcBindGroupLayoutSign, calcPipelineLayoutSign, calcSamplerSign, calcPipelineSign, calcResourceDefs} = require('webonly/utils_gpu');

const samplerCache = createGetter((desc, device) => device.createSampler(desc), calcSamplerSign);
const shaderCache = createGetter((code, device) => device.createShaderModule({code}));
const bindGroupLayoutCache = createGetter((entries, device) => device.createBindGroupLayout({entries}), calcBindGroupLayoutSign);
const pipelineLayoutCache = createGetter((layouts, device) => device.createPipelineLayout({bindGroupLayouts: layouts.map(v => bindGroupLayoutCache(v, device))}), calcPipelineLayoutSign);
const pipelineCache = createGetter(createPipeline, calcPipelineSign);
function createPipeline(desc, device){
	const {vertex, fragment, compute} = desc;
	if(!desc.layout){
		desc.layout = pipelineLayoutCache(desc.groups, device);
	}
	if(vertex && !vertex.module)vertex.module = shaderCache(processInclude(vertex.code), device);
	if(fragment && !fragment.module)fragment.module = shaderCache(processInclude(fragment.code), device);
	if(compute && !compute.module)compute.module = shaderCache(processInclude(compute.code), device);
	return compute ? device.createComputePipeline(desc) : device.createRenderPipeline(desc);
}
const mapCacheBindGroupLayout = createMapGetter(bindGroupLayoutCache);
const mapCacheSampler = createMapGetter(samplerCache);
const mapCachePipeline = createMapGetter(pipelineCache);
const createBindGroup = function(){
	function fn(v){return v.binding == this;}
	return (device, desc, entries) => {
		for(let entry of entries){
			const item = desc.find(fn, entry.binding);
			if(item.buffer){
				if(entry.resource.buffer instanceof GPUBuffer)continue;
				let bufferData = entry.resource.buffer;
				let bufferDataSize;
				let bufferSize;
				if(Array.isArray(bufferData)){
					const value = bufferData;
					const {type, stride, mapFn, length} = item.temp;
					bufferData = TypedArrayCache(type, length);
					bufferDataSize = 0;
					for(let i=0, n=value.length; i<n; ++i){
						bufferData.set(mapFn(value[i]), bufferDataSize);
						bufferDataSize += stride;
					}
					bufferSize = length * type.BYTES_PER_ELEMENT;
				}else{
					bufferSize = bufferData.byteLength;
				}
				bufferSize = Math.max(64, entry.resource.size ?? bufferSize);//less than 64 will warn
				const bufferType = item.buffer.type ?? 'uniform';
				const bufferUsage = bufferType == 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE;
				const buffer = fetchBuffer(bufferSize, bufferUsage | GPUBufferUsage.COPY_DST, device);
				device.queue.writeBuffer(buffer, 0, bufferData, 0, bufferDataSize);
				entry.resource.buffer = buffer;
				if(entry.resource.size === undefined)entry.resource.size = bufferSize;
			}/*else if(item.sampler){
				//if(entry.resource instanceof GPUSampler)continue;
				entry.resource = samplerCache(entry.resource);
			}*/
		}
		if(entries.length < desc.length){
			for(let entry of desc){
				if(entries.some(fn, entry.binding))continue;
				if(entry.sampler){
					entries.push({binding:entry.binding, resource:mapCacheSampler(entry.default, device)});
				}
			}
		}
		return device.createBindGroup({layout:mapCacheBindGroupLayout(desc, device), entries});
	};
}();

const isTransparent = function(){
	const testFn = v => v.blend !== undefined;
	return desc => desc.fragment?.targets?.some(testFn);
}();

const checkStage = function(){
	const calcRegExp = v => new RegExp('^[\\x20\\t]' + v, 'gm');
	const calcMinLen = ((p, f) => v => Math.min.apply(null, v.match(p).map(f)))(calcRegExp('*(?=\\S)'), v => v.length);
	return stage => {
		if(!stage)return;
		if(!stage.entryPoint)stage.entryPoint = 'main';
		stage.code = removeNestComments(stage.code.replace(calcRegExp(`{${calcMinLen(stage.code)}}`), ''));
	}
}();

const checkGroups = function(){
	const pattern = /^\s*array<.+?,\s*(\d+)\s*>\s*$/;
	const hasName = (code, name) => code && new RegExp(`\\b${name}\\b`).test(code);
	return desc => {
		for(let entries of desc.groups){
			let binding = 0;
			for(let entry of entries){
				if(entry.binding === undefined){
					entry.binding = binding++;
				}else{
					binding = entry.binding + 1;
				}
				if(entry.visibility === undefined){
					let visibility = 0;
					if(hasName(desc.vertex?.code, entry.name)){
						visibility |= GPUShaderStage.VERTEX;
					}
					if(hasName(desc.fragment?.code, entry.name)){
						visibility |= GPUShaderStage.FRAGMENT;
					}
					if(hasName(desc.compute?.code, entry.name)){
						visibility |= GPUShaderStage.COMPUTE;
					}
					entry.visibility = visibility;
				}
				if(entry.buffer && entry.temp){
					const {temp} = entry;
					if(temp.type === undefined){
						temp.type = Float32Array;
					}
					if(temp.stride === undefined){
						console.error(entry);
					}
					if(temp.length === undefined){
						temp.length = temp.stride * pattern.exec(entry.type)[1];
					}
				}
			}
		}
	}
}();

function assignDefaultValue(target, value){
	if(!target)return;
	for(let k in value){
		if(target[k] !== undefined)continue;
		target[k] = value[k];
	}
}

const checkStageFnInputs = function(){
	const calcVecType = function(){
		function calcType(t){
			switch(t){
				case 'sint':return 'i32';
				case 'uint':return 'u32';
			}
			return 'f32';
		}
		return (n, t) => n > 1 ? `vec${n}<${calcType(t)}>` : calcType(t);
	}();
	const calcBuiltin = function(){
		const p1 = v => new RegExp(`\\b${v}\\b`);
		const p2 = /\b\w+(?=:)/;
		return function(fnBody, args){
			const result = [];
			for(let arg of args){
				if(p1(arg.match(p2)[0]).test(fnBody)){
					result.push(arg);
				}
			}
			return result;
		}
	}();
	const calcBufferType = function(){
		const pattern = /^([a-z]+)\d+(?:|x(\d))$/;
		return format => {
			const info = pattern.exec(format);
			return calcVecType(Number(info[2]), info[1]);
		}
	}();
	const calcTargetType = function(){
		const pattern = /^([rgba]{1,4})\d+(\w+)/;
		return v => {
			const info = pattern.exec(v.format);
			return calcVecType(info[1].length, info[2]);
		}
	}();
	const argsVertex = ['@builtin(instance_index)instanceIndex:u32', '@builtin(vertex_index)vertexIndex:u32'];
	const argsFragment = ['@builtin(position)FragCoord:vec4<f32>'];
	const argsCompute = ['@builtin(workgroup_id)wgid:vec3<u32>', '@builtin(num_workgroups)numwgs:vec3<u32>'];
	return ({groups, vertex, fragment, compute}) => {
		if(compute){
			const {entryPoint, code} = compute;
			const info = /@workgroup_size\s*\(\s*\d+(|\s*,\s*\d+(|\s*,\s*\d+))\s*\)\s*(?=\{)/.exec(code);
			if(info){
				const args = calcBuiltin(findBody(code, info.index), argsCompute);
				compute.code = calcResourceDefs(groups, GPUShaderStage.COMPUTE) + code.replace(info[0], `@compute $& fn ${entryPoint}(${args.join(',')})`);
			}
		}
		if(vertex){
			const {entryPoint, code, buffers} = vertex;
			const info = /@vertex\b\s*(\w*)\s*(?=\{)/.exec(code);
			if(info){
				const args = calcBuiltin(findBody(code, info.index), argsVertex);
				for(let buffer of buffers ?? []){
					for(let {name, format, shaderLocation} of buffer.attributes){
						args.push(`@location(${shaderLocation})${name ?? buffer.name}:${calcBufferType(format)}`);
					}
				}
				const returnType = info[1] || '@builtin(position)vec4<f32>';
				vertex.code = calcResourceDefs(groups, GPUShaderStage.VERTEX) + code.replace(info[0], `@vertex fn ${entryPoint}(${args.join(',')})->${returnType}`);
			}
		}
		if(fragment){
			const {entryPoint, code, targets} = fragment;
			const info = /@fragment\s*(?=\{)/.exec(code);
			if(info){
				const args = calcBuiltin(findBody(code, info.index), argsFragment);
				const vertexOutput = /@vertex.*?->\s*(\w+)/.exec(vertex.code);
				if(vertexOutput){
					const structBody = new RegExp(`\\bstruct\\s+${vertexOutput[1]}\\s*\\{([^}]+)\\}`).exec(vertex.code)[1];
					args.push(...structBody.match(/@location\(\d+\)[^,]+/g));
				}
				let returnType, prefix;
				if(targets.length > 1){
					returnType = 'Output';
					prefix = `struct ${returnType}{` + targets.map((v, i) => `@location(${i})v${i}:${calcTargetType(v)}`).join(',') + '}\n';
				}else{
					returnType = `@location(0)${calcTargetType(targets[0])}`;
					prefix = '';
				}
				fragment.code = calcResourceDefs(groups, GPUShaderStage.FRAGMENT) + code.replace(info[0], prefix + `@fragment fn ${entryPoint}(${args.join(',')})->${returnType}`);
			}
		}
	}
}();

const checkVertexBuffers = function(){
	const pattern = /^[a-z]+(\d+)(?:|x(\d))$/;
	return buffers => {
		if(!buffers)return;
		let shaderLocation = 0;
		for(let buffer of buffers){
			let offset = 0;
			for(let attribute of buffer.attributes){
				if(attribute.shaderLocation === undefined){
					attribute.shaderLocation = shaderLocation;
				}else{
					shaderLocation = attribute.shaderLocation;
				}
				++shaderLocation;
				if(attribute.offset === undefined){
					attribute.offset = offset;
				}else{
					offset = attribute.offset;
				}
				const info = pattern.exec(attribute.format);
				offset += info[1] * (info[2] ?? 1) >> 3;
			}
			if(buffer.arrayStride === undefined){
				buffer.arrayStride = offset;
			}
			if(buffer.temp){
				const {temp} = buffer;
				if(temp.type === undefined){
					temp.type = Float32Array;
				}
				if(temp.stride === undefined){
					temp.stride = buffer.arrayStride / temp.type.BYTES_PER_ELEMENT;
				}
			}
		}
	}
}();

const checkFragmentTargets = function(){
	const blendCache = function(){
		const blendComponentCache = createGetter(desc => {
			const [srcFactor, operation, dstFactor] = desc.split(' ');
			return {srcFactor, operation, dstFactor};
		});
		return createGetter(desc => {
			const [color, alpha] = desc.split(';').map(blendComponentCache);
			return {color, alpha: alpha ?? color};
		});
	}();
	function castBlend(v){
		if(typeof v.blend === 'string')v.blend = blendCache(v.blend);
		if(v.format === undefined)v.format = 'bgra8unorm';
	}
	return targets => targets?.forEach(castBlend);
}();

class Pipeline {
	constructor(desc){
		this.desc = desc;
		this.opaque = !isTransparent(desc);
		checkStage(desc.vertex);
		checkStage(desc.fragment);
		checkStage(desc.compute);
		assignDefaultValue(desc.depthStencil, {format:'depth24plus-stencil8', depthWriteEnabled:true, depthCompare:'less-equal'});
		checkGroups(desc);
		checkVertexBuffers(desc.vertex?.buffers);
		checkFragmentTargets(desc.fragment?.targets);
		checkStageFnInputs(desc);
		const vertexBufferNameDict = Object.fromEntries(Array.from(desc.vertex?.buffers ?? [], (v, i) => [v.name, i]).filter(v => v[0]));
		const bindingNameDict = Object.fromEntries(desc.groups.map((v, i) => v.map(v => [v.name, [i, v.binding]])).flat().filter(v => v[0]));
		this.infoToGroupIndex = ([name]) => bindingNameDict[name]?.[0];
		this.infoToEntry = ([name, resource]) => ({binding: bindingNameDict[name][1], resource});
		this.nameToVertexBufferIndex = name => vertexBufferNameDict[name] ?? -1;
	}

	getRawValue(device){
		return mapCachePipeline(this.desc, device);
	}

	setVertexBuffer(renderPassEncoder, index, value){
		const {device} = renderPassEncoder;
		if(value instanceof GPUBuffer){
			renderPassEncoder.setVertexBuffer(index, value);
		}else if(Array.isArray(value)){
			const {arrayStride, temp:{type, stride, mapFn}} = this.desc.vertex.buffers[index];
			const array = TypedArrayCache(type, stride * value.length);
			for(let i=0, n=value.length; i<n; ++i)array.set(mapFn(value[i]), i * stride);
			const size = arrayStride * value.length;
			const buffer = fetchBuffer(size, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, device);
			renderPassEncoder.writeBuffer(buffer, 0, array, 0, stride * value.length);
			renderPassEncoder.setVertexBuffer(index, buffer, 0, size);
		}else{
			const {stepMode} = this.desc.vertex.buffers[index];
			if(stepMode === undefined){
				renderPassEncoder.setVertexBuffer(index, bufferCache(value, GPUBufferUsage.VERTEX, device));
				return;
			}
			const buffer = fetchBuffer(value.byteLength, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, device);//buffer may larger than request size
			renderPassEncoder.writeBuffer(buffer, 0, value);
			renderPassEncoder.setVertexBuffer(index, buffer, 0, value.byteLength);
		}
	}

	setResources(renderPassEncoder, resources){
		const {device} = renderPassEncoder;
		for(let [index, entries] of Map.groupBy(Object.entries(resources), this.infoToGroupIndex)){
			if(index === undefined){
				for(let [name, value] of entries){
					if(name === 'index' && value){
						const format = value instanceof Uint32Array ? 'uint32' : 'uint16';
						renderPassEncoder.setIndexBuffer(bufferCache(value, GPUBufferUsage.INDEX, device), format);
						continue;
					}
					const bufferIndex = this.nameToVertexBufferIndex(name);
					if(bufferIndex >= 0){
						this.setVertexBuffer(renderPassEncoder, bufferIndex, value);
					}
				}
				continue;
			}
			const bindGroup = createBindGroup(device, this.desc.groups[index], entries.map(this.infoToEntry));
			renderPassEncoder.setBindGroup(index, bindGroup);
		}
	}
}

/*
(0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5)
0-2-4
|/|/|
1-3-5
*/
Pipeline.Blit = function(){
	const vertexCode = `
		struct Output {
			@builtin(position) position: vec4<f32>,
			@location(0) uvxy: vec4<f32>,
		}
		@vertex Output {
			let vertex = vec2<f32>(vec2(vertexIndex & 1, vertexIndex >> 1));
			let position = vertex * 2 - 1;
			return Output(vec4(position, 0, 1), vec4(vertex.x, 1-vertex.y, position));
		}
	`;
	return (groups, target, fragmentCode, depthStencil) => new Pipeline({
		groups, depthStencil,
		vertex: {code:vertexCode},
		fragment: {code:fragmentCode, targets:[target]},
		primitive: {topology: 'triangle-strip'}
	});
}();

module.exports = Pipeline;
