'use strict';

const Vulkan = require('../Vulkan');
const defineConstGetter = require('utils/object/defineConstGetter');
const {createGetter, createMapGetter} = require('utils/cache');
const {calcBindGroupLayoutSign, calcPipelineLayoutSign, calcSamplerSign} = require('webonly/utils_gpu');
const {fetchBuffer} = require('../Vulkan/resource');

const samplerCache = createGetter(desc => Vulkan.device.createSampler(desc), calcSamplerSign);
const shaderCache = createGetter(code => Vulkan.device.createShaderModule({code}));
const bindGroupLayoutCache = createGetter(entries => Vulkan.device.createBindGroupLayout({entries}), calcBindGroupLayoutSign);
const pipelineLayoutCache = createGetter(layouts => Vulkan.device.createPipelineLayout({bindGroupLayouts: layouts.map(bindGroupLayoutCache)}), calcPipelineLayoutSign);
function createRenderPipeline(desc){
	const {vertex, fragment} = desc;
	if(!desc.layout){
		desc.layout = pipelineLayoutCache(desc.groups)
	}
	if(!vertex.module){
		vertex.module = shaderCache(vertex.code);
	}
	if(!fragment.module){
		fragment.module = shaderCache(fragment.code);
	}
	return Vulkan.device.createRenderPipeline(desc);
}
const mapCacheBindGroupLayout = createMapGetter(bindGroupLayoutCache);
const mapCacheSampler = createMapGetter(samplerCache);
const createBindGroup = function(){
	function fn(v){return v.binding == this;}
	return groups => (index, entries) => {
		const desc = groups[index];
		for(let entry of entries){
			const item = desc.find(fn, entry.binding);
			if(item.buffer){
				if(entry.resource.buffer instanceof GPUBuffer)continue;
				let bufferData, bufferDataSize;
				if(Array.isArray(entry.resource.buffer)){
					const value = entry.resource.buffer;
					const {array, stride, mapFn} = item.temp;
					for(let i=0, n=value.length; i<n; ++i)array.set(mapFn(value[i]), i * stride);
					bufferData = array;
					bufferDataSize = stride * value.length;
				}else{
					bufferData = entry.resource.buffer;
					bufferDataSize = entry.resource.dataSize;
				}
				const bufferSize = Math.max(64, entry.resource.size ?? bufferData.byteLength);//less than 64 will warn
				const {buffer} = fetchBuffer({usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, size: bufferSize});
				Vulkan.device.queue.writeBuffer(buffer, 0, bufferData, 0, bufferDataSize);
				entry.resource.buffer = buffer;
				if(entry.resource.size === undefined)entry.resource.size = bufferSize;
			}else if(item.sampler){
				if(entry.resource instanceof GPUSampler)continue;
				entry.resource = samplerCache(entry.resource);
			}
		}
		if(entries.length < desc.length){
			for(let entry of desc){
				if(entries.some(fn, entry.binding))continue;
				if(entry.sampler){
					entries.push({binding:entry.binding, resource:mapCacheSampler(entry.default)});
				}
			}
		}
		return Vulkan.device.createBindGroup({layout:mapCacheBindGroupLayout(desc), entries});
	};
}();
/*
function createBindGroupWith(resource, index=0){
	for(let desc of this){
		for(let entry of desc){
			if(typeof index === 'string'){
				if(entry.name !== index)continue;
			}else if(resource instanceof GPUTextureView){
				if(!(entry.texture || entry.storageTexture) || index-- > 0)continue;
			}else if(resource instanceof GPUSampler){
				if(!entry.sampler || index-- > 0)continue;
			}else if(resource instanceof GPUExternalTexture){
				if(!entry.externalTexture || index-- > 0)continue;
			}else if(resource.buffer instanceof GPUBuffer){
				if(!entry.buffer || index-- > 0)continue;
			}else{
				throw resource;
			}
			return createBindGroup.call(this, this.indexOf(desc), [{binding: entry.binding, resource}]);
		}
	}
	throw resource;
}

function findBufferIndex(name){
	const {groups, vertex:{buffers}} = this;
	for(let i=0, n=groups.length; i<n; ++i){
		for(let entry of groups[i]){
			if(entry.name === name)return i;
		}
	}
	for(let i=0, n=buffers.length; i<n; ++i){
		if(buffers[i].name === name)return i;
	}
	return -1;
}

function findbindGroupSlots(desc){
	const result = {};
	const groups = desc.groups;
	const buffers = desc.vertex?.buffers;
	if(groups){
		for(let i=0, n=groups.length; i<n; ++i){
			for(let {name, buffer} of groups[i]){
				if(name && buffer?.hasDynamicOffset){
					result[name] = i;
					break;
				}
			}
		}
	}
	if(buffers){
		for(let i=0, n=buffers.length; i<n; ++i){
			const {name, stepMode} = buffers[i];
			if(name && stepMode == 'instance'){
				result[name] = i;
			}
		}
	}
	return result;
}

function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}
//*/

class Material {
	static order = 0;

	static Subclass(pipelineDict, groupFnList){
		const pipelineDesc = pipelineDict.pipeline;
		const Sub = class extends this {};
		if(groupFnList)Sub.groupFn = newGroupFn(groupFnList);
		Sub.pipelineDesc = pipelineDesc;
		for(const [name, desc] of Object.entries(pipelineDict)){
			defineConstGetter(Sub, name, () => createRenderPipeline(desc));
		}
		Sub.pipelineUseDepthStencilFlag = pipelineDesc.depthStencil != null;
		Sub.vertexBuffers = pipelineDesc.vertex.buffers?.map(v => v.name);
		Sub.createBindGroup = createBindGroup(pipelineDesc.groups);
		return Sub;
	}
	
	get group(){
		return 0;
	}

	static draw(entityList){
		this.onSetPipelineAndBuffer();
		this.groupFn(entityList);
	}

	static onSetPipelineAndBuffer(){
		const pipeline = Vulkan.renderPassUseDepthStencilFlag === this.pipelineUseDepthStencilFlag ? this.pipeline : this.pipeline2;
		Vulkan.renderPassEncoder.setPipeline(pipeline);
	}

	static setBindGroup(index, entries){
		Vulkan.renderPassEncoder.setBindGroup(index, this.createBindGroup(index, entries));
	}

	static setVertexBuffer(index, value){
		if(Array.isArray(value)){
			const {valueArray, valueStride, arrayStride} = this.pipelineDesc.vertex.buffers[index];
			for(let i=0, n=value.length; i<n; ++i){
				valueArray.set(value[i], i * valueStride);
			}
			const size = arrayStride * value.length;
			const {buffer} = fetchBuffer({usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, size});
			Vulkan.device.queue.writeBuffer(buffer, 0, valueArray, 0, valueStride * value.length);
			Vulkan.renderPassEncoder.setVertexBuffer(index, buffer, 0, size);
		}else if(value instanceof GPUBuffer){
			Vulkan.renderPassEncoder.setVertexBuffer(index, value);
		}else{
			const {buffer} = fetchBuffer({usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, size: value.byteLength});//buffer may larger than request size
			Vulkan.device.queue.writeBuffer(buffer, 0, value);
			Vulkan.renderPassEncoder.setVertexBuffer(index, buffer, 0, value.byteLength);
		}
	}
}

Material.Utils = function(){
	const group = fn => list => Map.groupBy(list, fn);
	const cut = limit => function*(list){
		if(limit <= 1)return yield* list;
		const {length} = list;
		if(length <= limit)return yield list;
		let offset = 0;
		do{
			yield list.slice(offset, offset + limit);
			offset += limit;
		}while(offset < length);
	}
	return {
		cut,
		groupMesh: group(v => v.entity.mesh),
		groupTexture: group(v => v.material.texture),
	};
}();

const newGroupFn = function(){
	const reduceFn = (itemFn, groupFn) => function(itemList, ...args){
		const map = groupFn(itemList);
		if(map instanceof Map){
			for(let [k, v] of map){
				itemFn.call(this, v, ...args, k);
			}
		}else{
			for(let v of map){
				itemFn.call(this, v, ...args);
			}
		}
	}
	function itemFn(...args){
		this.onDrawBatched(...args);
	}
	return groupFnList => groupFnList.reduceRight(reduceFn, itemFn);
}();

module.exports = Material;
