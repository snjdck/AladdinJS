'use strict';

const Vulkan = require('../Vulkan');

function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}

class Material{
	static order = 0;
	static maxCountPerBatch = 1;
	static useMeshFlag = true;
	static bindGroupSlots = (v => () => v)([]);
	static setVertexBuffer(){
		const {renderPassEncoder, currentMesh:mesh} = Vulkan;
		if(!mesh.vertexData)return;
		if(!mesh._vertexBuffer){
			mesh._vertexBuffer = Vulkan.createBufferMapped(GPUBufferUsage.VERTEX, mesh.vertexData);;
		}
		renderPassEncoder.setVertexBuffer(0, mesh._vertexBuffer);
	}
	static setIndexBuffer(){
		const {renderPassEncoder, currentMesh:mesh} = Vulkan;
		if(!mesh.indexData)return;
		if(!mesh._indexBuffer){
			mesh._indexBuffer = Vulkan.createBufferMapped(GPUBufferUsage.INDEX, mesh.indexData);
		}
		renderPassEncoder.setIndexBuffer(mesh._indexBuffer);
	}
	/*
	static calcDrawCount(entityCount){
		return Math.ceil(entityCount / this.maxCountPerBatch);
	}
	*/
	get group(){
		return 0;
	}

	static draw(entityList){
		this.onDraw(entityList, this.bindGroupSlots().map(slot => slot.add(entityList)));
	}

	static onDraw(entityList, bindGroupInfoList, ...args){
		draw.call(this, entityList.length, bindGroupInfoList, updateFn, this.doDraw, ...args);
	}
}

function updateFn(index, batchIndex, bufferOffset){
	const {bindGroupSlots, bindIndexList} = this;
	bindGroupSlots()[index].active(bindIndexList[index], batchIndex, bufferOffset);
}

function draw(entityCount, bindGroupInfoList, updateFn, drawFn, ...args){
	const offsetList = new Array(bindGroupInfoList.length).fill(0);
	const indexList = offsetList.slice();
	for(let i=0; i<entityCount;){
		for(let j=bindGroupInfoList.length-1; j>=0; --j){
			if(i < offsetList[j]){
				const [batchIndex, bufferOffset, instanceCount] = bindGroupInfoList[j][indexList[j]-1];
				updateFn.call(this, j, batchIndex, bufferOffset + i - (offsetList[j] - instanceCount));
			}else{
				const [batchIndex, bufferOffset, instanceCount] = bindGroupInfoList[j][indexList[j]++];
				updateFn.call(this, j, batchIndex, bufferOffset);
				offsetList[j] += instanceCount;
			}
		}
		const offsetEnd = Math.min(...offsetList);
		drawFn.call(this, offsetEnd - i, ...args);
		i = offsetEnd;
	}
}

module.exports = Material;
