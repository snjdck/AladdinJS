'use strict';

const Pipeline = require('./Pipeline');

/*
function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}
//*/

class Material {
	static order = 0;
	//static maxCountPerDraw = 1;

	static Subclass(pipeline, groupFnList){
		const Sub = class extends this {};
		Sub.opaque = pipeline.opaque;
		//if(groupFnList)Sub.groupFn = newGroupFn(groupFnList);
		Sub.pipeline = pipeline;
		//Sub.setPipeline = pipeline.setPipeline.bind(pipeline);
		Sub.setResources = pipeline.setResources.bind(pipeline);
		return Sub;
	}

	static draw(entityList, renderPassEncoder){
		this.pipeline.setPipeline(renderPassEncoder);
		this.onDraw(entityList, renderPassEncoder);
	}
}

const drawDepth = function(){
	const filterFn = v => v.material;
	const groupFn = drawUnit => drawUnit.material.constructor;
	const mapFn = depthType => ({entity, material}) => ({entity, material: material[depthType]});
	const fnDict = {depth:mapFn('depth'), pick:mapFn('pick')};
	return (renderPassEncoder, shadowCasterList, vpMatrix, depthType) => {
		if(shadowCasterList.length <= 0)return;
		for(let [materialType, drawUnitList] of Map.groupBy(shadowCasterList.map(fnDict[depthType]).filter(filterFn), groupFn)){
			materialType.setResources(renderPassEncoder, {'vpMatrix': {buffer:vpMatrix}});
			materialType.draw(drawUnitList, renderPassEncoder);
		}
	}
}();

Material.drawDepth = (...args) => drawDepth(...args, 'depth');
Material.drawPick = (...args) => drawDepth(...args, 'pick');
Material.itemDict = new Map();

Material.Utils = function(){
	function* group2d(list){
		let nowKey, nowSet;
		for(const target of list){
			const key = target.texture.getRawAsset();
			if(nowKey === key){
				nowSet.push(target);
				continue;
			}
			if(nowKey)yield [nowKey, nowSet];
			nowKey = key;
			nowSet = [target];
		}
		yield [nowKey, nowSet];
	}
	const group = fn => list => Map.groupBy(list, fn);
	function* cut(limit, list){
		const {length} = list;
		if(length <= limit)return yield list;
		let offset = 0;
		do{
			yield list.slice(offset, offset + limit);
			offset += limit;
		}while(offset < length);
	}
	return {
		groupMesh: group(v => v.entity.mesh),
		groupTexture: group(v => v.material.texture),
		group2d,
		cut,
	};
}();
/*
const newGroupFn = function(){
	function* cut(limit, list){
		const {length} = list;
		if(length <= limit)return yield list;
		let offset = 0;
		do{
			yield list.slice(offset, offset + limit);
			offset += limit;
		}while(offset < length);
	}
	const reduceFn = (itemFn, groupFn) => function(itemList, ...args){
		for(let [k, v] of groupFn(itemList)){
			itemFn.call(this, v, k, ...args);
		}
	}
	function itemFn(itemList, ...args){
		for(let v of cut(this.maxCountPerDraw, itemList)){
			this.onDraw(v, ...args);
		}
	}
	return groupFnList => groupFnList.reduceRight(reduceFn, itemFn);
}();
*/
module.exports = Material;
