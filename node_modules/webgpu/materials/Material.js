'use strict';

const Vulkan = require('../Vulkan');
const drawSlotCacheList = require('../helper/drawSlotCacheList');
/*
function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}
//*/
class Material{
	static order = 0;
	static maxCountPerBatch = 1;
	static useMeshFlag = true;
	static bindGroupSlots = (v => () => v)([]);
	static setVertexBuffer(){
		const {renderPassEncoder, currentMesh:mesh} = Vulkan;
		if(!mesh.vertexData)return;
		if(!mesh._vertexBuffer){
			mesh._vertexBuffer = Vulkan.createBufferMapped(GPUBufferUsage.VERTEX, mesh.vertexData);;
		}
		renderPassEncoder.setVertexBuffer(0, mesh._vertexBuffer);
	}
	static setIndexBuffer(){
		const {renderPassEncoder, currentMesh:mesh} = Vulkan;
		if(!mesh.indexData)return;
		if(!mesh._indexBuffer){
			mesh._indexBuffer = Vulkan.createBufferMapped(GPUBufferUsage.INDEX, mesh.indexData);
		}
		renderPassEncoder.setIndexBuffer(mesh._indexBuffer, 'uint16');
	}
	/*
	static calcDrawCount(entityCount){
		return Math.ceil(entityCount / this.maxCountPerBatch);
	}
	*/
	get group(){
		return 0;
	}

	static draw(entityList){
		this.onDraw(entityList, this.bindGroupSlots().map(slot => slot.add(entityList)));
	}

	static onDraw(entityList, bindGroupInfoList, ...args){
		for(let data of drawSlotCacheList(entityList.length, this.bindGroupSlots(), bindGroupInfoList)){
			this.doDraw(...data, ...args);
		}
	}
}

module.exports = Material;
