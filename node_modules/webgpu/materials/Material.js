'use strict';

const Vulkan = require('../Vulkan');

const calcBindGroupInfoListFn = function(){
	function slotMapFn(slot){
		return slot.add(this);
	}
	return slotList => entityList => slotList.map(slotMapFn, entityList);
}();

const activeBindGroupFn = slotList => function*(infoList){
	if(slotList.length <= 0)return;
	const dataList = slotList.map((v, i) => [v, infoList[i], 0, 0]);
	for(let i=0;;){
		let offsetEnd = Number.MAX_SAFE_INTEGER;
		for(let data of dataList){
			const [slot, info, index, offset] = data;
			if(i < offset){
				const [batchIndex, bufferOffset, instanceCount] = info[index-1];
				slot.active(batchIndex, bufferOffset + i - (offset - instanceCount));
			}else if(index < info.length){
				const [batchIndex, bufferOffset, instanceCount] = info[index];
				slot.active(batchIndex, bufferOffset);
				data[2] = index + 1;
				data[3] = offset + instanceCount;
			}else{
				return;
			}
			offsetEnd = Math.min(offsetEnd, data[3]);
		}
		yield offsetEnd - i;
		i = offsetEnd;
	}
}

/*
console.log(Array.from(activeBindGroupFn([])(6, [])))
console.log(Array.from(activeBindGroupFn([{active(...args){
	console.log('active 1:', ...args)
}},{active(...args){
	console.log('active 2:', ...args)
}}])([[[0,0,3],[1,0,3]],[[0,0,2],[1,0,2],[2,0,2]]])))
//*/

/*
function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}
//*/
class Material{
	static order = 0;
	static maxCountPerBatch = 1;
	static useMeshFlag = true;
	//static pipelineAutoSetFlag = true;
	static calcBindGroupInfoList = (v => () => v)([]);
	//static activeBindGroup = v => [v];
	static Subclass(pipelineDesc, bindGroupSlots){
		const Sub = class extends this {};
		Vulkan.bindRenderPipeline(Sub, pipelineDesc);
		if(bindGroupSlots){
			bindGroupSlots = bindGroupSlots.map((v, i) => v?.bind(i)).filter(Boolean);
			Sub.calcBindGroupInfoList = calcBindGroupInfoListFn(bindGroupSlots);
			Sub.activeBindGroup = activeBindGroupFn(bindGroupSlots);
			Sub.slotCacheList = new Set(bindGroupSlots.map(v => v.target));
		}
		return Sub;
	}
	static setVertexBuffer(mesh){
		if(!mesh?.vertexData)return;
		Vulkan.renderPassEncoder.setVertexBuffer(0, mesh.vertexBuffer);
	}
	static setIndexBuffer(mesh){
		if(!mesh?.indexData)return;
		Vulkan.renderPassEncoder.setIndexBuffer(mesh.indexBuffer, 'uint16');
	}
	/*
	static calcDrawCount(entityCount){
		return Math.ceil(entityCount / this.maxCountPerBatch);
	}
	*/
	get group(){
		return 0;
	}

	static *calcDrawIterator(entityList){
		yield this.calcBindGroupInfoList(entityList);
	}

	static draw(entityList, mesh){
		//if(this.pipelineAutoSetFlag || pipelineSetFlag){
		this.slotCacheList?.forEach(Vulkan.requestReset);
		this.onSetPipelineAndBuffer(mesh);
		for(const bindGroupInfoList of this.calcDrawIterator(entityList, mesh)){
			for(const instanceCount of this.activeBindGroup(bindGroupInfoList)){
				this.onDraw(instanceCount, mesh);
			}
		}
	}

	static onSetPipelineAndBuffer(mesh){
		Vulkan.renderPassEncoder.setPipeline(this.pipeline);
		this.setVertexBuffer(mesh);
		this.setIndexBuffer(mesh);
	}
}

module.exports = Material;
