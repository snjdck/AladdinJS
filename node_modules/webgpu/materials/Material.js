'use strict';

const Vulkan = require('../Vulkan');
const defineConstGetter = require('utils/object/defineConstGetter');
const {createGetter} = require('utils/cache');
const {calcBindGroupLayoutSign, calcPipelineLayoutSign, calcSamplerSign} = require('webonly/utils_gpu');
const {activeBindGroup} = require('../helper/Slot');

const samplerCache = createGetter(desc => Vulkan.device.createSampler(desc), calcSamplerSign);
const shaderCache = createGetter(code => Vulkan.device.createShaderModule({code}));
const bindGroupLayoutCache = createGetter(entries => Vulkan.device.createBindGroupLayout({entries}), calcBindGroupLayoutSign);
const pipelineLayoutCache = createGetter(layouts => Vulkan.device.createPipelineLayout({bindGroupLayouts: layouts.map(bindGroupLayoutCache)}), calcPipelineLayoutSign);
function createRenderPipeline(desc){
	const {vertex, fragment} = desc;
	if(!desc.layout){
		desc.layout = pipelineLayoutCache(desc.groups)
	}
	if(!vertex.module){
		vertex.module = shaderCache(vertex.code);
	}
	if(!fragment.module){
		fragment.module = shaderCache(fragment.code);
	}
	return Vulkan.device.createRenderPipeline(desc);
}
const createBindGroup = function(){
	function fn(v){return v.binding == this;}
	return (desc, entries) => {
		for(let entry of entries){
			const {sampler} = desc.find(fn, entry.binding);
			if(sampler){
				if(entry.resource instanceof GPUSampler)continue;
				entry.resource = samplerCache(entry.resource);
			}
		}
		if(entries.length < desc.length){
			for(let entry of desc){
				if(entries.some(fn, entry.binding))continue;
				if(entry.sampler){
					entries.push({binding:entry.binding, resource:samplerCache(entry.default)});
				}
			}
		}
		return Vulkan.device.createBindGroup({layout:bindGroupLayoutCache(desc), entries});
	}
}();
/*
function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}
//*/

class Material {
	static order = 0;
	static maxCountPerBatch = 1;
	static useMeshFlag = true;

	static Subclass(pipelineDict, bindGroupSlots={}){
		const Sub = class extends this {};
		const pipelineDesc = pipelineDict.pipeline;
		for(const [name, desc] of Object.entries(pipelineDict)){
			defineConstGetter(Sub, name, () => createRenderPipeline(desc));
		}
		Sub.vertexBuffers = pipelineDesc.vertex.buffers?.map(v => v.name);
		Sub.createBindGroup = (index, entries) => createBindGroup(pipelineDesc.groups[index], entries);
		Vulkan.bindMaterialSlots(Sub, bindGroupSlots);
		return Sub;
	}
	
	get group(){
		return 0;
	}

	static *calcDrawIterator(entityList){
		yield * activeBindGroup(this.slotList, entityList);
	}

	static draw(entityList, mesh){
		//if(this.pipelineAutoSetFlag || pipelineSetFlag){
		this.onSetPipelineAndBuffer(mesh);
		for(const instanceCount of this.calcDrawIterator(entityList, mesh)){
			this.onDraw(instanceCount, mesh);
		}
	}

	static onSetPipelineAndBuffer(mesh){
		Vulkan.renderPassEncoder.setPipeline(this.pipeline);
	}

	static onDraw(instanceCount, mesh){
		if(this.useMeshFlag !== true){
			Vulkan.renderPassEncoder.draw(this.useMeshFlag, instanceCount);
			return;
		}
		const {subMeshList} = mesh;
		for(let i=0, n=subMeshList.length; i<n; ++i){
			this.onDrawSubMesh(instanceCount, subMeshList[i], i);
		}
	}

	static onDrawSubMesh(instanceCount, subMesh){
		subMesh.setBuffers(this.vertexBuffers);
		subMesh.draw(instanceCount);
	}
}

module.exports = Material;
