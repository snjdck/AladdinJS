'use strict';

const Vulkan = require('../Vulkan');

function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}

class Material{
	static order = 0;
	static maxCountPerBatch = 1;
	static useMeshFlag = true;
	static setVertexBuffer(){
		const {renderPassEncoder, currentMesh:mesh} = Vulkan;
		if(!mesh.vertexData)return;
		if(!mesh._vertexBuffer){
			mesh._vertexBuffer = Vulkan.createBufferMapped(GPUBufferUsage.VERTEX, mesh.vertexData);;
		}
		renderPassEncoder.setVertexBuffer(0, mesh._vertexBuffer);
	}
	static setIndexBuffer(){
		const {renderPassEncoder, currentMesh:mesh} = Vulkan;
		if(!mesh.indexData)return;
		if(!mesh._indexBuffer){
			mesh._indexBuffer = Vulkan.createBufferMapped(GPUBufferUsage.INDEX, mesh.indexData);
		}
		renderPassEncoder.setIndexBuffer(mesh._indexBuffer);
	}
	/*
	static calcDrawCount(entityCount){
		return Math.ceil(entityCount / this.maxCountPerBatch);
	}
	*/
	get group(){
		return 0;
	}

	static draw(entityList){
		this.onDraw(Vulkan.transformUniformMgr.register(entityList));
		//this.onDraw(drawBatched.call(transformUniformMgr, this.maxCountPerBatch, entityList, transformUniformMgr.register));
	}
}

module.exports = Material;
