'use strict';

const Pipeline = require('./Pipeline');

/*
function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}
//*/

class Material {
	static order = 0;
	static maxCountPerDraw = 1;

	static Subclass(pipelineDesc, groupFnList){
		const pipeline = new Pipeline(pipelineDesc);
		const Sub = class extends this {};
		Sub.opaque = pipeline.opaque;
		if(groupFnList)Sub.groupFn = newGroupFn(groupFnList);
		Sub.pipelineDesc = pipelineDesc;
		//Sub.vertexBuffers = pipelineDesc.vertex?.buffers?.map(v => v.name);
		Sub.setPipeline = pipeline.setPipeline.bind(pipeline);
		Sub.setResources = pipeline.setResources.bind(pipeline);
		return Sub;
	}

	static draw(entityList, renderPassEncoder){
		this.setPipeline(renderPassEncoder);
		this.groupFn(entityList, renderPassEncoder);
	}
}

Material.Utils = function(){
	function* group2d(list){
		let nowKey, nowSet;
		for(const target of list){
			const key = target.texture.getRawAsset();
			if(nowKey === key){
				nowSet.push(target);
				continue;
			}
			if(nowKey)yield [nowKey, nowSet];
			nowKey = key;
			nowSet = [target];
		}
		yield [nowKey, nowSet];
	}
	const group = fn => list => Map.groupBy(list, fn);
	return {
		groupMesh: group(v => v.entity.mesh),
		groupTexture: group(v => v.material.texture),
		group2d,
	};
}();

const newGroupFn = function(){
	function* cut(limit, list){
		const {length} = list;
		if(length <= limit)return yield list;
		let offset = 0;
		do{
			yield list.slice(offset, offset + limit);
			offset += limit;
		}while(offset < length);
	}
	const reduceFn = (itemFn, groupFn) => function(itemList, ...args){
		for(let [k, v] of groupFn(itemList)){
			itemFn.call(this, v, k, ...args);
		}
	}
	function itemFn(itemList, ...args){
		for(let v of cut(this.maxCountPerDraw, itemList)){
			this.onDraw(v, ...args);
		}
	}
	return groupFnList => groupFnList.reduceRight(reduceFn, itemFn);
}();

module.exports = Material;
