'use strict';

const Vulkan = require('../Vulkan');
const {calcBindGroupInfoList, activeBindGroup} = require('../helper/Slot');

/*
function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}
//*/

class Material {
	static order = 0;
	static maxCountPerBatch = 1;
	static useMeshFlag = true;

	static Subclass(pipelineDesc, bindGroupSlots={}, vertexBuffers=[]){
		const Sub = class extends this {};
		Vulkan.bindRenderPipeline(Sub, pipelineDesc);
		Vulkan.bindMaterialSlots(Sub, bindGroupSlots);
		Sub.activeVertexBuffers = subMesh => vertexBuffers.forEach((name, i) => Vulkan.renderPassEncoder.setVertexBuffer(i, subMesh.buffers[name]));
		return Sub;
	}
	
	static setVertexBuffer(mesh){
		if(!mesh?.vertexData)return;
		Vulkan.renderPassEncoder.setVertexBuffer(0, mesh.vertexBuffer);
	}

	static setIndexBuffer(mesh){
		if(!mesh?.indexData)return;
		Vulkan.renderPassEncoder.setIndexBuffer(mesh.indexBuffer, 'uint16');
	}
	
	get group(){
		return 0;
	}

	static *calcDrawIterator(entityList){
		yield calcBindGroupInfoList(this.slotList, entityList);
	}

	static draw(entityList, mesh){
		//if(this.pipelineAutoSetFlag || pipelineSetFlag){
		this.onSetPipelineAndBuffer(mesh);
		for(const bindGroupInfoList of this.calcDrawIterator(entityList, mesh)){
			for(const instanceCount of activeBindGroup(this.slotList, bindGroupInfoList)){
				this.onDraw(instanceCount, mesh);
			}
		}
	}

	static onSetPipelineAndBuffer(mesh){
		Vulkan.renderPassEncoder.setPipeline(this.pipeline);
		this.setVertexBuffer(mesh);
		this.setIndexBuffer(mesh);
	}
}

module.exports = Material;
