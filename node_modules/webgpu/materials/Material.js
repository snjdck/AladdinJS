'use strict';

const Vulkan = require('../Vulkan');
const {calcBindGroupInfoListFn, activeBindGroupFn} = require('../helper/SlotCache');
/*
function drawBatched(instanceCountPerDraw, instanceList, updateFn){
	const totalInstanceCount = instanceList.length;
	if(totalInstanceCount <= 0)return;
	let instanceIndex = 0;
	const result = [];
	while(instanceIndex < totalInstanceCount){
		const instanceCount = Math.min(instanceCountPerDraw, totalInstanceCount - instanceIndex);
		result.push(updateFn.call(this, instanceList, instanceIndex, instanceCount));
		instanceIndex += instanceCount;
	}
	return result;
}
//*/
class Material{
	static order = 0;
	static maxCountPerBatch = 1;
	static useMeshFlag = true;
	//static pipelineAutoSetFlag = true;
	static calcBindGroupInfoList = (v => () => v)([]);
	static activeBindGroup = v => [v];
	static Subclass(pipelineDesc, bindGroupSlots){
		const Sub = class extends this {};
		Vulkan.bindRenderPipeline(Sub, pipelineDesc);
		if(bindGroupSlots){
			Sub.calcBindGroupInfoList = calcBindGroupInfoListFn(bindGroupSlots);
			Sub.activeBindGroup = activeBindGroupFn(bindGroupSlots);
			Sub.slotCacheList = new Set(bindGroupSlots.map(v => v.target));
		}
		return Sub;
	}
	static setVertexBuffer(mesh){
		if(!mesh?.vertexData)return;
		Vulkan.renderPassEncoder.setVertexBuffer(0, mesh.vertexBuffer);
	}
	static setIndexBuffer(mesh){
		if(!mesh?.indexData)return;
		Vulkan.renderPassEncoder.setIndexBuffer(mesh.indexBuffer, 'uint16');
	}
	/*
	static calcDrawCount(entityCount){
		return Math.ceil(entityCount / this.maxCountPerBatch);
	}
	*/
	get group(){
		return 0;
	}

	static *calcDrawIterator(entityList){
		yield [entityList.length, this.calcBindGroupInfoList(entityList)];
	}

	static draw(entityList, mesh){
		//if(this.pipelineAutoSetFlag || pipelineSetFlag){
		this.slotCacheList?.forEach(Vulkan.requestReset);
		this.onSetPipelineAndBuffer(mesh);
		for(const [subEntityCount, bindGroupInfoList] of this.calcDrawIterator(entityList, mesh)){
			for(const instanceCount of this.activeBindGroup(subEntityCount, bindGroupInfoList)){
				this.onDraw(instanceCount, mesh);
			}
		}
	}

	static onSetPipelineAndBuffer(mesh){
		Vulkan.renderPassEncoder.setPipeline(this.pipeline);
		this.setVertexBuffer(mesh);
		this.setIndexBuffer(mesh);
	}
}

module.exports = Material;
