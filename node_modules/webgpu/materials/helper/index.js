
const fetchWorldMatrixListBuffer = function(){
	const stride = 12;
	const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
	return (renderPassEncoder, drawUnitList) => {
		const n = drawUnitList.length;
		const size = stride * n;
		const array = renderPassEncoder.fetchTempTypedArray(size);
		for(let i=0; i<n; ++i){
			const drawUnit = drawUnitList[i];
			array.set(drawUnit.worldTransform.rawData, i * stride);
			drawUnit.$id_world = i;
		}
		const buffer = renderPassEncoder.fetchTempBuffer(size << 2, usage);
		renderPassEncoder.writeBuffer(buffer, 0, array, 0, size);
		return buffer;
	}
}();

const fetchBoneStateTexture = function(){
	const mapFn = v => v.boneCount;
	const textureSize = {depthOrArrayLayers:2};
	return (renderPassEncoder, drawUnitList) => {
		textureSize.width = Math.max(...drawUnitList.map(mapFn));
		textureSize.height = drawUnitList.length;
		const data = renderPassEncoder.fetchTempTypedArray(textureSize.width * textureSize.height * textureSize.depthOrArrayLayers << 2);
		for(let j=0; j<textureSize.height; ++j){
			const drawUnit = drawUnitList[j];
			drawUnit.$id_boneState = j;
			const {boneState} = drawUnit;
			for(let i=0, n=boneState.length; i<n; ++i){
				const bone = boneState[i];
				if(!bone)continue;
				const offsetR = i + textureSize.width * j;
				const offsetT = i + textureSize.width * (j + textureSize.height);
				bone.rotation.copyToArray(data, offsetR << 2);
				bone.translation.copyToArray(data, offsetT << 2);
			}
		}
		const boneStateTexture = renderPassEncoder.fetchTempTexture(textureSize, 'rgba32float,0xA', '>=');
		renderPassEncoder.writeTexture({texture:boneStateTexture}, data, {bytesPerRow:textureSize.width<<4, rowsPerImage:textureSize.height}, textureSize);
		return renderPassEncoder.fetchTextureView(boneStateTexture);
	}
}();

exports.fetchWorldMatrixListBuffer = fetchWorldMatrixListBuffer;
exports.fetchBoneStateTexture = fetchBoneStateTexture;
