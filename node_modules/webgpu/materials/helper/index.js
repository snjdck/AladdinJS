const KeyFrame = require('webgpu/3d/KeyFrame');

const fetchWorldMatrixListBuffer = function(){
	const stride = 12;
	const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
	return (renderPassEncoder, drawUnitList) => {
		const n = drawUnitList.length;
		const size = stride * n;
		const array = renderPassEncoder.fetchTempTypedArray(size);
		for(let i=0; i<n; ++i){
			const drawUnit = drawUnitList[i];
			array.set(drawUnit.worldTransform.rawData, i * stride);
			drawUnit.$id_world = i;
		}
		const buffer = renderPassEncoder.fetchTempBuffer(size << 2, usage);
		renderPassEncoder.writeBuffer(buffer, 0, array, 0, size);
		return buffer;
	}
}();

const fetchBoneStateTexture = function(){
	const mapFn = v => v.boneCount;
	const textureSize = {depthOrArrayLayers:2};
	const keyFrame = new KeyFrame();
	return (renderPassEncoder, drawUnitList) => {
		textureSize.width = Math.max(...drawUnitList.map(mapFn));
		textureSize.height = drawUnitList.length;
		const area = textureSize.width * textureSize.height;
		const data = renderPassEncoder.fetchTempTypedArray(area * textureSize.depthOrArrayLayers << 2);
		for(let j=0; j<textureSize.height; ++j){
			const drawUnit = drawUnitList[j];
			drawUnit.$id_boneState = j;
			const {boneState, rootBone:{boneList}} = drawUnit;
			for(let i=0, n=boneList.length; i<n; ++i){
				const {id, matrix} = boneList[i];
				const bone = matrix ? matrix.append(boneState[id], keyFrame) : boneState[id];
				const offset = id + textureSize.width * j;
				bone.rotation.copyToArray(data, offset << 2);
				bone.translation.copyToArray(data, offset + area << 2);
			}
		}
		const boneStateTexture = renderPassEncoder.fetchTempTexture(textureSize, 'rgba32float,0xA', '>=');
		renderPassEncoder.writeTexture({texture:boneStateTexture}, data, {bytesPerRow:textureSize.width<<4, rowsPerImage:textureSize.height}, textureSize);
		return renderPassEncoder.fetchTextureView(boneStateTexture);
	}
}();

exports.fetchWorldMatrixListBuffer = fetchWorldMatrixListBuffer;
exports.fetchBoneStateTexture = fetchBoneStateTexture;
