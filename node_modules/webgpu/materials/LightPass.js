'use strict';

const Pipeline = require('./Pipeline');

const pipeline = new Pipeline({
	groups: [[
		{binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{sampleType:'unfilterable-float'}},//depth, sint, uint, unfilterable-float
		{binding:1, visibility:GPUShaderStage.FRAGMENT, texture:{sampleType:'unfilterable-float'}},//depth, sint, uint, unfilterable-float
		{binding:2, visibility:GPUShaderStage.FRAGMENT, texture:{sampleType:'float'}},//depth, sint, uint, unfilterable-float
		{binding:3, visibility:GPUShaderStage.FRAGMENT, sampler:{type:'filtering'}, default:{}},
		{binding:4, visibility:GPUShaderStage.FRAGMENT, sampler:{type:'non-filtering'}, default:{}},//comparison
		{binding:5, visibility:GPUShaderStage.FRAGMENT, texture:{sampleType:'unfilterable-float'}},
		{binding:6, visibility:GPUShaderStage.FRAGMENT, buffer:{}}
	]],
	vertex: {
		buffers: [{
			arrayStride: 2 << 2,
			stepMode: 'instance',
			attributes: [
				{shaderLocation: 0, offset: 0, format: 'float32x2'},
			]
		}],
		entryPoint: 'main',
		code: `
			struct Input {
				@builtin(vertex_index) vertex_index: u32,
				@location(0) uv_scale: vec2<f32>,
			}

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) uv2: vec2<f32>,
			}

			@vertex
			fn main(input: Input) -> Output {
				var vertex: vec2<f32>;
				vertex.x = f32(input.vertex_index >> 1);
				vertex.y = f32(input.vertex_index & 1);
				var position = vertex * 2 - 1;

				var output: Output;
				output.position = vec4<f32>(position.x, -position.y, 0, 1);
				output.uv = vertex * input.uv_scale;
				output.uv2 = vertex;
				return output;
			}
		`
	},
	fragment: {
		targets:[{
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'one', dstFactor: 'one-minus-src', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}],
		entryPoint: 'main',
		code: `
		struct MVP {
				screenMatrix: mat4x4<f32>,
				cameraMatrix: mat3x4<f32>,
			}
			@group(0) @binding(0) var texture_position: texture_2d<f32>;
			@group(0) @binding(1) var texture_normal: texture_2d<f32>;
			@group(0) @binding(2) var texture_color: texture_2d<f32>;
			@group(0) @binding(3) var sampler_filtering: sampler;
			@group(0) @binding(4) var sampler_non_filtering: sampler;

			@group(0) @binding(5) var texture_depth: texture_2d<f32>;
			@group(0) @binding(6) var<uniform> light: MVP;

			@fragment
			fn main(
				@location(0) uv: vec2<f32>,
				@location(1) uv2: vec2<f32>,
			) -> @location(0) vec4<f32> {
				var dir = vec3<f32>(1,0,1);
				dir = normalize(dir);
				let worldPosition = textureSample(texture_position, sampler_non_filtering, uv).rgb;
				
				let cameraPosition: vec3<f32> = vec4<f32>(worldPosition, 1) * light.cameraMatrix;
				let screenPosition: vec4<f32> = vec4<f32>(cameraPosition, 1) * light.screenMatrix;
				var depth_uv = (screenPosition.xy / screenPosition.w + 1) * 0.5;
				depth_uv.y = 1-depth_uv.y;
				//return vec4<f32>(vec3<f32>(worldPosition.x / 1000, worldPosition.y / 1000, worldPosition.z / 100),1);
				//return vec4<f32>(vec3<f32>((cameraPosition.x+1000) / 2000, (cameraPosition.y+900) / 2000, (cameraPosition.z+2000)/6000),1);
				//return vec4<f32>(vec3<f32>(screenPosition.z/screenPosition.w),1);

				var depth_value = textureSample(texture_depth, sampler_non_filtering, depth_uv).r;
				//depth_value *= 0.5;
				//return vec4<f32>(depth_value,depth_value,depth_value,1);
				let is_in_shadow = (screenPosition.z / screenPosition.w) > depth_value;

				let normal = textureSample(texture_normal, sampler_non_filtering, uv).rgb;
				let factor = dot(normal, dir);
				let baseColor = textureSample(texture_color, sampler_filtering, uv);
				if(is_in_shadow){
					return vec4<f32>(0, 0, 0, 1);
				}
				return vec4<f32>(baseColor.rgb * (factor + 1), baseColor.a);
			}
		`
	},
	primitive: {
		// (0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5)
		// 0-2-4
		// |/|/|
		// 1-3-5
		topology: 'triangle-strip',
	}
});

exports.pipeline = pipeline;
