'use strict';

const TextureMaterial = require('./TextureMaterial');
const Pipeline = require('./Pipeline');

const pipeline = new Pipeline({
	groups: TextureMaterial.pipeline.desc.groups,
	vertex: {
		buffers: TextureMaterial.pipeline.desc.vertex.buffers,
		code:`
		#include<skeleton>
		#include<transform>
		#include<cast>

		struct Output {
			@builtin(position) position: vec4<f32>,
			@location(0) uv: vec2<f32>,
			@location(1) @interpolate(flat) instanceIndex: u32,
			@location(2) world_normal: vec3<f32>,
		}

		@vertex Output {
			let boneMatrix = getBoneMatrix(boneStateTexture, boneIndex, instanceIndex);
			let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;
			let modelNormal: vec3<f32> = normal * m34tom33(boneMatrix);

			let worldMatrix = worldMatrixList[instanceIndex];
			let worldPosition = vec4<f32>(modelPosition, 1) * worldMatrix;
			let worldNormal = modelNormal * m34tom33(worldMatrix);

			return Output(positionWorldToScreen(worldPosition, vpMatrix), uv, instanceIndex, worldNormal);
		}
	`},
	fragment:{
		targets:[{format: 'bgra8unorm'}, {writeMask:7,format: 'rgba16float'},{format: 'rgba16float'}],
		code: `
			//The fragment stage has fewer output components (3) than the color format (TextureFormat::RGBA32Float) component count (4).
			@fragment{
				return Output(textureSample(baseTexture, g_sampler, uv), vec4<f32>(normalize(world_normal),0), textureSample(baseTexture, g_sampler, uv));
			}
		`
	},
	depthStencil: {}
});

module.exports = TextureMaterial.Subclass(pipeline);
