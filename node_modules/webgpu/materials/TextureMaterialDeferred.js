'use strict';

const TextureMaterial = require('./TextureMaterial');

const pipeline = TextureMaterial.pipeline.clone({
	vertex: {code:`
		#include<skeleton>
		#include<transform>
		#include<cast>

		struct Output {
			@builtin(position) position: vec4<f32>,
			@location(0) uv: vec2<f32>,
			@location(1) @interpolate(flat) instanceIndex: u32,
			@location(2) world_normal: vec3<f32>,
			//@location(3) world_position: vec3<f32>,
		}

		@vertex
		fn main(
			@builtin(instance_index) instanceIndex: u32,
			@location(0) position: vec3<f32>,
			@location(1) normal: vec3<f32>,
			@location(2) uv: vec2<f32>,
			@location(3) boneIndex: u32,
		) -> Output {
			let boneMatrix = getBoneMatrix(animationTexture, boneIndex, instanceIndex);
			let modelPosition: vec3<f32> = vec4<f32>(position, 1) * boneMatrix;
			let modelNormal: vec3<f32> = normal * m34tom33(boneMatrix);

			let worldMatrix = worldMatrixList[instanceIndex];
			let worldPosition = vec4<f32>(modelPosition, 1) * worldMatrix;
			let worldNormal = modelNormal * m34tom33(worldMatrix);

			var output: Output;
			output.position = positionWorldToScreen(worldPosition);
			output.uv = uv;
			//output.world_position = worldPosition;
			output.world_normal = worldNormal;
			output.instanceIndex = instanceIndex;
			return output;
		}
	`},
	fragment:{
		targets:[{format: 'bgra8unorm'}, {writeMask:7,format: 'rgba16float'},{format: 'rgba16float'}],
		code: `
			//The fragment stage has fewer output components (3) than the color format (TextureFormat::RGBA32Float) component count (4).
			struct OutputDeferred {
				@location(0) color: vec4<f32>,
				@location(1) normal: vec4<f32>,
				@location(2) emissive: vec4<f32>,
			}

			@fragment
			fn main(
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
				@location(2) normal: vec3<f32>,
				//@location(3) position: vec3<f32>,
			) -> OutputDeferred {
				return OutputDeferred(textureSample(baseTexture, g_sampler, uv), vec4<f32>(normalize(normal),0), textureSample(baseTexture, g_sampler, uv));
			}
		`
	}
});

module.exports = TextureMaterial.Subclass(pipeline);
