'use strict';

const Material = require('./Material');
const Pipeline = require('./Pipeline');

const maxCountPerDraw = 100;

const pipeline = new Pipeline({
	groups: [[
		{name:'viewport', type:'Viewport', buffer:{}},
		{name:'g_sampler', sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'clamp-to-edge', addressModeV:'clamp-to-edge', addressModeW:'clamp-to-edge'}}
	], [
		{name:'baseTexture', texture:{}}
	]],
	vertex: {
		buffers: [{
			name: 'rectInfoList',
			stepMode: 'instance',
			attributes: [
				{format: 'float32x4', name:'worldMatrixX'},
				{format: 'float32x4', name:'worldMatrixY'},
				{format: 'float32x4', name:'textureMul'},
				{format: 'float32x4', name:'textureAdd'},
				{format: 'float32x4', name:'rectSize'},//w,rw,h,rh
				{format: 'float32x4', name:'scale9grid'},//lm,rm,tm,bm
			],
			temp:{stride:24,mapFn: function(){
				const vertexData = new Float32Array(24);
				return function(drawUnit){
					const {texture} = drawUnit;
					drawUnit.worldTransform.copyToArray(vertexData);
					if(texture){
						vertexData.set(texture.xyuvMul, 8);
						vertexData.set(texture.xyuvAdd, 12);
						vertexData.set(texture.scale9grid, 20);
						vertexData[16] = drawUnit.width;
						vertexData[17] = texture.width;
						vertexData[18] = drawUnit.height;
						vertexData[19] = texture.height;
					}else{
						vertexData[ 8] = vertexData[ 9] = vertexData[10] = vertexData[11] = 1;
						vertexData[12] = vertexData[13] = vertexData[14] = vertexData[15] =
						vertexData[20] = vertexData[21] = vertexData[22] = vertexData[23] = 0;
						vertexData[16] = vertexData[17] = drawUnit.width;
						vertexData[18] = vertexData[19] = drawUnit.height;
					}
					return vertexData;
				}
			}()}
		}],
		code: `
			const indexList = array<vec4<i32>, 14>(
				vec4<i32>( 4, 5, 0, 5),
				vec4<i32>( 1, 0, 5, 6),
				vec4<i32>( 1, 6, 2, 1),
				vec4<i32>( 6, 7, 2, 7), 
				vec4<i32>( 3, 2, 8, 9),
				vec4<i32>( 4, 9, 5, 4),
				vec4<i32>( 9,10, 5,10),
				vec4<i32>( 6, 5,10,11),
				vec4<i32>( 6,11, 7, 6),
				vec4<i32>(12,13, 8,13),
				vec4<i32>( 9, 8,13,14),
				vec4<i32>( 9,14,10, 9),
				vec4<i32>(14,15,10,15),
				vec4<i32>(11,10,-1,-1)
			);

			struct Viewport {
				screenXYWH: vec4<f32>,
				matrixInv: mat2x3<f32>,
			}

			struct Output {
				@builtin(position) position: vec4<f32>,
				//[[location(0), interpolate(linear)]]//(perspective, linear, flat), (center, centroid, sample)
				@location(0) uv: vec2<f32>,
			}

			@vertex Output {
				let vertexID = indexList[vertexIndex >> 2][vertexIndex & 3];
				let inputPosition = vec2<f32>(vec2((vertexID >> 1) & 1, vertexID >> 3));

				let margin = select(
					vec4<f32>(1, -1, 1, -1) * scale9grid,
					vec4<f32>(),
					vec4<bool>(
						(vertexID & 0x3) == 1,
						(vertexID & 0x3) == 2,
						(vertexID & 0xc) == 4,
						(vertexID & 0xc) == 8
					)
				);

				var xyuv: vec4<f32> = fma(inputPosition.xxyy, rectSize, margin.xxzz + margin.yyww);
				xyuv.y = xyuv.y / rectSize.y;
				xyuv.w = xyuv.w / rectSize.w;
				xyuv = fma(xyuv.xzyw, textureMul, textureAdd);

				var position: vec2<f32> = xyuv.xy;
				position = vec3<f32>(position, 1) * mat2x3<f32>(worldMatrixX.xyz, worldMatrixY.xyz);
				position = vec3<f32>(position, 1) * viewport.matrixInv;
				position = fma(position, viewport.screenXYWH.xy, viewport.screenXYWH.zw);

				return Output(vec4<f32>(position, 0, 1), xyuv.zw);
			}
		`
	},
	fragment: {
		targets:[{blend: 'src-alpha add one-minus-src-alpha'}],
		code: `@fragment{return textureSample(baseTexture, g_sampler, uv);}`
	}
});

class Material2D extends Material.Subclass(pipeline){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(list, renderPassEncoder){
		for(let [texture, itemList] of Material.Utils.group2d(list)){
			if(!(texture instanceof GPUTexture)){
				texture = renderPassEncoder.loadTexture(texture.title, false);
				if(!texture)continue;
			}
			renderPassEncoder.setResources({'baseTexture': renderPassEncoder.fetchTextureView(texture, '2d,all,0,1')});
			for(let drawUnitList of Material.Utils.cut(maxCountPerDraw, itemList)){
				renderPassEncoder.setResources({'rectInfoList': drawUnitList});
				renderPassEncoder.draw(54, drawUnitList.length);//total 9 rect, exery rect has 2 triangle, every triangle has 3 index.
			}
		}
	}
}

module.exports = Material2D;

/*let vertexData = new Float32Array([
	0, 0, 0, 0, 0, 0,
	0, 0, 1, 0, 0, 0,
	1, 0, 0,-1, 0, 0,
	1, 0, 0, 0, 0, 0,
	
	0, 0, 0, 0, 1, 0,
	0, 0, 1, 0, 1, 0,
	1, 0, 0,-1, 1, 0,
	1, 0, 0, 0, 1, 0,
	
	0, 1, 0, 0, 0,-1,
	0, 1, 1, 0, 0,-1,
	1, 1, 0,-1, 0,-1,
	1, 1, 0, 0, 0,-1,
	
	0, 1, 0, 0, 0, 0,
	0, 1, 1, 0, 0, 0,
	1, 1, 0,-1, 0, 0,
	1, 1, 0, 0, 0, 0
]);*/


const pickPipeline = new Pipeline({
	groups: [[{name:'viewport', type:'Viewport', buffer:{}}]],
	vertex: {
		buffers: [
			{name: 'meshId', stepMode: 'instance', attributes: [{format:'uint32'}], temp:{type:Uint32Array, mapFn: v => [v.pickID]}},
		{
			name: 'rectInfoList',
			stepMode: 'instance',
			attributes: [
				{format: 'float32x4', name:'worldMatrixX'},
				{format: 'float32x4', name:'worldMatrixY'},
				{format: 'float32x4', name:'whxy'},
			],
			temp:{stride:12,mapFn: function(){
				const vertexData = new Float32Array(12);
				return function(drawUnit){
					const {texture} = drawUnit;
					drawUnit.worldTransform.copyToArray(vertexData);
					if(texture){
						vertexData[ 8] = texture.xyuvMul[0];
						vertexData[ 9] = texture.xyuvMul[1];
						vertexData[10] = texture.xyuvAdd[0];
						vertexData[11] = texture.xyuvAdd[1];
					}else{
						vertexData[ 8] = vertexData[ 9] = 1;
						vertexData[10] = vertexData[11] = 0;
					}
					vertexData[3] = drawUnit.width;
					vertexData[7] = drawUnit.height;
					return vertexData;
				}
			}()}
		}],
		code:`
			struct Viewport {
				screenXYWH: vec4<f32>,
				matrixInv: mat2x3<f32>,
			}

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) @interpolate(flat) id: u32,
			}

			@vertex Output {
				let vertex = vec2<f32>(vec2(vertexIndex & 1, vertexIndex >> 1));
				var position = fma(vertex * vec2(worldMatrixX.w, worldMatrixY.w), whxy.xy, whxy.zw);

				position = vec3<f32>(position, 1) * mat2x3<f32>(worldMatrixX.xyz, worldMatrixY.xyz);
				position = vec3<f32>(position, 1) * viewport.matrixInv;
				position = fma(position, viewport.screenXYWH.xy, viewport.screenXYWH.zw);

				return Output(vec4<f32>(position, 0, 1), meshId);
			}
	`},
	fragment: {targets:[{format: 'r32uint'}], code: `@fragment{return id;}`},
	depthStencil:{depthCompare:'always'},
	primitive: {topology: 'triangle-strip'}
});

Material2D.Pick = pickPipeline;