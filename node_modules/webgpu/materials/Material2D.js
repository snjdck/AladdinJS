'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const {createWeakMapGetter} = require('utils/cache');
const batchDrawListFactory = require('../helper/batchDrawListFactory');
const batchDrawList = batchDrawListFactory(v => v.texture.getRawAsset());

const pipelineDesc = {
	groups: [[
		{binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'clamp-to-edge', addressModeV:'clamp-to-edge', addressModeW:'clamp-to-edge'}}
	], [
		{binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{}}
	]],
	vertex: {
		buffers: [{
			arrayStride: 24 << 2,
			stepMode: 'instance',
			attributes: [
				{shaderLocation: 0, offset: 0, format: 'float32x4'},
				{shaderLocation: 1, offset: 16, format: 'float32x4'},
				{shaderLocation: 2, offset: 32, format: 'float32x4'},
				{shaderLocation: 3, offset: 48, format: 'float32x4'},
				{shaderLocation: 4, offset: 64, format: 'float32x4'},
				{shaderLocation: 5, offset: 80, format: 'float32x4'}
			]
		}],
		entryPoint: 'main',
		code: `
			const indexList = array<vec4<i32>, 14>(
				vec4<i32>( 4, 5, 0, 5),
				vec4<i32>( 1, 0, 5, 6),
				vec4<i32>( 1, 6, 2, 1),
				vec4<i32>( 6, 7, 2, 7), 
				vec4<i32>( 3, 2, 8, 9),
				vec4<i32>( 4, 9, 5, 4),
				vec4<i32>( 9,10, 5,10),
				vec4<i32>( 6, 5,10,11),
				vec4<i32>( 6,11, 7, 6),
				vec4<i32>(12,13, 8,13),
				vec4<i32>( 9, 8,13,14),
				vec4<i32>( 9,14,10, 9),
				vec4<i32>(14,15,10,15),
				vec4<i32>(11,10,-1,-1)
			);

			struct Viewport {
				screenXYWH: vec4<f32>,
				matrixInv: mat2x3<f32>,
			};

			struct Viewport_Block {
				viewportList: array<Viewport, 256>,
			};

			@binding(0) @group(0) var<uniform> viewportBlock: Viewport_Block;

			struct Input {
				@location(0) worldMatrixX: vec4<f32>,
				@location(1) worldMatrixY: vec4<f32>,
				@location(2) textureMul  : vec4<f32>,
				@location(3) textureAdd  : vec4<f32>,
				@location(4) rectSize    : vec4<f32>, //w,rw,h,rh
				@location(5) scale9grid  : vec4<f32>, //lm,rm,tm,bm
				@builtin(vertex_index) vertexIndex: u32,
				//[[builtin(instance_index)]] instanceIndex: u32;
			};

			struct Output {
				@builtin(position) position: vec4<f32>,
				//[[location(0), interpolate(linear)]]//(perspective, linear, flat), (center, centroid, sample)
				@location(0) uv: vec2<f32>,
			};

			@vertex
			fn main(input: Input) -> Output {
				var vertexID: i32 = indexList[input.vertexIndex >> 2][input.vertexIndex & 3];
				var viewport: Viewport = viewportBlock.viewportList[u32(input.worldMatrixX.w)];

				var inputPosition = vec2<f32>(vec2<i32>(
					(vertexID >> 1) & 1,
					 vertexID >> 3
				));

				var margin = select(
					vec4<f32>(1.0, -1.0, 1.0, -1.0) * input.scale9grid,
					vec4<f32>(),
					vec4<bool>(
						(vertexID & 0x3) == 1,
						(vertexID & 0x3) == 2,
						(vertexID & 0xc) == 4,
						(vertexID & 0xc) == 8
					)
				);

				var xyuv: vec4<f32> = fma(inputPosition.xxyy, input.rectSize, margin.xxzz + margin.yyww);
				xyuv.y = xyuv.y / input.rectSize.y;
				xyuv.w = xyuv.w / input.rectSize.w;
				xyuv = fma(xyuv.xzyw, input.textureMul, input.textureAdd);

				var position: vec2<f32> = xyuv.xy;
				position = vec3<f32>(position, 1.0) * mat2x3<f32>(input.worldMatrixX.xyz, input.worldMatrixY.xyz);
				position = vec3<f32>(position, 1.0) * viewport.matrixInv;
				position = fma(position, viewport.screenXYWH.xy, viewport.screenXYWH.zw);

				var output: Output;
				output.position = vec4<f32>(position, 0.0, 1.0);
				output.uv = xyuv.zw;
				return output;
			}
		`
	},
	fragment: {
		targets:[{
			format: 'bgra8unorm',
			writeMask: 0xF,
			blend: {
				color:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}],
		entryPoint: 'main',
		code: `
			@binding(1) @group(0) var mySampler: sampler;
			@binding(0) @group(1) var myTexture: texture_2d<f32>;

			struct Input {
				@location(0) uv: vec2<f32>,
			};

			@fragment
			fn main(input: Input) -> @location(0) vec4<f32> {
				return textureSample(myTexture, mySampler, input.uv);
			}
		`
	}
};

const pipelineWithDepthStencilDesc = {//no need structuredClone
	...pipelineDesc,
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: false,
		depthCompare: 'less-equal',
	}
};

const bindGroupCache = createWeakMapGetter((texture, material) => material.createBindGroupWith(texture));

class Material2D extends Material.Subclass(
	{pipeline: pipelineDesc, pipelineWithDepthStencil: pipelineWithDepthStencilDesc},
	{'2d':0}
){
	static useMeshFlag = 54;//total 9 rect, exery rect has 2 triangle, every triangle has 3 index.
	static onSetPipelineAndBuffer(useDepthStencilFlag){
		const pipeline = useDepthStencilFlag ? this.pipelineWithDepthStencil : this.pipeline;
		Vulkan.renderPassEncoder.setPipeline(pipeline);
	}
	static *calcDrawIterator(entityList){
		for(const [texture, subEntityList] of batchDrawList(entityList)){
			Vulkan.renderPassEncoder.setBindGroup(1, bindGroupCache(texture, this));
			yield * super.calcDrawIterator(subEntityList);
		}
	}
	static New = (v => () => v)(new this());
}

module.exports = Material2D;
