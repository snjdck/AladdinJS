'use strict';

const Material = require('./Material');
const Pipeline = require('./Pipeline');

const maxCountPerDraw = 100;

const pipeline = new Pipeline({
	groups: [[
		{name:'viewport', binding:0, visibility:GPUShaderStage.VERTEX, buffer:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'clamp-to-edge', addressModeV:'clamp-to-edge', addressModeW:'clamp-to-edge'}}
	], [
		{name:'baseTexture', binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{}}
	]],
	vertex: {
		buffers: [{
			name: 'rectInfoList',
			arrayStride: 24 << 2,
			stepMode: 'instance',
			attributes: [
				{shaderLocation: 0, offset: 0, format: 'float32x4'},
				{shaderLocation: 1, offset: 16, format: 'float32x4'},
				{shaderLocation: 2, offset: 32, format: 'float32x4'},
				{shaderLocation: 3, offset: 48, format: 'float32x4'},
				{shaderLocation: 4, offset: 64, format: 'float32x4'},
				{shaderLocation: 5, offset: 80, format: 'float32x4'}
			],
			temp:{array:new Float32Array(24 * maxCountPerDraw), stride:24, mapFn: function(){
				const vertexData = new Float32Array(24);
				return function(drawUnit){
					const {texture} = drawUnit;
					drawUnit.worldTransform.copyToArray(vertexData);
					if(texture){
						vertexData.set(texture.xyuvMul, 8);
						vertexData.set(texture.xyuvAdd, 12);
						vertexData.set(texture.scale9grid, 20);
						vertexData[16] = drawUnit.width;
						vertexData[17] = texture.width;
						vertexData[18] = drawUnit.height;
						vertexData[19] = texture.height;
					}else{
						vertexData[ 8] = vertexData[ 9] = vertexData[10] = vertexData[11] = 1;
						vertexData[12] = vertexData[13] = vertexData[14] = vertexData[15] =
						vertexData[20] = vertexData[21] = vertexData[22] = vertexData[23] = 0;
						vertexData[16] = vertexData[17] = drawUnit.width;
						vertexData[18] = vertexData[19] = drawUnit.height;
					}
					return vertexData;
				}
			}()}
		}],
		entryPoint: 'main',
		code: `
			const indexList = array<vec4<i32>, 14>(
				vec4<i32>( 4, 5, 0, 5),
				vec4<i32>( 1, 0, 5, 6),
				vec4<i32>( 1, 6, 2, 1),
				vec4<i32>( 6, 7, 2, 7), 
				vec4<i32>( 3, 2, 8, 9),
				vec4<i32>( 4, 9, 5, 4),
				vec4<i32>( 9,10, 5,10),
				vec4<i32>( 6, 5,10,11),
				vec4<i32>( 6,11, 7, 6),
				vec4<i32>(12,13, 8,13),
				vec4<i32>( 9, 8,13,14),
				vec4<i32>( 9,14,10, 9),
				vec4<i32>(14,15,10,15),
				vec4<i32>(11,10,-1,-1)
			);

			struct Viewport {
				screenXYWH: vec4<f32>,
				matrixInv: mat2x3<f32>,
			}

			@group(0) @binding(0) var<uniform> viewport: Viewport;

			struct Input {
				@location(0) worldMatrixX: vec4<f32>,
				@location(1) worldMatrixY: vec4<f32>,
				@location(2) textureMul  : vec4<f32>,
				@location(3) textureAdd  : vec4<f32>,
				@location(4) rectSize    : vec4<f32>, //w,rw,h,rh
				@location(5) scale9grid  : vec4<f32>, //lm,rm,tm,bm
				@builtin(vertex_index) vertexIndex: u32,
				//[[builtin(instance_index)]] instanceIndex: u32;
			}

			struct Output {
				@builtin(position) position: vec4<f32>,
				//[[location(0), interpolate(linear)]]//(perspective, linear, flat), (center, centroid, sample)
				@location(0) uv: vec2<f32>,
			}

			@vertex
			fn main(input: Input) -> Output {
				let vertexID = indexList[input.vertexIndex >> 2][input.vertexIndex & 3];
				let inputPosition = vec2<f32>(vec2((vertexID >> 1) & 1, vertexID >> 3));

				let margin = select(
					vec4<f32>(1, -1, 1, -1) * input.scale9grid,
					vec4<f32>(),
					vec4<bool>(
						(vertexID & 0x3) == 1,
						(vertexID & 0x3) == 2,
						(vertexID & 0xc) == 4,
						(vertexID & 0xc) == 8
					)
				);

				var xyuv: vec4<f32> = fma(inputPosition.xxyy, input.rectSize, margin.xxzz + margin.yyww);
				xyuv.y = xyuv.y / input.rectSize.y;
				xyuv.w = xyuv.w / input.rectSize.w;
				xyuv = fma(xyuv.xzyw, input.textureMul, input.textureAdd);

				var position: vec2<f32> = xyuv.xy;
				position = vec3<f32>(position, 1) * mat2x3<f32>(input.worldMatrixX.xyz, input.worldMatrixY.xyz);
				position = vec3<f32>(position, 1) * viewport.matrixInv;
				position = fma(position, viewport.screenXYWH.xy, viewport.screenXYWH.zw);

				return Output(vec4<f32>(position, 0, 1), xyuv.zw);
			}
		`
	},
	fragment: {
		targets:[{
			format: 'bgra8unorm',
			writeMask: 0xF,
			blend: {
				color:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}],
		entryPoint: 'main',
		code: `
			@group(0) @binding(1) var mySampler: sampler;
			@group(1) @binding(0) var myTexture: texture_2d<f32>;

			@fragment
			fn main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
				return textureSample(myTexture, mySampler, uv);
			}
		`
	}
});
/*
const pipeline2 = {//no need structuredClone
	...pipeline,
	depthStencil: {
		format: 'depth24plus-stencil8',
		depthWriteEnabled: false,
		depthCompare: 'less-equal',
	}
};
*/
class Material2D extends Material.Subclass(pipeline){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(list, renderPassEncoder){
		for(let [texture, itemList] of Material.Utils.group2d(list)){
			this.setResources(renderPassEncoder, {'baseTexture': texture});
			for(let drawUnitList of Material.Utils.cut(maxCountPerDraw, itemList)){
				this.setResources(renderPassEncoder, {'rectInfoList': drawUnitList});
				renderPassEncoder.draw(54, drawUnitList.length);//total 9 rect, exery rect has 2 triangle, every triangle has 3 index.
			}
		}
	}
}

module.exports = Material2D;

/*let vertexData = new Float32Array([
	0, 0, 0, 0, 0, 0,
	0, 0, 1, 0, 0, 0,
	1, 0, 0,-1, 0, 0,
	1, 0, 0, 0, 0, 0,
	
	0, 0, 0, 0, 1, 0,
	0, 0, 1, 0, 1, 0,
	1, 0, 0,-1, 1, 0,
	1, 0, 0, 0, 1, 0,
	
	0, 1, 0, 0, 0,-1,
	0, 1, 1, 0, 0,-1,
	1, 1, 0,-1, 0,-1,
	1, 1, 0, 0, 0,-1,
	
	0, 1, 0, 0, 0, 0,
	0, 1, 1, 0, 0, 0,
	1, 1, 0,-1, 0, 0,
	1, 1, 0, 0, 0, 0
]);*/