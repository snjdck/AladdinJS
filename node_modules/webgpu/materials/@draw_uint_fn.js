
exports.transform =  function(){
	const buffer = new Float32Array(13);
	return drawUnit => {
		buffer.set(drawUnit.entity.worldTransform.rawData)
		//buffer[12] = drawUnit.cameraIndex;
		return buffer;
	}
}();

exports.filter = function(){
	const vertexData = new Float32Array(4);
	return function({frameRect:{width, height}, drawRect}){
		vertexData[0] = drawRect.x / width;
		vertexData[1] = drawRect.y / height;
		vertexData[2] = drawRect.width / width;
		vertexData[3] = drawRect.height / height;
		return vertexData;
	}
}();

exports.color = ({material}) => new Float32Array(material.color);

exports.bound = function(){
	const buffer = new Float32Array(7);
	return drawUnit => {
		const {bound} = drawUnit.material;
		buffer[0] = bound.minX;
		buffer[1] = bound.minY;
		buffer[2] = bound.minZ;
		buffer[3] = drawUnit.cameraIndex;
		buffer[4] = bound.maxX;
		buffer[5] = bound.maxY;
		buffer[6] = bound.maxZ;
		return buffer;
	}
}();
exports.bone = function(){
	const objectBuffer3D = new Float32Array(256*4);
	return drawUnit => {
		drawUnit.entity.copyBoneStateToBuffer(objectBuffer3D);
		return objectBuffer3D;
	}
}();

exports.g2d = function(){
	const vertexData = new Float32Array(24);
	const allZero = new Float32Array(4);
	const allOne = new Float32Array(4).fill(1);
	return function(instance){
		const {worldTransform, texture, width, height, fgColor, viewportIndex} = instance;
		worldTransform.copyToArray(vertexData);
		vertexData[3] = 0;//viewportIndex;
		if(texture){
			vertexData.set(texture.xyuvMul, 8);
			vertexData.set(texture.xyuvAdd, 12);
			vertexData.set(texture.scale9grid, 20);
			vertexData[16] = width;
			vertexData[17] = texture.width;
			vertexData[18] = height;
			vertexData[19] = texture.height;
		}else{
			vertexData.set(allOne, 8);
			vertexData.set(allZero, 12);
			vertexData.set(allZero, 20);
			vertexData[16] = width;
			vertexData[17] = width;
			vertexData[18] = height;
			vertexData[19] = height;
		}
		return vertexData;
	}
}();
