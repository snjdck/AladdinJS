'use strict';

const Vulkan = require('../Vulkan');
const Material = require('./Material');
const Texture2D = require('../2d/Texture2D');

const maxCountPerDraw = 100;

const pipeline = {
	groups: [[
		{binding:0, visibility:GPUShaderStage.FRAGMENT, texture:{}},
		{binding:1, visibility:GPUShaderStage.FRAGMENT, sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'clamp-to-edge', addressModeV:'clamp-to-edge', addressModeW:'clamp-to-edge'}}
	], [
		{binding:0, visibility:GPUShaderStage.FRAGMENT, buffer:{}, temp:{array:new Float32Array(4 * maxCountPerDraw), stride:4, mapFn: v => v.material.color}}
	]],
	vertex:{
		buffers: [{
			arrayStride: 4 << 2,
			stepMode: 'instance',
			attributes: [
				{shaderLocation: 0, offset: 0, format: 'float32x4'}
			],
			temp:{array:new Float32Array(4 * maxCountPerDraw), stride:4, mapFn: ({frameRect:{width, height}, drawRect}) => [drawRect.x / width, drawRect.y / height, drawRect.width / width, drawRect.height / height]}
		}],
		entryPoint: 'main',
		code: `
			struct Input {
				@builtin(vertex_index) vertexIndex: u32,
				@builtin(instance_index) instanceIndex: u32,
				@location(0) sourceRect: vec4<f32>,
			};

			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,//flat
			};

			@vertex
			fn main(input: Input) -> Output {
				var destRect:vec4<f32> = input.sourceRect * vec2<f32>(2.0, -2.0).xyxy;
				//destRect.xy = destRect.xy + vec2<f32>(-1.0, 1.0);
				destRect.x = destRect.x - 1.0;
				destRect.y = destRect.y + 1.0;
				var vertexXY: vec2<f32> = vec2<f32>(f32(input.vertexIndex >> 1u), f32(input.vertexIndex & 1u));
				var output: Output;
				output.position = vec4<f32>(fma(vertexXY, destRect.zw, destRect.xy), 0.0, 1.0);
				output.uv = fma(vertexXY, input.sourceRect.zw, input.sourceRect.xy);
				output.instanceIndex = input.instanceIndex << 4u;//min bindgroup is 256 bytes, 16 of vec4<f32>
				return output;
			}
		`
	},
	fragment:{
		targets:[{
			format: 'bgra8unorm',
			blend: {
				color:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'},
				alpha:{srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add'}
			}
		}],
		entryPoint: 'main',
		code: `
			struct Color {
				mixColor : array<vec4<f32>, ${maxCountPerDraw}>,
			};

			@group(0) @binding(1) var g_sampler: sampler;
			@group(0) @binding(0) var g_texture: texture_2d<f32>;
			@group(1) @binding(0) var<uniform> g_color: Color;

			struct Input {
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,
			};

			struct Output {
				@location(0) color: vec4<f32>,
			};

			@fragment
			fn main(input: Input) -> Output {
				var s : f32 = dpdx(input.uv.x);
				var t : f32 = dpdy(input.uv.y);

				var ns: f32 = - s;
				var nt: f32 = - t;

				var tc0 : vec2<f32> = input.uv + vec2<f32>(ns,   nt);
				var tc1 : vec2<f32> = input.uv + vec2<f32>( 0.0, nt);
				var tc2 : vec2<f32> = input.uv + vec2<f32>( s,   nt);
				var tc3 : vec2<f32> = input.uv + vec2<f32>(ns,  0.0);
				var tc4 : vec2<f32> = input.uv;
				var tc5 : vec2<f32> = input.uv + vec2<f32>( s,    0.0);
				var tc6 : vec2<f32> = input.uv + vec2<f32>(ns,    t);
				var tc7 : vec2<f32> = input.uv + vec2<f32>( 0.0,  t);
				var tc8 : vec2<f32> = input.uv + vec2<f32>( s,    t);

				var col0 : vec4<f32> = textureSample(g_texture, g_sampler, tc0);
				var col1 : vec4<f32> = textureSample(g_texture, g_sampler, tc1);
				var col2 : vec4<f32> = textureSample(g_texture, g_sampler, tc2);
				var col3 : vec4<f32> = textureSample(g_texture, g_sampler, tc3);
				var col4 : vec4<f32> = textureSample(g_texture, g_sampler, tc4);
				var col5 : vec4<f32> = textureSample(g_texture, g_sampler, tc5);
				var col6 : vec4<f32> = textureSample(g_texture, g_sampler, tc6);
				var col7 : vec4<f32> = textureSample(g_texture, g_sampler, tc7);
				var col8 : vec4<f32> = textureSample(g_texture, g_sampler, tc8);

				var sum : vec4<f32> = (
					1.0 * col0 + 2.0 * col1 + 1.0 * col2 +
					2.0 * col3 + 4.0 * col4 + 2.0 * col5 +
					1.0 * col6 + 2.0 * col7 + 1.0 * col8
				) * (1.0 / 16.0);

				var output: Output;
				output.color = sum * g_color.mixColor[input.instanceIndex];
				return output;
			}
		`
	},
	primitive: {
		topology: 'triangle-strip',
		stripIndexFormat: 'uint16',
	}
};

class BlurFilter extends Material.Subclass({pipeline}, []){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(drawUnitList){
		this.setBindGroup(1, [{binding:0, resource:{buffer:drawUnitList}}]);
		this.setVertexBuffer(0, drawUnitList);
		Vulkan.renderPassEncoder.draw(4, drawUnitList.length);
	}
	constructor(color){
		super();
		this.color = color;
		this.texture = new Texture2D();
	}
}

module.exports = BlurFilter;
