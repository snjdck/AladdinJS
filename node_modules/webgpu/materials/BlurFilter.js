'use strict';

const Material = require('./Material');
const Pipeline = require('./Pipeline');
const Texture2D = require('../2d/Texture2D');

const maxCountPerDraw = 100;

const pipeline = new Pipeline({
	groups: [[
		{name:'texture', texture:{}},
		{name:'g_sampler', sampler:{}, default:{magFilter:'linear', minFilter:'linear', addressModeU:'clamp-to-edge', addressModeV:'clamp-to-edge', addressModeW:'clamp-to-edge'}}
	], [
		{name:'colorList', type:'Color', buffer:{}, temp:{array:new Float32Array(4 * maxCountPerDraw), stride:4, mapFn: v => v.material.color}}
	]],
	vertex:{
		buffers: [{
			name: 'sourceRectList',
			arrayStride: 4 << 2,
			stepMode: 'instance',
			attributes: [
				{shaderLocation: 0, offset: 0, format: 'float32x4', name:'sourceRect'}
			],
			temp:{array:new Float32Array(4 * maxCountPerDraw), stride:4, mapFn: ({frameRect:{width, height}, drawRect}) => [drawRect.x / width, drawRect.y / height, drawRect.width / width, drawRect.height / height]}
		}],
		code: `
			struct Output {
				@builtin(position) position: vec4<f32>,
				@location(0) uv: vec2<f32>,
				@location(1) @interpolate(flat) instanceIndex: u32,//flat
			}

			@vertex
			fn main() -> Output {
				var destRect:vec4<f32> = sourceRect * vec2<f32>(2.0, -2.0).xyxy;
				//destRect.xy = destRect.xy + vec2<f32>(-1.0, 1.0);
				destRect.x = destRect.x - 1.0;
				destRect.y = destRect.y + 1.0;
				var vertexXY: vec2<f32> = vec2<f32>(f32(vertexIndex >> 1u), f32(vertexIndex & 1u));
				var output: Output;
				output.position = vec4<f32>(fma(vertexXY, destRect.zw, destRect.xy), 0.0, 1.0);
				output.uv = fma(vertexXY, sourceRect.zw, sourceRect.xy);
				output.instanceIndex = instanceIndex << 4u;//min bindgroup is 256 bytes, 16 of vec4<f32>
				return output;
			}
		`
	},
	fragment:{
		targets:[{
			format: 'bgra8unorm',
			blend: 'src-alpha add one-minus-src-alpha'
		}],
		code: `
			struct Color {
				mixColor : array<vec4<f32>, ${maxCountPerDraw}>,
			}

			@fragment
			fn main() -> Output {
				var s : f32 = dpdx(uv.x);
				var t : f32 = dpdy(uv.y);

				var ns: f32 = - s;
				var nt: f32 = - t;

				var tc0 : vec2<f32> = uv + vec2<f32>(ns,   nt);
				var tc1 : vec2<f32> = uv + vec2<f32>( 0.0, nt);
				var tc2 : vec2<f32> = uv + vec2<f32>( s,   nt);
				var tc3 : vec2<f32> = uv + vec2<f32>(ns,  0.0);
				var tc4 : vec2<f32> = uv;
				var tc5 : vec2<f32> = uv + vec2<f32>( s,    0.0);
				var tc6 : vec2<f32> = uv + vec2<f32>(ns,    t);
				var tc7 : vec2<f32> = uv + vec2<f32>( 0.0,  t);
				var tc8 : vec2<f32> = uv + vec2<f32>( s,    t);

				var col0 : vec4<f32> = textureSample(texture, g_sampler, tc0);
				var col1 : vec4<f32> = textureSample(texture, g_sampler, tc1);
				var col2 : vec4<f32> = textureSample(texture, g_sampler, tc2);
				var col3 : vec4<f32> = textureSample(texture, g_sampler, tc3);
				var col4 : vec4<f32> = textureSample(texture, g_sampler, tc4);
				var col5 : vec4<f32> = textureSample(texture, g_sampler, tc5);
				var col6 : vec4<f32> = textureSample(texture, g_sampler, tc6);
				var col7 : vec4<f32> = textureSample(texture, g_sampler, tc7);
				var col8 : vec4<f32> = textureSample(texture, g_sampler, tc8);

				var sum : vec4<f32> = (
					1.0 * col0 + 2.0 * col1 + 1.0 * col2 +
					2.0 * col3 + 4.0 * col4 + 2.0 * col5 +
					1.0 * col6 + 2.0 * col7 + 1.0 * col8
				) * (1.0 / 16.0);

				return Output(sum * colorList.mixColor[instanceIndex]);
			}
		`
	},
	primitive: {
		topology: 'triangle-strip',
		stripIndexFormat: 'uint16',
	}
});

class BlurFilter extends Material.Subclass(pipeline, []){
	static maxCountPerDraw = maxCountPerDraw;
	static onDraw(drawUnitList, renderPassEncoder){
		this.setResources(renderPassEncoder, {
			'colorList': {buffer:drawUnitList},
			'sourceRectList': drawUnitList
		});
		renderPassEncoder.draw(4, drawUnitList.length);
	}
	constructor(color){
		super();
		this.color = color;
		this.texture = new Texture2D();
	}
}

module.exports = BlurFilter;
