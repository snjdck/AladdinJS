'use strict';
const {fetchArrayBuffer} = require('webonly/utils');
const fs = {async readFileSync(url){
	return new Uint8Array(await fetchArrayBuffer(url));
}};
require('bluetooth/Buffer');
const {RADIAN} = require('webgpu/math');
const Matrix3D = require('webgpu/math/Matrix3D');
const Vector3D = require('webgpu/math/Vector3D');
const Vulkan = require('webgpu/Vulkan');
const AABB = require('webgpu/bounds/AABB');
const {parse, calcMeshBound, readVector3, castPosition, castRotation} = require('./bmd');
const world1objects = require('./world1objects');

module.exports = async function(worldID){
	const mapObjData = await fs.readFileSync(`./assets/World${worldID}/Terrain.obj`);
	let offset = 1;
	const objCount = mapObjData.readInt16LE(offset);
	offset += 2;
	const objList = [];
	for(let i=0; i<objCount; ++i){
		const id = mapObjData.readInt16LE(offset);
		const pos = readVector3(mapObjData, offset+2);
		const rot = readVector3(mapObjData, offset+14);
		const scale = mapObjData.readFloatLE(offset+26);
		offset += 30;
		pos.y -= 25600;
		castPosition(pos);
		castRotation(rot);
		const matrix = new Matrix3D();
		matrix.rotation.fromEulerAngles(rot.x * RADIAN, rot.y * RADIAN, rot.z * RADIAN);
		matrix.translation.setTo(pos.x, pos.y, pos.z);
		matrix.scale = scale;
		const name = worldID == 1 ? `Object1/${world1objects[id]}` : `Object${worldID}/Object${(id+1).toString().padStart(2, '0')}`;
		objList.push({name, matrix});
	}
	const fileDict = Object.create(null);
	for(let file of new Set(objList.map(v => v.name))){
		let mesh = await Vulkan.loadModel(`./assets/${file}.bmd`);
		calcMeshBound(mesh);
		mesh.subMeshList.forEach(subMesh => {
			subMesh.texture = `../assets/Object${worldID}/` + subMesh.texture;
		});
		fileDict[file] = mesh;
	}
	objList.forEach(v => v.mesh = fileDict[v.name]);
	return objList;
	/*
	x: -120 24762
	y: 360 25000
	z: -524 677
	map tile size 128
	*/
}

const vertex = new Vector3D();

function transBound(bound, matrix){
	const result = new AABB();
	vertex.setTo(bound.minX, bound.minY, bound.minZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.maxX, bound.minY, bound.minZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.minX, bound.maxY, bound.minZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.maxX, bound.maxY, bound.minZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.minX, bound.minY, bound.maxZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.maxX, bound.minY, bound.maxZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.minX, bound.maxY, bound.maxZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.maxX, bound.maxY, bound.maxZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	return result;
}