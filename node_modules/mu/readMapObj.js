const fs = require('fs');
const {parse, calcMeshBound} = require('./bmd');
const world1objects = require('./world1objects');

module.exports = function(worldID){
	let mapObjData = fs.readFileSync(`./assets/World${worldID}/Terrain.obj`);
	let offset = 1;
	let objCount = mapObjData.readInt16LE(offset);
	offset += 2;
	let objList = [];
	for(let i=0; i<objCount; ++i){
		let id = mapObjData.readInt16LE(offset);
		let x = mapObjData.readFloatLE(offset+2);
		let y = mapObjData.readFloatLE(offset+6);
		let z = mapObjData.readFloatLE(offset+10);
		let rx = mapObjData.readFloatLE(offset+14);
		let ry = mapObjData.readFloatLE(offset+18);
		let rz = mapObjData.readFloatLE(offset+22);
		let scale = mapObjData.readFloatLE(offset+26);
		offset += 30;
		objList.push({id, x, y, z, rx, ry, rz, scale});
	}
	if(worldID == 1){
		objList.forEach(v => v.file = `Object1/${world1objects[v.id]}`);
	}else{
		objList.forEach(v => v.file = `Object${worldID}/Object${(v.id+1).toString().padStart(2, '0')}`);
	}
	let fileDict = Object.create(null);
	for(let file of new Set(objList.map(v => v.file))){
		let path = `./assets/${file}.bmd`;
		if(!fs.existsSync(path)){
			console.warn(path + ' not exist!');
			continue;
		}
		let mesh = parse(fs.readFileSync(path));
		calcMeshBound(mesh);
		mesh.subMeshList.forEach(subMesh => {
			subMesh.texture = `../assets/Object${worldID}/` + subMesh.texture;
		});
		fileDict[file] = mesh;
	}
	objList.forEach(v => v.mesh = fileDict[v.file]);
	return objList;
	/*
	x: -120 24762
	y: 360 25000
	z: -524 677
	map tile size 128
	*/
}