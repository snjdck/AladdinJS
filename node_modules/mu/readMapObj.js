'use strict';
const fs = {readFileSync(url){
	return loadData(url, 'arraybuffer').then(buffer => new Uint8Array(buffer));
}};
const {loadData} = require('utils/loader');
const {RADIAN} = require('webgpu/math');
const Matrix3D = require('webgpu/math/Matrix3D');
const Vector3D = require('webgpu/math/Vector3D');
const Vulkan = require('webgpu/Vulkan');
const AABB = require('webgpu/bounds/AABB');
const {parse, calcMeshBound, readVector3, castPosition, castRotation} = require('./bmd');
const world1objects = require('./world1objects');

module.exports = async function(worldID){
	let mapObjData = await fs.readFileSync(`./assets/World${worldID}/Terrain.obj`);
	let offset = 1;
	let objCount = mapObjData.readInt16LE(offset);
	offset += 2;
	let objList = [];
	for(let i=0; i<objCount; ++i){
		let id = mapObjData.readInt16LE(offset);
		let pos = readVector3(mapObjData, offset+2);
		let rot = readVector3(mapObjData, offset+14);
		let scale = mapObjData.readFloatLE(offset+26);
		offset += 30;
		pos.y -= 25600;
		castPosition(pos);
		castRotation(rot);
		let matrix = new Matrix3D();
		matrix.rotation.fromEulerAngles(rot.x * RADIAN, rot.y * RADIAN, rot.z * RADIAN);
		matrix.translation.setTo(pos.x, pos.y, pos.z);
		matrix.scale = scale;
		objList.push({id, matrix});
	}
	if(worldID == 1){
		objList.forEach(v => v.file = `Object1/${world1objects[v.id]}`);
	}else{
		objList.forEach(v => v.file = `Object${worldID}/Object${(v.id+1).toString().padStart(2, '0')}`);
	}
	let fileDict = Object.create(null);
	for(let file of new Set(objList.map(v => v.file))){
		let path = `./assets/${file}.bmd`;
		/*
		if(!fs.existsSync(path)){
			console.warn(path + ' not exist!');
			continue;
		}
		//*/
		let data;
		try{
			data = await fs.readFileSync(path);
		}catch{
			console.warn(path + ' not exist!');
			continue;
		}
		let mesh = Vulkan.addMeshBufferGetter(parse(data));
		calcMeshBound(mesh);
		mesh.subMeshList.forEach(subMesh => {
			subMesh.texture = `../assets/Object${worldID}/` + subMesh.texture;
		});
		fileDict[file] = mesh;
		if(mesh.animationList.length != 1){
			console.log(mesh.name, mesh.animationList, mesh.boneList.length)
		}
	}
	objList.forEach(v => {
		let mesh = fileDict[v.file];
		v.mesh = mesh;
		let boundList = mesh.subMeshList.map(subMesh => subMesh.boundDict[0]);
		v.boundList = boundList.map(bound => transBound(bound, v.matrix));
	});
	return objList;
	/*
	x: -120 24762
	y: 360 25000
	z: -524 677
	map tile size 128
	*/
}

const vertex = new Vector3D();

function transBound(bound, matrix){
	const result = new AABB();
	vertex.setTo(bound.minX, bound.minY, bound.minZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.maxX, bound.minY, bound.minZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.minX, bound.maxY, bound.minZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.maxX, bound.maxY, bound.minZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.minX, bound.minY, bound.maxZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.maxX, bound.minY, bound.maxZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.minX, bound.maxY, bound.maxZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	vertex.setTo(bound.maxX, bound.maxY, bound.maxZ);
	matrix.transformPoint(vertex);
	result.add(vertex);
	return result;
}