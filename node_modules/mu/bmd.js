
const Matrix3D = require('webgpu/math/Matrix3D');
const Vector3D = require('webgpu/math/Vector3D');
const Animation = require('webgpu/3d/Animation');
const AABB = require('webgpu/bounds/AABB');

const byteSizePerVertex = 36;//x, y, z, nx, ny, nz, u, v, boneID
const keyList = [0xd1, 0x73, 0x52, 0xf6, 0xd2, 0x9a, 0xcb, 0x27, 0x3e, 0xaf, 0x59, 0x31, 0x37, 0xb3, 0xe7, 0xa2];

function decode(fileData){
	if(fileData[3] == 0x0A)
		return fileData.slice(4);
	if(fileData[3] == 0x0C){
		let offset = 0x5E;
		for(let i=8, n=fileData.length; i<n; ++i){
			let value = fileData[i];
			let key = keyList[(i - 8) & 0xF];
			fileData[i] = ((value ^ key) - offset) & 0xFF;
			offset = (value + 0x3D) & 0xFF;
		}
		return fileData.slice(8);
	}
}

function parse(fileData){
	fileData = decode(fileData);
	if(!fileData)return;
	let offset = 32;
	const subMeshCount = fileData.readUInt16LE(offset);
	const boneCount = fileData.readUInt16LE(offset + 2);
	const animationCount = fileData.readUInt16LE(offset + 4);
	offset += 6;
	const subMeshList = new Array(subMeshCount);
	const animationList = new Array(animationCount);
	const keyFrameCountList = new Array(animationCount);
	const boneList = [];
	//let vertexOffset = 0;
	for(let _=0; _<subMeshCount; ++_){
		const vertexListSize = fileData.readUInt16LE(offset);
		const normalListSize = fileData.readUInt16LE(offset + 2);
		const uvListSize = fileData.readUInt16LE(offset + 4);
		const triangleCount = fileData.readUInt16LE(offset + 6);
		const subMeshIndex = fileData.readUInt16LE(offset + 8);
		offset += 10;
		const vertexList = new Array(vertexListSize);
		const normalList = new Array(normalListSize);
		const uvList = new Array(uvListSize);
		//const boneData = [];
		for(let i=0; i<vertexListSize; ++i){
			const vec3 = readVector3(fileData, offset + 4);
			castPosition(vec3);
			vec3.boneID = fileData.readUInt16LE(offset);
			offset += 16;
			vertexList[i] = vec3;
		}
		for(let i=0; i<normalListSize; ++i){
			//const boneID = fileData.readUInt16LE(offset);
			const vec3 = readVector3(fileData, offset + 4);
			castPosition(vec3);
			//const n = fileData.readUInt32LE(offset + 16);
			offset += 20;
			normalList[i] = vec3;
		}
		for(let i=0; i<uvListSize; ++i){
			const u = fileData.readFloatLE(offset);
			const v = fileData.readFloatLE(offset + 4);
			offset += 8;
			uvList[i] = {u, v};
		}
		const vertexCount = triangleCount * 3;
		//const vertexData = new DataView(new ArrayBuffer(vertexCount * byteSizePerVertex));
		const positionData = new Float32Array(vertexCount * 3);
		const normalData = new Float32Array(vertexCount * 3);
		const uvData = new Float32Array(vertexCount * 2);
		const boneData = new Uint32Array(vertexCount);
		for(let i=0; i<triangleCount; ++i){
			const vertexIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			const normalIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			const uvIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			offset += 40;
			for(let j=0; j<3; ++j){
				//const dataOffset = (i * 3 + j) * byteSizePerVertex;
				const vertex = vertexList[vertexIndexList[j]];
				const normal = normalList[normalIndexList[j]];
				const uv = uvList[uvIndexList[j]];

				const index = i * 3 + j;

				positionData[index * 3] = vertex.x;
				positionData[index * 3 + 1] = vertex.y;
				positionData[index * 3 + 2] = vertex.z;

				normalData[index * 3] = normal.x;
				normalData[index * 3 + 1] = normal.y;
				normalData[index * 3 + 2] = normal.z;

				uvData[index * 2] = uv.u;
				uvData[index * 2 + 1] = uv.v;

				boneData[index] = vertex.boneID;
				/*
				vertexData.setFloat32(dataOffset   , vertex.x, true);
				vertexData.setFloat32(dataOffset+ 4, vertex.y, true);
				vertexData.setFloat32(dataOffset+ 8, vertex.z, true);
				vertexData.setFloat32(dataOffset+12, normal.x, true);
				vertexData.setFloat32(dataOffset+16, normal.y, true);
				vertexData.setFloat32(dataOffset+20, normal.z, true);
				vertexData.setFloat32(dataOffset+24, uv.u, true);
				vertexData.setFloat32(dataOffset+28, uv.v, true);
				/*
				let index = boneData.indexOf(vertex.boneID);
				if(index < 0){
					index = boneData.length;
					boneData.push(vertex.boneID);
				}
				*/
				//vertexData.setUint32(dataOffset+32, vertex.boneID, true);
			}
		}
		const texture = readCString(fileData, offset);
		offset += 32;
		//subMeshList[subMeshIndex] = {vertexData, vertexCount, boneData, texture, boneCount:boneData.length, vertexOffset};
		subMeshList[subMeshIndex] = {vertexCount, texture, attributes:{
			position: positionData,
			normal: normalData,
			uv: uvData,
			boneIndex: boneData,
		}};
		//vertexOffset += vertexCount;
	}
	for(let i=0; i<animationCount; ++i){
		const keyFrameCount = fileData.readUInt16LE(offset);
		const hasOffsetFlag = fileData.readUInt8(offset + 2);
		offset += 3;
		const offsetData = [];
		const offsetTotal = new Vector3D();
		if(hasOffsetFlag){
			for(let i=0; i<keyFrameCount; ++i){
				offsetData.push(offsetTotal.clone());
				offsetTotal.add(castPosition(readVector3(fileData, offset + 12 * i)));
			}
			offset += 12 * keyFrameCount;//three float
		}
		keyFrameCountList[i] = keyFrameCount;
		animationList[i] = new Animation(i.toString(), keyFrameCount-1, Object.create(null));
		animationList[i].keyFrameTimes = Array.from({length:keyFrameCount}, (_, i) => i);
		animationList[i].keyFrameCount = keyFrameCount;
		animationList[i].offsetData = offsetData;
	}
	for(let boneID=0; boneID<boneCount; ++boneID){
		const noBoneFlag = fileData.readUInt8(offset);
		offset += 1;
		if(noBoneFlag)continue;
		const boneName = readCString(fileData, offset);
		const bonePID = fileData.readInt16LE(offset + 32);
		offset += 34;
		for(let i=0; i<animationCount; ++i){
			const keyFrameCount = keyFrameCountList[i];
			const animation = animationList[i];
			const matrixList = Array.from({length:keyFrameCount}, () => new Matrix3D());
			animation.trackDict[boneID] = matrixList;
			for(let j=0; j<keyFrameCount; ++j){
				matrixList[j].translation.copyFrom(castPosition(readVector3(fileData, offset)));
				offset += 12;
				if(bonePID < 0 && animation.offsetData.length){
					matrixList[j].translation.subtract(animation.offsetData[j]);
				}
			}
			for(let j=0; j<keyFrameCount; ++j){
				const vec3 = castRotation(readVector3(fileData, offset));
				matrixList[j].rotation.fromEulerAngles(vec3.x, vec3.y, vec3.z);
				offset += 12;
			}
		}
		boneList.push({boneID, bonePID, boneName});
	}
	console.assert(offset == fileData.length);
	const mesh = {subMeshList, animationList, boneList};
	const prototype = Object.assign(Object.create(mesh), subMeshProto);
	subMeshList.forEach(subMesh => Object.setPrototypeOf(subMesh, prototype));
	subMeshList.forEach(subMesh => subMesh.boundDict = Object.create(null));
	mesh.name = readCString(fileData, 0);
	/*
	const vertexData = new Uint8Array(vertexOffset * byteSizePerVertex);
	subMeshList.forEach(subMesh => vertexData.set(new Uint8Array(subMesh.vertexData.buffer), subMesh.vertexOffset * byteSizePerVertex));
	mesh.vertexData = vertexData;
	mesh.vertexCount = vertexOffset;
	*/
	return mesh;
}

function readVector3(fileData, offset){
	const x = fileData.readFloatLE(offset);
	const y = fileData.readFloatLE(offset + 4);
	const z = fileData.readFloatLE(offset + 8);
	return {x, y, z};
}

function castPosition(vec3){
	vec3.y = -vec3.y;
	return vec3;
}

function castRotation(vec3){
	vec3.x = -vec3.x;
	vec3.z = -vec3.z;
	return vec3;
}

function readCString(data, offset){
	let end = offset;
	while(data[end] && end < offset + 32)
		++end;
	return String.fromCharCode(...data.slice(offset, end));
}

const subMeshProto = {
	copyVertexDataForCPU(){
		const {vertexData, vertexCount} = this;
		const dataView = new DataView(vertexData.buffer.slice(0));
		for(let i=0; i<vertexCount; ++i){
			const dataOffset = i * byteSizePerVertex;
			dataView.setUint32(dataOffset+32, 0, true);
		}
		return dataView;
	},
	updateVertexDataForCPU:function(){
		const matrix = new Matrix3D();
		const vertex = new Vector3D();
		return function(dataView, boneMatrixList){
			const {vertexData, vertexCount/*, boneData*/} = this;
			for(let i=0; i<vertexCount; ++i){
				const dataOffset = i * byteSizePerVertex;
				
				let boneIndex = vertexData.getUint32(dataOffset+32, true);
				//let boneID = boneData[boneIndex];
				//let {worldTransform} = boneList[boneID];
				matrix.setFromArray(boneMatrixList, boneIndex << 3);

				vertex.x = vertexData.getFloat32(dataOffset   , true);
				vertex.y = vertexData.getFloat32(dataOffset+ 4, true);
				vertex.z = vertexData.getFloat32(dataOffset+ 8, true);
				matrix.transformPoint(vertex);
				dataView.setFloat32(dataOffset   , vertex.x, true);
				dataView.setFloat32(dataOffset+ 4, vertex.y, true);
				dataView.setFloat32(dataOffset+ 8, vertex.z, true);

				vertex.x = vertexData.getFloat32(dataOffset+12, true);
				vertex.y = vertexData.getFloat32(dataOffset+16, true);
				vertex.z = vertexData.getFloat32(dataOffset+20, true);
				matrix.transformNormal(vertex);
				dataView.setFloat32(dataOffset+12, vertex.x, true);
				dataView.setFloat32(dataOffset+16, vertex.y, true);
				dataView.setFloat32(dataOffset+20, vertex.z, true);
			}
		}
	}()
};

function calcMeshBound(mesh){
	const {subMeshList, animationList} = mesh;
	for(let subMesh of subMeshList){
		for(let animation of animationList){
			calcSubMeshBoundByAnimation(subMesh, animation);
		}
	}
}

function calcMeshBoundByAnimation(mesh, animation){
	const {subMeshList} = mesh;
	for(let subMesh of subMeshList){
		calcSubMeshBoundByAnimation(subMesh, animation);
	}
}

const calcSubMeshBoundByAnimation = function(){
	const vertex = new Vector3D();
	return function(subMesh, animation){
		const {vertexData, vertexCount, boneData, boundDict} = subMesh;
		const {name, duration, trackDict} = animation;
		const bound = boundDict[name] = new AABB();
		for(let keyFrameIndex=0; keyFrameIndex<duration; ++keyFrameIndex){
			for(let i=0; i<vertexCount; ++i){
				const dataOffset = i * byteSizePerVertex;
				
				let boneID = vertexData.getUint32(dataOffset+32, true);
				//let boneID = boneData[boneIndex];

				const matrix = trackDict[boneID][keyFrameIndex];

				vertex.x = vertexData.getFloat32(dataOffset   , true);
				vertex.y = vertexData.getFloat32(dataOffset+ 4, true);
				vertex.z = vertexData.getFloat32(dataOffset+ 8, true);

				matrix.transformPoint(vertex);

				bound.add(vertex);
			}
		}
	}
}()

module.exports = {
	parse,
	calcMeshBound,
	calcMeshBoundByAnimation,
	calcSubMeshBoundByAnimation,
	readVector3,
	castPosition,
	castRotation,
};
