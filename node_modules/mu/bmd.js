
const {Matrix3D} = require('opengl/math');
const {Animation, AnimationTrack} = require('opengl/animations');
const {AttribIndex} = require('opengl/const');

const byteSizePerVertex = 36;//x, y, z, nx, ny, nz, u, v, boneID
const keyList = [0xd1, 0x73, 0x52, 0xf6, 0xd2, 0x9a, 0xcb, 0x27, 0x3e, 0xaf, 0x59, 0x31, 0x37, 0xb3, 0xe7, 0xa2];

function decode(fileData){
	if(fileData[3] == 0x0A)
		return fileData.slice(4);
	if(fileData[3] == 0x0C){
		let offset = 0x5E;
		for(let i=8, n=fileData.length; i<n; ++i){
			let value = fileData[i];
			let key = keyList[(i - 8) & 0xF];
			fileData[i] = ((value ^ key) - offset) & 0xFF;
			offset = (value + 0x3D) & 0xFF;
		}
		return fileData.slice(8);
	}
}

function parse(fileData){
	fileData = decode(fileData);
	if(!fileData)return;
	let offset = 32;
	const subMeshCount = fileData.readUInt16LE(offset);
	const boneCount = fileData.readUInt16LE(offset + 2);
	const animationCount = fileData.readUInt16LE(offset + 4);
	offset += 6;
	const subMeshList = new Array(subMeshCount);
	const animationList = new Array(animationCount);
	const keyFrameCountList = new Array(animationCount);
	const boneList = [];
	for(let _=0; _<subMeshCount; ++_){
		const vetrexCount = fileData.readUInt16LE(offset);
		const normalCount = fileData.readUInt16LE(offset + 2);
		const uvCount = fileData.readUInt16LE(offset + 4);
		const triangleCount = fileData.readUInt16LE(offset + 6);
		const subMeshIndex = fileData.readUInt16LE(offset + 8);
		offset += 10;
		const vertexList = new Array(vetrexCount);
		const normalList = new Array(normalCount);
		const uvList = new Array(uvCount);
		const boneData = [];
		for(let i=0; i<vetrexCount; ++i){
			const boneID = fileData.readUInt16LE(offset);
			const x = fileData.readFloatLE(offset + 4);
			const y = fileData.readFloatLE(offset + 8);
			const z = fileData.readFloatLE(offset + 12);
			offset += 16;
			vertexList[i] = {boneID, x, y, z};
		}
		for(let i=0; i<normalCount; ++i){
			//const boneID = fileData.readUInt16LE(offset);
			const x = fileData.readFloatLE(offset + 4);
			const y = fileData.readFloatLE(offset + 8);
			const z = fileData.readFloatLE(offset + 12);
			//const n = fileData.readUInt32LE(offset + 16);
			offset += 20;
			normalList[i] = {x, y, z};
		}
		for(let i=0; i<uvCount; ++i){
			const u = fileData.readFloatLE(offset);
			const v = fileData.readFloatLE(offset + 4);
			offset += 8;
			uvList[i] = {u, v};
		}
		const vertexCount = triangleCount * 3;
		const vertexData = new ArrayBuffer(vertexCount * byteSizePerVertex);
		const dataView = new DataView(vertexData);
		for(let i=0; i<triangleCount; ++i){
			const vertexIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			const normalIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			const uvIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			offset += 40;
			for(let j=0; j<3; ++j){
				const dataOffset = (i * 3 + j) * byteSizePerVertex;
				const vertex = vertexList[vertexIndexList[j]];
				const normal = normalList[normalIndexList[j]];
				const uv = uvList[uvIndexList[j]];

				dataView.setFloat32(dataOffset   , vertex.x, true);
				dataView.setFloat32(dataOffset+ 4, vertex.y, true);
				dataView.setFloat32(dataOffset+ 8, vertex.z, true);
				dataView.setFloat32(dataOffset+12, normal.x, true);
				dataView.setFloat32(dataOffset+16, normal.y, true);
				dataView.setFloat32(dataOffset+20, normal.z, true);
				dataView.setFloat32(dataOffset+24, uv.u, true);
				dataView.setFloat32(dataOffset+28, uv.v, true);

				let index = boneData.indexOf(vertex.boneID);
				if(index < 0){
					index = boneData.length;
					boneData.push(vertex.boneID);
				}

				dataView.setUint32(dataOffset+32, index << 1, true);
			}
		}
		const texture = readCString(fileData, offset);
		offset += 32;
		subMeshList[subMeshIndex] = Object.assign(
			Object.create(subMeshProto),
			{vertexData, vertexCount, boneData, texture, boneCount:boneData.length << 1}
		);
	}
	for(let i=0; i<animationCount; ++i){
		const keyFrameCount = fileData.readUInt16LE(offset);
		const hasOffsetFlag = fileData.readUInt8(offset + 2);
		offset += 3;
		if(hasOffsetFlag){
			offset += 12 * keyFrameCount;//three float
		}
		keyFrameCountList[i] = keyFrameCount;
		animationList[i] = new Animation(i.toString(), keyFrameCount, Object.create(null));
	}
	for(let boneID=0; boneID<boneCount; ++boneID){
		const noBoneFlag = fileData.readUInt8(offset);
		offset += 1;
		if(noBoneFlag)continue;
		const boneName = readCString(fileData, offset);
		const bonePID = fileData.readInt16LE(offset + 32);
		offset += 34;
		for(let i=0; i<animationCount; ++i){
			const keyFrameCount = keyFrameCountList[i];
			const animation = animationList[i];
			const matrixList = new Array(keyFrameCount);
			animation.trackDict[boneID] = new AnimationTrack(matrixList);
			for(let j=0; j<keyFrameCount; ++j){
				matrixList[j] = new Matrix3D();
				matrixList[j].time = j;
			}
			for(let j=0; j<keyFrameCount; ++j){
				const x = fileData.readFloatLE(offset);
				const y = fileData.readFloatLE(offset + 4);
				const z = fileData.readFloatLE(offset + 8);
				offset += 12;
				matrixList[j].translation.setTo(x, y, z);
			}
			for(let j=0; j<keyFrameCount; ++j){
				const x = fileData.readFloatLE(offset);
				const y = fileData.readFloatLE(offset + 4);
				const z = fileData.readFloatLE(offset + 8);
				offset += 12;
				matrixList[j].rotation.fromEulerAngles(x, y, z);
			}
		}
		boneList.push({boneID, bonePID, boneName});
	}
	console.assert(offset == fileData.length);
	return {subMeshList, animationList, boneList};
}

function readCString(data, offset){
	let end = offset;
	while(data[end] && end < offset + 32)
		++end;
	return data.toString('ascii', offset, end);
}

const subMeshProto = {
	bindCount: 1,
	onCreateVAO(gl){
		gl.vertexAttribPointer(AttribIndex.inputPosition, 3, gl.FLOAT, false, byteSizePerVertex, 0);
		gl.vertexAttribPointer(AttribIndex.inputUV, 2, gl.FLOAT, false, byteSizePerVertex, 24);
		gl.vertexAttribIPointer(AttribIndex.boneIndex, 1, gl.INT, byteSizePerVertex, 32);

		gl.enableVertexAttribArray(AttribIndex.inputPosition);
		gl.enableVertexAttribArray(AttribIndex.inputUV);
		gl.enableVertexAttribArray(AttribIndex.boneIndex);
		
		gl.vertexAttrib4f(AttribIndex.boneWeight, 1, 0, 0, 0);
	},
	onDraw(gl, instanceCount){
		gl.drawArraysInstanced(gl.TRIANGLES, 0, this.vertexCount, instanceCount);
	}
};

module.exports = parse;