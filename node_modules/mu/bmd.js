
const {Matrix3D, Vector3D} = require('opengl/math');
const {Animation} = require('opengl/animations');
const {AttribIndex} = require('opengl/const');
const {AABB} = require('opengl/bounds');

const byteSizePerVertex = 36;//x, y, z, nx, ny, nz, u, v, boneID
const keyList = [0xd1, 0x73, 0x52, 0xf6, 0xd2, 0x9a, 0xcb, 0x27, 0x3e, 0xaf, 0x59, 0x31, 0x37, 0xb3, 0xe7, 0xa2];

function decode(fileData){
	if(fileData[3] == 0x0A)
		return fileData.slice(4);
	if(fileData[3] == 0x0C){
		let offset = 0x5E;
		for(let i=8, n=fileData.length; i<n; ++i){
			let value = fileData[i];
			let key = keyList[(i - 8) & 0xF];
			fileData[i] = ((value ^ key) - offset) & 0xFF;
			offset = (value + 0x3D) & 0xFF;
		}
		return fileData.slice(8);
	}
}

function parse(fileData){
	fileData = decode(fileData);
	if(!fileData)return;
	let offset = 32;
	const subMeshCount = fileData.readUInt16LE(offset);
	const boneCount = fileData.readUInt16LE(offset + 2);
	const animationCount = fileData.readUInt16LE(offset + 4);
	offset += 6;
	const subMeshList = new Array(subMeshCount);
	const animationList = new Array(animationCount);
	const keyFrameCountList = new Array(animationCount);
	const boneList = [];
	let vertexOffset = 0;
	for(let _=0; _<subMeshCount; ++_){
		const vertexListSize = fileData.readUInt16LE(offset);
		const normalListSize = fileData.readUInt16LE(offset + 2);
		const uvListSize = fileData.readUInt16LE(offset + 4);
		const triangleCount = fileData.readUInt16LE(offset + 6);
		const subMeshIndex = fileData.readUInt16LE(offset + 8);
		offset += 10;
		const vertexList = new Array(vertexListSize);
		const normalList = new Array(normalListSize);
		const uvList = new Array(uvListSize);
		//const boneData = [];
		for(let i=0; i<vertexListSize; ++i){
			const vec3 = readVector3(fileData, offset + 4);
			castPosition(vec3);
			vec3.boneID = fileData.readUInt16LE(offset);
			offset += 16;
			vertexList[i] = vec3;
		}
		for(let i=0; i<normalListSize; ++i){
			//const boneID = fileData.readUInt16LE(offset);
			const vec3 = readVector3(fileData, offset + 4);
			castPosition(vec3);
			//const n = fileData.readUInt32LE(offset + 16);
			offset += 20;
			normalList[i] = vec3;
		}
		for(let i=0; i<uvListSize; ++i){
			const u = fileData.readFloatLE(offset);
			const v = fileData.readFloatLE(offset + 4);
			offset += 8;
			uvList[i] = {u, v};
		}
		const vertexCount = triangleCount * 3;
		const vertexData = new DataView(new ArrayBuffer(vertexCount * byteSizePerVertex));
		for(let i=0; i<triangleCount; ++i){
			const vertexIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			const normalIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			const uvIndexList = [fileData.readUInt16LE(offset+2), fileData.readUInt16LE(offset+4), fileData.readUInt16LE(offset+6)];
			offset += 8;
			offset += 40;
			for(let j=0; j<3; ++j){
				const dataOffset = (i * 3 + j) * byteSizePerVertex;
				const vertex = vertexList[vertexIndexList[j]];
				const normal = normalList[normalIndexList[j]];
				const uv = uvList[uvIndexList[j]];

				vertexData.setFloat32(dataOffset   , vertex.x, true);
				vertexData.setFloat32(dataOffset+ 4, vertex.y, true);
				vertexData.setFloat32(dataOffset+ 8, vertex.z, true);
				vertexData.setFloat32(dataOffset+12, normal.x, true);
				vertexData.setFloat32(dataOffset+16, normal.y, true);
				vertexData.setFloat32(dataOffset+20, normal.z, true);
				vertexData.setFloat32(dataOffset+24, uv.u, true);
				vertexData.setFloat32(dataOffset+28, uv.v, true);
				/*
				let index = boneData.indexOf(vertex.boneID);
				if(index < 0){
					index = boneData.length;
					boneData.push(vertex.boneID);
				}
				*/
				vertexData.setUint32(dataOffset+32, vertex.boneID, true);
			}
		}
		const texture = readCString(fileData, offset);
		offset += 32;
		//subMeshList[subMeshIndex] = {vertexData, vertexCount, boneData, texture, boneCount:boneData.length, vertexOffset};
		subMeshList[subMeshIndex] = {vertexData, vertexCount, texture, vertexOffset};
		vertexOffset += vertexCount;
	}
	for(let i=0; i<animationCount; ++i){
		const keyFrameCount = fileData.readUInt16LE(offset);
		const hasOffsetFlag = fileData.readUInt8(offset + 2);
		offset += 3;
		if(hasOffsetFlag){
			offset += 12 * keyFrameCount;//three float
		}
		keyFrameCountList[i] = keyFrameCount;
		animationList[i] = new Animation(i.toString(), keyFrameCount, Object.create(null));
	}
	for(let boneID=0; boneID<boneCount; ++boneID){
		const noBoneFlag = fileData.readUInt8(offset);
		offset += 1;
		if(noBoneFlag)continue;
		const boneName = readCString(fileData, offset);
		const bonePID = fileData.readInt16LE(offset + 32);
		offset += 34;
		for(let i=0; i<animationCount; ++i){
			const keyFrameCount = keyFrameCountList[i];
			const animation = animationList[i];
			const matrixList = new Array(keyFrameCount);
			animation.trackDict[boneID] = matrixList;
			for(let j=0; j<keyFrameCount; ++j){
				matrixList[j] = new Matrix3D();
				matrixList[j].time = j;
			}
			for(let j=0; j<keyFrameCount; ++j){
				const vec3 = readVector3(fileData, offset);
				castPosition(vec3);
				offset += 12;
				matrixList[j].translation.setTo(vec3.x, vec3.y, vec3.z);
			}
			for(let j=0; j<keyFrameCount; ++j){
				const vec3 = readVector3(fileData, offset);
				castRotation(vec3);
				offset += 12;
				matrixList[j].rotation.fromEulerAngles(vec3.x, vec3.y, vec3.z);
			}
		}
		boneList.push({boneID, bonePID, boneName});
	}
	console.assert(offset == fileData.length);
	const mesh = {subMeshList, animationList, boneList, boneCount};
	const prototype = Object.assign(Object.create(mesh), subMeshProto);
	subMeshList.forEach(subMesh => Object.setPrototypeOf(subMesh, prototype));
	subMeshList.forEach(subMesh => subMesh.boundDict = Object.create(null));
	mesh.name = readCString(fileData, 0);
	const vertexData = new Uint8Array(vertexOffset * byteSizePerVertex);
	subMeshList.forEach(subMesh => vertexData.set(new Uint8Array(subMesh.vertexData.buffer), subMesh.vertexOffset * byteSizePerVertex));
	mesh.vertexData = vertexData;
	mesh.vertexCount = vertexOffset;
	return mesh;
}

function readVector3(fileData, offset){
	const x = fileData.readFloatLE(offset);
	const y = fileData.readFloatLE(offset + 4);
	const z = fileData.readFloatLE(offset + 8);
	return {x, y, z};
}

function castPosition(vec3){
	vec3.y = -vec3.y;
}

function castRotation(vec3){
	vec3.x = -vec3.x;
	vec3.z = -vec3.z;
}

function readCString(data, offset){
	let end = offset;
	while(data[end] && end < offset + 32)
		++end;
	return String.fromCharCode(...data.slice(offset, end));
	return Array.from(data.slice(offset, end), v => String.fromCharCode(v)).join('');
	return data.toString('ascii', offset, end);
}

const subMeshProto = {
	onCreateVAO(gl){
		gl.vertexAttribPointer(AttribIndex.inputPosition, 3, gl.FLOAT, false, byteSizePerVertex, 0);
		gl.vertexAttribPointer(AttribIndex.inputNormal, 3, gl.FLOAT, false, byteSizePerVertex, 12);
		gl.vertexAttribPointer(AttribIndex.inputUV, 2, gl.FLOAT, false, byteSizePerVertex, 24);
		gl.vertexAttribIPointer(AttribIndex.boneIndex, 1, gl.INT, byteSizePerVertex, 32);

		gl.enableVertexAttribArray(AttribIndex.inputPosition);
		gl.enableVertexAttribArray(AttribIndex.inputNormal);
		gl.enableVertexAttribArray(AttribIndex.inputUV);
		gl.enableVertexAttribArray(AttribIndex.boneIndex);
	},
	onActive(gl){
		//this is not a part of VAO
		gl.vertexAttrib1f(AttribIndex.boneWeight, 1);
		gl.vertexAttribI4i(AttribIndex.boneInfo, 1, this.boneCount, 0, 0);
	},
	onDraw(gl, instanceCount){
		gl.drawArraysInstanced(gl.TRIANGLES, 0, this.vertexCount, instanceCount);
	},
	copyVertexDataForCPU(){
		const {vertexData, vertexCount} = this;
		const dataView = new DataView(vertexData.buffer.slice(0));
		for(let i=0; i<vertexCount; ++i){
			const dataOffset = i * byteSizePerVertex;
			dataView.setUint32(dataOffset+32, 0, true);
		}
		return dataView;
	},
	updateVertexDataForCPU:function(){
		const matrix = new Matrix3D();
		const vertex = new Vector3D();
		return function(dataView, boneMatrixList){
			const {vertexData, vertexCount/*, boneData*/} = this;
			for(let i=0; i<vertexCount; ++i){
				const dataOffset = i * byteSizePerVertex;
				
				let boneIndex = vertexData.getUint32(dataOffset+32, true);
				//let boneID = boneData[boneIndex];
				//let {worldTransform} = boneList[boneID];
				matrix.setFromArray(boneMatrixList, boneIndex << 3);

				vertex.x = vertexData.getFloat32(dataOffset   , true);
				vertex.y = vertexData.getFloat32(dataOffset+ 4, true);
				vertex.z = vertexData.getFloat32(dataOffset+ 8, true);
				matrix.transformPoint(vertex);
				dataView.setFloat32(dataOffset   , vertex.x, true);
				dataView.setFloat32(dataOffset+ 4, vertex.y, true);
				dataView.setFloat32(dataOffset+ 8, vertex.z, true);

				vertex.x = vertexData.getFloat32(dataOffset+12, true);
				vertex.y = vertexData.getFloat32(dataOffset+16, true);
				vertex.z = vertexData.getFloat32(dataOffset+20, true);
				matrix.transformNormal(vertex);
				dataView.setFloat32(dataOffset+12, vertex.x, true);
				dataView.setFloat32(dataOffset+16, vertex.y, true);
				dataView.setFloat32(dataOffset+20, vertex.z, true);
			}
		}
	}()
};

function calcMeshBound(mesh){
	const {subMeshList, animationList} = mesh;
	for(let subMesh of subMeshList){
		for(let animation of animationList){
			calcSubMeshBoundByAnimation(subMesh, animation);
		}
	}
}

function calcMeshBoundByAnimation(mesh, animation){
	const {subMeshList} = mesh;
	for(let subMesh of subMeshList){
		calcSubMeshBoundByAnimation(subMesh, animation);
	}
}

const calcSubMeshBoundByAnimation = function(){
	const vertex = new Vector3D();
	return function(subMesh, animation){
		const {vertexData, vertexCount, boneData, boundDict} = subMesh;
		const {name, duration, trackDict} = animation;
		const bound = boundDict[name] = new AABB();
		for(let keyFrameIndex=0; keyFrameIndex<duration; ++keyFrameIndex){
			for(let i=0; i<vertexCount; ++i){
				const dataOffset = i * byteSizePerVertex;
				
				let boneIndex = vertexData.getUint32(dataOffset+32, true);
				let boneID = boneData[boneIndex];

				const matrix = trackDict[boneID][keyFrameIndex];

				vertex.x = vertexData.getFloat32(dataOffset   , true);
				vertex.y = vertexData.getFloat32(dataOffset+ 4, true);
				vertex.z = vertexData.getFloat32(dataOffset+ 8, true);

				matrix.transformPoint(vertex);

				bound.add(vertex);
			}
		}
	}
}()

module.exports = {
	parse,
	calcMeshBound,
	calcMeshBoundByAnimation,
	calcSubMeshBoundByAnimation,
	readVector3,
	castPosition,
	castRotation,
};
