
const KeyFrame = require('webgpu/3d/KeyFrame');
const Vector3D = require('webgpu/math/Vector3D');
const Animation = require('webgpu/3d/Animation');
const BoneObject = require('webgpu/3d/BoneObject');
const AABB = require('webgpu/bounds/AABB');

const keyList = [0xd1, 0x73, 0x52, 0xf6, 0xd2, 0x9a, 0xcb, 0x27, 0x3e, 0xaf, 0x59, 0x31, 0x37, 0xb3, 0xe7, 0xa2];

function decode(fileData){
	if(fileData[3] == 0x0A)return fileData.subarray(4);
	if(fileData[3] == 0x0C){
		let offset = 0x5E;
		for(let i=8, n=fileData.length; i<n; ++i){
			let value = fileData[i];
			let key = keyList[(i - 8) & 0xF];
			fileData[i] = ((value ^ key) - offset) & 0xFF;
			offset = (value + 0x3D) & 0xFF;
		}
		return fileData.subarray(8);
	}
}

function parse(arrayBuffer){
	const fileData = decode(new Uint8Array(arrayBuffer));
	if(!fileData)return;
	const dataView = new DataView(fileData.buffer, fileData.byteOffset);
	let offset = 32;
	const subMeshCount = dataView.getUint16(offset, true);
	const boneCount = dataView.getUint16(offset + 2, true);
	const animationCount = dataView.getUint16(offset + 4, true);
	offset += 6;
	const subMeshList = new Array(subMeshCount);
	const animationList = new Array(animationCount);
	const keyFrameCountList = new Array(animationCount);
	const boneList = [];
	for(let _=0; _<subMeshCount; ++_){
		const vertexListSize = dataView.getUint16(offset, true);
		const normalListSize = dataView.getUint16(offset + 2, true);
		const uvListSize = dataView.getUint16(offset + 4, true);
		const triangleCount = dataView.getUint16(offset + 6, true);
		const subMeshIndex = dataView.getUint16(offset + 8, true);
		offset += 10;
		const vertexList = new Array(vertexListSize);
		const normalList = new Array(normalListSize);
		const uvList = new Array(uvListSize);
		for(let i=0; i<vertexListSize; ++i){
			const vec3 = castPosition(readVector3(dataView, offset + 4));
			vec3.boneID = dataView.getUint16(offset, true);
			offset += 16;
			vertexList[i] = vec3;
		}
		for(let i=0; i<normalListSize; ++i){
			//const boneID = dataView.getUint16(offset, true);
			const vec3 = castPosition(readVector3(dataView, offset + 4));
			//const n = fileData.readUInt32LE(offset + 16);
			offset += 20;
			normalList[i] = vec3;
		}
		for(let i=0; i<uvListSize; ++i){
			const u = dataView.getFloat32(offset, true);
			const v = dataView.getFloat32(offset + 4, true);
			offset += 8;
			uvList[i] = {u, v};
		}
		const vertexCount = triangleCount * 3;
		const positionData = new Float32Array(vertexCount * 3);
		const normalData = new Float32Array(vertexCount * 3);
		const uvData = new Float32Array(vertexCount * 2);
		const boneJoints = new Uint16Array(vertexCount * 4);
		const boneWeights = new Float32Array(vertexCount * 4);
		for(let i=0; i<triangleCount; ++i){
			const vertexIndexList = [dataView.getUint16(offset+2, true), dataView.getUint16(offset+4, true), dataView.getUint16(offset+6, true)];
			offset += 8;
			const normalIndexList = [dataView.getUint16(offset+2, true), dataView.getUint16(offset+4, true), dataView.getUint16(offset+6, true)];
			offset += 8;
			const uvIndexList = [dataView.getUint16(offset+2, true), dataView.getUint16(offset+4, true), dataView.getUint16(offset+6, true)];
			offset += 8;
			offset += 40;
			for(let j=0; j<3; ++j){
				const vertex = vertexList[vertexIndexList[j]];
				const normal = normalList[normalIndexList[j]];
				const uv = uvList[uvIndexList[j]];

				const index = i * 3 + j;

				positionData[index * 3] = vertex.x;
				positionData[index * 3 + 1] = vertex.y;
				positionData[index * 3 + 2] = vertex.z;

				normalData[index * 3] = normal.x;
				normalData[index * 3 + 1] = normal.y;
				normalData[index * 3 + 2] = normal.z;

				uvData[index << 1] = uv.u;
				uvData[index << 1 | 1] = uv.v;

				boneJoints[index << 2] = vertex.boneID;
				boneWeights[index << 2] = 1;
			}
		}
		const texture = readCString(dataView, offset);
		offset += 32;
		subMeshList[subMeshIndex] = {vertexCount, texture, attributes:{
			position: positionData,
			normal: normalData,
			uv: uvData,
			boneJoints,
			boneWeights
		}};
	}
	for(let i=0; i<animationCount; ++i){
		const keyFrameCount = dataView.getUint16(offset, true);
		const hasOffsetFlag = dataView.getUint8(offset + 2);
		offset += 3;
		const offsetData = [];
		const offsetTotal = new Vector3D();
		if(hasOffsetFlag){
			for(let i=0; i<keyFrameCount; ++i){
				offsetData.push(offsetTotal.clone());
				offsetTotal.add(castPosition(readVector3(dataView, offset + 12 * i)));
			}
			offset += 12 * keyFrameCount;//three float
		}
		keyFrameCountList[i] = keyFrameCount;
		animationList[i] = new Animation(i.toString(), keyFrameCount-1, Object.create(null));
		animationList[i].keyFrameTimes = Array.from({length:keyFrameCount}, (_, i) => i);
		animationList[i].offsetData = offsetData;
	}
	for(let boneID=0; boneID<boneCount; ++boneID){
		const noBoneFlag = dataView.getUint8(offset);
		offset += 1;
		if(noBoneFlag)continue;
		const boneName = readCString(dataView, offset);
		const bonePID = dataView.getInt16(offset + 32, true);
		offset += 34;
		for(let i=0; i<animationCount; ++i){
			const keyFrameCount = keyFrameCountList[i];
			const animation = animationList[i];
			const matrixList = Array.from({length:keyFrameCount}, () => new KeyFrame());
			animation.trackDict[boneID] = matrixList;
			for(let j=0; j<keyFrameCount; ++j){
				matrixList[j].translation.copyFrom(castPosition(readVector3(dataView, offset)));
				offset += 12;
				if(bonePID < 0 && animation.offsetData.length){
					matrixList[j].translation.subtract(animation.offsetData[j]);
				}
			}
			for(let j=0; j<keyFrameCount; ++j){
				const vec3 = castRotation(readVector3(dataView, offset));
				matrixList[j].rotation.fromEulerAngles(vec3.x, vec3.y, vec3.z);
				offset += 12;
			}
		}
		const bone = {id:boneID, name:boneName};
		if(bonePID >= 0)bone.parent = boneList.find(v => v.id == bonePID);
		boneList.push(bone);
	}
	console.assert(offset == dataView.byteLength);
	const mesh = {subMeshList, animationList, boneList};
	const prototype = Object.assign(Object.create(mesh), subMeshProto);
	subMeshList.forEach(subMesh => Object.setPrototypeOf(subMesh, prototype));
	mesh.name = readCString(dataView, 0);
	return mesh;
}

function readVector3(dataView, offset){
	const x = dataView.getFloat32(offset, true);
	const y = dataView.getFloat32(offset + 4, true);
	const z = dataView.getFloat32(offset + 8, true);
	return {x, y, z};
}

function castPosition(vec3){
	vec3.y = -vec3.y;
	return vec3;
}

function castRotation(vec3){
	vec3.x = -vec3.x;
	vec3.z = -vec3.z;
	return vec3;
}

function readCString(data, offset){
	let list = [];
	for(let i=0; i<32; ++i){
		let char = data.getUint8(offset+i);
		if(char == 0)break;
		list.push(char);
	}
	return String.fromCharCode(...list);
}

const subMeshProto = {
	copyVertexDataForCPU(){
		return {vertexCount, texture, attributes:{uv, boneIndex, position:position.slice(), normal:normal.slice()}};
	},
	updateVertexDataForCPU:function(){
		const vertex = new Vector3D();
		return function(attributes, boneState){
			const {vertexCount, attributes:{position, normal, boneIndex}} = this;
			for(let i=0; i<vertexCount; ++i){
				const matrix = boneState[boneIndex[i]];
				const offset = i << 2;
				
				vertex.x = position[offset];
				vertex.y = position[offset+1];
				vertex.z = position[offset+2];
				matrix.transformPoint(vertex);
				attributes.position[offset] = vertex.x;
				attributes.position[offset+1] = vertex.y;
				attributes.position[offset+2] = vertex.z;

				vertex.x = normal[offset];
				vertex.y = normal[offset+1];
				vertex.z = normal[offset+2];
				matrix.transformNormal(vertex);
				attributes.normal[offset] = vertex.x;
				attributes.normal[offset+1] = vertex.y;
				attributes.normal[offset+2] = vertex.z;
			}
		}
	}()
};

function calcMeshBound(mesh){
	const rootBone = new BoneObject(mesh.boneList);
	const boneState = rootBone.buildBoneState();
	const vertex = new Vector3D();
	const boundList = [];
	for(let animation of mesh.animationList){
		const {duration, trackDict} = animation;
		for(let keyFrameIndex=0; keyFrameIndex<=duration; ++keyFrameIndex){
			const {boneList} = rootBone;
			for(let i=0, n=boneList.length; i<n; ++i){
				const {id, parent} = boneList[i];
				if(parent){
					boneState[id].copyFrom(trackDict[id][keyFrameIndex]).append(boneState[parent.id]);
				}else{
					boneState[id].copyFrom(trackDict[id][keyFrameIndex]);
				}
			}
		}
		for(let subMesh of mesh.subMeshList){
			const {vertexCount, attributes:{position, boneIndex}} = subMesh;
			const bound = new AABB();
			for(let i=0; i<vertexCount; ++i){
				const matrix = boneState[boneIndex[i]];
				const offset = i << 2;
				vertex.x = position[offset];
				vertex.y = position[offset+1];
				vertex.z = position[offset+2];
				bound.add(matrix.transformPoint(vertex));
			}
			boundList.push(bound);
		}
	}
	if(boundList.length > 0){
		mesh.boundAABB = boundList.reduce((a, b) => a.union(b));
	}
}

module.exports = {
	parse,
	readVector3,
	castPosition,
	castRotation,
	calcMeshBound,
};
