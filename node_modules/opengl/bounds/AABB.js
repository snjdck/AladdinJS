
class AABB {
	constructor(){
		this.clear();
	}

	clear(){
		this.minX = Infinity;
		this.minY = Infinity;
		this.minZ = Infinity;
		this.maxX = -Infinity;
		this.maxY = -Infinity;
		this.maxZ = -Infinity;
	}

	add({x, y, z}){
		return this.addXYZ(x, y, z);
	}

	addXYZ(x, y, z){
		if(x < this.minX)this.minX = x;
		if(x > this.maxX)this.maxX = x;
		if(y < this.minY)this.minY = y;
		if(y > this.maxY)this.maxY = y;
		if(z < this.minZ)this.minZ = z;
		if(z > this.maxZ)this.maxZ = z;
		return this;
	}

	contains(other){
		return this.minX <= other.minX && other.maxX <= this.maxX
			&& this.minY <= other.minY && other.maxY <= this.maxY
			&& this.minZ <= other.minZ && other.maxZ <= this.maxZ;
	}

	containsPt(pt){
		return this.minX <= pt.x && pt.x <= this.maxX
			&& this.minY <= pt.y && pt.y <= this.maxY
			&& this.minZ <= pt.z && pt.z <= this.maxZ;
	}

	hitTest(other){
		return !((this.minX >= other.maxX) || (this.maxX <= other.minX)
			||   (this.minY >= other.maxY) || (this.maxY <= other.minY)
			||   (this.minZ >= other.maxZ) || (this.maxZ <= other.minZ));
	}

	union(other, result=this){
		result.minX = Math.min(this.minX, other.minX);
		result.minY = Math.min(this.minY, other.minY);
		result.minZ = Math.min(this.minZ, other.minZ);
		result.maxX = Math.max(this.maxX, other.maxX);
		result.maxY = Math.max(this.maxY, other.maxY);
		result.maxZ = Math.max(this.maxZ, other.maxZ);
		return result;
	}

	getProjectLen(axis){
		let halfSizeX = (this.maxX - this.minX) * 0.5;
		let halfSizeY = (this.maxY - this.minY) * 0.5;
		let halfSizeZ = (this.maxZ - this.minZ) * 0.5;
		return halfSizeX * Math.abs(axis.x) + halfSizeY * Math.abs(axis.y) + halfSizeZ * Math.abs(axis.z);
	}

	intersectPlane(a, b, c, d){
		const {minX,
		minY,
		minZ,
		maxX,
		maxY,
		maxZ} = this;
		//let x1, y1, z1;//min
		let x2, y2, z2;//max
		if(a >= 0){
			//x1 = minX;
			x2 = maxX;
		}else{
			//x1 = maxX;
			x2 = minX;
		}
		if(b >= 0){
			//y1 = minY;
			y2 = maxY;
		}else{
			//y1 = maxY;
			y2 = minY;
		}
		if(c >= 0){
			//z1 = minZ;
			z2 = maxZ;
		}else{
			//z1 = maxZ;
			z2 = minZ;
		}
		//console.log('aabb', a * x2 , b * y2 , c * z2 , d);
		let result = a * x2 + b * y2 + c * z2 + d;
		return result > 0;

	}

	transform(matrix, result=this){
		var sourceMinX = source.minX;
		var sourceMaxX = source.maxX;
		var sourceMinY = source.minY;
		var sourceMaxY = source.maxY;
		var sourceMinZ = source.minZ;
		var sourceMaxZ = source.maxZ;
		
		var rawData = matrix.rawData;
		var minX = rawData[12], maxX = minX;
		var minY = rawData[13], maxY = minY;
		var minZ = rawData[14], maxZ = minZ;
		var factor;
		
		if((factor = rawData[0]) > 0){
			minX += factor * sourceMinX;
			maxX += factor * sourceMaxX;
		}else{
			minX += factor * sourceMaxX;
			maxX += factor * sourceMinX;
		}
		if((factor = rawData[4]) > 0){
			minX += factor * sourceMinY;
			maxX += factor * sourceMaxY;
		}else{
			minX += factor * sourceMaxY;
			maxX += factor * sourceMinY;
		}
		if((factor = rawData[8]) > 0){
			minX += factor * sourceMinZ;
			maxX += factor * sourceMaxZ;
		}else{
			minX += factor * sourceMaxZ;
			maxX += factor * sourceMinZ;
		}
		if((factor = rawData[1]) > 0){
			minY += factor * sourceMinX;
			maxY += factor * sourceMaxX;
		}else{
			minY += factor * sourceMaxX;
			maxY += factor * sourceMinX;
		}
		if((factor = rawData[5]) > 0){
			minY += factor * sourceMinY;
			maxY += factor * sourceMaxY;
		}else{
			minY += factor * sourceMaxY;
			maxY += factor * sourceMinY;
		}
		if((factor = rawData[9]) > 0){
			minY += factor * sourceMinZ;
			maxY += factor * sourceMaxZ;
		}else{
			minY += factor * sourceMaxZ;
			maxY += factor * sourceMinZ;
		}
		if((factor = rawData[2]) > 0){
			minZ += factor * sourceMinX;
			maxZ += factor * sourceMaxX;
		}else{
			minZ += factor * sourceMaxX;
			maxZ += factor * sourceMinX;
		}
		if((factor = rawData[6]) > 0){
			minZ += factor * sourceMinY;
			maxZ += factor * sourceMaxY;
		}else{
			minZ += factor * sourceMaxY;
			maxZ += factor * sourceMinY;
		}
		if((factor = rawData[10]) > 0){
			minZ += factor * sourceMinZ;
			maxZ += factor * sourceMaxZ;
		}else{
			minZ += factor * sourceMaxZ;
			maxZ += factor * sourceMinZ;
		}
		
		result.setMinMax(minX, minY, minZ, maxX, maxY, maxZ);
	}

	setMinMax(minX, minY, minZ, maxX, maxY, maxZ){
		this.minX = minX;
		this.minY = minY;
		this.minZ = minZ;
		this.maxX = maxX;
		this.maxY = maxY;
		this.maxZ = maxZ;
		return this;
	}
}

module.exports = AABB;
