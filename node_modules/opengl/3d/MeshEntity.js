'use strict';

const Clock = require('../Clock');
const WebGL = require('../WebGL');
const DisplayObject3D = require("../DisplayObject3D");
const {MeshVertexArray} = require("../vertexarrays");
const {TextureMaterial, TextureHitTestMaterial, DepthMaterial} = require("../materials");
const BoneObject = require('./BoneObject');

function buildBoneTree(entity){
	const boneDict = Object.create(null);
	const boneList = [];
	const boneObjectList = [];
	for(let {boneName, boneID, bonePID} of entity.mesh.boneList){
		let boneParent = bonePID < 0 ? entity : boneList[bonePID];
		let bone = new BoneObject(boneParent, boneID);

		boneDict[boneName] = bone;
		boneList[boneID] = bone;
		boneObjectList.push(bone);

		if(bonePID >= 0){
			boneParent.addChild(bone);
		}else if(entity.rootBone){
			entity.rootBone.addSibling(bone);
		}else{
			entity.rootBone = bone;
		}
	}
	entity.boneDict = boneDict;
	entity.boneList = boneList;
	entity.boneObjectList = boneObjectList;
}

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.subEntityList = mesh.subMeshList.map(subMesh => Object.create(this, {
			entity: {value: this},
			subMesh: {value: subMesh},
			vao: {value: MeshVertexArray.new(subMesh)},
			boneMatrixList: {value: new Float32Array(Math.max(subMesh.boneData.length, 1) * 8)},
		}));
		/*
		this.subEntityList.forEach(subEntity => 
			WebGL.textureMgr.fetch(subEntity.subMesh.texture, texture => {
				subEntity.defaultMaterial = new TextureMaterial(texture);
				subEntity.hitTestMaterial = new TextureHitTestMaterial(texture);
			})
		);
		//*/
		if(!(createSkeleton && mesh.boneList.length > 0))return;
		buildBoneTree(this);
		this.animationList = mesh.animationList;
		//this.animation = this.animationList[88] || this.animationList[0];
		this.animation = this.animationList[1] || this.animationList[0];
		this.animationTime = 0;
		//this.timeChangedFlag = true;
	}

	updateAnimationAndBone(){
		const {animation, animationTime, boneObjectList} = this;
		if(animation){
			let {timeElapsed} = Clock;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(!boneObjectList)return;
		for(let i=0, n=boneObjectList.length; i<n; ++i){
			let bone = boneObjectList[i];
			animation.calcTransform(bone.id, animationTime, bone.transform);
			bone.transform.append(bone.parent.worldTransform, bone.worldTransform);
		}
	}

	collectDrawUnits(collector){
		const {subEntityList, attachmentDict, boneDict} = this;
		const skeleton = this.skeleton || this;
		let needUpdateFlag = true;
		for(let i=0; i<subEntityList.length; ++i){
			const subEntity = subEntityList[i];
			if(!subEntity.visible)continue;
			if(subEntity.staticBound && collector.viewFrustum.canCull(subEntity.staticBound)){
				continue;
			}
			if(!subEntity.defaultMaterial){
				let texture = WebGL.textureMgr.fetch(subEntity.subMesh.texture);
				if(texture){
					subEntity.defaultMaterial = new TextureMaterial(texture);
					subEntity.hitTestMaterial = new TextureHitTestMaterial(texture);
				}
				continue;
			}
			if(needUpdateFlag){
				this.updateAnimationAndBone();
				needUpdateFlag = false;
			}

			if(!skeleton.boneList){
				skeleton.worldTransform.copyToArray(subEntity.boneMatrixList);
			}else{
				let {boneMatrixList, subMesh:{boneData}} = subEntity;
				for(let i=0, n=boneData.length; i<n; ++i){
					let bone = skeleton.boneList[boneData[i]];
					bone.worldTransform.copyToArray(boneMatrixList, i << 3);
				}
			}
			subEntity.material = subEntity.defaultMaterial;
			collector.addDrawUnit(subEntity);
		}
		if(attachmentDict == null || attachmentDict.size == 0)return;
		if(needUpdateFlag)this.updateAnimationAndBone();
		for(const [attachment, boneName] of attachmentDict){
			attachment.transform = boneDict[boneName].worldTransform;
			attachment.collectDrawUnits(collector);
		}
	}

	shareSkeletonWith(target){
		this.skeleton = target;
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		if(!(boneName in this.boneDict))return;
		if(!this.attachmentDict){
			this.attachmentDict = new Map();
		}
		if(clearOtherObjects)this.unbindObjects(boneName);
		this.attachmentDict.set(target, boneName);
	}

	unbindObject(target){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		attachmentDict.delete(target);
	}

	unbindObjects(boneName){
		const {attachmentDict} = this;
		if(attachmentDict == null || attachmentDict.size == 0)return;
		if(boneName == null){
			attachmentDict.clear();
			return;
		}
		for(const [attachment, name] of attachmentDict){
			if(name != boneName)continue;
			attachmentDict.delete(attachment);
		}
	}
}

module.exports = MeshEntity;