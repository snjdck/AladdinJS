"use strict";

const DisplayObject3D = require("../DisplayObject3D");
const {MeshVertexArray} = require("../vertexarrays");
const {DrawMode} = require("../renderers");
const {TextureMaterial, TextureHitTestMaterial, DepthMaterial} = require("../materials");
const ObjectCache = require("utils/ObjectCache");

class BoneObject extends DisplayObject3D
{
	constructor(entity, boneID){
		super();
		Object.defineProperty(this, "entity", {value:entity});
		Object.defineProperty(this, "boneID", {value:boneID});
	}
	onUpdate(timeElapsed){
		this.updateBoneState();
		super.onUpdate(timeElapsed);
	}
	updateBoneState(){
		let {boneID, transform} = this;
		let {animation, animationTime} = this.entity;
		animation.calcTransform(boneID, animationTime, transform);
		this.onTransformChanged();
	}
}

class SubMeshEntity extends DisplayObject3D
{
	constructor(subMesh, formatList){
		super();
		this.visible = true;
		this.subMesh = subMesh;
		this.vao = MeshVertexArray.new(subMesh, formatList);
		let boneCount = subMesh.boneData.length;
		this.boneMatrixList = new Float32Array(boneCount > 0 ? boneCount * 8 : 8);
		this.drawUnitCache = new ObjectCache(function(bind){Object.setPrototypeOf(this,bind)}, null, [this]);
	}
	onUpdate(timeElapsed){
		super.onUpdate(timeElapsed);
		this.drawUnitCache.putAllIn();
	}
	collectDrawUnits(collector, gl, mode){
		let {drawUnitCache, parent, subMesh} = this;
		if(this.materials.length <= 0){
			let texture = gl.textureMgr.fetch(subMesh.texture);
			if(texture){
				this.materials.push(new TextureMaterial(texture));
				this.hitTestMaterial = new TextureHitTestMaterial(texture);
			}
			return;
		}
		if(mode == DrawMode.Pick){
			if(this.hitTestMaterial){
				let drawUnit = drawUnitCache.getOut();
				drawUnit.material = this.hitTestMaterial;
				collector.addDrawUnit(drawUnit);
			}
			return;
		}
		this.updateBoneMatrixList(parent.skeleton || parent);
		if(mode == DrawMode.ShadowMap){
			if(!parent.castShadow)return;
			let drawUnit = drawUnitCache.getOut();
			drawUnit.material = DepthMaterial.new();
			collector.addDrawUnit(drawUnit);
			return;
		}
		for(let material of this.materials){
			let drawUnit = drawUnitCache.getOut();
			drawUnit.material = material;
			collector.addDrawUnit(drawUnit);
		}
	}
	updateBoneMatrixList({worldTransform, boneList}){
		if(boneList == null){
			worldTransform.copyToArray(this.boneMatrixList);
			return;
		}
		let {boneMatrixList, subMesh:{boneData}} = this;
		for(let i=boneData.length-1; i>=0; --i){
			let boneID = boneData[i];
			boneList[boneID].worldTransform.copyToArray(boneMatrixList, i << 3);
		}
	}
}

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		mesh.subMeshList.map(subMesh => this.addChild(new SubMeshEntity(subMesh, mesh.formatList)));
		if(!(createSkeleton && mesh.boneList.length > 0)){
			return;
		}
		let boneDict = new Map();
		let boneList = [];
		for(let {boneName, boneID, bonePID} of mesh.boneList){
			let bone = new BoneObject(this, boneID);
			let boneParent = bonePID < 0 ? this : boneList[bonePID];
			boneParent.addChild(bone);
			boneDict[boneName] = bone;
			boneList[boneID] = bone;
		}
		this.boneDict = boneDict;
		this.boneList = boneList;
		this.animationList = mesh.animationList;
		//this.animation = this.animationList[88] || this.animationList[0];
		this.animation = this.animationList[1] || this.animationList[0];
		this.animationTime = 0;
		console.log(this.animationList);
	}

	onUpdate(timeElapsed){
		if(this.animation){
			this.animationTime += timeElapsed * 0.001;
			if(this.animationTime > this.animation.duration){
				this.animationTime = 0;
			}
		}
		super.onUpdate(timeElapsed);
	}

	shareSkeletonWith(target){
		this.skeleton = target;
	}

	getBoneEntity(name){
		return this.boneDict[name];
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		let boneEntity = this.getBoneEntity(boneName);
		if(clearOtherObjects){
			boneEntity.removeAllChildren();
		}
		if(target){
			boneEntity.addChild(target);
		}
	}

	unbindObjectToBone(boneName, target){
		let boneEntity = this.getBoneEntity(boneName);
		boneEntity.removeChild(target);
	}

	collectDrawUnits(collector, gl, mode){
		if(mode == DrawMode.Pick && !this.mouseEnabled){
			return;
		}
		super.collectDrawUnits(collector, gl, mode);
	}
}

module.exports = MeshEntity;