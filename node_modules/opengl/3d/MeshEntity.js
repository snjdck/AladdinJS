'use strict';

const Clock = require('../Clock');
const WebGL = require('../WebGL');
const DisplayObject3D = require("../DisplayObject3D");
const {MeshVertexArray} = require("../vertexarrays");
const {TextureMaterial, TextureHitTestMaterial, DepthMaterial} = require("../materials");
const BoneObject = require('./BoneObject');

function buildBoneTree(entity){
	const boneDict = Object.create(null);
	const boneList = [];
	const boneObjectList = [];
	for(let {boneName, boneID, bonePID} of entity.mesh.boneList){
		let boneParent = bonePID < 0 ? entity : boneList[bonePID];
		let bone = new BoneObject(boneParent, boneID);

		boneDict[boneName] = bone;
		boneList[boneID] = bone;
		boneObjectList.push(bone);

		if(bonePID >= 0){
			boneParent.addChild(bone);
		}else if(entity.rootBone){
			entity.rootBone.addSibling(bone);
		}else{
			entity.rootBone = bone;
		}
	}
	entity.boneDict = boneDict;
	entity.boneList = boneList;
	entity.boneObjectList = boneObjectList;
}

function createSubMeshEntity(subMesh){
	return {
		subMesh,
		visible: true,
		mouseEnabled: true,
		castShadow: false,
		vao: MeshVertexArray.new(subMesh),
		boneMatrixList: new Float32Array(Math.max(subMesh.boneData.length, 1) * 8),
	};
}

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.mesh = mesh;
		this.subEntityList = mesh.subMeshList.map(createSubMeshEntity);
		if(!(createSkeleton && mesh.boneList.length > 0))return;
		buildBoneTree(this);
		this.animationList = mesh.animationList;
		//this.animation = this.animationList[88] || this.animationList[0];
		this.animation = this.animationList[1] || this.animationList[0];
		this.animationTime = 0;
		this.timeChangedFlag = true;
		this.attachmentCount = 0;
	}

	set castShadow(value){
		this.subEntityList.forEach(entity => entity.castShadow = value);
	}

	updateAnimationAndBone(){
		const {animation, animationTime, boneObjectList} = this;
		if(animation){
			let {timeElapsed} = Clock;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(!boneObjectList)return;
		for(let i=0, n=boneObjectList.length; i<n; ++i){
			let bone = boneObjectList[i];
			animation.calcTransform(bone.id, animationTime, bone.transform);
			bone.transform.append(bone.parent.worldTransform, bone.worldTransform);
		}
	}

	collectDrawUnits(collector){
		const {subEntityList, boneDict} = this;
		const skeleton = this.skeleton || this;
		let needUpdateFlag = true;
		for(let i=0; i<subEntityList.length; ++i){
			const subEntity = subEntityList[i];
			if(!subEntity.visible)continue;
			if(subEntity.staticBound && collector.viewFrustum.canCull(subEntity.staticBound)){
				continue;
			}
			if(!subEntity.defaultMaterial){
				let texture = WebGL.textureMgr.fetch(subEntity.subMesh.texture);
				if(texture){
					subEntity.defaultMaterial = new TextureMaterial(texture);
					subEntity.hitTestMaterial = new TextureHitTestMaterial(texture);
				}
				continue;
			}
			if(needUpdateFlag){
				this.updateAnimationAndBone();
				needUpdateFlag = false;
			}

			if(!skeleton.boneList){
				skeleton.worldTransform.copyToArray(subEntity.boneMatrixList);
			}else{
				let {boneMatrixList, subMesh:{boneData}} = subEntity;
				for(let i=0, n=boneData.length; i<n; ++i){
					let bone = skeleton.boneList[boneData[i]];
					bone.worldTransform.copyToArray(boneMatrixList, i << 3);
				}
			}
			subEntity.material = subEntity.defaultMaterial;
			collector.addDrawUnit(subEntity);
		}
		if(this.attachmentCount == 0)return;
		const {attachmentDict} = this;
		for(let boneName in attachmentDict){
			let attachmentList = attachmentDict[boneName];
			if(!attachmentList)continue;
			const count = attachmentList.length;
			if(count == 0)continue;
			let bone = boneDict[boneName];
			if(needUpdateFlag){
				this.updateAnimationAndBone();
				needUpdateFlag = false;
			}
			for(let i=0; i<count; ++i){
				let attachment = attachmentList[i];
				attachment.transform = bone.worldTransform;
				attachment.collectDrawUnits(collector);
			}
		}
	}

	shareSkeletonWith(target){
		this.skeleton = target;
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		if(!(boneName in this.boneDict))return;
		if(!this.attachmentDict){
			this.attachmentDict = Object.create(null);
		}
		++this.attachmentCount;
		const list = this.attachmentDict[boneName];
		if(list == null){
			this.attachmentDict[boneName] = [target];
		}else if(clearOtherObjects){
			this.attachmentCount -= list.length;
			list[0] = target;
			list.length = 1;
		}else{
			list.push(target);
		}
	}

	unbindObjectToBone(boneName, target){
		if(!this.attachmentDict)return;
		const list = this.attachmentDict[boneName];
		if(!list || list.length == 0)return;
		const index = list.indexOf(target);
		if(index >= 0){
			list.splice(index, 1);
			--this.attachmentCount;
		}
	}
}

module.exports = MeshEntity;