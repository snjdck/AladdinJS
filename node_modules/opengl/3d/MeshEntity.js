'use strict';

const Clock = require('../Clock');
const WebGL = require('../WebGL');
const DisplayObject3D = require("../DisplayObject3D");
const {MeshVertexArray} = require("../vertexarrays");
const {TextureMaterial, TextureHitTestMaterial, DepthMaterial} = require("../materials");
const BoneObject = require('./BoneObject');

function buildBoneTree(entity){
	const boneDict = Object.create(null);
	const boneList = [];
	const boneObjectList = [];
	for(let {boneName, boneID, bonePID} of entity.mesh.boneList){
		let boneParent = bonePID < 0 ? entity : boneList[bonePID];
		let bone = new BoneObject(boneParent, boneID);

		boneDict[boneName] = bone;
		boneList[boneID] = bone;
		boneObjectList.push(bone);

		if(bonePID >= 0){
			boneParent.addChild(bone);
		}else if(entity.rootBone){
			entity.rootBone.addSibling(bone);
		}else{
			entity.rootBone = bone;
		}
	}
	entity.boneDict = boneDict;
	entity.boneList = boneList;
	entity.boneObjectList = boneObjectList;
}

class SubMeshEntity
{
	constructor(subMesh){
		this.visible = true;
		this.subMesh = subMesh;
		this.vao = MeshVertexArray.new(subMesh);
		this.boneMatrixList = new Float32Array(Math.max(subMesh.boneData.length, 1) * 8);
	}
}

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		this.attachmentDict = Object.create(null);
		this.mesh = mesh;
		this.subEntityList = mesh.subMeshList.map(subMesh => new SubMeshEntity(subMesh));
		if(!(createSkeleton && mesh.boneList.length > 0))return;
		buildBoneTree(this);
		this.animationList = mesh.animationList;
		//this.animation = this.animationList[88] || this.animationList[0];
		this.animation = this.animationList[1] || this.animationList[0];
		this.animationTime = 0;
		this.timeChangedFlag = true;
	}

	set castShadow(value){
		this.subEntityList.forEach(entity => entity.castShadow = value);
	}

	updateAnimationAndBone(){
		const {animation, animationTime, boneObjectList} = this;
		if(animation){
			let {timeElapsed} = Clock;
			this.animationTime += timeElapsed * 0.01;
			if(this.animationTime > animation.duration){
				this.animationTime = 0;
			}
		}
		if(!boneObjectList)return;
		for(let i=0, n=boneObjectList.length; i<n; ++i){
			let bone = boneObjectList[i];
			animation.calcTransform(bone.id, animationTime, bone.transform);
			bone.transform.append(bone.parent.worldTransform, bone.worldTransform);
		}
	}

	collectDrawUnits(collector){
		const {subEntityList, attachmentDict, boneDict} = this;
		const skeleton = this.skeleton || this;
		let needUpdateFlag = true;
		for(let i=0; i<subEntityList.length; ++i){
			const subEntity = subEntityList[i];
			if(!subEntity.visible)continue;
			if(subEntity.staticBound && collector.viewFrustum.canCull(subEntity.staticBound)){
				continue;
			}
			if(!subEntity.material){
				let texture = WebGL.textureMgr.fetch(subEntity.subMesh.texture);
				if(texture){
					subEntity.material = new TextureMaterial(texture);
					subEntity.hitTestMaterial = new TextureHitTestMaterial(texture);
				}
				continue;
			}
			if(needUpdateFlag){
				this.updateAnimationAndBone();
				needUpdateFlag = false;
			}

			if(!skeleton.boneList){
				skeleton.worldTransform.copyToArray(subEntity.boneMatrixList);
			}else{
				let {boneMatrixList, subMesh:{boneData}} = subEntity;
				for(let i=0, n=boneData.length; i<n; ++i){
					let bone = skeleton.boneList[boneData[i]];
					bone.worldTransform.copyToArray(boneMatrixList, i << 3);
				}
			}
			
			collector.addDrawUnit(subEntity);
		}
		for(let boneName in attachmentDict){
			let attachmentList = attachmentDict[boneName];
			if(!attachmentList || attachmentList.length == 0)continue;
			const count = attachmentList.length;
			if(count <= 0)continue;
			let bone = boneDict[boneName];
			if(needUpdateFlag){
				this.updateAnimationAndBone();
				needUpdateFlag = false;
			}
			for(let i=0; i<count; ++i){
				let attachment = attachmentList[i];
				attachment.transform = bone.worldTransform;
				attachment.collectDrawUnits(collector);
			}
		}
	}

	shareSkeletonWith(target){
		this.skeleton = target;
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		if(!(boneName in this.boneDict))return;
		const list = this.attachmentDict[boneName];

		if(clearOtherObjects && list && list.length > 0){
			list.length = 0;
		}

		if(list){
			list.push(target);
		}else{
			this.attachmentDict[boneName] = [target];
		}
	}

	unbindObjectToBone(boneName, target){
		const list = this.attachmentDict[boneName];
		if(!list || list.length <= 0)return;
		const index = list.indexOf(target);
		if(index >= 0)list.splice(index, 1);
	}
}

module.exports = MeshEntity;