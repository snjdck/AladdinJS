"use strict";

const WebGL = require('./WebGL');
const {VertexArray2D} = require("./vertexarrays");
const {UniformBuffer} = require("./uniformbuffers");
const {UniformBlockIndex} = require("./const");
const {batchDraw, RenderState, DrawMode} = require("./renderers");
const {ProgramName} = require('./const');

class Render2D
{
	constructor(){
		let {programMgr} = WebGL;
		const {MAX_UNIFORM_BLOCK_SIZE, MAX_VERTEX_UNIFORM_VECTORS} = programMgr;
		const MAX_2D_OBJECTS = Math.min(1024, MAX_UNIFORM_BLOCK_SIZE >> 5);
		programMgr.addShaderSourceDefine('MAX_2D_OBJECTS', MAX_2D_OBJECTS);
		this.vao = VertexArray2D.new(MAX_2D_OBJECTS);
		this.worldMatrixBuffer = new UniformBuffer(2, 0, MAX_VERTEX_UNIFORM_VECTORS);
		this.invalidateFlag = true;
		this.targetList = [];
		this.activeTexture = null;
		this.batchDraw = batchDraw.bind(this, MAX_2D_OBJECTS);
	}

	set mode(value){
		if(value == DrawMode.Pick){
			this.shader = ProgramName.shader2d_picking;
			this.renderState = RenderState.Pick2D;
		}else{
			this.shader = ProgramName.shader2d;
			this.renderState = RenderState.Normal2D;
		}
	}

	viewport(width, height){
		this.width = width;
		this.height = height;
	}

	invalidate(){
		this.invalidateFlag = true;
	}

	drawBegin(){
		const {gl, renderState, programMgr} = WebGL;
		const {vao,
			worldMatrixBuffer,
		} = this;

		let program = programMgr.useProgram(this.shader);
		this.address_screenMatrix = gl.getUniformLocation(program, 'screenMatrix');
		this.address_InstanceIDBase = gl.getUniformLocation(program, 'InstanceIDBase');

		worldMatrixBuffer.active(UniformBlockIndex.WorldMatrix_BLOCK);
		vao.active();
		renderState.merge(this.renderState);
	}

	drawBitmap(target){
		if(target.texture == null){
			this.targetList.push(target);
			return;
		}
		let texture = target.texture.getRawAsset();
		if(texture != this.activeTexture){
			this.submit();
		}
		this.targetList.push(target);
		this.activeTexture = texture;
	}

	submit(){
		if(this.targetList.length <= 0)return;
		if(this.invalidateFlag){
			this.drawBegin();
			this.invalidateFlag = false;
		}
		const {gl, profileMgr} = WebGL;
		const {targetList} = this;

		gl.bindTexture(gl.TEXTURE_2D, this.activeTexture);
		let drawCount = this.batchDraw(targetList);
		
		profileMgr.profile2d.drawCount += drawCount;
		profileMgr.profile2d.textureSwitchCount++;

		targetList.length = 0;
		this.activeTexture = null;
	}

	onPrepareBuffer(instanceCount){
		const {
			vao,
			worldMatrixBuffer,
		} = this;

		vao.allocBuffer(instanceCount);
		worldMatrixBuffer.alloc(instanceCount);
	}

	onUpdateBuffer(instance, index){
		const {worldTransform, texture, width, height, fgColor} = instance;

		const {
			vao,
			worldMatrixBuffer,
		} = this;

		worldTransform.copyToArray(worldMatrixBuffer.floatView, index << 3);
		if(texture){
			vao.updateBuffer(index, 0, ...texture.xyuvMul, ...texture.xyuvAdd, width, texture.width, height, texture.height, ...texture.scale9grid);
		}else{
			vao.updateBuffer(index, 0, 1, 1, 1, 1, 0, 0, 0, 0, width, width, height, height, 0, 0, 0, 0);
		}

		if(this.address_InstanceIDBase){
			let {gl, mouseMgr} = WebGL;
			if(index == 0){
				gl.uniform1i(this.address_InstanceIDBase, mouseMgr.nextPickID);
			}
			mouseMgr.pickRegister(instance);
		}
	}

	onUploadBufferAndDraw(instanceCount){
		const {gl} = WebGL;
		const {
			vao,
			worldMatrixBuffer,
			width,
			height,
		} = this;

		gl.uniform2f(this.address_screenMatrix, 2 / width, -2 / height);
		worldMatrixBuffer.upload(instanceCount);
		vao.uploadBuffer(instanceCount);

		vao.draw(instanceCount);
	}
}

module.exports = Render2D;