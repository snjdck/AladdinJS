'use strict';

const WebGL = require('./WebGL');
const {VertexArray2D} = require('./vertexarrays');
const {batchDraw, BitmapQueue, RenderState, DrawMode} = require('./renderers');
const {ProgramName} = require('./const');

class Render2D
{
	constructor(){
		let {programMgr} = WebGL;
		const {MAX_UNIFORM_BLOCK_SIZE} = programMgr;
		const MAX_2D_OBJECTS = Math.min(1024, MAX_UNIFORM_BLOCK_SIZE >> 5);
		this.vao = VertexArray2D.new(MAX_2D_OBJECTS);
		this.batchDraw = batchDraw.bind(this, MAX_2D_OBJECTS);
		this.bitmapQueue = new BitmapQueue();
	}

	viewport(width, height){
		this.width = width;
		this.height = height;
	}

	reset(mode){
		const {gl, renderState, programMgr} = WebGL;
		const {vao, width, height} = this;

		let program;

		if(mode == DrawMode.Pick){
			program = programMgr.useProgram(ProgramName.shader2d_picking);
			renderState.merge(RenderState.Pick2D);
			this.address_InstanceIDBase = program.address.InstanceIDBase;
		}else{
			program = programMgr.useProgram(ProgramName.shader2d);
			renderState.merge(RenderState.Normal2D);
			this.address_InstanceIDBase = null;
		}

		gl.uniform2f(program.address.screenWH, 2 / width, -2 / height);
		vao.active();
	}

	drawBitmap(target){
		this.bitmapQueue.add(target);
	}

	submit(){
		this.bitmapQueue.draw(this.batchDraw).clear();
	}

	onPrepareBuffer(instanceCount){
		const {vao} = this;
		vao.allocBuffer(instanceCount);
	}

	onUpdateBuffer(instance, index){
		const {worldTransform, texture, width, height, fgColor} = instance;

		const {vao} = this;

		worldTransform.copyToArray(tempList, 0, 3);
		if(texture){
			vao.updateBuffer(index, 0, ...tempList, ...texture.xyuvMul, ...texture.xyuvAdd, width, texture.width, height, texture.height, ...texture.scale9grid);
		}else{
			vao.updateBuffer(index, 0, ...tempList, 1, 1, 1, 1, 0, 0, 0, 0, width, width, height, height, 0, 0, 0, 0);
		}

		if(this.address_InstanceIDBase){
			let {gl, mouseMgr} = WebGL;
			if(index == 0){
				gl.uniform1i(this.address_InstanceIDBase, mouseMgr.nextPickID);
			}
			mouseMgr.pickRegister(instance);
		}
	}

	onUploadBufferAndDraw(instanceCount){
		const {vao} = this;
		vao.uploadBufferAndDraw(instanceCount);
	}
}

const tempList = new Float32Array(6);

module.exports = Render2D;
