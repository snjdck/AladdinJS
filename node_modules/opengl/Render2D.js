"use strict";

const WebGL = require('./WebGL');
const {VertexArray2D} = require("./vertexarrays");
const {UniformBuffer} = require("./uniformbuffers");
const {batchDraw, RenderState, DrawMode} = require("./renderers");

class Render2D
{
	constructor(){
		let {programMgr} = WebGL;
		this.vao = VertexArray2D.new();
		this.uniformBuffer = new UniformBuffer(7, 1, programMgr.MAX_VERTEX_UNIFORM_VECTORS);
		this.invalidateFlag = true;
		this.targetList = [];
		this.activeTexture = null;
	}

	set mode(value){
		let {programMgr} = WebGL;
		if(value == DrawMode.Pick){
			this.isPickMode = true;
			this.program = programMgr.fetch("shader2d&pick");
			this.renderState = RenderState.Pick2D;
		}else{
			this.isPickMode = false;
			this.program = programMgr.fetch("shader2d");
			this.renderState = RenderState.Normal2D;
		}
	}

	viewport(width, height){
		this.width = width;
		this.height = height;
		this.uniformBuffer.setFloats(0, 2 / width, -2 / height);
	}

	invalidate(){
		this.invalidateFlag = true;
	}

	drawBegin(){
		const {gl, renderState} = WebGL;
		const {vao, uniformBuffer} = this;

		gl.useProgram(this.program);

		uniformBuffer.active();
		vao.active();
		renderState.merge(this.renderState);
	}

	drawBitmap(target){
		if(target.texture == null){
			this.targetList.push(target);
			return;
		}
		let texture = target.texture.getRawAsset();
		if(texture != this.activeTexture){
			this.submit();
		}
		this.targetList.push(target);
		this.activeTexture = texture;
	}

	submit(){
		if(this.targetList.length <= 0)return;
		if(this.invalidateFlag){
			this.drawBegin();
			this.invalidateFlag = false;
		}
		const {gl, profileMgr} = WebGL;
		const {vao, uniformBuffer, targetList} = this;
		gl.bindTexture(gl.TEXTURE_2D, this.activeTexture);
		let drawCount = batchDraw(vao, uniformBuffer, targetList, this.updateUniform, this.isPickMode, 2);
		
		profileMgr.profile2d.drawCount += drawCount;
		profileMgr.profile2d.textureSwitchCount++;

		targetList.length = 0;
		this.activeTexture = null;
	}

	updateUniform(uniformBuffer, target, index){
		let offset = uniformBuffer.calcValueCount(index);
		const {worldTransform, texture, width, height, fgColor} = target;
		
		worldTransform.copyToArray(uniformBuffer.floatView, offset);
		if(texture){
			uniformBuffer.setFloatv(offset+8 , texture.xyuvMul);
			uniformBuffer.setFloatv(offset+12, texture.xyuvAdd);
			uniformBuffer.setFloatv(offset+20, texture.scale9grid);
			uniformBuffer.setFloats(offset+16, width, texture.width, height, texture.height);
		}else{
			uniformBuffer.setFloats(offset+8, 1, 1, 1, 1, 0, 0, 0, 0, width, width, height, height, 0, 0, 0, 0);
		}
		uniformBuffer.setFloats(offset+24, fgColor.r, fgColor.g, fgColor.b, fgColor.a);
	}
}

module.exports = Render2D;