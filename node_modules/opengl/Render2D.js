'use strict';

const WebGL = require('./WebGL');
const {VertexArray2D} = require('./vertexarrays');
const {batchDraw, BitmapQueue, RenderState, DrawMode} = require('./renderers');
const {ProgramName} = require('./const');

class Render2D
{
	constructor(){
		let {programMgr} = WebGL;
		const {MAX_UNIFORM_BLOCK_SIZE} = programMgr;
		const MAX_2D_OBJECTS = Math.min(1024, MAX_UNIFORM_BLOCK_SIZE >> 5);
		this.vao = VertexArray2D.new(MAX_2D_OBJECTS);
		this.batchDraw = batchDraw.bind(this, MAX_2D_OBJECTS);
		this.bitmapQueue = new BitmapQueue(v => v.texture.getRawAsset());
	}

	viewport(width, height){
		this.width = width;
		this.height = height;
	}

	reset(mode){
		const {gl, renderState, programMgr} = WebGL;
		const {vao, width, height} = this;

		let program;

		if(mode == DrawMode.Pick){
			program = programMgr.useProgram(ProgramName.shader2d_picking);
			renderState.merge(RenderState.Pick2D);
			this.address_InstanceIDBase = program.address.InstanceIDBase;
		}else{
			program = programMgr.useProgram(ProgramName.shader2d);
			renderState.merge(RenderState.Normal2D);
			this.address_InstanceIDBase = null;
		}

		gl.uniform2f(program.address.screenWH, 2 / width, -2 / height);
		vao.active();
	}

	drawBitmap(target){
		this.bitmapQueue.add(target);
	}

	submit(){
		this.bitmapQueue.draw(this.onDraw, this).clear();
		/*
		const {renderPassEncoder} = Vulkan;
		this.totalDrawCount = 0;
		this.bitmapQueue.draw(this.onDraw, this).clear();
		renderPassEncoder.endPass();
		*/
	}

	onDraw(instanceList){
		const {gl, profileMgr:{profile2d}} = WebGL;
		const texture = instanceList[0].texture.getRawAsset();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		profile2d.drawCount += this.batchDraw(instanceList);
		profile2d.textureSwitchCount++;
		/*
		const texture = instanceList[0].texture.getRawAsset();
		const {renderPassEncoder, textureBindGroupLayout, createTextureBindGroup} = Vulkan;
		renderPassEncoder.setBindGroup(0, createTextureBindGroup(textureBindGroupLayout, texture));
		this.batchDraw(instanceList);
		*/
	}

	onUpdateBufferBatch(instanceList, offset, instanceCount, batchIndex){
		const {vao} = this;
		if(batchIndex == 0)vao.allocBuffer(instanceCount);
		for(let i=0; i<instanceCount; ++i){
			const {worldTransform, texture, width, height, fgColor} = instanceList[offset+i];
			worldTransform.copyToArray(tempList, 0, 3);
			if(texture){
				vao.updateBuffer(i, 0, ...tempList, ...texture.xyuvMul, ...texture.xyuvAdd, width, texture.width, height, texture.height, ...texture.scale9grid);
			}else{
				vao.updateBuffer(i, 0, ...tempList, 1, 1, 1, 1, 0, 0, 0, 0, width, width, height, height, 0, 0, 0, 0);
			}
		}
		if(!this.address_InstanceIDBase)return;
		const {gl, mouseMgr} = WebGL;
		gl.uniform1i(this.address_InstanceIDBase, mouseMgr.nextPickID);
		mouseMgr.pickRegisterList(instanceList, offset, instanceCount);
		/*
		if(batchIndex == 0){
			this.vertexBufferData = new Float32Array(instanceFloatCount * instanceCount);
		}
		const {vertexBufferData} = this;
		for(let i=0; i<instanceCount; ++i){
			const {worldTransform, texture, width, height, fgColor} = instanceList[offset+i];
			worldTransform.copyToArray(tempList, 0, 3);
			const j = instanceFloatCount * i;
			vertexBufferData.set(tempList, j);
			if(texture){
				vertexBufferData.set(texture.xyuvMul, j+6);
				vertexBufferData.set(texture.xyuvAdd, j+10);
				vertexBufferData.set(texture.scale9grid, j+18);
				vertexBufferData[j+14] = width;
				vertexBufferData[j+15] = texture.width;
				vertexBufferData[j+16] = height;
				vertexBufferData[j+17] = texture.height;
			}else{
				vertexBufferData.set(allOne, j+6);
				vertexBufferData.set(allZero, j+10);
				vertexBufferData.set(allZero, j+18);
				vertexBufferData[j+14] = width;
				vertexBufferData[j+15] = width;
				vertexBufferData[j+16] = height;
				vertexBufferData[j+17] = height;
			}
		}
		return;
		if(!this.address_InstanceIDBase)return;
		const {gl, mouseMgr} = WebGL;
		gl.uniform1i(this.address_InstanceIDBase, mouseMgr.nextPickID);
		mouseMgr.pickRegisterList(instanceList, offset, instanceCount);
		*/
	}

	onUploadBufferAndDraw(instanceCount){
		const {vao} = this;
		vao.uploadBufferAndDraw(instanceCount);
		/*
		const {renderPassEncoder} = Vulkan;
		renderPassEncoder.drawIndexed(triangleCount, instanceCount, 0, 0, this.totalDrawCount);
		this.totalDrawCount += instanceCount;
		*/
	}
}

const tempList = new Array(6);
const allZero = new Float32Array(4);
const allOne = new Float32Array(4).fill(1);

const instanceFloatCount = 22;
const instanceByteSize = instanceFloatCount << 2;

const vertexCountX = 4;
const vertexCountY = 4;
const triangleCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.

const vertexState = {
	indexFormat: 'uint16',
	vertexBuffers:[{
		arrayStride: instanceByteSize,
		stepMode: 'instance',
		attributes:[{
			shaderLocation: 0,
			offset: 0,
			format: 'float3'
		},{
			shaderLocation: 1,
			offset: 3 << 2,
			format: 'float3'
		},{
			shaderLocation: 2,
			offset: 6 << 2,
			format: 'float4'
		},{
			shaderLocation: 3,
			offset: 10 << 2,
			format: 'float4'
		},{
			shaderLocation: 4,
			offset: 14 << 2,
			format: 'float4'
		},{
			shaderLocation: 5,
			offset: 18 << 2,
			format: 'float4'
		}]
	}]
}

module.exports = Render2D;
