'use strict';

const WebGL = require('../WebGL');
const {TextureRenderTarget} = require('../rendertargets');
const {MaxRectsBinPack} = require('utils/MaxRectsBinPack');

const {DRAW_FRAMEBUFFER_BINDING, VIEWPORT} = WebGL2RenderingContext;
let width = 2048;
let height = 2048;

class Bitmap3DManager
{
	constructor(){
		this.rectPack = new MaxRectsBinPack(width, height);
		this.frameBuffer = new TextureRenderTarget(width, height);
		this.list = [];
	}

	reset(){
		this.rectPack.clear();
		this.list.length = 0;
	}

	register(bitmap3D){
		const {width, height} = bitmap3D;
		bitmap3D.drawRect = this.rectPack.insert(width, height);
		console.assert(bitmap3D.drawRect, 'no rect')
		this.list.push(bitmap3D);
	}

	draw(){
		if(this.list.length <= 0)return;
		const {frameBuffer, list} = this;
		const {gl, renderStateStack, textureMgr} = WebGL;
		renderStateStack.save(DRAW_FRAMEBUFFER_BINDING, VIEWPORT);
		frameBuffer.active();
		gl.clearBufferfv(gl.COLOR, 0, zero);
		gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);
		for(let bitmap3D of list){
			const {drawRect, camera, root3d} = bitmap3D;
			gl.viewport(drawRect.x, drawRect.y, drawRect.width, drawRect.height);
			camera.render(root3d);
			const texture = bitmap3D.texture;
			texture.rawTexture = frameBuffer.colorBuffer;
			texture.setUV(width, height, drawRect);
		}
		renderStateStack.load(DRAW_FRAMEBUFFER_BINDING, VIEWPORT);
	}
}

const zero = new Float32Array(4);

module.exports = Bitmap3DManager;
