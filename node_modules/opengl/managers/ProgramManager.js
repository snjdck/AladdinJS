"use strict";

const WebGL = require('../WebGL');
const {UniformBlockIndex, SamplerUniformIndex} = require('../const');
const {createGetter} = require('utils/cache');

class ProgramManager
{
	constructor(){
		this.calcWebGLInfo();
		this.programGetter = createGetter(this.newProgram);
		this.vsGetter = createGetter(this.createShader);
		this.fsGetter = createGetter(this.createShader);
	}

	useProgram(name){
		let program = this.programGetter(name);
		WebGL.gl.useProgram(program);
		if(this.needInitFlag){
			this.needInitFlag = false;
			this.calcProgramInfo(program, name);
		}
		return program;
	}

	newProgram(name){
		let [vn, fn] = name.split("&", 2);
		fn = fn || vn;
		return this.createProgram(`${vn}.vert`, `${fn}.frag`);
	}

	createProgram(vName, fName){
		let {gl} = WebGL;
		let program = gl.createProgram();
		gl.attachShader(program, this.vsGetter(vName, gl.VERTEX_SHADER));
		gl.attachShader(program, this.fsGetter(fName, gl.FRAGMENT_SHADER));
		gl.linkProgram(program);
		if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
			let info = gl.getProgramInfoLog(program);
			throw new Error(info);
		}
		this.needInitFlag = true;
		return program;
	}

	createShader(name, type){
		let {gl} = WebGL;
		let shader = gl.createShader(type);
		//gl.shaderSource(shader, source.replace(/^#version\s.+$/m, shaderHeader));
		gl.shaderSource(shader, loadSource(name));
		gl.compileShader(shader);
		if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
			let info = gl.getShaderInfoLog(shader);
			throw new Error(info);
		}
		return shader;
	}

	calcProgramInfo(program, name){
		let {gl} = WebGL;
		//program.name = name;
		const ACTIVE_ATTRIBUTES = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
		//console.log('----------------attr', name, ACTIVE_ATTRIBUTES)
		for(let i=0; i<ACTIVE_ATTRIBUTES; ++i){
			const info = gl.getActiveAttrib(program, i);
			//console.log(info)
		}
		const ACTIVE_UNIFORMS = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		console.log('----------------uniform', name, ACTIVE_UNIFORMS)
		for(let i=0; i<ACTIVE_UNIFORMS; ++i){
			const info = gl.getActiveUniform(program, i);
			//console.log(info)
			if(isSamplerUniform(info.type)){
				let location = gl.getUniformLocation(program, info.name);
				let oldIndex = gl.getUniform(program, location);
				let newIndex = SamplerUniformIndex[info.name];
				if(!Number.isInteger(newIndex))console.warn(`uniform sampler '${name}' should be Integer in SamplerUniformIndex.js!`);
				if(oldIndex == newIndex)continue;
				gl.uniform1i(location, newIndex);
			}
		}
		const ACTIVE_UNIFORM_BLOCKS = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
		for(let i=0; i<ACTIVE_UNIFORM_BLOCKS; ++i){
			let name = gl.getActiveUniformBlockName(program, i);
			let oldIndex = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_BINDING);
			let newIndex = UniformBlockIndex[name];
			if(!Number.isInteger(newIndex))console.warn(`uniform block '${name}' should be Integer in UniformBlockIndex.js!`);
			if(oldIndex == newIndex)continue;
			gl.uniformBlockBinding(program, i, newIndex);
		}
	}

	calcWebGLInfo(){
		let {gl} = WebGL;
		let keys = [//language: GLSL ES 3.00
			"MAX_RENDERBUFFER_SIZE",
			"MAX_TEXTURE_SIZE",
			"MAX_VERTEX_ATTRIBS",
			"MAX_VERTEX_UNIFORM_VECTORS",
			"MAX_FRAGMENT_UNIFORM_VECTORS",
			"MAX_VERTEX_TEXTURE_IMAGE_UNITS",
			"MAX_TEXTURE_IMAGE_UNITS",
			"MAX_VARYING_VECTORS",
			"MAX_DRAW_BUFFERS",
			"MAX_UNIFORM_BLOCK_SIZE",
			"MAX_UNIFORM_BUFFER_BINDINGS",
		];
		keys.forEach(key => this[key] = gl.getParameter(gl[key]));
		this.shaderHeader = "$&\n" + keys.map(key => `#define ${key} ${this[key]}`).join("\n");
		console.log(this.shaderHeader);
	}
}

const loadSource = function(){
	const fs = require('fs');
	let formatSourceName = path => 'shaders/' + (path.includes('.') ? path : path + '.glsl');
	let inlcudePattern = /^#include\s*<(.+)>$/gm;
	let includeReplaceFn = (_, v) => loadSource(v);
	return createGetter(
		path => fs.readFileSync(formatSourceName(path), 'utf8').replace(inlcudePattern, includeReplaceFn),
		formatSourceName
	);
}();

const isSamplerUniform = function(typeList){
	return type => typeList.includes(type);
}([
	'SAMPLER_2D',
	'SAMPLER_3D',
	'SAMPLER_CUBE',
	'SAMPLER_2D_SHADOW',
	'SAMPLER_2D_ARRAY',
	'SAMPLER_2D_ARRAY_SHADOW',
	'SAMPLER_CUBE_SHADOW',
	'INT_SAMPLER_2D',
	'INT_SAMPLER_3D',
	'INT_SAMPLER_CUBE',
	'INT_SAMPLER_2D_ARRAY',
	'UNSIGNED_INT_SAMPLER_2D',
	'UNSIGNED_INT_SAMPLER_3D',
	'UNSIGNED_INT_SAMPLER_CUBE',
	'UNSIGNED_INT_SAMPLER_2D_ARRAY',
].map(v => WebGL2RenderingContext[v]));

module.exports = ProgramManager;
