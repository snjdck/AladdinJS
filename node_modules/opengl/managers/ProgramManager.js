"use strict";

const WebGL = require('../WebGL');
const {UniformBlockIndex, SamplerUniformIndex, AttribIndex} = require('../const');
const {createGetter} = require('utils/cache');

class ProgramManager
{
	constructor(){
		this.calcWebGLInfo();
		this.programGetter = createGetter(this.newProgram);
		this.vsGetter = createGetter(this.createShader);
		this.fsGetter = createGetter(this.createShader);
		this.shaderSouceDefineDict = Object.create(null);
	}

	useProgram(name){
		let program = this.programGetter(name);
		WebGL.gl.useProgram(program);
		if(this.needInitFlag){
			this.needInitFlag = false;
			this.calcProgramInfo(program, name);
		}
		return program;
	}

	newProgram(name){
		return this.createProgram.apply(this, name.split(':'));
	}

	createProgram(vName, fName){
		let {gl} = WebGL;
		let program = gl.createProgram();
		gl.attachShader(program, this.vsGetter(vName, gl.VERTEX_SHADER));
		gl.attachShader(program, this.fsGetter(fName, gl.FRAGMENT_SHADER));
		gl.linkProgram(program);
		if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
			let info = gl.getProgramInfoLog(program);
			throw new Error(info);
		}
		this.needInitFlag = true;
		return program;
	}

	createShader(name, type){
		let index = name.indexOf('?');
		let source = '#version 300 es\n';
		if(index >= 0){
			source += genDefines(name.slice(index+1).split('&').map(v => v.split('=')));
			name = name.slice(0, index);
		}
		source += this.getShaderSourceDefineText();
		source += loadSource(name);
		if(type == WebGL2RenderingContext.VERTEX_SHADER){
			source = bindAttribLocation(source);
		}
		let {gl} = WebGL;
		let shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
			let info = gl.getShaderInfoLog(shader);
			throw new Error(info);
		}
		return shader;
	}

	calcProgramInfo(program, name){
		let {gl} = WebGL;
		const ACTIVE_ATTRIBUTES = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
		//console.log('----------------attribute', name, ACTIVE_ATTRIBUTES)
		for(let i=0; i<ACTIVE_ATTRIBUTES; ++i){
			const {name} = gl.getActiveAttrib(program, i);
			//console.log(i, name)
			if(name.indexOf('gl_') == 0)continue;
			let oldIndex = gl.getAttribLocation(program, name);
			let newIndex = AttribIndex[name];
			if(!Number.isInteger(newIndex))console.warn(`Attrib '${name}' should be Integer in AttribIndex.js!`);
			console.assert(oldIndex == newIndex);
		}
		const ACTIVE_UNIFORMS = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		//console.log('----------------uniform', name, ACTIVE_UNIFORMS)
		for(let i=0; i<ACTIVE_UNIFORMS; ++i){
			const {name, type} = gl.getActiveUniform(program, i);
			//console.log(i, name)
			if(isSamplerUniform(type)){
				let location = gl.getUniformLocation(program, name);
				let oldIndex = gl.getUniform(program, location);
				let newIndex = SamplerUniformIndex[name];
				if(!Number.isInteger(newIndex))console.warn(`uniform sampler '${name}' should be Integer in SamplerUniformIndex.js!`);
				if(oldIndex == newIndex)continue;
				gl.uniform1i(location, newIndex);
			}
		}
		const ACTIVE_UNIFORM_BLOCKS = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
		//console.log('----------------uniform block', name, ACTIVE_UNIFORM_BLOCKS)
		for(let i=0; i<ACTIVE_UNIFORM_BLOCKS; ++i){
			let name = gl.getActiveUniformBlockName(program, i);
			let oldIndex = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_BINDING);
			let newIndex = UniformBlockIndex[name];
			if(!Number.isInteger(newIndex))console.warn(`uniform block '${name}' should be Integer in UniformBlockIndex.js!`);
			if(oldIndex == newIndex)continue;
			gl.uniformBlockBinding(program, i, newIndex);
		}
	}

	calcWebGLInfo(){
		let {gl} = WebGL;
		let keys = [
			"MAX_VERTEX_ATTRIBS",				//gl_MaxVertexAttribs = 16
			"MAX_VERTEX_UNIFORM_VECTORS",		//gl_MaxVertexUniformVectors = 4096
			"MAX_FRAGMENT_UNIFORM_VECTORS",		//gl_MaxFragmentUniformVectors = 1024
			"MAX_VERTEX_TEXTURE_IMAGE_UNITS",	//gl_MaxVertexTextureImageUnits = 16
			"MAX_TEXTURE_IMAGE_UNITS",			//gl_MaxTextureImageUnits = 16
			"MAX_COMBINED_TEXTURE_IMAGE_UNITS",	//gl_MaxCombinedTextureImageUnits = 32(MAX_VERTEX_TEXTURE_IMAGE_UNITS + MAX_TEXTURE_IMAGE_UNITS)
			"MAX_VARYING_VECTORS",				//gl_MaxVertexOutputVectors = gl_MaxFragmentInputVectors = 30
			"MAX_DRAW_BUFFERS",					//gl_MaxDrawBuffers = 8
			"MAX_RENDERBUFFER_SIZE",			//=16384
			"MAX_TEXTURE_SIZE",					//=16384
			"MAX_UNIFORM_BLOCK_SIZE",			//=65536=4096x16(one register = four float = 16 byte)
			"MAX_VERTEX_UNIFORM_BLOCKS",		//=12
			"MAX_FRAGMENT_UNIFORM_BLOCKS",		//=12
			"MAX_UNIFORM_BUFFER_BINDINGS",		//=24(MAX_VERTEX_UNIFORM_BLOCKS + MAX_FRAGMENT_UNIFORM_BLOCKS)
		];
		keys.forEach(key => this[key] = gl.getParameter(gl[key]));
		console.log(keys.map(key => `#define ${key} ${this[key]}`).join("\n"));
	}

	addShaderSourceDefine(key, value){
		this.shaderSouceDefineDict[key] = value;
	}

	getShaderSourceDefineText(){
		return genDefines(Object.entries(this.shaderSouceDefineDict));
	}
}

const loadSource = function(){
	const fs = require('fs');
	let formatSourceName = path => 'shaders/' + (path.includes('.') ? path : path + '.glsl');
	let inlcudePattern = /^#include\s*<(.+)>$/gm;
	let includeReplaceFn = (_, v) => loadSource(v);
	return createGetter(
		path => fs.readFileSync(formatSourceName(path), 'utf8').replace(inlcudePattern, includeReplaceFn),
		formatSourceName
	);
}();

const genDefines = function(){
	const genDefine = ([k, v='']) => `#define ${k} ${v}\n`;
	return list => list.map(genDefine).join('');
}();

const bindAttribLocation = function(){
	const pattern = /^layout\s*\(\s*location\s*=\s*auto\s*\)([^;]+?)(\w+)\s*;/gm;
	function fn(_, prefix, name){
		let location = AttribIndex[name];
		return `layout(location=${location})${prefix}${name};`;
	}
	return v => v.replace(pattern, fn);
}();

const isSamplerUniform = function(typeList){
	return type => typeList.includes(type);
}([
	'SAMPLER_2D',
	'SAMPLER_3D',
	'SAMPLER_CUBE',
	'SAMPLER_2D_SHADOW',
	'SAMPLER_2D_ARRAY',
	'SAMPLER_2D_ARRAY_SHADOW',
	'SAMPLER_CUBE_SHADOW',
	'INT_SAMPLER_2D',
	'INT_SAMPLER_3D',
	'INT_SAMPLER_CUBE',
	'INT_SAMPLER_2D_ARRAY',
	'UNSIGNED_INT_SAMPLER_2D',
	'UNSIGNED_INT_SAMPLER_3D',
	'UNSIGNED_INT_SAMPLER_CUBE',
	'UNSIGNED_INT_SAMPLER_2D_ARRAY',
].map(v => WebGL2RenderingContext[v]));

module.exports = ProgramManager;
