"use strict";

const WebGL = require('../WebGL');
const UniformBlockIndex = require('../uniformbuffers/UniformBlockIndex');

class ProgramManager
{
	constructor(){
		let {gl} = WebGL;
		this.calcWebGLInfo(gl);
		this.gl = gl;
		this.programDict = Object.create(null);
		this.vsDict = Object.create(null);
		this.fsDict = Object.create(null);
	}

	fetch(name){
		return newCacheFunc(this.programDict, name, () => this.newProgram(name));
	}

	newProgram(name){
		let [vn, fn] = name.split("&", 2);
		fn = fn || vn;
		let program = this.createProgram(`${vn}.vert`, `${fn}.frag`);
		this.calcProgramInfo(program, name);
		this.bindUniformBlocks(program);
		return program;
	}

	createProgram(vName, fName){
		let {gl} = this;
		let program = gl.createProgram();
		gl.attachShader(program, this.newShader(vName, gl.VERTEX_SHADER));
		gl.attachShader(program, this.newShader(fName, gl.FRAGMENT_SHADER));
		gl.linkProgram(program);
		if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
			let info = gl.getProgramInfoLog(program);
			throw new Error(info);
		}
		return program;
	}

	newShader(name, type){
		let {vsDict, fsDict, gl} = this;
		let shaderDict = (type == gl.VERTEX_SHADER) ? vsDict : (type == gl.FRAGMENT_SHADER) ? fsDict : null;
		return newCacheFunc(shaderDict, name, () => this.createShader(loadSource(name), type));
	}

	createShader(source, type){
		let {gl} = this;
		let shader = gl.createShader(type);
		//gl.shaderSource(shader, source.replace(/^#version\s.+$/m, shaderHeader));
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
			let info = gl.getShaderInfoLog(shader);
			throw new Error(info);
		}
		return shader;
	}

	calcProgramInfo(program, name){
		let {gl} = this;
		program.name = name;
		for(let key of ["ACTIVE_ATTRIBUTES", "ACTIVE_UNIFORMS", "ACTIVE_UNIFORM_BLOCKS"]){
			program[key] = gl.getProgramParameter(program, gl[key]);
		}
		if(program.ACTIVE_UNIFORM_BLOCKS > 0){
			program.uniformBlockSizeList = new Array(program.ACTIVE_UNIFORM_BLOCKS).fill().map(
				(_, i) => gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE) / 16
			);
		}
	}

	calcWebGLInfo(gl){
		let keys = [//language: GLSL ES 3.00
			"MAX_RENDERBUFFER_SIZE",
			"MAX_TEXTURE_SIZE",
			"MAX_VERTEX_ATTRIBS",
			"MAX_VERTEX_UNIFORM_VECTORS",
			"MAX_FRAGMENT_UNIFORM_VECTORS",
			"MAX_VERTEX_TEXTURE_IMAGE_UNITS",
			"MAX_TEXTURE_IMAGE_UNITS",
			"MAX_VARYING_VECTORS",
			"MAX_DRAW_BUFFERS",
			"MAX_UNIFORM_BLOCK_SIZE",
			"MAX_UNIFORM_BUFFER_BINDINGS",
		];
		keys.forEach(key => this[key] = gl.getParameter(gl[key]));
		this.shaderHeader = "$&\n" + keys.map(key => `#define ${key} ${this[key]}`).join("\n");
		console.log(this.shaderHeader);
	}

	bindUniformBlocks(program){
		let {gl} = WebGL;
		let {MAX_UNIFORM_BUFFER_BINDINGS} = this;
		for(let [i, name] of UniformBlockIndex.ALL_NAMES.entries()){
			let index = gl.getUniformBlockIndex(program, name);
			if(index >= MAX_UNIFORM_BUFFER_BINDINGS)continue;
			gl.uniformBlockBinding(program, index, i);
		}
	}
}

const fs = require("fs");
const fileDict = Object.create(null);

function loadSource(path){
	if(!path.includes("."))
		path += ".glsl";
	path = `shaders/${path}`;
	let source = fileDict[path];
	if(source)return source;
	source = fs.readFileSync(path, "utf8");
	source = source.replace(/^#include\s*<(.+)>$/gm, function(){
		return loadSource(arguments[1]);
	});
	fileDict[path] = source;
	return source;
}

function newCacheFunc(dict, name, createFun){
	let value = dict[name];
	if(!value){
		dict[name] = value = createFun();
	}
	return value;
}

module.exports = ProgramManager;
