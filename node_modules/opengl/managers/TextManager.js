'use strict';

const WebGL = require('../WebGL');
const {Texture2D} = require('../textures');
const {MaxRectsBinPack, Rect} = require('utils/MaxRectsBinPack');

const width = 2048;
const height = 2048;

class TextManager
{
	constructor(){
		this.rectPack = new MaxRectsBinPack(width, height);
		this.fontDict = new Map();
		this.context = createCanvasContext();
		this.rawTexture = WebGL.createTexture(width, height);
		this.dirtyRectList = [];
	}

	getCharTexture2D(char, fontSize){
		const {rawTexture, fontDict, rectPack, context, dirtyRectList} = this;

		if(!fontDict.has(fontSize)){
			fontDict.set(fontSize, new Map());
		}

		const charDict = fontDict.get(fontSize);

		if(!charDict.has(char)){
			const textRect = calcTextRect(context, char);
			const packRect = rectPack.insert(textRect.width, textRect.height);
			charDict.set(char, {packRect, textRect});
			context.fillText(char, packRect.x + textRect.x, packRect.y + textRect.y);
			this.needUpdate = true;
			dirtyRectList.push(packRect);
		}

		const {packRect, textRect} = charDict.get(char);
		
		const texture = new Texture2D();
		const {xyuvMul, xyuvAdd} = texture;
		texture.rawTexture = rawTexture;
		texture.setUV(width, height, packRect, false);
		xyuvAdd[1] = fontSize - textRect.y;
		return texture;
	}

	needUpdate(text, fontSize){
		let list = text.split('').filter(v => /\S/.test(v));
		if(list.length <= 0)return false;
		const {fontDict} = this;
		if(!fontDict.has(fontSize))return true;
		const charDict = fontDict.get(fontSize);
		return !list.every(v => charDict.has(v));
	}

	*getTextBitmap(matrix, text, fontSize){
		this.context.font = `${fontSize}px 微软雅黑`;
		let offset = 0;
		for(let i=0; i<text.length; ++i){
			let char = text.charAt(i);
			let texture = this.getCharTexture2D(char, fontSize);
			const {packRect} = this.fontDict.get(fontSize).get(char);
			let worldTransform = matrix.clone();
			worldTransform.translate(offset, 0);
			offset += packRect.width;
			yield {
				width: packRect.width,
				height: packRect.height,
				worldTransform, texture
			};
		}
		if(this.needUpdate){
			const {gl} = WebGL;
			const {rawTexture, context, dirtyRectList} = this;
			const area = Rect.Merge(dirtyRectList);
			gl.bindTexture(gl.TEXTURE_2D, rawTexture);
			gl.texSubImage2D(gl.TEXTURE_2D, 0, area.x, area.y, area.width, area.height, gl.RGBA, gl.UNSIGNED_BYTE, context.canvas);
			this.needUpdate = false;
			dirtyRectList.length = 0;
		}
	}
}

function calcTextRect(context, char){
	let metrics = context.measureText(char);
	return {
		x: metrics.actualBoundingBoxLeft,
		y: metrics.actualBoundingBoxAscent,
		width: metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight,
		height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
	};
}

function createCanvasContext(){
	let canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;
	let context = canvas.getContext('2d');
	context.fillStyle = '#FFFFFF';
	context.strokeStyle = 'green';
	context.textBaseline = 'ideographic';//bottom,top
	/*
	canvas.setAttribute('style', 'position: absolute;left: 0;');
	document.body.appendChild(canvas)
	context.fillText("你好,world", 100, 30);
	//*/
	return context;
}

module.exports = TextManager;
