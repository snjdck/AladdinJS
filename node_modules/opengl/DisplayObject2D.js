"use strict";

const Transform2D = require("./Transform2D");
const {DrawMode} = require("./renderers");
const assert = require("assert");

class DisplayObject2D extends Transform2D
{
	constructor(){
		super();
		//Object.defineProperty(this, "_children", {value:[]});
		this.mouseEnabled = false;
		this.mouseChildren = true;
		this.visible = true;
		this.fgColor = {r:0, g:0, b:0, a:0};
	}

	isVisible(){
		return this.visible && super.isVisible();
	}

	set parent(value){
		value.addChild(this);
	}

	get root(){
		let target = this;
		while(target._parent)
			target = target._parent;
		return target;
	}

	get scene(){
		return this.root._scene;
	}

	onUpdate(){
		for(let child of this._children){
			if(child.isVisible()){
				child.onUpdate();
			}
		}
	}

	onDraw(mode){
		for(let child of this._children){
			if(child.isVisible()){
				child.draw(mode);
			}
		}
	}

	draw(mode){
		if(mode != DrawMode.Pick && this.filter){
			this.filter.draw(this);
		}else{
			this.onDraw(mode);
		}
	}

	forEach(fn){
		for(let child of this._children){
			if(child.isVisible()){
				child.forEach(fn);
			}
		}
		fn(this);
	}

	contains(child){
		return this.isDescendant(child);
	}

	swapSelfToTop(){
		this.parent.swapChildToTop(this);
	}
	
	swapSelfToBottom(){
		this.parent.swapChildToBottom(this);
	}

	onChildAdding(child, index){
		if(child.parent){
			if(child.parent === this){
				this.setChildIndex(child, Math.min(index, this.numChildren-1));
				return child;
			}
			child.parent.removeChild(child);
		}
	}

	onChildAdded(child){
		child._parent = this;
		child.markWorldMatrixDirty();
	}

	onChildRemoved(child){
		child._parent = null;
		child.markWorldMatrixDirty();
	}
}

module.exports = DisplayObject2D;