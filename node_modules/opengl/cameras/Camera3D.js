'use strict';

const WebGL = require('../WebGL');
const ViewFrustum = require('./ViewFrustum');
const Light3D = require("../lights/Light3D");
const DisplayObject3D = require("../DisplayObject3D");
const DrawUnitCollector = require("../DrawUnitCollector");
const {ScreenRenderTarget, DepthRenderTarget} = require("../rendertargets");
const {UniformBuffer, MvpUniformBuffer} = require("../uniformbuffers");
const {RenderState, DrawMode} = require("../renderers");
const {Nothing} = require("./ClearFlags");
const {delayNew} = require("utils/cache");
const {ProgramName} = require('../const');

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.viewFrustum = new ViewFrustum();
		this.drawUnitCollector = new DrawUnitCollector(this.viewFrustum);
		this.lens = lens;
		//camera can render to back buffer or frame buffer
		this.renderTarget = null;
		//multi cameras render order control
		this.depth = 0;
		this._rect = [0, 0, 1, 1];
		this._rectSetFlag = false;
		this.clearFlags = Nothing;

		this.mvpUniformBuffer = new MvpUniformBuffer();
	}

	get rect(){
		return this._rect;
	}

	set rect(value){
		this._rectSetFlag = true;
		this._rect = value;
	}

	drawDepthBuffer(drawUnitList){
		let {gl, render2d, renderQueue} = WebGL;
		if(!this.geomRenderTarget){
			this.geomRenderTarget = new ScreenRenderTarget(render2d.width, render2d.height);
		}
		this.geomRenderTarget.active();
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		renderQueue.draw(this, drawUnitList);
	}

	render(root, mode){
		const {gl, drawScreen, programMgr, renderState, renderQueue, renderStateStack} = WebGL;
		const {drawUnitCollector, renderTarget} = this;
		const {drawUnitList, lightList} = drawUnitCollector;

		this.viewFrustum.update(this);
		
		this.mvpUniformBuffer.update(this);
		this.mvpUniformBuffer.upload();

		if(renderTarget){
			renderTarget.active();
			gl.viewport(0, 0, renderTarget.width, renderTarget.height);
		}

		if(mode != DrawMode.Pick){//when pick, we will draw 2d objects first, so we can't clear exist color buffer info.
			this.clearFlags.call(gl);
		}

		if(this._rectSetFlag){
			const {drawingBufferWidth:bw, drawingBufferHeight:bh} = gl;
			const [rx, ry, rw, rh] = this.rect;
			gl.scissor(
				Math.max(0, 0.5 * bw * (1 - rw + rx)),
				Math.max(0, 0.5 * bh * (1 - rh + ry)),
				bw * rw, bh * rh
			);
		}

		drawUnitCollector.clear();
		const collectFn = (mode instanceof Function) ? mode : collectDrawUnits;
		traverseDisplayObjectTree(root, collectFn, drawUnitCollector);

		//console.log('drawUnitList', drawUnitList.length);

		if(lightList.length <= 0){//no lights
			if(this._rectSetFlag)gl.enable(gl.SCISSOR_TEST);
			renderQueue.draw(this, drawUnitList);
		}else{
			renderStateStack.save(gl.VIEWPORT, gl.DRAW_FRAMEBUFFER_BINDING);
			lightList.forEach(light => light.drawShadowMap(root));

			renderStateStack.load(gl.VIEWPORT);
			this.drawDepthBuffer(drawUnitList);

			renderStateStack.load(gl.DRAW_FRAMEBUFFER_BINDING);
			if(this._rectSetFlag)gl.enable(gl.SCISSOR_TEST);

			renderState.merge(RenderState.Pick2D);
			gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.colorBuffer);
			programMgr.useProgram(ProgramName.screen_quad);
			drawScreen();

			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.depthBuffer);
			gl.activeTexture(gl.TEXTURE0);

			renderState.merge(RenderState.Shadow);
			const uniformBuffer = getUniformBuffer();
			programMgr.useProgram(ProgramName.shadow);
			uniformBuffer.active();
			for(let {camera} of lightList){
				camera.worldTransformInvert.copyToArray(uniformBuffer.floatView, 16);
				uniformBuffer.setFloatv(0, camera.lens);
				uniformBuffer.upload();
				gl.bindTexture(gl.TEXTURE_2D, camera.renderTarget.depthBuffer);
				drawScreen();
			}
		}

		if(this._rectSetFlag)gl.disable(gl.SCISSOR_TEST);
	}

	renderPicking(){
		const {renderQueue} = WebGL;
		const {drawUnitList} = this.drawUnitCollector;
		for(let i=drawUnitList.length-1; i>=0; --i){
			let drawUnit = drawUnitList[i];
			if(drawUnit.mouseEnabled && drawUnit.hitTestMaterial){
				drawUnit.material = drawUnit.hitTestMaterial;
			}else{
				drawUnitList.splice(i, 1);
			}
		}
		renderQueue.draw(this, drawUnitList);
	}
}

const getUniformBuffer = delayNew(() => new UniformBuffer(6));

function collectDrawUnits(node){
	if(!node.visible)return true;
	if(node.collectDrawUnits){
		node.collectDrawUnits(this);
		return true;
	}
	if(node instanceof Light3D){
		this.addLight(node);
	}
}

const traverseDisplayObjectTree = function(){
	const queue = [];
	return function(root, handler, self){
		queue.push(root);
		while(queue.length > 0){
			let item = queue.pop();
			if(handler.call(self, item))continue;
			let children = item._children;
			if(children.length == 0)continue;
			queue.unshift.apply(queue, item._children);
		}
	}
}();

module.exports = Camera3D;