'use strict';

const WebGL = require('../WebGL');
const ViewFrustum = require('./ViewFrustum');
const Light3D = require("../lights/Light3D");
const {ScreenRenderTarget, DepthRenderTarget} = require("../rendertargets");
const {UniformBuffer, MvpUniformBuffer} = require("../uniformbuffers");
const {DrawUnitCollector, RenderState, DrawMode} = require("../renderers");
const {Nothing} = require("./ClearFlags");
const {delayNew} = require("utils/cache");
const traverseTree = require('utils/traverseTree');
const {ProgramName, UniformBlockIndex} = require('../const');
const Transform = require('../Transform');
const {Matrix3D, Vector3D} = require('../math');

class Camera3D extends Transform
{
	constructor(lens){
		super(Matrix3D);
		this.viewFrustum = new ViewFrustum();
		this.drawUnitCollector = new DrawUnitCollector(this.viewFrustum);
		this.lens = lens;
		//camera can render to back buffer or frame buffer
		this.renderTarget = null;
		//multi cameras render order control
		this.depth = 0;
		this._rect = [0, 0, 1, 1];
		this._rectSetFlag = false;
		this.clearFlags = Nothing;

		this.mvpUniformBuffer = new MvpUniformBuffer();
		this.cameraOffset = new Vector3D();
		this.cameraPosition = new Vector3D();
	}

	get worldX(){
		return this.cameraPosition.x;
	}

	get worldY(){
		return this.cameraPosition.y;
	}

	get worldZ(){
		return this.cameraPosition.z;
	}

	set worldX(value){
		const {transform, cameraOffset, cameraPosition} = this;
		cameraPosition.x = value;
		cameraPosition.add(cameraOffset, transform.translation);
		this.onTransformChanged();
	}

	set worldY(value){
		const {transform, cameraOffset, cameraPosition} = this;
		cameraPosition.y = value;
		cameraPosition.add(cameraOffset, transform.translation);
		this.onTransformChanged();
	}

	set worldZ(value){
		const {transform, cameraOffset, cameraPosition} = this;
		cameraPosition.z = value;
		cameraPosition.add(cameraOffset, transform.translation);
		this.onTransformChanged();
	}

	setOffset(value){
		const {transform, cameraOffset, cameraPosition} = this;
		cameraOffset.setTo(0, 0, value);
		transform.rotation.rotateVector(cameraOffset);
		cameraPosition.add(cameraOffset, transform.translation);
		this.onTransformChanged();
	}

	get rect(){
		return this._rect;
	}

	set rect(value){
		this._rectSetFlag = true;
		this._rect = value;
	}

	drawDepthBuffer(){
		let {gl, render2d} = WebGL;
		if(!this.geomRenderTarget){
			this.geomRenderTarget = new ScreenRenderTarget(render2d.width, render2d.height);
		}
		this.geomRenderTarget.active();
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		this.drawUnitCollector.draw();
	}

	render(root, mode){
		const {gl, drawScreen, programMgr, renderState, renderStateStack} = WebGL;
		const {drawUnitCollector, renderTarget} = this;
		const {drawUnitList, lightList} = drawUnitCollector;

		this.viewFrustum.update(this);
		
		this.mvpUniformBuffer.active(UniformBlockIndex.MVP_BLOCK);
		this.mvpUniformBuffer.update(this);
		this.mvpUniformBuffer.upload();

		if(renderTarget){
			renderTarget.active();
			gl.viewport(0, 0, renderTarget.width, renderTarget.height);
		}

		if(mode != DrawMode.Pick){//when pick, we will draw 2d objects first, so we can't clear exist color buffer info.
			this.clearFlags.call(gl);
		}

		if(this._rectSetFlag){
			const {drawingBufferWidth:bw, drawingBufferHeight:bh} = gl;
			const [rx, ry, rw, rh] = this.rect;
			gl.scissor(
				Math.max(0, 0.5 * bw * (1 - rw + rx)),
				Math.max(0, 0.5 * bh * (1 - rh + ry)),
				bw * rw, bh * rh
			);
		}

		drawUnitCollector.clear();
		const collectFn = (mode instanceof Function) ? mode : collectDrawUnits;
		traverseTree.call(drawUnitCollector, root, collectFn);

		//console.log('drawUnitList', drawUnitList.length);

		if(lightList.length <= 0){//no lights
			if(this._rectSetFlag)gl.enable(gl.SCISSOR_TEST);
			drawUnitCollector.draw();
		}else{
			renderStateStack.save(gl.VIEWPORT, gl.DRAW_FRAMEBUFFER_BINDING);
			lightList.forEach(light => light.drawShadowMap(root));

			renderStateStack.load(gl.VIEWPORT);
			this.drawDepthBuffer();

			renderStateStack.load(gl.DRAW_FRAMEBUFFER_BINDING);
			if(this._rectSetFlag)gl.enable(gl.SCISSOR_TEST);

			renderState.merge(RenderState.Pick2D);
			gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.colorBuffer);
			programMgr.useProgram(ProgramName.screen_quad);
			drawScreen();

			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.depthBuffer);
			gl.activeTexture(gl.TEXTURE0);

			renderState.merge(RenderState.Shadow);
			const uniformBuffer = getUniformBuffer();
			programMgr.useProgram(ProgramName.shadow);
			uniformBuffer.active();
			for(let {camera} of lightList){
				camera.worldTransformInvert.copyToArray(uniformBuffer.floatView, 16);
				uniformBuffer.setFloatv(0, camera.lens);
				uniformBuffer.upload();
				gl.bindTexture(gl.TEXTURE_2D, camera.renderTarget.depthBuffer);
				drawScreen();
			}
		}

		if(this._rectSetFlag)gl.disable(gl.SCISSOR_TEST);
	}

	renderPicking(){
		this.mvpUniformBuffer.active(UniformBlockIndex.MVP_BLOCK);
		this.drawUnitCollector.drawPicking();
	}
}

const getUniformBuffer = delayNew(() => new UniformBuffer(6));

function collectDrawUnits(node){
	if(!node.visible)return true;
	if(node.collectDrawUnits){
		node.collectDrawUnits(this);
		return true;
	}
	if(node instanceof Light3D){
		this.addLight(node);
	}
}

module.exports = Camera3D;