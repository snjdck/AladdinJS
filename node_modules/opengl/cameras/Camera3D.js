"use strict";

const WebGL = require('../WebGL');
const DisplayObject3D = require("../DisplayObject3D");
const DrawUnitCollector = require("../DrawUnitCollector");
const {ScreenRenderTarget, DepthRenderTarget} = require("../rendertargets");
const {UniformBuffer} = require("../uniformbuffers");
const {RenderState, DrawMode} = require("../renderers");
const {ShadowProgram} = require("../programs");

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.drawUnitCollector = new DrawUnitCollector();
		this.lens = lens;
		this.shadowProgram = ShadowProgram.new();
		//camera can render to back buffer or frame buffer
		this.randerTarget = null;
		//multi cameras render order control
		this.depth = 0;
		this.uniformBuffer = new UniformBuffer(4, 8, 128);
	}

	drawDepthBuffer(drawUnitList){
		let {gl, render2d, renderQueue} = WebGL;
		if(!this.geomRenderTarget){
			this.geomRenderTarget = new ScreenRenderTarget(render2d.width, render2d.height);
		}
		this.geomRenderTarget.active();
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		renderQueue.draw(this, drawUnitList);
	}

	render(root, mode){
		let {gl, util, programMgr, renderState, renderQueue, renderStateStack} = WebGL;
		let {drawUnitCollector, uniformBuffer} = this;
		let {drawUnitList, lightList} = drawUnitCollector;
		drawUnitCollector.clear();
		root.collectDrawUnits(drawUnitCollector, mode);

		if(lightList.length <= 0){//no lights
			renderQueue.draw(this, drawUnitList);
			return;
		}

		renderStateStack.save(gl.VIEWPORT, gl.FRAMEBUFFER_BINDING);
		lightList.forEach(light => light.drawShadowMap(root));

		renderStateStack.load(gl.VIEWPORT);
		this.drawDepthBuffer(drawUnitList);

		renderStateStack.load(gl.FRAMEBUFFER_BINDING);

		renderState.merge(RenderState.Pick2D);
		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.colorBuffer);
		gl.useProgram(programMgr.fetch("screen&normal"));
		util.drawScreen();

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.depthBuffer);
		gl.activeTexture(gl.TEXTURE0);

		renderState.merge(RenderState.Shadow);
		this.shadowProgram.active();
		this.worldTransform.copyToArray(uniformBuffer.floatView, 16);
		uniformBuffer.setFloatv(0, this.lens);
		uniformBuffer.active();
		for(let light of lightList){
			light.camera.worldTransformInvert.copyToArray(uniformBuffer.floatView, 24);
			uniformBuffer.setFloatv(32, light.camera.lens);
			uniformBuffer.upload();
			gl.bindTexture(gl.TEXTURE_2D, light.shadowRenderTarget.depthBuffer);
			util.drawScreen();
		}
	}
}

module.exports = Camera3D;