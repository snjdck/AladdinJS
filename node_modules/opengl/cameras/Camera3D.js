"use strict";

const WebGL = require('../WebGL');
const Light3D = require("../lights/Light3D");
const DisplayObject3D = require("../DisplayObject3D");
const DrawUnitCollector = require("../DrawUnitCollector");
const {ScreenRenderTarget, DepthRenderTarget} = require("../rendertargets");
const {UniformBuffer} = require("../uniformbuffers");
const {RenderState, DrawMode} = require("../renderers");
const {ShadowProgram} = require("../programs");
const {Nothing} = require("./ClearFlags");

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.drawUnitCollector = new DrawUnitCollector();
		this.lens = lens;
		this.shadowProgram = ShadowProgram.new();
		//camera can render to back buffer or frame buffer
		this.randerTarget = null;
		//multi cameras render order control
		this.depth = 0;
		this.uniformBuffer = new UniformBuffer(0, 13, 128);
		this._rect = [0, 0, 1, 1];
		this._rectDirtyFlag = false;
		this.clearFlags = Nothing;
	}

	get rect(){
		return this._rect;
	}

	set rect(value){
		this._rectDirtyFlag = true;
		this._rect = value;
	}

	drawDepthBuffer(drawUnitList){
		let {gl, render2d, renderQueue} = WebGL;
		if(!this.geomRenderTarget){
			this.geomRenderTarget = new ScreenRenderTarget(render2d.width, render2d.height);
		}
		this.geomRenderTarget.active();
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		renderQueue.draw(this, drawUnitList);
	}

	render(root, mode){
		let {gl, util, programMgr, renderState, renderQueue, renderStateStack} = WebGL;
		let {drawUnitCollector, uniformBuffer} = this;
		let {drawUnitList, lightList} = drawUnitCollector;

		this.clearFlags.call(gl);

		if(this._rectDirtyFlag){
			const {drawingBufferWidth:bw, drawingBufferHeight:bh} = gl;
			const [rx, ry, rw, rh] = this.rect;
			gl.scissor(
				Math.max(0, 0.5 * bw * (1 - rw + rx)),
				Math.max(0, 0.5 * bh * (1 - rh + ry)),
				bw * rw, bh * rh
			);
		}

		drawUnitCollector.clear();

		let collectFn = mode == DrawMode.Pick ? collectPickUnits : collectDrawUnits;

		root.forEach(collectFn, drawUnitCollector);

		if(lightList.length <= 0){//no lights
			if(this._rectDirtyFlag)gl.enable(gl.SCISSOR_TEST);
			renderQueue.draw(this, drawUnitList);
			if(this._rectDirtyFlag)gl.disable(gl.SCISSOR_TEST);
			return;
		}

		renderStateStack.save(gl.VIEWPORT, gl.FRAMEBUFFER_BINDING);
		lightList.forEach(light => light.drawShadowMap(root));

		renderStateStack.load(gl.VIEWPORT);
		this.drawDepthBuffer(drawUnitList);

		renderStateStack.load(gl.FRAMEBUFFER_BINDING);
		if(this._rectDirtyFlag)gl.enable(gl.SCISSOR_TEST);

		renderState.merge(RenderState.Pick2D);
		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.colorBuffer);
		gl.useProgram(programMgr.fetch("screen&normal"));
		util.drawScreen();

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.depthBuffer);
		gl.activeTexture(gl.TEXTURE0);

		renderState.merge(RenderState.Shadow);
		this.shadowProgram.active();
		this.worldTransform.copyToArray(uniformBuffer.floatView, 16);
		uniformBuffer.setFloatv(0, this.lens);
		uniformBuffer.setFloatv(48, this.rect);
		uniformBuffer.active();
		for(let light of lightList){
			light.camera.worldTransformInvert.copyToArray(uniformBuffer.floatView, 24);
			uniformBuffer.setFloatv(32, light.camera.lens);
			uniformBuffer.upload();
			gl.bindTexture(gl.TEXTURE_2D, light.shadowRenderTarget.depthBuffer);
			util.drawScreen();
		}

		if(this._rectDirtyFlag)gl.disable(gl.SCISSOR_TEST);
	}
}

function collectPickUnits(node){
	if(node.mouseEnabled && node.drawUnitCache && node.hitTestMaterial){
		let drawUnit = node.drawUnitCache.getOut();
		drawUnit.material = node.hitTestMaterial;
		this.addDrawUnit(drawUnit);
	}
}

function collectDrawUnits(node){
	if(!node.isVisible())return;
	if(node instanceof Light3D){
		this.addLight(node);
		return;
	}
	if(node.collectDrawUnits){
		node.collectDrawUnits(this);
	}
}

module.exports = Camera3D;