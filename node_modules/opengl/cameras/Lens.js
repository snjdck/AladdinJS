"use strict";

/**
column 1 -> register x
column 2 -> register y
column 3 -> register z
column 4 -> register w
*/
function OrthoLH(width, height, zNear, zFar){
	let matrix = new Float32Array(16);
	matrix[ 0] = 2 / width;
	matrix[ 5] = 2 / height;
	matrix[10] = 2 / (zFar - zNear);
	matrix[14] = (zNear + zFar) / (zNear - zFar);
	matrix[15] = 1;
	return matrix;
}

function ResizeOrthoLH(matrix, width, height){
	matrix[0] = 2 / width;
	matrix[5] = 2 / height;
}

/**
 * @param fieldOfViewY 视野范围(弧度)
 * @param aspectRatio 高宽比(3/4, 9/16)
 */		
function PerspectiveFieldOfViewLH(fieldOfViewY, aspectRatio, zNear, zFar){
	let yScale = 1 / Math.tan(fieldOfViewY * 0.5);
	let xScale = yScale * aspectRatio;

	let matrix = new Float32Array(16);
	matrix[ 0] = xScale;
	matrix[ 5] = yScale;
	matrix[10] = (zFar + zNear) / (zFar - zNear);
	matrix[14] = (zFar * zNear) / (zNear - zFar) * 2;
	matrix[11] = 1;
	return matrix;
}

function Invert(input){
	let matrix = new Float32Array(16);
	if(input[11] == 0){
		matrix[ 0] = 1 / input[ 0];
		matrix[ 5] = 1 / input[ 5];
		matrix[10] = 1 / input[10];
		matrix[14] = - matrix[10] * input[14];
		matrix[15] = 1;
	}else{
		matrix[ 0] = input[14] / input[0];
		matrix[ 5] = input[14] / input[5];
		matrix[14] = input[14];
		matrix[11] = 1;
		matrix[15] = - input[10];
	}
	return matrix;
}

module.exports = {
	OrthoLH,
	ResizeOrthoLH,
	PerspectiveFieldOfViewLH,
	Invert
};

/*
position (x, y, z, w=1)
if visible:
-w' < x' < w'
-w' < y' < w'
-w' < z' < w'


-w' < x'
=>
0 < w' + x' = (col4 dot p) + (col1 dot p) = col4 + col1
0 < w' - x' = col4 - col1

0 < w' + y' = col4 + col2
0 < w' - y' = col4 - col2

bool Plane::intersect(const Vector3 &bbMin, const Vector3 &bbMax)
{
	Vector3 min, max;
	Vector3 normal(a,b,c);
	if (normal.x >= 0.0f)
	{
		min.x = bbMin.x;
		max.x = bbMax.x;
	}
	else
	{
		min.x = bbMax.x;
		max.x = bbMin.x;
	}
	if (normal.y >= 0.0f)
	{
		min.y = bbMin.y;
		max.y = bbMax.y;
	}
	else
	{
		min.y = bbMax.y;
		max.y = bbMin.y;
	}
	if (normal.z >= 0.0f)
	{
		min.z = bbMin.z;
		max.z = bbMax.z;
	}
	if (distance(min) > 0.0f)
	{
		return false;
	}
	if (distance(max) >= 0.0f)
	{
		return true;
	}
	return false;



*/