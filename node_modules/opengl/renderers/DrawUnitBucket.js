'use strict';

const WebGL = require('../WebGL');
const ObjectBucket = require('ds/ObjectBucket');

class DrawUnitBucket extends ObjectBucket
{
	constructor(mapObjCache){
		super();
		this.mapObjCache = mapObjCache;
		this.regKeyFn(getMaterialType, updateMaterialType);
		this.regKeyFn(getRenderState, updateRenderState);
		this.regKeyFn(getTexture, updateTexture);
		this.regKeyFn(getVAO, updateVAO);
	}

	newMap(){
		return this.mapObjCache.getOut();
	}
}

function getMaterialType(drawUnit, key){
	let material = key ? drawUnit[key] : drawUnit.material;
	return material.constructor;
}

function getRenderState(drawUnit, key){
	let material = key ? drawUnit[key] : drawUnit.material;
	return material.renderState;
}

function getTexture(drawUnit, key){
	let material = key ? drawUnit[key] : drawUnit.material;
	return material.texture;
}

function getVAO(drawUnit){
	return drawUnit.vao;
}

const guard = (key, fn) => function(value){
	let oldValue = this.get(key);
	if(value == oldValue)return;
	this.set(key, value);
	fn.call(this, value, oldValue);
}

const updateShader = guard('shader', function(value){
	const {gl, programMgr, profileMgr} = WebGL;
	profileMgr.profile3d.shaderSwitchCount++;
	let program = programMgr.useProgram(value);
	this.set('program', program);
})

const updateMaterialType = guard('materialType', materialType => {
	const {gl, programMgr, profileMgr} = WebGL;
	profileMgr.profile3d.shaderSwitchCount++;
	const program = programMgr.useProgram(materialType.shader);
	materialType.address = program.address;
})

const updateRenderState = guard('renderState', value => {
	WebGL.profileMgr.profile3d.stateSwitchCount++;
	WebGL.renderState.merge(value);
})

const updateTexture = guard('texture', function(value){
	const {gl, profileMgr} = WebGL;
	let materialType = this.get('materialType');
	materialType.bindTexture(gl, value);
	profileMgr.profile3d.textureSwitchCount++;
})

const updateVAO = guard('vao', value => {
	WebGL.profileMgr.profile3d.vaoSwitchCount++;
	value.active();
})

module.exports = DrawUnitBucket;
