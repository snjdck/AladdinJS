'use strict';

const WebGL = require('../WebGL');
const {calcBitCount} = require('utils/math');

const {
	NEVER,
	ALWAYS,
	EQUAL,
	NOTEQUAL,
	LESS,
	GREATER,
	LEQUAL,
	GEQUAL,

	FUNC_ADD,
	FUNC_SUBTRACT,
	FUNC_REVERSE_SUBTRACT,
	MIN,
	MAX,

	ZERO,
	ONE,
	SRC_COLOR,
	ONE_MINUS_SRC_COLOR,
	DST_COLOR,
	ONE_MINUS_DST_COLOR,
	SRC_ALPHA,
	ONE_MINUS_SRC_ALPHA,
	DST_ALPHA,
	ONE_MINUS_DST_ALPHA,
	CONSTANT_COLOR,
	ONE_MINUS_CONSTANT_COLOR,
	CONSTANT_ALPHA,
	ONE_MINUS_CONSTANT_ALPHA,
	SRC_ALPHA_SATURATE,

} = WebGL2RenderingContext;



/*

15 * 15 * 5
gl.blendEquation(mode);
gl.FUNC_ADD
gl.FUNC_SUBTRACT source - dest
gl.FUNC_REVERSE_SUBTRACT dest - source
gl.MIN
gl.MAX

gl.blendFunc(sfactor, dfactor);
gl.ZERO
gl.ONE
gl.SRC_COLOR
gl.ONE_MINUS_SRC_COLOR
gl.DST_COLOR
gl.ONE_MINUS_DST_COLOR
gl.SRC_ALPHA
gl.ONE_MINUS_SRC_ALPHA
gl.DST_ALPHA
gl.ONE_MINUS_DST_ALPHA

gl.CONSTANT_COLOR
gl.ONE_MINUS_CONSTANT_COLOR
gl.CONSTANT_ALPHA
gl.ONE_MINUS_CONSTANT_ALPHA

gl.SRC_ALPHA_SATURATE	
min(AS, 1 - AD), min(AS, 1 - AD), min(AS, 1 - AD), 1

Multiplies the RGB colors by the smaller of either the source alpha value or the value of 1 minus the destination alpha value.
*/

class RenderState
{
	constructor(){
		this.blendEnabled = false;
		this.blendEquation = WebGLRenderingContext.FUNC_ADD;
		this.blendFuncSource = WebGLRenderingContext.ONE;
		this.blendFuncDest = WebGLRenderingContext.ZERO;

		this.depthTestEnabled = false;
		this.depthMask = true;
		this.depthFunc = WebGLRenderingContext.LESS;
	}

	load(){
		const {gl} = WebGL;

		this.blendEnabled = gl.isEnabled(gl.BLEND);
		this.blendEquation = gl.getParameter(gl.BLEND_EQUATION_RGB);
		this.blendFuncSource = gl.getParameter(gl.BLEND_SRC_RGB);
		this.blendFuncDest = gl.getParameter(gl.BLEND_DST_RGB);

		this.depthTestEnabled = gl.isEnabled(gl.DEPTH_TEST);
		this.depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
		this.depthFunc = gl.getParameter(gl.DEPTH_FUNC);

		return this;
	}

	isBlendFuncEqual(other){
		return this.blendFuncSource == other.blendFuncSource && this.blendFuncDest == other.blendFuncDest;
	}

	merge(other){
		if(this == other)return;
		const {gl} = WebGL;
		depthTestSet(gl, this, other);
		blendSet(gl, this, other);
		if(other.depthTestEnabled){
			depthMaskSet(gl, this, other);
			depthFuncSet(gl, this, other);
		}
		if(other.blendEnabled){
			blendEquationSet(gl, this, other);
			if(!this.isBlendFuncEqual(other)){
				this.blendFuncSource = other.blendFuncSource;
				this.blendFuncDest = other.blendFuncDest;
				gl.blendFunc(this.blendFuncSource, this.blendFuncDest);
			}
		}
	}

	isTransparent(){
		if(!this.blendEnabled)return false;
		if(this.blendFuncDest != ZERO)return true;
		const {blendFuncSource} = this;
		if(blendFuncSource == DST_COLOR)return true;
		if(blendFuncSource == DST_ALPHA)return true;
		if(blendFuncSource == ONE_MINUS_DST_COLOR)return true;
		if(blendFuncSource == ONE_MINUS_DST_ALPHA)return true;
		return false;
	}
}

const propSetFn = (key, updateFn) => (gl, source, dest) => {
	let v = dest[key];
	if(source[key] != v){
		source[key] = v;
		updateFn(gl, v);
	}
};

const blendSet = propSetFn("blendEnabled", (gl, v) => v ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND));
const blendEquationSet = propSetFn("blendEquation", (gl, v) => gl.blendEquation(v));

const depthTestSet = propSetFn("depthTestEnabled", (gl, v) => v ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST));
const depthMaskSet = propSetFn("depthMask", (gl, v) => gl.depthMask(v));
const depthFuncSet = propSetFn("depthFunc", (gl, v) => gl.depthFunc(v));

RenderState.get = function(){
	const depthFuncList = [NEVER,ALWAYS,EQUAL,NOTEQUAL,LESS,GREATER,LEQUAL,GEQUAL];
	const blendEquationList = [FUNC_ADD,FUNC_SUBTRACT,FUNC_REVERSE_SUBTRACT,MIN,MAX];
	const blendFuncList = [ZERO,ONE,SRC_COLOR,ONE_MINUS_SRC_COLOR,DST_COLOR,ONE_MINUS_DST_COLOR,SRC_ALPHA,ONE_MINUS_SRC_ALPHA,DST_ALPHA,ONE_MINUS_DST_ALPHA,CONSTANT_COLOR,ONE_MINUS_CONSTANT_COLOR,CONSTANT_ALPHA,ONE_MINUS_CONSTANT_ALPHA,SRC_ALPHA_SATURATE];

	const defaultBlend = {blendEnabled: false, blendEquation: FUNC_ADD, blendFuncSource: SRC_ALPHA, blendFuncDest: ONE_MINUS_SRC_ALPHA};
	const defaultDepth = {depthTestEnabled: false, depthMask: true, depthFunc: LEQUAL};
	const defaultState = Object.assign({}, defaultDepth, defaultBlend);

	const depthKeySize = calcBitCount(depthFuncList.length) + 2;
	const blendEquationSize = calcBitCount(blendEquationList.length);
	const blendFuncSize = calcBitCount(blendFuncList.length);

	function calcIndex(list, value){
		const index = list.indexOf(value);
		console.assert(index >= 0);
		return index;
	}

	const cache = new Map();
	const state = Object.create(null);

	return function(value){
		Object.assign(state, defaultState, value);
		let depthKey = 0;
		let blendKey = 0;
		if(state.depthTestEnabled){
			depthKey = 1;
			depthKey |= state.depthMask << 1;
			depthKey |= calcIndex(depthFuncList, state.depthFunc) << 2;
		}
		if(state.blendEnabled){
			blendKey = 1;
			blendKey |= calcIndex(blendEquationList, state.blendEquation) << 1;
			blendKey |= calcIndex(blendFuncList, state.blendFuncSource) << (blendEquationSize + 1);
			blendKey |= calcIndex(blendFuncList, state.blendFuncDest) << (blendFuncSize + blendEquationSize + 1);
		}
		const key = depthKey | blendKey << depthKeySize;
		if(cache.has(key))return cache.get(key);
		const result = Object.freeze(Object.assign(new RenderState(), state));
		cache.set(key, result);
		return result;
	}
}();

RenderState.Shadow = RenderState.get({
	blendEnabled: true,
	blendFuncSource: DST_COLOR,
	blendFuncDest: ZERO
});
RenderState.Normal2D = RenderState.get({blendEnabled: true});
RenderState.Pick2D = RenderState.get();

module.exports = RenderState;