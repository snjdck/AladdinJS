'use strict';

const DrawUnitBucketGroup = require('./DrawUnitBucketGroup');

class DrawUnitCollector
{
	constructor(viewFrustum){
		this.viewFrustum = viewFrustum;
		this.pickUnitList = [];
		this.lightList = [];
		this.bucketGroup = new DrawUnitBucketGroup();
	}

	clear(){
		this.pickUnitList.length = 0;
		this.lightList.length = 0;
		
		this.bucketGroup.clear();
	}

	addDrawUnit(drawUnit){
		this.bucketGroup.add(drawUnit);
		if(drawUnit.mouseEnabled && drawUnit.hitTestMaterial){
			this.pickUnitList.push(drawUnit);
		}
	}

	addLight(light){
		this.lightList.push(light);
	}

	draw(){
		this.bucketGroup.draw();
	}

	drawPicking(){
		const {bucketGroup, pickUnitList} = this;
		bucketGroup.clear();
		for(let i=0, n=pickUnitList.length; i<n; ++i){
			bucketGroup.add(pickUnitList[i], 'hitTestMaterial');
		}
		bucketGroup.draw();
	}
}
/*
const sortFn = (a, b) => a.drawIndex - b.drawIndex;
function calcBitCount(v){
	let n = 0;
	while(1 << n < v)++n;
	return n;
}
function addIfNotExist(map, k){
	if(!map.has(k)){
		map.set(k, map.size);
	}
}

		const {drawUnitList, transparentSet, shaderMap, textureMap, renderStateMap, vaoMap} = this;

		const shaderBits = calcBitCount(shaderMap.size);
		const textureBits = calcBitCount(textureMap.size);
		const renderStateBits = calcBitCount(renderStateMap.size);
		const vaoBits = calcBitCount(vaoMap.size);

		for(let i=0, n=drawUnitList.length; i<n; ++i){
			const drawUnit = drawUnitList[i];
			const {material} = drawUnit;
			let drawIndex = transparentSet == 3 && material.isTransparent() ? 1 : 0;
			drawIndex = drawIndex << shaderBits | shaderMap.get(material.shader);
			drawIndex = drawIndex << textureBits | textureMap.get(material.texture);
			drawIndex = drawIndex << renderStateBits | renderStateMap.get(material.renderState);
			drawIndex = drawIndex << vaoBits | vaoMap.get(drawUnit.vao);
			drawUnit.drawIndex = drawIndex;
		}

		drawUnitList.sort(sortFn);

		let curr_vao, curr_shader, curr_texture, curr_renderState;
		const {gl, programMgr, profileMgr} = WebGL;

		for(let i=0, n=drawUnitList.length; i<n;){
			const {vao, material:{shader, texture, renderState}, drawIndex} = drawUnitList[i];
			
			if(curr_shader != shader){
				curr_shader = shader;
				profileMgr.profile3d.shaderSwitchCount++;
				let program = programMgr.useProgram(shader);
				this.address_InstanceIDBase = gl.getUniformLocation(program, 'InstanceIDBase');
			}
			if(curr_texture != texture){
				curr_texture = texture;
				profileMgr.profile3d.textureSwitchCount++;
			}
			if(curr_renderState != renderState){
				curr_renderState = renderState;
				profileMgr.profile3d.stateSwitchCount++;
				WebGL.renderState.merge(renderState);
			}
			if(curr_vao != vao){
				curr_vao = vao;
				profileMgr.profile3d.vaoSwitchCount++;
				vao.active();
			}

			let toIndex = i + 1;
			while(toIndex < n && drawUnitList[toIndex].drawIndex == drawIndex)
				++toIndex;

			const drawCount = batchDraw.call(this, vao.maxCountPerDraw, drawUnitList, i, toIndex, vao);
			profileMgr.profile3d.drawCount += drawCount;
			i = toIndex;
		}
//*/
module.exports = DrawUnitCollector;
