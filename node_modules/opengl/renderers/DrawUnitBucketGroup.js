'use strict';

const WebGL = require('../WebGL');
const batchDraw = require('./batchDraw');
const ObjectCache = require('utils/ObjectCache');
const DrawUnitBucket = require('./DrawUnitBucket');

class DrawUnitBucketGroup
{
	constructor(){
		this.context = new Map();
		this.mapObjCache = new ObjectCache(() => new Map(), v => v.clear());
		//this.bucketOpaque = new DrawUnitBucket(this.mapObjCache);
		//this.bucketTransparent = new DrawUnitBucket(this.mapObjCache);
		this.bucket = new DrawUnitBucket(this.mapObjCache);
	}

	clear(){
		//this.bucketOpaque.clear();
		//this.bucketTransparent.clear();
		this.bucket.clear();
		this.mapObjCache.putAllIn();
		this.context.clear();
	}

	add(drawUnit, key){
		//let bucket = drawUnit.material.renderState.isTransparent() ? this.bucketTransparent : this.bucketOpaque;
		this.bucket.add(drawUnit, key);
	}

	get(key){
		return this.context.get(key);
	}

	set(key, value){
		this.context.set(key, value);
	}

	draw(){
		this.bucket.forEach(this.onDraw, this);
		//this.bucketOpaque.forEach(this.onDraw, this);
		//this.bucketTransparent.forEach(this.onDraw, this);
	}

	onDraw(drawUnitList){
		let vao = this.get('vao');
		const drawCount = batchDraw.call(this, vao.maxCountPerDraw, drawUnitList);
		WebGL.profileMgr.profile3d.drawCount += drawCount;
	}

	onUpdateBufferBatch(instanceList, offset, instanceCount, batchIndex){
		let materialType = this.get('materialType');
		materialType.onDrawBatch(instanceList, offset, instanceCount, batchIndex);

		let address_InstanceIDBase = materialType.address.InstanceIDBase;
		if(!address_InstanceIDBase)return;
		let {gl, mouseMgr} = WebGL;
		gl.uniform1i(address_InstanceIDBase, mouseMgr.nextPickID);
		mouseMgr.pickRegisterList(instanceList, offset, instanceCount);
	}

	onUploadBufferAndDraw(instanceCount){
		let vao = this.get('vao');
		vao.draw(instanceCount);
	}
}

module.exports = DrawUnitBucketGroup;
