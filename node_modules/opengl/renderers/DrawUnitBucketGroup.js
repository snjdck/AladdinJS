'use strict';

const WebGL = require('../WebGL');
const batchDraw = require('./batchDraw');
const ObjectCache = require('utils/ObjectCache');
const DrawUnitBucket = require('./DrawUnitBucket');

class DrawUnitBucketGroup
{
	constructor(){
		this.context = new Map();
		this.mapObjCache = new ObjectCache(Map, v => v.clear());
		this.bucketOpaque = new DrawUnitBucket(this.mapObjCache);
		this.bucketTransparent = new DrawUnitBucket(this.mapObjCache);
	}

	clear(){
		this.bucketOpaque.clear();
		this.bucketTransparent.clear();
		this.mapObjCache.putAllIn();
		this.context.clear();
	}

	add(drawUnit){
		let bucket = drawUnit.material.isTransparent() ? this.bucketTransparent : this.bucketOpaque;
		bucket.add(drawUnit);
	}

	get(key){
		return this.context.get(key);
	}

	set(key, value){
		this.context.set(key, value);
	}

	draw(){
		this.bucketOpaque.forEach(this.onDraw, this);
		this.bucketTransparent.forEach(this.onDraw, this);
	}

	onDraw(drawUnitList){
		let vao = this.get('vao');
		const drawCount = batchDraw.call(this, vao.maxCountPerDraw, drawUnitList);
		WebGL.profileMgr.profile3d.drawCount += drawCount;
	}

	onUpdateBufferBatch(instanceList, offset, instanceCount, batchIndex){
		let {gl, mouseMgr} = WebGL;
		let address_InstanceIDBase = this.get('address_InstanceIDBase');

		if(address_InstanceIDBase){
			gl.uniform1i(address_InstanceIDBase, mouseMgr.nextPickID);
			for(let i=0; i<instanceCount; ++i){
				let instance = instanceList[offset+i];
				mouseMgr.pickRegister(instance);
			}
		}

		for(let i=0; i<instanceCount; ++i){
			let instance = instanceList[offset+i];
			instance.material.onDraw(instance, i, batchIndex);
		}
	}

	onUploadBufferAndDraw(instanceCount){
		let vao = this.get('vao');
		vao.draw(instanceCount);
	}
}

module.exports = DrawUnitBucketGroup;
