"use strict";

const WebGL = require('../WebGL');
const batchDraw = require('./batchDraw');
const switchTraverse = require('./switchTraverse');
const mat4 = require('../math/mat4');
const simd = require('../math/simd');
//const ObjectGroup = require("utils/ObjectGroup");
const ArrayKeyMap = require('ds/ArrayKeyMap');

const ObjectCache = require('utils/ObjectCache');

const UniformBlockIndex = require('../const/UniformBlockIndex');

const mapCache = new ObjectCache(Map, v => v.clear());

class DrawUnitGroup extends ArrayKeyMap
{
	constructor(){
		super(6);
	}

	newMap(){
		return mapCache.getOut();
	}

	add(drawUnit){
		let key = [];
		key[0] = drawUnit.material.isTransparent();
		key[1] = drawUnit.material.shader;
		key[2] = drawUnit.material.texture;
		key[3] = drawUnit.material.renderState;
		key[4] = drawUnit.vao;
		key[5] = drawUnit;
		this.set(key);
	}

	clear(){
		super.clear();
		mapCache.putAllIn();
	}
}

const temp1Data = new Float32Array(16);
//const temp2Data = new Float32Array(16);
//const temp3Data = new Float32Array(16);
//const planeList = new Float32Array(16);
//const sum = (a, b) => a + b;

class RenderQueue
{
	constructor(){
		this.drawUnitGroup = new DrawUnitGroup();
		this.switchTraverse = switchTraverse.bind(this, ['shader', 'texture', 'renderState', 'vao'], this.onDraw);
	}

	draw(camera, drawUnitList){
		if(drawUnitList.length <= 0){
			return;
		}
		

		camera.worldTransformInvert.rotation.toMatrix(temp1Data, camera.worldTransformInvert.translation);

		simd.floatView.set(temp1Data);
		simd.floatView.set(camera.lens, 16);
		simd.mat4_concat();
		simd.calc_planes();
		console.time('cull');

		let testResult = simd.calc(drawUnitList);

		console.timeEnd('cull')//4ms
		console.log('cull', testResult.length);//4106, 15fps
		//19 no bound
		//4106 4135 29
		//*/
		const {drawUnitGroup} = this;
		for(let index of testResult){
			drawUnitGroup.add(drawUnitList[index]);
		}

		//drawUnitList.forEach(drawUnitGroup.add, drawUnitGroup);

		//render(drawUnitGroup.map.get(false), camera);
		//render(drawUnitGroup.map.get(true) , camera);

		//render3d.uniformBuffer.active();
		camera.mvpUniformBuffer.active(UniformBlockIndex.MVP_BLOCK);

		let groupA = drawUnitGroup.map.get(false);
		let groupB = drawUnitGroup.map.get(true);

		if(groupA)this.switchTraverse(groupA);
		if(groupB)this.switchTraverse(groupB);

		drawUnitGroup.clear();
	}

	set shader(value){
		const {gl, programMgr, profileMgr} = WebGL;
		profileMgr.profile3d.shaderSwitchCount++;
		let program = programMgr.useProgram(value);
		this.address_InstanceIDBase = gl.getUniformLocation(program, 'InstanceIDBase');
	}

	set texture(value){
		const {gl, profileMgr} = WebGL;
		profileMgr.profile3d.textureSwitchCount++;
		//gl.bindTexture(gl.TEXTURE_2D, value);
	}

	set renderState(value){
		const {profileMgr, renderState} = WebGL;
		profileMgr.profile3d.stateSwitchCount++;
		renderState.merge(value);
	}

	set vao(value){
		const {profileMgr} = WebGL;
		profileMgr.profile3d.vaoSwitchCount++;
		this._vao = value;
	}

	onDraw(drawUnitList){
		let {profileMgr} = WebGL;
		let drawCount = batchDraw.call(this, this._vao.maxCountPerDraw, drawUnitList);
		profileMgr.profile3d.drawCount += drawCount;
	}

	onPrepareBuffer(instanceCount){
		this._vao.active();
	}

	onUpdateBuffer(instance, index, batchIndex){
		instance.material.onDraw(instance, index, batchIndex);

		if(this.address_InstanceIDBase){
			let {gl, mouseMgr} = WebGL;
			if(index == 0){
				gl.uniform1i(this.address_InstanceIDBase, mouseMgr.nextPickID);
			}
			mouseMgr.pickRegister(instance);
		}
	}

	onUploadBufferAndDraw(instanceCount){
		this._vao.draw(instanceCount);
	}
}
/*
function render(rootDict, camera){
	if(!rootDict)return;
	const {gl, programMgr, profileMgr, renderState} = WebGL;
	for(let [shader, shaderDict] of rootDict){
		profileMgr.profile3d.shaderSwitchCount++;
		let program = programMgr.useProgram(shader);
		for(let [texture, textureDict] of shaderDict){
			profileMgr.profile3d.textureSwitchCount++;
			gl.bindTexture(gl.TEXTURE_2D, texture);
			for(let [state, materialDict] of textureDict){
				profileMgr.profile3d.stateSwitchCount++;
				renderState.merge(state);
				for(let [vao, vaoDict] of materialDict){
					let drawUnitList = Array.from(vaoDict.keys());
					if(drawUnitList.length <= 0)continue;
					profileMgr.profile3d.vaoSwitchCount++;
					vao.active();

					let drawUnit = drawUnitList[0];
					let {material} = drawUnit;

					if(program){
						material.onActiveUniform(camera, program);
						program = null;
					}
					material.onActiveVAO(drawUnit);
					material.draw(drawUnit, drawUnitList);
				}
			}
		}
	}
}
*/
module.exports = RenderQueue;
