"use strict";

const WebGL = require('../WebGL');
const batchDraw = require('./batchDraw');
const switchTraverse = require('./switchTraverse');
const mat4 = require('../math/mat4');
const simd = require('../math/simd');
//const ObjectGroup = require("utils/ObjectGroup");
const ArrayKeyMap = require('ds/ArrayKeyMap');

const ObjectCache = require('utils/ObjectCache');

const UniformBlockIndex = require('../const/UniformBlockIndex');

const mapCache = new ObjectCache(Map, v => v.clear());

class DrawUnitGroup extends ArrayKeyMap
{
	constructor(){
		super(6);
	}

	newMap(){
		return mapCache.getOut();
	}

	add(drawUnit){
		let key = [];
		key[0] = drawUnit.material.isTransparent();
		key[1] = drawUnit.material.shader;
		key[2] = drawUnit.material.texture;
		key[3] = drawUnit.material.renderState;
		key[4] = drawUnit.vao;
		key[5] = drawUnit;
		this.set(key);
	}

	clear(){
		super.clear();
		mapCache.putAllIn();
	}
}

const temp1Data = new Float32Array(16);
const temp2Data = new Float32Array(16);
const planeList = new Float32Array(16);
const sum = (a, b) => a + b;

class RenderQueue
{
	constructor(){
		this.drawUnitGroup = new DrawUnitGroup();
		this.switchTraverse = switchTraverse.bind(this, ['shader', 'texture', 'renderState', 'vao'], this.onDraw);
	}

	draw(camera, drawUnitList){
		if(drawUnitList.length <= 0){
			return;
		}

		camera.worldTransformInvert.rotation.toMatrix(temp1Data, camera.worldTransformInvert.translation);
		mat4.concat(temp1Data, camera.lens, temp2Data);

		let a0=temp2Data[3], b0=temp2Data[7], c0=temp2Data[11], d0=temp2Data[15];
		let a1=temp2Data[0], b1=temp2Data[4], c1=temp2Data[8], d1=temp2Data[12];
		let a2=temp2Data[1], b2=temp2Data[5], c2=temp2Data[9], d2=temp2Data[13];

		let list = [
			[a0-a1, b0-b1, c0-c1, d0-d1],
			[a0+a1, b0+b1, c0+c1, d0+d1],
			[a0-a2, b0-b2, c0-c2, d0-d2],
			[a0+a2, b0+b2, c0+c2, d0+d2]
		];
		planeList.set([a0-a1, b0-b1, c0-c1, d0-d1], 0);
		planeList.set([a0+a1, b0+b1, c0+c1, d0+d1], 4);
		planeList.set([a0-a2, b0-b2, c0-c2, d0-d2], 8);
		planeList.set([a0+a2, b0+b2, c0+c2, d0+d2], 12);
		//*
		console.time('cull');
		let idList = [];
		let totalCount = drawUnitList.length
		for(let i=drawUnitList.length-1 ; i>=0; --i){
			const {staticBound} = drawUnitList[i];
			if(!staticBound)continue;
			idList.push(i);
		}
		let boundList = [];
		for(let id of idList){
			boundList.push(drawUnitList[id].staticBound);
		}
		let testResult = simd.calc(planeList, boundList.length, boundList);
		let cullCount = testResult.reduce(sum, 0);

		for(let i=testResult.length-1 ; i>=0; --i){
			if(testResult[i]){
				drawUnitList.splice(idList[i], 1);
				//++cullCount;
			}
		}

		/*let cullCount = 0;
		for(let i=drawUnitList.length-1 ; i>=0; --i){
			const {staticBound} = drawUnitList[i];
			if(!staticBound)continue;
			if(simd.calc(planeList, 1, [staticBound])[0]){
				drawUnitList.splice(i, 1);
					++cullCount;
			}
			//staticBound.intersectPlane.apply(staticBound, list[0]);
			/*
			for(let plane of list){

				if(!staticBound.intersectPlane.apply(staticBound, plane)){
					drawUnitList.splice(i, 1);
					++cullCount;
					break;
				}
			}
			//*/
		//}
		console.timeEnd('cull')//4ms
		console.log('cull', cullCount, totalCount, boundList.length,
		testResult.length);//4106, 15fps
		//*/

		//let {render3d} = WebGL;
		let {drawUnitGroup} = this;

		drawUnitList.forEach(drawUnitGroup.add, drawUnitGroup);

		//render(drawUnitGroup.map.get(false), camera);
		//render(drawUnitGroup.map.get(true) , camera);

		//render3d.uniformBuffer.active();
		camera.mvpUniformBuffer.active(UniformBlockIndex.MVP_BLOCK);

		let groupA = drawUnitGroup.map.get(false);
		let groupB = drawUnitGroup.map.get(true);

		if(groupA)this.switchTraverse(groupA);
		if(groupB)this.switchTraverse(groupB);

		drawUnitGroup.clear();
	}

	set shader(value){
		const {gl, programMgr, profileMgr} = WebGL;
		profileMgr.profile3d.shaderSwitchCount++;
		let program = programMgr.useProgram(value);
		this.address_InstanceIDBase = gl.getUniformLocation(program, 'InstanceIDBase');
	}

	set texture(value){
		const {gl, profileMgr} = WebGL;
		profileMgr.profile3d.textureSwitchCount++;
		//gl.bindTexture(gl.TEXTURE_2D, value);
	}

	set renderState(value){
		const {profileMgr, renderState} = WebGL;
		profileMgr.profile3d.stateSwitchCount++;
		renderState.merge(value);
	}

	set vao(value){
		const {profileMgr} = WebGL;
		profileMgr.profile3d.vaoSwitchCount++;
		this._vao = value;
	}

	onDraw(drawUnitList){
		let {profileMgr} = WebGL;
		let drawCount = batchDraw.call(this, this._vao.maxCountPerDraw, drawUnitList);
		profileMgr.profile3d.drawCount += drawCount;
	}

	onPrepareBuffer(instanceCount){
		this._vao.active();
	}

	onUpdateBuffer(instance, index, batchIndex){
		instance.material.onDraw(instance, index, batchIndex);

		if(this.address_InstanceIDBase){
			let {gl, mouseMgr} = WebGL;
			if(index == 0){
				gl.uniform1i(this.address_InstanceIDBase, mouseMgr.nextPickID);
			}
			mouseMgr.pickRegister(instance);
		}
	}

	onUploadBufferAndDraw(instanceCount){
		this._vao.draw(instanceCount);
	}
}
/*
function render(rootDict, camera){
	if(!rootDict)return;
	const {gl, programMgr, profileMgr, renderState} = WebGL;
	for(let [shader, shaderDict] of rootDict){
		profileMgr.profile3d.shaderSwitchCount++;
		let program = programMgr.useProgram(shader);
		for(let [texture, textureDict] of shaderDict){
			profileMgr.profile3d.textureSwitchCount++;
			gl.bindTexture(gl.TEXTURE_2D, texture);
			for(let [state, materialDict] of textureDict){
				profileMgr.profile3d.stateSwitchCount++;
				renderState.merge(state);
				for(let [vao, vaoDict] of materialDict){
					let drawUnitList = Array.from(vaoDict.keys());
					if(drawUnitList.length <= 0)continue;
					profileMgr.profile3d.vaoSwitchCount++;
					vao.active();

					let drawUnit = drawUnitList[0];
					let {material} = drawUnit;

					if(program){
						material.onActiveUniform(camera, program);
						program = null;
					}
					material.onActiveVAO(drawUnit);
					material.draw(drawUnit, drawUnitList);
				}
			}
		}
	}
}
*/
module.exports = RenderQueue;
