"use strict";

const WebGL = require('../WebGL');
const batchDraw = require('./batchDraw');
const switchTraverse = require('./switchTraverse');
//const ObjectGroup = require("utils/ObjectGroup");
const ArrayKeyMap = require('ds/ArrayKeyMap');

const ObjectCache = require('utils/ObjectCache');

const UniformBlockIndex = require('../const/UniformBlockIndex');

const mapCache = new ObjectCache(Map, v => v.clear());

class DrawUnitGroup extends ArrayKeyMap
{
	constructor(){
		super(6);
	}

	newMap(){
		return mapCache.getOut();
	}

	add(drawUnit){
		let key = [];
		key[0] = drawUnit.material.isTransparent();
		key[1] = drawUnit.material.shader;
		key[2] = drawUnit.material.texture;
		key[3] = drawUnit.material.renderState;
		key[4] = drawUnit.vao;
		key[5] = drawUnit;
		this.set(key);
	}

	clear(){
		super.clear();
		mapCache.putAllIn();
	}
}

class RenderQueue
{
	constructor(){
		this.drawUnitGroup = new DrawUnitGroup();
		this.switchTraverse = switchTraverse.bind(this, ['shader', 'texture', 'renderState', 'vao'], this.onDraw);
	}

	draw(camera, drawUnitList){
		if(drawUnitList.length <= 0){
			return;
		}

		//let {render3d} = WebGL;
		let {drawUnitGroup} = this;

		drawUnitList.forEach(drawUnitGroup.add, drawUnitGroup);

		//render(drawUnitGroup.map.get(false), camera);
		//render(drawUnitGroup.map.get(true) , camera);

		//render3d.uniformBuffer.active();
		camera.mvpUniformBuffer.active(UniformBlockIndex.MVP_BLOCK);

		let groupA = drawUnitGroup.map.get(false);
		let groupB = drawUnitGroup.map.get(true);

		if(groupA)this.switchTraverse(groupA);
		if(groupB)this.switchTraverse(groupB);

		drawUnitGroup.clear();
	}

	set shader(value){
		const {gl, programMgr, profileMgr} = WebGL;
		profileMgr.profile3d.shaderSwitchCount++;
		let program = programMgr.useProgram(value);
		this.address_InstanceIDBase = gl.getUniformLocation(program, 'InstanceIDBase');
	}

	set texture(value){
		const {gl, profileMgr} = WebGL;
		profileMgr.profile3d.textureSwitchCount++;
		//gl.bindTexture(gl.TEXTURE_2D, value);
	}

	set renderState(value){
		const {profileMgr, renderState} = WebGL;
		profileMgr.profile3d.stateSwitchCount++;
		renderState.merge(value);
	}

	set vao(value){
		const {profileMgr} = WebGL;
		profileMgr.profile3d.vaoSwitchCount++;
		this._vao = value;
	}

	onDraw(drawUnitList){
		let {profileMgr} = WebGL;
		let drawCount = batchDraw.call(this, this._vao.maxCountPerDraw, drawUnitList);
		profileMgr.profile3d.drawCount += drawCount;
	}

	onPrepareBuffer(instanceCount){
		this._vao.active();
	}

	onUpdateBuffer(instance, index, batchIndex){
		instance.material.onDraw(instance, index, batchIndex);

		if(this.address_InstanceIDBase){
			let {gl, mouseMgr} = WebGL;
			if(index == 0){
				gl.uniform1i(this.address_InstanceIDBase, mouseMgr.nextPickID);
			}
			mouseMgr.pickRegister(instance);
		}
	}

	onUploadBufferAndDraw(instanceCount){
		this._vao.draw(instanceCount);
	}
}
/*
function render(rootDict, camera){
	if(!rootDict)return;
	const {gl, programMgr, profileMgr, renderState} = WebGL;
	for(let [shader, shaderDict] of rootDict){
		profileMgr.profile3d.shaderSwitchCount++;
		let program = programMgr.useProgram(shader);
		for(let [texture, textureDict] of shaderDict){
			profileMgr.profile3d.textureSwitchCount++;
			gl.bindTexture(gl.TEXTURE_2D, texture);
			for(let [state, materialDict] of textureDict){
				profileMgr.profile3d.stateSwitchCount++;
				renderState.merge(state);
				for(let [vao, vaoDict] of materialDict){
					let drawUnitList = Array.from(vaoDict.keys());
					if(drawUnitList.length <= 0)continue;
					profileMgr.profile3d.vaoSwitchCount++;
					vao.active();

					let drawUnit = drawUnitList[0];
					let {material} = drawUnit;

					if(program){
						material.onActiveUniform(camera, program);
						program = null;
					}
					material.onActiveVAO(drawUnit);
					material.draw(drawUnit, drawUnitList);
				}
			}
		}
	}
}
*/
module.exports = RenderQueue;
