function({m, a, b, n1, n2, n3}, i){
  let t = m * i / 4;
  return (Math.abs(Math.cos(t) / a) ** n2 + Math.abs(Math.sin(t) / b) ** n3) ** (-1 / n1);
}

Binding to the GL_FRAMEBUFFER target is equivalent to binding that framebuffer to both GL_DRAW_FRAMEBUFFER and GL_READ_FRAMEBUFFER.
Note that most other uses of GL_FRAMEBUFFER mean the draw framebuffer; this is the case when it means both.

https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext
https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL2RenderingContext

https://en.wikipedia.org/wiki/OpenGL_Shading_Language
https://www.khronos.org/registry/webgl/specs/latest/2.0/
https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object
https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview
https://www.khronos.org/opengl/wiki/Fragment#Fragment_discard

WebGL 1.0 => OpenGL ES 2.0 + GLSL ES 1.00(GLSL 1.20) = #version 100 es
WebGL 2.0 => OpenGL ES 3.0 + GLSL ES 3.00(GLSL 3.30) = #version 300 es

Only std140 layout is allowed in WebGL

绘制缓冲区
WebGLRenderingContext.clear()
WebGL2RenderingContext.vertexAttribDivisor()		Modifies the rate at which generic vertex attributes advance when rendering multiple instances of primitives with gl.drawArraysInstanced() and gl.drawElementsInstanced().default = 0, update per vertex,when > 0, update per n instance.
WebGL2RenderingContext.drawBuffers()				Specifies a list of color buffers to be drawn into.
WebGL2RenderingContext.clearBuffer[fiuv]()			Clears buffers from the currently bound framebuffer.

Uniform 和 Attribute
WebGLRenderingContext.getUniformLocation()
WebGL2RenderingContext.uniform[1234][f|i|ui][v]()
WebGLRenderingContext.uniformMatrix[234]fv()
WebGLRenderingContext.vertexAttrib[1234]f[v]()
WebGL2RenderingContext.vertexAttribI[iuv]()			Methods specifying integer values for generic vertex attributes.
WebGLRenderingContext.vertexAttribPointer()
WebGL2RenderingContext.vertexAttribIPointer()		Specifies integer data formats and locations of vertex attributes in a vertex attributes array.

纹理
WebGLRenderingContext.bindTexture()			bind to activeTexture unit, call order(activeTexture + bindTexture), default active texture unit is 0
WebGLRenderingContext.texParameterf()
WebGLRenderingContext.texParameteri()
WebGL2RenderingContext.texStorage2D()		Specifies all levels of two-dimensional texture storage.
WebGL2RenderingContext.texStorage3D()		Specifies all levels of a three-dimensional texture or two-dimensional array texture.
WebGLRenderingContext.texSubImage2D()
WebGL2RenderingContext.texSubImage3D()		Specifies a sub-rectangle of the current 3D texture.
WebGLRenderingContext.copyTexSubImage2D()
WebGL2RenderingContext.copyTexSubImage3D()	Copies pixels from the current WebGLFramebuffer into an existing 3D texture sub-image.

帧缓冲区
WebGLRenderingContext.readPixels()
WebGL2RenderingContext.blitFramebuffer()			将一个像素块从读取帧缓区冲传输到绘制帧缓冲区。
WebGL2RenderingContext.readBuffer()					选择一个颜色缓冲作为像素的source。

缓冲区
WebGLRenderingContext.bindBuffer()
WebGLRenderingContext.bufferData()
WebGLRenderingContext.bufferSubData()
WebGL2RenderingContext.copyBufferSubData()		将缓冲区的部分数据复制到另一个缓冲区。
WebGL2RenderingContext.getBufferSubData()		从缓冲区中读取数据，然后将其写入到 ArrayBuffer 或 SharedArrayBuffer 中。

状态信息
WebGLRenderingContext.activeTexture()			选择要激活的纹理单元。
WebGLRenderingContext.blendColor()				设置源和目标的混和因子。
WebGLRenderingContext.blendEquation()			用同一个表达式设置 RGB 混和表达式和 alpha 混和表达式。
WebGLRenderingContext.blendEquationSeparate()	分开设置 RGB 混和表达式和 alpha 混和表达式。
WebGLRenderingContext.blendFunc()				定义用于像素混合算法的函数。
WebGLRenderingContext.blendFuncSeparate()		分别定义混合像素RGB通道和透明通道的函数。
WebGLRenderingContext.clearColor()				设置用于清空用的颜色。
WebGLRenderingContext.clearDepth()				设置清除深度缓存时的深度值。
WebGLRenderingContext.clearStencil()			设置清除模板缓冲区时的模板值。
WebGLRenderingContext.colorMask()				设置在绘制或渲染WebGLFramebuffer时要开启或关闭的颜色分量。
WebGLRenderingContext.cullFace()				设置多边形的正面和/或反面是否要被排除。
WebGLRenderingContext.depthFunc()				设置比较输入像素深度和深度缓存值得函数。
WebGLRenderingContext.depthMask()				设置是否写入深度缓存。
WebGLRenderingContext.depthRange()				设置从规范化设备坐标映射到窗口或视口坐标时的深度范围。
WebGLRenderingContext.disable()					禁用这个上下文的WebGL功能。
WebGLRenderingContext.enable()					启用这个上下文的WebGL功能。
WebGLRenderingContext.frontFace()				设置多边形的正面使用顺时针还是逆时针绘制表示。
WebGLRenderingContext.getParameter()			返回给入参数名的值。
WebGLRenderingContext.getError()				返回错误信息。
WebGLRenderingContext.isEnabled()				测试这个上下文的WebGL功能是否开启。
WebGLRenderingContext.pixelStorei()				设置像素存储模式。
WebGLRenderingContext.polygonOffset()			设置多边形偏移的比例和单位，从而计算深度值。（补充：解决深度冲突）
WebGLRenderingContext.sampleCoverage()			为抗锯齿效果设置多重取样覆盖参数。
WebGLRenderingContext.stencilFunc()				同时设置前面和背面的模板测试函数，及其引用值。
WebGLRenderingContext.stencilFuncSeparate()		可分开设置前面或背面的模板测试函数，及其引用值。
WebGLRenderingContext.stencilMask()				同时启用或禁用，前面和背面的模板测试掩码。
WebGLRenderingContext.stencilMaskSeparate()		可分开启用或禁用，前面和背面的模板测试掩码。
WebGLRenderingContext.stencilOp()				同时设置，在前面和背面的模板缓冲区上执行的操作。
WebGLRenderingContext.stencilOpSeparate()		可分开设置，在前面和背面的模板缓冲区上执行的操作。

Uniform 缓冲对象
WebGL2RenderingContext.bindBufferBase()			Binds a given WebGLBuffer to a given binding point (target) at a given index.
WebGL2RenderingContext.bindBufferRange()		Binds a range of a given WebGLBuffer to a given binding point (target) at a given index.


matrix default is column_major, not row_major.

mat2 a 2×2 floating-point matrix
mat3 a 3×3 floating-point matrix
mat4 a 4×4 floating-point matrix
mat2x2 same as a mat2
mat2x3 a floating-point matrix with 2 columns and 3 rows
mat2x4 a floating-point matrix with 2 columns and 4 rows
mat3x2 a floating-point matrix with 3 columns and 2 rows
mat3x3 same as a mat3
mat3x4 a floating-point matrix with 3 columns and 4 rows
mat4x2 a floating-point matrix with 4 columns and 2 rows
mat4x3 a floating-point matrix with 4 columns and 3 rows
mat4x4 same as a mat4

vec3 v, u;
mat3 m;
u = v * m;
is equivalent to
u.x = dot(v, m[0]); // m[0] is the left column of m
u.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b
u.z = dot(v, m[2]);
And
u = m * v;
is equivalent to
u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;
u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;
u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;
And
mat3 m, n, r;
r = m * n;
is equivalent to
r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;
r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;
r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;
r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;
r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;
r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;
r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;
r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;
r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;
and similarly for other sizes of vectors and matrices.

Non-array attribute values
A vertex shader can read an attribute that is not currently enabled (via glEnableVertexAttribArray). The value that it gets is defined by special context state, which is *not* part of the VAO.

Because the attribute is defined by context state, it is constant over the course of a single draw call. Each attribute index has a separate value.

Warning: Every time you issue a drawing command with an array enabled, the corresponding context attribute values become undefined. So if you want to, for example, use the non-array attribute index 3 after previously using an array in index 3, you need to repeatedly reset it to a known value.




Normally, a discarded fragment will also not affect the current depth or stencil buffers. However, there are certain cases where such updates can occur, even for a discarded fragment.

If a fragment shader specifies that depth/stencil tests should happen before the shader, then this also means that the depth/stencil buffers will be updated before the shader (in accord with the Stencil Test operation and Write Masks). So with early fragment tests turned on, if the fragment shader explicitly discards the fragment, the depth and stencil buffers will have already been updated. This also means that Occlusion Query sample counts are updated even from such discarded fragments.

The other way is specific to the stencil buffer. If Stencil Testing is active, then discarded fragments can still affect the stencil buffer. The stencil test can modify the stencil buffer, even on a stencil or depth test failure. And since the stencil test happens before the depth test, the depth test failures cannot prevent the stencil test from updating the stencil buffer.

Outside of these cases, a discarded fragment will have no effects.


https://www.khronos.org/opengl/wiki/Depth_Test
When depth testing is disabled, writes to the depth buffer are also disabled.


MRT0：

RGB通道存储不受局部光源（点光源和聚光灯）影响的色彩值：自发光，以及环境贴图和平行光。
Alpha通道未使用。
MRT1：

RGB通道存储法线，用于SSAO。
Alpha通道存储深度，用于光照计算、体积雾、SSAO、位移（smart displacement）、景深、投影、边缘检测和厚度测量。
MRT2：

RGB通道存储漫反射，用于光照计算。
Alpha通道存储环境光遮蔽，如果SSAO启用，这个通道将被忽略。
MRT3：

RGB通道存储高光，用于光照计算。
Alpha通道未使用。
在星际2中重度使用了HDR（高动态范围），所以这些延迟缓存都是4通道16bit浮点格式，这样不仅可以回避精度问题，
还可以节省在片元着色器中为了解码缓存所需要的指令。同时，这也带来一个问题，因为API的限制，所有的缓存（渲染对象）都需要相同的精度，
所以最后输出的对象是每像素24个字节，浪费了大量带宽（不过在暴雪看来都是值得的）。



漫反射(Diffuse) + 高光 + 法线 + 深度

Diffuse R

Diffuse G

Diffuse B

Specular Level

-----

Normal.x

Normal.y

Gloss * sign(Normal.z)

Material ID

-----

R16(Depth)

G16(Reflection  Level等)
