function({m, a, b, n1, n2, n3}, i){
  let t = m * i / 4;
  return (Math.abs(Math.cos(t) / a) ** n2 + Math.abs(Math.sin(t) / b) ** n3) ** (-1 / n1);
}



matrix default is column_major, not row_major.

mat2 a 2×2 floating-point matrix
mat3 a 3×3 floating-point matrix
mat4 a 4×4 floating-point matrix
mat2x2 same as a mat2
mat2x3 a floating-point matrix with 2 columns and 3 rows
mat2x4 a floating-point matrix with 2 columns and 4 rows
mat3x2 a floating-point matrix with 3 columns and 2 rows
mat3x3 same as a mat3
mat3x4 a floating-point matrix with 3 columns and 4 rows
mat4x2 a floating-point matrix with 4 columns and 2 rows
mat4x3 a floating-point matrix with 4 columns and 3 rows
mat4x4 same as a mat4

vec3 v, u;
mat3 m;
u = v * m;
is equivalent to
u.x = dot(v, m[0]); // m[0] is the left column of m
u.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b
u.z = dot(v, m[2]);
And
u = m * v;
is equivalent to
u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;
u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;
u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;
And
mat3 m, n, r;
r = m * n;
is equivalent to
r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;
r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;
r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;
r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;
r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;
r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;
r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;
r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;
r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;
and similarly for other sizes of vectors and matrices.

Non-array attribute values
A vertex shader can read an attribute that is not currently enabled (via glEnableVertexAttribArray). The value that it gets is defined by special context state, which is *not* part of the VAO.

Because the attribute is defined by context state, it is constant over the course of a single draw call. Each attribute index has a separate value.

Warning: Every time you issue a drawing command with an array enabled, the corresponding context attribute values become undefined. So if you want to, for example, use the non-array attribute index 3 after previously using an array in index 3, you need to repeatedly reset it to a known value.




Normally, a discarded fragment will also not affect the current depth or stencil buffers. However, there are certain cases where such updates can occur, even for a discarded fragment.

If a fragment shader specifies that depth/stencil tests should happen before the shader, then this also means that the depth/stencil buffers will be updated before the shader (in accord with the Stencil Test operation and Write Masks). So with early fragment tests turned on, if the fragment shader explicitly discards the fragment, the depth and stencil buffers will have already been updated. This also means that Occlusion Query sample counts are updated even from such discarded fragments.

The other way is specific to the stencil buffer. If Stencil Testing is active, then discarded fragments can still affect the stencil buffer. The stencil test can modify the stencil buffer, even on a stencil or depth test failure. And since the stencil test happens before the depth test, the depth test failures cannot prevent the stencil test from updating the stencil buffer.

Outside of these cases, a discarded fragment will have no effects.


https://www.khronos.org/opengl/wiki/Depth_Test
When depth testing is disabled, writes to the depth buffer are also disabled.


MRT0：

RGB通道存储不受局部光源（点光源和聚光灯）影响的色彩值：自发光，以及环境贴图和平行光。
Alpha通道未使用。
MRT1：

RGB通道存储法线，用于SSAO。
Alpha通道存储深度，用于光照计算、体积雾、SSAO、位移（smart displacement）、景深、投影、边缘检测和厚度测量。
MRT2：

RGB通道存储漫反射，用于光照计算。
Alpha通道存储环境光遮蔽，如果SSAO启用，这个通道将被忽略。
MRT3：

RGB通道存储高光，用于光照计算。
Alpha通道未使用。
在星际2中重度使用了HDR（高动态范围），所以这些延迟缓存都是4通道16bit浮点格式，这样不仅可以回避精度问题，
还可以节省在片元着色器中为了解码缓存所需要的指令。同时，这也带来一个问题，因为API的限制，所有的缓存（渲染对象）都需要相同的精度，
所以最后输出的对象是每像素24个字节，浪费了大量带宽（不过在暴雪看来都是值得的）。



漫反射(Diffuse) + 高光 + 法线 + 深度

Diffuse R

Diffuse G

Diffuse B

Specular Level

-----

Normal.x

Normal.y

Gloss * sign(Normal.z)

Material ID

-----

R16(Depth)

G16(Reflection  Level等)
