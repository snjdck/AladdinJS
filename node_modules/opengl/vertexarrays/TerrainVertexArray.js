"use strict";

const WebGL = require('../WebGL');
const {createMeshIndices} = require('utils/geometry');
const VertexArray = require('./VertexArray');
const {AttribIndex} = require('../const');
const {decode, decodeBmp} = require('fileformats/images');
const fs = require('fs');

class TerrainVertexArray extends VertexArray
{
	constructor(){
		super();
		this.vertexCountX = vertexCountX;
		this.vertexCountY = vertexCountY;
	}

	onCreate(gl){
		let {getImageJpegData} = WebGL;

		const vertexDataLength = vertexCountX * vertexCountY * bytePerVertex;

		getImageJpegData('../assets/World1/TerrainLight.jpg').then(({data:lightData}) => {
			let heightData = decodeBmp(fs.readFileSync('./assets/World1/TerrainHeight.bmp')).data;
			let mapData = fs.readFileSync('./assets/World1/Terrain.map');
			let vertexData = new Uint8Array(vertexDataLength);
			for(let j=0; j<vertexCountY; ++j){
				for(let i=0; i<vertexCountX; ++i){
					let offset = j * vertexCountX + i;
					let vertexOffset = (i * vertexCountX + j) * bytePerVertex;
					vertexData[vertexOffset] = mapData[offset];
					vertexData[vertexOffset + 1] = mapData[offset + 65536];
					vertexData[vertexOffset + 2] = mapData[offset + 65536 * 2];
					offset = (vertexCountY - j - 1) * vertexCountX + i;
					vertexData[vertexOffset + 3] = heightData[offset];
					for(let k=0; k<4; ++k){
						vertexData[vertexOffset + 4 + k] = lightData[offset * 4 + k];
					}
				}
			}
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexData);
		});
		
		let indexData = new Uint16Array(createMeshIndices(vertexCountX, vertexCountY));
		
		super.onCreate(gl, vertexDataLength, indexData);

		gl.vertexAttribPointer(AttribIndex.map_layer, 2, gl.UNSIGNED_BYTE, false, bytePerVertex, 0);
		gl.vertexAttribPointer(AttribIndex.map_layermix_height, 2, gl.UNSIGNED_BYTE, true, bytePerVertex, 2);
		gl.vertexAttribPointer(AttribIndex.map_light, 4, gl.UNSIGNED_BYTE, true, bytePerVertex, 4);

		gl.enableVertexAttribArray(AttribIndex.map_layer);
		gl.enableVertexAttribArray(AttribIndex.map_layermix_height);
		gl.enableVertexAttribArray(AttribIndex.map_light);
	}

	draw(instanceCount){
		let {gl} = WebGL;
		gl.drawElements(gl.TRIANGLES, triangleCount, gl.UNSIGNED_SHORT, 0);
	}
}

const bytePerVertex = 8;
const vertexCountX = 256;
const vertexCountY = 256;
const triangleCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.

module.exports = TerrainVertexArray;
