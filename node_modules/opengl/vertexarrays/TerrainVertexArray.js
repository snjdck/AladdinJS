"use strict";

const WebGL = require('../WebGL');
const {createMeshIndices} = require('utils/geometry');
const VertexArray = require('./VertexArray');
const {AttribIndex} = require('../const');
const {decode, decodeBmp} = require('fileformats/images');
const fs = require('fs');

class TerrainVertexArray extends VertexArray
{
	constructor(){
		super();
		this.vertexCountX = vertexCountX;
		this.vertexCountY = vertexCountY;
	}

	onCreate(gl){
		let heightData = decodeBmp(fs.readFileSync('./assets/World1/TerrainHeight.bmp'));
		//let lightData = 

		let vertexData = new Float32Array(vertexCountX * vertexCountY * 4);

		let mapData = fs.readFileSync('./assets/World1/Terrain.map');
		for(let j=0; j<vertexCountY; ++j){
			for(let i=0; i<vertexCountX; ++i){
				let offset = j * vertexCountX + i;
				let vertexOffset = i * vertexCountX + j;
				vertexData[vertexOffset * 4] = mapData[offset];
				vertexData[vertexOffset * 4 + 1] = mapData[offset + 65536];
				vertexData[vertexOffset * 4 + 2] = mapData[offset + 65536 * 2] / 0xFF;
				vertexData[vertexOffset * 4 + 3] = heightData.data[offset] * 0.1;
			}
		}
		
		let indexData = new Uint16Array(createMeshIndices(vertexCountX, vertexCountY));
		
		super.onCreate(gl, vertexData, indexData);

		gl.vertexAttribPointer(AttribIndex.map_layer, 4, gl.FLOAT, false, 16, 0);
		gl.enableVertexAttribArray(AttribIndex.map_layer);
	}

	draw(instanceCount){
		let {gl} = WebGL;
		gl.drawElements(gl.TRIANGLES, triangleCount, gl.UNSIGNED_SHORT, 0);
	}
}

const vertexCountX = 256;
const vertexCountY = 256;
const triangleCount = (vertexCountX - 1) * (vertexCountY - 1) * 2 * 3;//exery rect has 2 triangle, every triangle has 3 index.

module.exports = TerrainVertexArray;
