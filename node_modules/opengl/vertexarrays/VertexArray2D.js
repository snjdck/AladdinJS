"use strict";

const WebGL = require('../WebGL');
const {createMeshIndices} = require('utils/geometry');
const VertexArray = require('./VertexArray');
const {AttribIndex} = require('../const');

class VertexArray2D extends VertexArray
{
	static new(maxInstanceCount){
		return new VertexArray2D(maxInstanceCount);
	}

	constructor(maxInstanceCount){
		super();
		this.maxInstanceCount = maxInstanceCount;
		this.instanceData = new Float32Array(instanceFloatCount);
	}

	onCreate(gl){
		/*let vertexData = new Float32Array([
			0, 0, 0, 0, 0, 0,
			0, 0, 1, 0, 0, 0,
			1, 0, 0,-1, 0, 0,
			1, 0, 0, 0, 0, 0,
			
			0, 0, 0, 0, 1, 0,
			0, 0, 1, 0, 1, 0,
			1, 0, 0,-1, 1, 0,
			1, 0, 0, 0, 1, 0,
			
			0, 1, 0, 0, 0,-1,
			0, 1, 1, 0, 0,-1,
			1, 1, 0,-1, 0,-1,
			1, 1, 0, 0, 0,-1,
			
			0, 1, 0, 0, 0, 0,
			0, 1, 1, 0, 0, 0,
			1, 1, 0,-1, 0, 0,
			1, 1, 0, 0, 0, 0
		]);*/
		let indexData = new Uint8Array(createMeshIndices(4, 4));
		
		super.onCreate(gl, null, indexData);

		this.vertexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, instanceByteSize * this.maxInstanceCount, gl.DYNAMIC_DRAW);

		gl.vertexAttribPointer(AttribIndex.worldMatrix, 3, gl.FLOAT, false, instanceByteSize, 0);
		gl.vertexAttribPointer(AttribIndex.worldMatrix+1, 3, gl.FLOAT, false, instanceByteSize, 3 << 2);
		gl.vertexAttribPointer(AttribIndex.textureMul, 4, gl.FLOAT, false, instanceByteSize, 6 << 2);
		gl.vertexAttribPointer(AttribIndex.textureAdd, 4, gl.FLOAT, false, instanceByteSize, 10 << 2);
		gl.vertexAttribPointer(AttribIndex.rectSize, 4, gl.FLOAT, false, instanceByteSize, 14 << 2);
		gl.vertexAttribPointer(AttribIndex.scale9grid, 4, gl.FLOAT, false, instanceByteSize, 18 << 2);

		gl.enableVertexAttribArray(AttribIndex.worldMatrix);
		gl.enableVertexAttribArray(AttribIndex.worldMatrix+1);
		gl.enableVertexAttribArray(AttribIndex.textureMul);
		gl.enableVertexAttribArray(AttribIndex.textureAdd);
		gl.enableVertexAttribArray(AttribIndex.rectSize);
		gl.enableVertexAttribArray(AttribIndex.scale9grid);

		gl.vertexAttribDivisor(AttribIndex.worldMatrix, 1);
		gl.vertexAttribDivisor(AttribIndex.worldMatrix+1, 1);
		gl.vertexAttribDivisor(AttribIndex.textureMul, 1);
		gl.vertexAttribDivisor(AttribIndex.textureAdd, 1);
		gl.vertexAttribDivisor(AttribIndex.rectSize, 1);
		gl.vertexAttribDivisor(AttribIndex.scale9grid, 1);
	}

	onActive(gl){
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	}

	allocBuffer(instanceCount){
		let size = instanceFloatCount * instanceCount;
		if(this.instanceData.length < size){
			this.instanceData = new Float32Array(size);
		}
	}

	updateBuffer(instanceIndex, offset, ...data){
		this.instanceData.set(data, instanceFloatCount * instanceIndex + offset);
	}

	uploadBufferAndDraw(instanceCount){
		let {gl} = WebGL;
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.instanceData, 0, instanceFloatCount * instanceCount);
		gl.drawElementsInstanced(gl.TRIANGLES, 54, gl.UNSIGNED_BYTE, 0, instanceCount);
	}
}

const instanceFloatCount = 22;
const instanceByteSize = instanceFloatCount << 2;

module.exports = VertexArray2D;