'use strict';

const DisplayObject3D = require('./DisplayObject3D');
const Camera3D = require('./cameras/Camera3D');
const Light3D = require('./lights/Light3D');
const traverseTree = require('utils/traverseTree');

class Scene3D
{
	constructor(){
		this.root = new DisplayObject3D();
		this.root._scene = this;
		this.cameraList = [];
		this.lightList = [];
		this.root.addListener('childAdded', this.onChildAdded.bind(this));
		this.root.addListener('childRemoved', this.onChildRemoved.bind(this));
	}

	onChildAdded(child){
		const {cameraList, lightList} = this;
		const cameraCount = cameraList.length;
		traverseTree.call(cameraList, child, collectCameras);
		traverseTree.call(lightList, child, collectLights);
		if(cameraList.length != cameraCount){
			cameraList.sort(sortCameras);
		}
	}

	onChildRemoved(child){
		const {cameraList, lightList} = this;
		traverseTree.call(cameraList, child, removeCameras);
		traverseTree.call(lightList, child, removeLights);
	}

	update(){
		//this.root.onUpdate();
	}

	draw(mode){
		const {root, cameraList} = this;
		for(let camera of cameraList){
			camera.render(root, mode);
		}
	}
}

const collectFn = type => function(node){
	if(node instanceof type){
		this.push(node);
	}
}

const removeFn = type => function(node){
	if(node instanceof type){
		let index = this.indexOf(node);
		if(index >= 0){
			this.splice(index, 1);
		}
	}
}

const collectCameras = collectFn(Camera3D);
const collectLights = collectFn(Light3D);
const removeCameras = removeFn(Camera3D);
const removeLights = removeFn(Light3D);

const sortCameras = (l, r) => l.depth - r.depth;

module.exports = Scene3D;
