"use strict";

const batchDraw = require("../renderers/batchDraw");
const WebGL = require('../WebGL');

class Material{
	constructor(shader){
		this.shader = shader;
		this.isPickMode = false;
		this.addressInstanceID = 0;
		this.context = new Context(this);
	}
	draw(context, drawUnitList){
		let {render3d, profileMgr} = WebGL;
		let {uniformBuffer} = render3d;
		let {vao} = context;
		this.context.vao = vao;
		uniformBuffer.registerCount = vao.boneCount;
		let drawCount = batchDraw.call(this.context, drawUnitList, uniformBuffer.maxInstanceCount);
		profileMgr.profile3d.drawCount += drawCount;
	}
	isTransparent(){return false;}
	onUpdate(){}
	onActiveUniform(camera, program){}
	onActiveVAO(drawUnit){}
	onDraw(uniformBuffer, drawUnit, index){}
}

class Context
{
	constructor(material){
		this.material = material;
	}

	onPrepareBuffer(instanceCount){
		let {render3d, profileMgr} = WebGL;
		let {uniformBuffer} = render3d;

		uniformBuffer.alloc(instanceCount);
	}

	onUpdateBuffer(instance, index){

		let {render3d, profileMgr, mouseMgr} = WebGL;
		let {uniformBuffer} = render3d;

		this.material.onDraw(uniformBuffer, instance, index);

		if(this.material.isPickMode){
			mouseMgr.pickRegister(instance);
		}
	}

	onUploadBuffer(instanceCount){
		let {render3d, profileMgr} = WebGL;
		let {uniformBuffer} = render3d;

		uniformBuffer.upload(instanceCount);
	}

	onDraw(instanceCount){
		this.vao.draw(instanceCount);
	}

	onBatchBegin(){
		if(!this.material.isPickMode)return;
		let {render3d, profileMgr, mouseMgr} = WebGL;
		let {uniformBuffer} = render3d;
		uniformBuffer.setInts(this.material.addressInstanceID, mouseMgr.nextPickID);
	}
}

module.exports = Material;