'use strict';

const WebGL = require('./WebGL');
const batchDraw = require('./renderers/batchDraw');

class DrawUnitCollector
{
	constructor(viewFrustum){
		this.viewFrustum = viewFrustum;
		this.drawUnitList = [];
		this.lightList = [];

		this.transparentSet = 0;
		this.shaderMap = new Map();
		this.textureMap = new Map();
		this.renderStateMap = new Map();
		this.vaoMap = new Map();
	}

	clear(){
		this.drawUnitList.length = 0;
		this.lightList.length = 0;
		return;
		this.transparentSet = 0;
		this.shaderMap.clear();
		this.textureMap.clear();
		this.renderStateMap.clear();
		this.vaoMap.clear();
	}

	addDrawUnit(drawUnit){
		this.drawUnitList.push(drawUnit);
		return;
		const {drawUnitList, shaderMap, textureMap, renderStateMap, vaoMap} = this;
		const {vao, material:{shader, texture, renderState}} = drawUnit;

		this.transparentSet |= 1 << drawUnit.material.isTransparent();
		addIfNotExist(shaderMap, shader);
		addIfNotExist(textureMap, texture);
		addIfNotExist(renderStateMap, renderState);
		addIfNotExist(vaoMap, vao);
	}

	addLight(light){
		this.lightList.push(light);
	}

	draw(){
		const {drawUnitList, transparentSet, shaderMap, textureMap, renderStateMap, vaoMap} = this;

		const shaderBits = calcBitCount(shaderMap.size);
		const textureBits = calcBitCount(textureMap.size);
		const renderStateBits = calcBitCount(renderStateMap.size);
		const vaoBits = calcBitCount(vaoMap.size);

		for(let i=0, n=drawUnitList.length; i<n; ++i){
			const drawUnit = drawUnitList[i];
			let drawIndex = transparentSet == 3 && drawUnit.material.isTransparent() ? 1 : 0;
			if(shaderBits){
				drawIndex <<= shaderBits;
				drawIndex |= shaderMap.get(drawUnit.material.shader);
			}
			if(textureBits){
				drawIndex <<= textureBits;
				drawIndex |= textureMap.get(drawUnit.material.texture);
			}
			if(renderStateBits){
				drawIndex <<= renderStateBits;
				drawIndex |= renderStateMap.get(drawUnit.material.renderState);
			}
			if(vaoBits){
				drawIndex <<= vaoBits;
				drawIndex |= vaoMap.get(drawUnit.vao);
			}
			drawUnit.drawIndex = drawIndex;
		}

		drawUnitList.sort(sortFn);

		let curr_vao, curr_shader, curr_texture, curr_renderState;
		const {gl, programMgr, profileMgr} = WebGL;

		for(let i=0, n=drawUnitList.length; i<n;){
			const {vao, material:{shader, texture, renderState}, drawIndex} = drawUnitList[i];
			
			if(curr_shader != shader){
				curr_shader = shader;
				profileMgr.profile3d.shaderSwitchCount++;
				let program = programMgr.useProgram(shader);
				this.address_InstanceIDBase = gl.getUniformLocation(program, 'InstanceIDBase');
			}
			if(curr_texture != texture){
				curr_texture = texture;
				profileMgr.profile3d.textureSwitchCount++;
			}
			if(curr_renderState != renderState){
				curr_renderState = renderState;
				profileMgr.profile3d.stateSwitchCount++;
				WebGL.renderState.merge(renderState);
			}
			if(curr_vao != vao){
				curr_vao = vao;
				profileMgr.profile3d.vaoSwitchCount++;
				vao.active();
			}

			let toIndex = i + 1;
			while(toIndex < n && drawUnitList[toIndex].drawIndex == drawIndex)
				++toIndex;

			const drawCount = batchDraw.call(this, vao.maxCountPerDraw, drawUnitList, i, toIndex, vao);
			profileMgr.profile3d.drawCount += drawCount;
			i = toIndex;
		}
	}

	onPrepareBuffer(instanceCount){}

	onUpdateBuffer(instance, index, batchIndex){
		instance.material.onDraw(instance, index, batchIndex);

		if(this.address_InstanceIDBase){
			let {gl, mouseMgr} = WebGL;
			if(index == 0){
				gl.uniform1i(this.address_InstanceIDBase, mouseMgr.nextPickID);
			}
			mouseMgr.pickRegister(instance);
		}
	}

	onUploadBufferAndDraw(instanceCount, vao){
		vao.draw(instanceCount);
	}
}

const sortFn = (a, b) => a.drawIndex - b.drawIndex;
function calcBitCount(v){
	let n = 0;
	while(1 << n < v)++n;
	return n;
}
function addIfNotExist(map, k){
	if(!map.has(k)){
		map.set(k, map.size);
	}
}

module.exports = DrawUnitCollector;