"use strict";

const WebGL = require('../WebGL');
const Filter2D = require("./Filter2D");

class BlurFilter extends Filter2D
{
	constructor(radius=4){
		super();
		this.shader = 'screen&filters/blur';
		this.radius = radius;
	}

	onDraw(image){
		let {gl, drawScreen, render2d, renderStateStack} = WebGL;
		const {program, radius} = this;
		let weight = calcWeight(radius);

		if(!this.addressSetFlag){
			this.addressSetFlag = true;
			let program = gl.getParameter(gl.CURRENT_PROGRAM);
			this.radiusAddress = gl.getUniformLocation(program, "radius");
			this.weightAddress = gl.getUniformLocation(program, "weight");
			this.offsetAddress = gl.getUniformLocation(program, "offset");
		}

		gl.uniform1i( this.radiusAddress, radius);
		gl.uniform1fv(this.weightAddress, weight);

		offset.length = radius << 1;
		offset.fill(0);
		let dx = 1 / render2d.width;
		let dy = 1 / render2d.height;

		let filterFrameBuffer = this.borrowFrameBuffer();
		gl.bindTexture(gl.TEXTURE_2D, image);

		for(let i=1; i<radius; ++i){
			offset[i*2] = i * dx;
		}
		gl.uniform2fv(this.offsetAddress, offset);
		drawScreen();

		renderStateStack.load(gl.DRAW_FRAMEBUFFER_BINDING);
		gl.bindTexture(gl.TEXTURE_2D, filterFrameBuffer.colorBuffer);
		
		for(let i=1; i<radius; ++i){
			offset[i*2] = 0;
			offset[i*2+1] = i * dy;
		}
		gl.uniform2fv(this.offsetAddress, offset);
		drawScreen();

		this.returnFrameBuffer(filterFrameBuffer);
	}
}

const offset = [];

const calcWeight = (function(){
	const c1 = Math.sqrt(2 * Math.PI);
	const list = [];
	return radius => {
		list.length = radius;
		const sigma = radius / 2.57;
		const deno =  1 / (sigma * c1);
		const nume = -1 / (sigma * sigma * 2);
		list[0] = deno;
		let sum = deno;
		for(let i=1; i<radius; ++i){
			let v = deno * Math.exp(nume * i * i);
			list[i] = v;
			sum += 2 * v;
		}
		let factor = 1 / sum;
		for(let i=0; i<radius; ++i){
			list[i] *= factor;
		}
		return list;
	};
})();

module.exports = BlurFilter;