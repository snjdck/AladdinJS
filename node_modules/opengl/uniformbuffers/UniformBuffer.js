"use strict";

const WebGL = require('../WebGL');
/*
const sum = (add => list => list.reduce(add, 0))((a, b) => a + b);

class UniformBuffer
{
	constructor(registerCount, baseDataCount, maxRegisterCount){
		Object.defineProperty(this, "maxRegisterCount", {value:maxRegisterCount-baseDataCount});
		Object.defineProperty(this, "baseDataCount", {value:baseDataCount});
		this.registerCount = registerCount;
		this.data = new ArrayBuffer(this.calcValueCount(1) << 2);
		this.floatView = new Float32Array(this.data);
		this.intView = new Int32Array(this.data);
	}

	get registerCount(){
		return this._registerCount;
	}

	set registerCount(value){
		value = Math.max(value >> 0, 1);
		this._registerCount = value;
		this._maxInstanceCount = Math.floor(this.maxRegisterCount / value);
	}

	get maxInstanceCount(){
		return this._maxInstanceCount;
	}

	active(index=0){
		let {gl} = WebGL;
		gl.bindBufferBase(gl.UNIFORM_BUFFER, index, this.createUniformBuffer(gl));
	}

	upload(instanceCount=1){
		let {gl} = WebGL;
		gl.bindBuffer(gl.UNIFORM_BUFFER, this.createUniformBuffer(gl));
		gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.floatView, 0, this.calcValueCount(instanceCount));
	}

	alloc(instanceCount){
		instanceCount = Math.min(instanceCount, this.maxInstanceCount);
		let valueCount = this.calcValueCount(instanceCount);
		if(valueCount <= this.intView.length){
			return;
		}
		let data = new ArrayBuffer(valueCount << 2);
		let intView = new Int32Array(data);
		if(this.baseDataCount > 0){
			intView.set(this.intView.subarray(0, this.baseDataCount << 2));
		}
		this.data = data;
		this.intView = intView;
		this.floatView = new Float32Array(data);
	}

	createUniformBuffer(gl){
		if(this.buffer)return this.buffer;
		let buffer = gl.createBuffer();
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
		gl.bufferData(gl.UNIFORM_BUFFER, gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS) << 4, gl.DYNAMIC_DRAW);
		this.buffer = buffer;
		return buffer;
	}

	calcValueCount(instanceCount){
		let {baseDataCount, registerCount} = this;
		return (baseDataCount + registerCount * instanceCount) << 2;
	}

	setInts(index, ...values){
		this.intView.set(values, index);
	}

	setIntv(index, values){
		this.intView.set(values, index);
	}

	setFloats(index, ...values){
		this.floatView.set(values, index);
	}

	setFloatv(index, values){
		this.floatView.set(values, index);
	}
}
*/
class UniformBuffer
{
	constructor(registerCount){
		this.data = new ArrayBuffer(registerCount << 4);
		this.floatView = new Float32Array(this.data);
		this.intView = new Int32Array(this.data);
	}

	active(index=0){
		let {gl} = WebGL;
		gl.bindBufferBase(gl.UNIFORM_BUFFER, index, this.createUniformBuffer(gl));
	}

	upload(){
		let {gl} = WebGL;
		gl.bindBuffer(gl.UNIFORM_BUFFER, this.createUniformBuffer(gl));
		gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.data);
	}

	createUniformBuffer(gl){
		if(this.buffer)return this.buffer;
		let buffer = gl.createBuffer();
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
		gl.bufferData(gl.UNIFORM_BUFFER, this.data.byteLength, gl.DYNAMIC_DRAW);
		this.buffer = buffer;
		return buffer;
	}

	setInts(index, ...values){
		this.intView.set(values, index);
	}

	setIntv(index, values){
		this.intView.set(values, index);
	}

	setFloats(index, ...values){
		this.floatView.set(values, index);
	}

	setFloatv(index, values){
		this.floatView.set(values, index);
	}
}

module.exports = UniformBuffer;
/*
class UniformBuffer2
{
	constructor(dataSizeList, baseDataRegCount=0){
		Object.defineProperty(this, "baseDataRegCount", {value:baseDataRegCount});
		this.dataSizeList = dataSizeList;
		this.instanceCount = 0;
		this.alloc(1);
	}

	active(index=0){
		let {gl} = WebGL;
		gl.bindBufferBase(gl.UNIFORM_BUFFER, index, this.createUniformBuffer(gl));
	}

	upload(instanceCount=1){
		let {gl} = WebGL;
		let {dataSizeList} = this;
		gl.bindBuffer(gl.UNIFORM_BUFFER, this.createUniformBuffer(gl));
		if(Array.isArray(dataSizeList) && this.instanceCount != instanceCount){
			for(let dataSize of dataSizeList){
				gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.intView, 0, this.calcValueCount(instanceCount));
			}
		}else{
			gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.intView, 0, this.calcValueCount(instanceCount));
		}
	}

	alloc(instanceCount){
		if(instanceCount <= this.instanceCount)return;
		this.instanceCount = instanceCount;
		this.isBufferDirty = true;
		let valueCount = this.calcValueCount(instanceCount);
		let data = new ArrayBuffer(valueCount << 2);
		let intView = new Int32Array(data);
		if(this.baseDataRegCount > 0){
			intView.set(this.intView.subarray(0, this.baseDataRegCount << 2));
		}
		this.data = data;
		this.intView = intView;
		this.floatView = new Float32Array(data);
	}

	createUniformBuffer(gl){
		if(this.isBufferDirty){
			if(this.buffer){
				gl.deleteBuffer(this.buffer);
				this.buffer = null;
			}
			this.isBufferDirty = false;
		}
		if(this.buffer)return this.buffer;
		let buffer = gl.createBuffer();
		gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
		gl.bufferData(gl.UNIFORM_BUFFER, this.data.byteLength, gl.DYNAMIC_DRAW);
		this.buffer = buffer;
		return buffer;
	}

	calcValueCount(instanceCount){
		let {baseDataRegCount, dataSizeList} = this;
		let count = Array.isArray(dataSizeList) ? sum(dataSizeList) : dataSizeList;
		return (baseDataRegCount + Math.ceil(count * instanceCount / 4)) << 2;
	}

	setInts(index, ...values){
		this.intView.set(values, index);
	}

	setIntv(index, values){
		this.intView.set(values, index);
	}

	setFloats(index, ...values){
		this.floatView.set(values, index);
	}

	setFloatv(index, values){
		this.floatView.set(values, index);
	}
}
*/
/*

// WebGL1: 
void gl.bufferData(target, size, usage); 
void gl.bufferData(target, ArrayBuffer? srcData, usage); 
void gl.bufferData(target, ArrayBufferView srcData, usage); 

// WebGL2: 
void gl.bufferData(target, ArrayBufferView srcData, usage, srcOffset, length);

// WebGL1: 
void gl.bufferSubData(target, offset, ArrayBuffer srcData); 
void gl.bufferSubData(target, offset, ArrayBufferView srcData); 

// WebGL2: 
void gl.bufferSubData(target, dstByteOffset, ArrayBufferView srcData, srcOffset, length);

Camera3D
Render2D
Render3D
*/

