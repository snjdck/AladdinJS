const {wasm, op} = require('wasm');
const {gen_vuint} = require('wasm/utils');

const byteCode = wasm.generate(
	wasm.mem('memory', 10).export(),

	wasm.import('Math.pow(i32,i32):i32'),
	wasm.import('Math.max(i32,i32):i32'),
	wasm.import('Math.min()'),
	wasm.import('Math.sin():i32'),
	wasm.import('console.log(i32)'),
	wasm.import('console.log(f32)', 'printFloat'),
	
	wasm.func('add(a:i32,b:i32):i32', null, ctx => [
		op.local.get(ctx.a),
		op.local.get(ctx.b),
		op.i32.add,
		//[op.return],
	]).export(),

	wasm.func('square(v:i32):i32', null, ctx => [
		op.local.get(ctx.v),
		op.local.get(ctx.v),
		op.i32.mul,
		//[op.return],
	]).export(),

	wasm.func('test_mem():i32', {i32:['t', 's'],f32:['b']}, ctx => [
		op.i32.const(8),
			op.i32.const(0), op.i32.load,
			op.i32.const(4), op.i32.load,
			op.i32.add,
		op.i32.store,

		op.i32.const(3),
		op.local.get(ctx.t),
		op.call(ctx.funcIndex('Math.pow')),
	]).export(),

	wasm.func('new_simd()', {v128:['a', 'b']}, ctx => [
		op.i32.const(32),
			op.i32.const( 0), op.v128.load,
			op.i32.const(16), op.v128.load,
			op.i32x4.add,
		op.v128.store,

		op.i32.const(8),
		op.call(ctx.funcIndex('console.log')),
		op.f32.const(8.88),
		op.call(ctx.funcIndex('printFloat')),
	]).export('test_simd'),

	wasm.func('dot_mul(v:v128):f32', null, ctx => [
		op.local.get(0),
		op.f32x4.extract_lane(0),
		op.local.get(0),
		op.f32x4.extract_lane(1),
		op.local.get(0),
		op.f32x4.extract_lane(2),
		op.local.get(0),
		op.f32x4.extract_lane(3),
		op.f32.add,
		op.f32.add,
		op.f32.add,
	]),

	wasm.func('f32x4_mul(a:v128,b:v128):f32', null, ctx => [
		op.local.get(0),
		op.local.get(1),
		op.f32x4.mul,
		op.call(ctx.funcIndex('dot_mul')),
	]),

	wasm.func('testAABB(n:i32)', {v128:['plane'],i32:['i','j','offset','result']}, ctx => [
		op.loop(),
			op.i32.const(0),
			op.local.set(ctx.i),
			op.block(),
				op.loop(),
					op.local.get(ctx.j),//j * 32
					op.i32.const(5),
					op.i32.shl,

					op.local.tee(ctx.offset),
					op.i32.const(64),
					op.i32.add,
					op.v128.load,//min bound

					op.local.get(ctx.offset),
					op.i32.const(80),
					op.i32.add,
					op.v128.load,//max bound

					op.local.get(ctx.i),//i * 16
					op.i32.const(4),
					op.i32.shl,
					op.v128.load,//plane
					op.local.tee(ctx.plane),
					
					op.f32.const(0),
					op.f32x4.splat,
					op.f32x4.lt,
					op.v128.bitselect,
					op.local.get(ctx.plane),
					op.call(ctx.funcIndex('f32x4_mul')),
					op.f32.const(0),
					op.f32.le,
					op.local.set(ctx.result),//cull if 1

					op.local.get(ctx.j),//result save location
					op.local.get(ctx.result),
						//op.i32.const(1),
						op.i32.store8,
						op.local.get(ctx.result),
						op.br_if(1),//break loop

					/*op.if(),//set cull
						op.local.get(ctx.j),//result save location
						op.i32.const(1),
						op.i32.store8,
						op.br(2),//break loop
					op.else,
						op.local.get(ctx.j),//result save location
						op.i32.const(0),//no cull
						op.i32.store8,
					op.end,*/

					op.local.get(ctx.i),
					op.i32.const(1),
					op.i32.add,
					op.local.tee(ctx.i),
					op.i32.const(4),
					op.i32.lt_s,
					op.br_if(),//continue loop
				op.end,
				//op.local.get(ctx.j),//result save location
				//op.i32.const(0),//no cull
				//op.i32.store8,
			op.end,
			op.local.get(ctx.j),
			op.i32.const(1),
			op.i32.add,
			op.local.tee(ctx.j),
			op.local.get(ctx.n),
			op.i32.lt_s,
			op.br_if(),//continue
		op.end,
	]).export(),
)

let floatView;
let u8View;
let testAABB;

/*
plane 16 float => 4 v128
every bound 6float => 2 v128

5000 * 32
160000
*/
//let floatList = new Int32Array(memory.buffer);

async function init(){
	const {instance} = await WebAssembly.instantiate(byteCode, {Math,console});
	const exports = instance.exports;
	floatView = new Float32Array(exports.memory.buffer);
	u8View = new Uint8Array(exports.memory.buffer);
	testAABB = exports.testAABB;
	let planeList = new Float32Array(16);
	planeList.set([3,3,3,3, 4, 4, 4, 4, -5, -5, -5, -5, 6, 6, 6, 6]);
	console.log(floatView.slice(0, 24));
	calc(planeList, 2, [
		{minX:10,minY:10, minZ:10, maxX:20, maxY:20, maxZ:20},
		{minX:30,minY:30, minZ:30, maxX:40, maxY:40, maxZ:40},
	]);
	console.log(u8View.slice(0, 2));
	//return true;
}

function calc(planeList, n, boundList){
	floatView.set(planeList);
	for(let i=0; i<n; ++i){
		let index = 16 + i * 8;
		let aabb = boundList[i];
		floatView[index  ] = aabb.minX;
		floatView[index+1] = aabb.minY;
		floatView[index+2] = aabb.minZ;
		floatView[index+3] = 1;
		floatView[index+4] = aabb.maxX;
		floatView[index+5] = aabb.maxY;
		floatView[index+6] = aabb.maxZ;
		floatView[index+7] = 1;
	}
	testAABB(n);
	return u8View.subarray(0, n);
}


exports.init = init;
exports.calc = calc;