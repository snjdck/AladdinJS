const {wasm, op} = require('wasm');
const {gen_vuint} = require('wasm/utils');

const helper_gen_matrix = offset => [
	op.i32.const(offset),
	op.i32.const(offset   ), op.f32.load, op.f32x4.splat,
	op.local.get(0), op.f32x4.mul,
	op.i32.const(offset+ 4), op.f32.load, op.f32x4.splat,
	op.local.get(1), op.f32x4.mul,
	op.i32.const(offset+ 8), op.f32.load, op.f32x4.splat,
	op.local.get(2), op.f32x4.mul,
	op.i32.const(offset+12), op.f32.load, op.f32x4.splat,
	op.local.get(3), op.f32x4.mul,
	op.f32x4.add, op.f32x4.add, op.f32x4.add,
	op.v128.store
].flat();

const helper_gen_plane = (id, offset) => [
	op.local.get(id),
	op.i32.const(offset << 2), op.f32.load, op.f32x4.replace_lane(0),
	op.i32.const(offset + 4 << 2), op.f32.load, op.f32x4.replace_lane(1),
	op.i32.const(offset + 8 << 2), op.f32.load, op.f32x4.replace_lane(2),
	op.i32.const(offset + 12 << 2), op.f32.load, op.f32x4.replace_lane(3),
	op.local.set(id),
].flat();

const byteCode = wasm.generate(
	wasm.mem('memory', 10).export(),

	wasm.import('Math.pow(i32,i32):i32'),
	wasm.import('Math.max(i32,i32):i32'),
	wasm.import('Math.min()'),
	wasm.import('Math.sin():i32'),
	wasm.import('console.log(i32)'),
	wasm.import('console.log(f32)', 'printFloat'),
	
	wasm.func('add(a:i32,b:i32):i32', null, ctx => [
		op.local.get(ctx.a),
		op.local.get(ctx.b),
		op.i32.add,
		//[op.return],
	]).export(),

	wasm.func('square(v:i32):i32', null, ctx => [
		op.local.get(ctx.v),
		op.local.get(ctx.v),
		op.i32.mul,
		//[op.return],
	]).export(),

	wasm.func('test_mem():i32', {i32:['t', 's'],f32:['b']}, ctx => [
		op.i32.const(8),
			op.i32.const(0), op.i32.load,
			op.i32.const(4), op.i32.load,
			op.i32.add,
		op.i32.store,

		op.i32.const(3),
		op.local.get(ctx.t),
		op.call(ctx.funcIndex('Math.pow')),
	]).export(),

	wasm.func('new_simd()', {v128:['a', 'b']}, ctx => [
		op.i32.const(32),
			op.i32.const( 0), op.v128.load,
			op.i32.const(16), op.v128.load,
			op.i32x4.add,
		op.v128.store,

		op.i32.const(8),
		op.call(ctx.funcIndex('console.log')),
		op.f32.const(8.88),
		op.call(ctx.funcIndex('printFloat')),
	]).export('test_simd'),
/*
	wasm.func('dot_mul(v:v128):f32', null, ctx => [
		op.local.get(0),
		op.f32x4.extract_lane(0),
		op.local.get(0),
		op.f32x4.extract_lane(1),
		op.local.get(0),
		op.f32x4.extract_lane(2),
		op.local.get(0),
		op.f32x4.extract_lane(3),
		op.f32.add,
		op.f32.add,
		op.f32.add,
	]),

	wasm.func('f32x4_mul(a:v128,b:v128):f32', null, ctx => [
		op.local.get(0),
		op.local.get(1),
		op.f32x4.mul,
		op.call(ctx.funcIndex('dot_mul')),
	]),
*/
	wasm.func('testAABB(n:i32):i32', {
		i32:['planeIndex', 'aabbIndex', 'offset', 'notCullCount'],
		v128:['plane', 'aabb_min', 'aabb_max', 'zero'],
	}, (ctx, address=64) => [
		/*
		planeIndex (4 float)
		aabbIndex (8 float)
		*/
		op.f32.const(0), op.f32x4.splat,
		op.local.set(ctx.zero),

		op.loop(),//loop aabb
			op.local.get(ctx.aabbIndex),
			op.i32.const(5),
			op.i32.shl,//j * 32, aabb index

			op.local.tee(ctx.offset),
			op.i32.const(address),
			op.i32.add,
			op.v128.load,//min bound
			op.local.set(ctx.aabb_min),

			op.local.get(ctx.offset),
			op.i32.const(address+16),
			op.i32.add,
			op.v128.load,//max bound
			op.local.set(ctx.aabb_max),

			op.block(), op.loop(),//loop plane
				op.local.get(ctx.aabb_min),
				op.local.get(ctx.aabb_max),

				op.local.get(ctx.planeIndex),
				op.i32.const(4), op.i32.shl,//planeIndex * 16
				op.v128.load,//plane
				op.local.tee(ctx.plane),
				
				op.local.get(ctx.zero), op.f32x4.lt,
				op.v128.bitselect,

				op.local.get(ctx.plane),
				op.f32x4.mul,
				
				op.local.tee(ctx.plane), op.f32x4.extract_lane(0),
				op.local.get(ctx.plane), op.f32x4.extract_lane(1),
				op.local.get(ctx.plane), op.f32x4.extract_lane(2),
				op.local.get(ctx.plane), op.f32x4.extract_lane(3),
				op.f32.add, op.f32.add, op.f32.add,//add four component of ctx.plane(f32x4)

				op.f32.const(0), op.f32.lt,//v < 0
				op.br_if(1),//culled, break loop

				//--increase plane index
				op.local.get(ctx.planeIndex),
				op.i32.const(1), op.i32.add,
				op.local.tee(ctx.planeIndex),
				//==increase plane index

				op.i32.const(4), op.i32.lt_s,
				op.br_if(),//continue loop

				//--result save location
				op.local.get(ctx.notCullCount),
				op.i32.const(1), op.i32.shl,
				op.i32.const(address), op.i32.add,
				//==result save location
				op.local.get(ctx.aabbIndex),
				op.i32.store16,//save result

				op.local.get(ctx.notCullCount),
				op.i32.const(1), op.i32.add,
				op.local.set(ctx.notCullCount),
			op.end, op.end,

			op.i32.const(0), op.local.set(ctx.planeIndex),//reset plane index = 0

			//--increase aabb index
			op.local.get(ctx.aabbIndex),
			op.i32.const(1), op.i32.add,
			op.local.tee(ctx.aabbIndex),
			//==increase aabb index

			op.local.get(ctx.n), op.i32.lt_s,
			op.br_if(),//continue
		op.end,
		op.local.get(ctx.notCullCount),
	]).export(),

	wasm.func('mat4_concat()', {v128: ['a', 'b', 'c', 'd']}, ctx => [
		op.i32.const( 64), op.v128.load, op.local.set(0),
		op.i32.const( 80), op.v128.load, op.local.set(1),
		op.i32.const( 96), op.v128.load, op.local.set(2),
		op.i32.const(112), op.v128.load, op.local.set(3),
		helper_gen_matrix( 0),
		helper_gen_matrix(16),
		helper_gen_matrix(32),
		helper_gen_matrix(48),
	]).export(),

	wasm.func('calc_planes()', {v128: ['a', 'b', 'c']}, ctx => [
		helper_gen_plane(ctx.a, 3),
		helper_gen_plane(ctx.b, 0),
		helper_gen_plane(ctx.c, 1),

		op.i32.const(0),
		op.local.get(ctx.a),
		op.local.get(ctx.b),
		op.f32x4.sub,
		op.v128.store,

		op.i32.const(16),
		op.local.get(ctx.a),
		op.local.get(ctx.b),
		op.f32x4.add,
		op.v128.store,

		op.i32.const(32),
		op.local.get(ctx.a),
		op.local.get(ctx.c),
		op.f32x4.sub,
		op.v128.store,

		op.i32.const(48),
		op.local.get(ctx.a),
		op.local.get(ctx.c),
		op.f32x4.add,
		op.v128.store,
	]).export(),
);



let floatView;
let u8View;
let u16View;
let testAABB;

/*
plane 16 float => 4 v128
every bound 6float => 2 v128

5000 * 32
160000
*/
//let floatList = new Int32Array(memory.buffer);

async function init(){
	const {instance} = await WebAssembly.instantiate(byteCode, {Math,console});
	const _exports = instance.exports;
	exports.floatView = floatView = new Float32Array(_exports.memory.buffer);
	u8View = new Uint8Array(_exports.memory.buffer);
	u16View = new Uint16Array(_exports.memory.buffer);
	testAABB = _exports.testAABB;
	exports._cull_bound = _exports._cull_bound;
	exports.mat4_concat = _exports.mat4_concat;
	exports.calc_planes = _exports.calc_planes;
	let planeList = new Float32Array(16);
	planeList.set([3,3,3,3, 4, 4, 4, 4, -5, -5, -5, -5, 6, 6, 6, 6]);
	console.log(floatView.slice(0, 24));
	calc(planeList, 2, [
		{minX:10,minY:10, minZ:10, maxX:20, maxY:20, maxZ:20},
		{minX:30,minY:30, minZ:30, maxX:40, maxY:40, maxZ:40},
	]);
	console.log(u8View.slice(0, 2));
	//return true;
}

function calc(drawUnitList){
	const n = drawUnitList.length;
	//floatView.set(planeList);
	for(let i=0; i<n; ++i){
		let index = 16 + i * 8;
		let aabb = drawUnitList[i].staticBound;
		if(!aabb){
			floatView.set(zeroAABB, index);
			continue;
		}
		floatView[index  ] = aabb.minX;
		floatView[index+1] = aabb.minY;
		floatView[index+2] = aabb.minZ;
		floatView[index+3] = 1;
		floatView[index+4] = aabb.maxX;
		floatView[index+5] = aabb.maxY;
		floatView[index+6] = aabb.maxZ;
		floatView[index+7] = 1;
	}
	let notCullCount = testAABB(n);
	return u16View.subarray(32, 32 + notCullCount);
}

const zeroAABB = new Float32Array(8);


exports.init = init;
exports.calc = calc;