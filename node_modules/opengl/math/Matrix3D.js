"use strict";

/*
[x, y, z, 1] * matrix4x4 * matrix4x4
*/
const Quaternion = require("./Quaternion");
const Vector3D = require("./Vector3D");

const tempVector = new Vector3D();

/* 缩放,旋转,偏移 */
class Matrix3D{
	static Interpolate(a, b, f, result){
		Vector3D.Interpolate(a.translation, b.translation, f, result.translation);
		Quaternion.Slerp(a.rotation, b.rotation, f, result.rotation);
		//result.scale = a.scale * (1 - f) + b.scale * f;
	}

	static concat(left, right, result){
		let {rotation:rotationL, translation:translationL} = left;
		let {rotation:rotationR, translation:translationR} = right;
		rotationR.rotateVector(translationL, tempVector);
		translationR.add(tempVector, result.translation);
		rotationR.prepend(rotationL, result.rotation);
	}

	static invert(matrix, result){
		let {rotation, translation} = result;
		matrix.translation.negate(translation);
		matrix.rotation.negate(rotation);
		rotation.rotateVector(translation);
	}

	constructor(){
		this.rotation = new Quaternion();
		this.translation = new Vector3D();
	}

	identity(){
		this.translation.identity();
		this.rotation.identity();
	}
	
	copyFrom(source){
		this.translation.copyFrom(source.translation);
		this.rotation.copyFrom(source.rotation);
	}

	append(other, result=this){
		Matrix3D.concat(this, other, result);
	}
	
	prepend(other, result=this){
		Matrix3D.concat(other, this, result);
	}
	
	invert(result=this){
		Matrix3D.invert(this, result);
	}

	interpolate(to, f, result){
		return Matrix3D.Interpolate(this, to, f, result);
	}

	copyToArray(list, offset=0){
		let {rotation, translation} = this;
		rotation.copyToArray(list, offset);
		translation.copyToArray(list, offset + 4);
		list[offset+7] = 1;
	}

	setFromArray(list, offset=0){
		let {rotation, translation} = this;
		rotation.setFromArray(list, offset);
		translation.setFromArray(list, offset + 4);
	}

	transformPoint(pt, result=pt){
		let {rotation, translation} = this;
		rotation.rotateVector(pt, result);
		result.add(translation);
		return result;
	}

	transformNormal(pt, result=pt){
		let {rotation} = this;
		rotation.rotateVector(pt, result);
		return result;
	}
}

const buffer = new Float32Array(8);

module.exports = Matrix3D;