
class Vector3D{
	static Interpolate(a, b, fb, result){
		const fa = 1 - fb;
		for(let i=0; i<3; ++i){
			result.rawData[i] = a.rawData[i] * fa + b.rawData[i] * fb;
		}
		return result;
	}

	constructor(x=0, y=0, z=0){
		this.rawData = new Float32Array([x, y, z]);
	}

	get x(){return this.rawData[0];}
	get y(){return this.rawData[1];}
	get z(){return this.rawData[2];}
	set x(v){this.rawData[0] = v;}
	set y(v){this.rawData[1] = v;}
	set z(v){this.rawData[2] = v;}

	identity(){
		this.rawData.fill(0);
	}

	get length(){
		return Math.hypot.apply(null, this.rawData);
	}

	normalize(result=this){
		const factor = 1.0 / Math.hypot.apply(null, this.rawData);
		for(let i=0; i<3; ++i){
			result.rawData[i] = this.rawData[i] * factor;
		}
		return result;
	}

	setTo(...xyz){
		this.rawData.set(xyz);
	}

	copyFrom(other){
		this.rawData.set(other.rawData);
	}

	negate(result=this){
		for(let i=0; i<3; ++i){
			result.rawData[i] = -this.rawData[i];
		}
		return result;
	}

	scaleBy(value, result=this){
		for(let i=0; i<3; ++i){
			result.rawData[i] = this.rawData[i] * value;
		}
		return result;
	}

	add(other, result=this){
		for(let i=0; i<3; ++i){
			result.rawData[i] = this.rawData[i] + other.rawData[i];
		}
		return result;
	}

	subtract(other, result=this){
		for(let i=0; i<3; ++i){
			result.rawData[i] = this.rawData[i] - other.rawData[i];
		}
		return result;
	}

	copyToArray(list, offset=0){
		for(let i=0; i<3; ++i){
			list[offset+i] = this.rawData[i];
		}
	}

	setFromArray(list, offset=0){
		for(let i=0; i<3; ++i){
			this.rawData[i] = list[offset+i];
		}
	}

	dotProd(other){
		let result = 0;
		for(let i=0; i<3; ++i){
			result += this.rawData[i] * other.rawData[i];
		}
		return result;
	}

	crossProd(other, result=this){
		const [ax, ay, az] = this.rawData;
		const [bx, by, bz] = other.rawData;
		result.rawData[0] = (ay * bz) - (az * by);
		result.rawData[1] = (az * bx) - (ax * bz);
		result.rawData[2] = (ax * by) - (ay * bx);
	}

	crossProdAxisX(v, result=this){
		result.setTo(0, v.z, -v.y);
	}

	crossProdAxisY(v, result=this){
		result.setTo(-v.z, 0, v.x);
	}

	crossProdAxisZ(v, result=this){
		result.setTo(v.y, -v.x, 0);
	}

	reflect(normal, result=this){
		let len = this.dotProd(normal) * 2;
		for(let i=0; i<3; ++i){
			result.rawData[i] = this.rawData[i] - normal.rawData[i] * len;
		}
	}
}

Vector3D.X_AXIS = Object.freeze(new Vector3D(1, 0, 0));
Vector3D.Y_AXIS = Object.freeze(new Vector3D(0, 1, 0));
Vector3D.Z_AXIS = Object.freeze(new Vector3D(0, 0, 1));

module.exports = Vector3D;