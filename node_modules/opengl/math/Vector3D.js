
class Vector3D{
	static Interpolate(a, b, f, result){
		result.x = a.x + (b.x - a.x) * f;
		result.y = a.y + (b.y - a.y) * f;
		result.z = a.z + (b.z - a.z) * f;
		return result;
	}

	constructor(x=0, y=0, z=0){
		this.x = x;
		this.y = y;
		this.z = z;
	}

	identity(){
		this.x = 0;
		this.y = 0;
		this.z = 0;
	}

	get length(){
		return Math.hypot(this.x, this.y, this.z);
	}

	normalize(result=this){
		return this.scaleBy(1 / this.length, result);
	}

	setTo(x, y, z){
		this.x = x;
		this.y = y;
		this.z = z;
	}

	copyFrom(other){
		this.x = other.x;
		this.y = other.y;
		this.z = other.z;
	}

	negate(result=this){
		result.x = - this.x;
		result.y = - this.y;
		result.z = - this.z;
		return result;
	}

	scaleBy(value, result=this){
		result.x = this.x * value;
		result.y = this.y * value;
		result.z = this.z * value;
		return result;
	}

	add(other, result=this){
		result.x = this.x + other.x;
		result.y = this.y + other.y;
		result.z = this.z + other.z;
		return result;
	}

	subtract(other, result=this){
		result.x = this.x - other.x;
		result.y = this.y - other.y;
		result.z = this.z - other.z;
		return result;
	}

	copyToArray(list, offset=0){
		list[offset  ] = this.x;
		list[offset+1] = this.y;
		list[offset+2] = this.z;
	}

	setFromArray(list, offset=0){
		this.x = list[offset];
		this.y = list[offset+1];
		this.z = list[offset+2];
	}

	dotProd(other){
		return (this.x * other.x) + (this.y * other.y) + (this.z * other.z);
	}

	crossProd(other, result=this){
		let {x:ax, y:ay, z:az} = this;
		let {x:bx, y:by, z:bz} = other;
		result.x = (ay * bz) - (az * by);
		result.y = (az * bx) - (ax * bz);
		result.z = (ax * by) - (ay * bx);
	}

	crossProdAxisX(v, result=this){
		result.setTo(0, v.z, -v.y);
	}

	crossProdAxisY(v, result=this){
		result.setTo(-v.z, 0, v.x);
	}

	crossProdAxisZ(v, result=this){
		result.setTo(v.y, -v.x, 0);
	}

	reflect(normal, result=this){
		let len = this.dotProd(normal) * 2;
		result.x = this.x - normal.x * len;
		result.y = this.y - normal.y * len;
		result.z = this.z - normal.z * len;
	}
}

Vector3D.X_AXIS = Object.freeze(new Vector3D(1, 0, 0));
Vector3D.Y_AXIS = Object.freeze(new Vector3D(0, 1, 0));
Vector3D.Z_AXIS = Object.freeze(new Vector3D(0, 0, 1));

module.exports = Vector3D;