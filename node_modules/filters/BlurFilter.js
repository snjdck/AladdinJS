"use strict";

const Filter2D = require("./Filter2D");

class BlurFilter extends Filter2D
{
	constructor(radius=4){
		super();
		this.shader = "screen&filters/blur";
		this.radius = radius;
	}

	onDraw(gl, program, image){
		const {radius} = this;
		let weight = calcWeight(radius);

		gl.uniform1i( gl.getUniformLocation(program, "radius"), radius);
		gl.uniform1fv(gl.getUniformLocation(program, "weight"), weight);

		offset.length = radius << 1;
		offset.fill(0);
		let dx = 1 / gl.render2d.width;
		let dy = 1 / gl.render2d.height;

		let offsetLocation = gl.getUniformLocation(program, "offset");

		let filterFrameBuffer = this.borrowFrameBuffer(gl);
		gl.bindTexture(gl.TEXTURE_2D, image);

		for(let i=1; i<radius; ++i){
			offset[i*2] = i * dx;
		}
		gl.uniform2fv(offsetLocation, offset);
		gl.render2d.drawScreen();

		gl.renderStateStack.load(gl.FRAMEBUFFER_BINDING);
		gl.bindTexture(gl.TEXTURE_2D, filterFrameBuffer.colorBuffer);
		
		for(let i=1; i<radius; ++i){
			offset[i*2] = 0;
			offset[i*2+1] = i * dy;
		}
		gl.uniform2fv(offsetLocation, offset);
		gl.render2d.drawScreen();

		this.returnFrameBuffer(gl, filterFrameBuffer);
	}
}

const offset = [];

const calcWeight = (function(){
	const c1 = Math.sqrt(2 * Math.PI);
	const list = [];
	return radius => {
		list.length = radius;
		const sigma = radius / 2.57;
		const deno =  1 / (sigma * c1);
		const nume = -1 / (sigma * sigma * 2);
		list[0] = deno;
		let sum = deno;
		for(let i=1; i<radius; ++i){
			let v = deno * Math.exp(nume * i * i);
			list[i] = v;
			sum += 2 * v;
		}
		let factor = 1 / sum;
		for(let i=0; i<radius; ++i){
			list[i] *= factor;
		}
		return list;
	};
})();

module.exports = BlurFilter;