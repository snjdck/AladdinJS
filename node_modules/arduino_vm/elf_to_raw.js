'use strict';

function readElfHeader(buffer){
	const e_type = buffer.readUint16LE(16);
	const e_machine = buffer.readUint16LE(18);
	const e_version = buffer.readUint32LE(20);
	const e_entry = buffer.readUint32LE(24);
	const e_phoff = buffer.readUint32LE(28);
	const e_shoff = buffer.readUint32LE(32);
	const e_flags = buffer.readUint32LE(36);
	const e_ehsize = buffer.readUint16LE(40);
	const e_phentsize = buffer.readUint16LE(42);
	const e_phnum = buffer.readUint16LE(44);
	const e_shentsize = buffer.readUint16LE(46);
	const e_shnum = buffer.readUint16LE(48);
	const e_shstrndx = buffer.readUint16LE(50);
	return {e_type,e_machine,e_version,e_entry,e_phoff,e_shoff,e_flags,e_ehsize,e_phentsize,e_phnum,e_shentsize,e_shnum,e_shstrndx};
}

function readProgramHeader(buffer, offset){
	const p_type = buffer.readUint32LE(offset);
	const p_offset = buffer.readUint32LE(offset+4);
	const p_vaddr = buffer.readUint32LE(offset+8);
	const p_paddr = buffer.readUint32LE(offset+12);
	const p_filesz = buffer.readUint32LE(offset+16);
	const p_memsz = buffer.readUint32LE(offset+20);
	const p_flags = buffer.readUint32LE(offset+24);
	const p_align = buffer.readUint32LE(offset+28);
	return {p_type,p_offset,p_vaddr,p_paddr,p_filesz,p_memsz,p_flags,p_align};
}

function readSectionHeader(buffer, offset){
	const sh_name = buffer.readUint32LE(offset);
	const sh_type = buffer.readUint32LE(offset+4);
	const sh_flags = buffer.readUint32LE(offset+8);
	const sh_addr = buffer.readUint32LE(offset+12);
	const sh_offset = buffer.readUint32LE(offset+16);
	const sh_size = buffer.readUint32LE(offset+20);
	const sh_link = buffer.readUint32LE(offset+24);
	const sh_info = buffer.readUint32LE(offset+28);
	const sh_addralign = buffer.readUint32LE(offset+32);
	const sh_entsize = buffer.readUint32LE(offset+36);
	return {sh_name,sh_type,sh_flags,sh_addr,sh_offset,sh_size,sh_link,sh_info,sh_addralign,sh_entsize};
}

function findSectionData(buffer, sectionList, name){
	const section = sectionList.find(section => section.name == name);
	return buffer.slice(section.sh_offset, section.sh_offset + section.sh_size);
}

function getSectionList(buffer){
	const info = readElfHeader(buffer);
	const sectionList = [];
	for(let i=0; i<info.e_shnum; ++i){
		sectionList.push(readSectionHeader(buffer, info.e_shoff + i * info.e_shentsize))
	}
	/*
	for(let i=0; i<info.e_phnum; ++i){
		readProgramHeader(buffer, info.e_phoff + i * info.e_phentsize)
	}
	*/
	const shstrtabOffset = sectionList[info.e_shstrndx].sh_offset;
	for(const section of sectionList){
		const offset = shstrtabOffset + section.sh_name;
		section.name = buffer.toString('utf8', offset, buffer.indexOf(0, offset));
	}
	return sectionList;
}

function parse(buffer){
	const sectionList = getSectionList(buffer);
	return Buffer.concat([
		findSectionData(buffer, sectionList, '.text'),
		findSectionData(buffer, sectionList, '.data')
	]);
}

exports.getSectionList = getSectionList;
exports.parse = parse;
