'use strict';

const {TaskExecutor} = require('../utils/task');
const createSendFn = queue => send => data => queue(() => send(data, 1));

function readN(list, offset, count){
	let result = 0;
	for(let i=0; i<count; ++i){
		result = result << 8 | list[offset+i];
	}
	return result;
}

const findUSB = function(){
	function dataOut(ab){
		return {
			data:ab,
			direction:'out',
			index:4,//interfaceNumber
			recipient:'interface',
			requestType:'class',
			request:9,
			value:0x200
		}
	}
	function dataIn(length){
		return {
			length,
			direction:'in',
			index:4,//interfaceNumber
			recipient:'interface',
			requestType:'class',
			request:1,
			value:0x100
		}
	}
	const {usb, runtime} = chrome;
	const getDevices = () => new Promise(resolve => usb.getDevices({filters:[{vendorId:0x0d28,productId:0x0204}]}, resolve));
	const openDevice = device => new Promise(resolve => usb.openDevice(device, resolve));
	const closeDevice = handler => new Promise(resolve => usb.closeDevice(handler, resolve));
	const listInterfaces = handler => new Promise(resolve => usb.listInterfaces(handler, resolve));
	const claimInterface = (handler, interfaceNumber) => new Promise(resolve => usb.claimInterface(handler, interfaceNumber, resolve));
	const releaseInterface = (handler, interfaceNumber) => new Promise(resolve => usb.releaseInterface(handler, interfaceNumber, resolve));
	const controlTransfer = (handler, info) => new Promise((resolve, reject) => usb.controlTransfer(handler, info, result => {
		if(result.resultCode !== 0){
			reject(result.resultCode);
		}else{
			resolve(result.data);
		}
	}));
	const controlTransferOut = (handler, ab) => controlTransfer(handler, dataOut(ab));
	const controlTransferIn = (handler, count) => controlTransfer(handler, dataIn(count));
	return async function(callback){
		const deviceList = await getDevices();
		if(deviceList.length == 0)return Promise.reject();
		const handler = await openDevice(deviceList[0]);
		const interfaceList = await listInterfaces(handler);
		const {interfaceNumber} = interfaceList.find(v => v.interfaceClass == 255);
		console.assert(interfaceNumber === 4);
		await claimInterface(handler, interfaceNumber);
		await callback((byteList, recvCount) => controlTransferOut(handler, new Uint8Array(byteList).buffer).then(() => controlTransferIn(handler, recvCount)));
		await releaseInterface(handler, interfaceNumber);
		await closeDevice(handler);
	}
}();

function*cutData(data, batchSize){
	for(let i=0, n=data.length; i<n; i+=batchSize){
		yield data.slice(i, i + batchSize);
	}
}

function parseHex(data){
	let list = data.match(/:.+/g).map(v => v.match(/\w{2}/g).map(v => parseInt(v, 16)));
	let result = [];
	console.log(list.filter(v => Boolean(v[3])));
	for(let v of list){
		if(v[3] == 4){
			if(v[4] == 16){
				break;
			}
			continue;
		}
		result.push(...v.slice(4, -1));

		continue;
		if(v[3] == 5)continue;
		if(v[3] == 1)break;
		if(v[3] == 2){
			result.push([readN(v, 4, v[0]) << 4, []]);
			continue;
		}
		if(v[3] == 4){
			result.push([readN(v, 4, v[0]) << 16, []]);
			continue;
		}
		if(v[3] != 0){
			continue;
		}
		const dest = result[result.length-1];
		if(dest[1].length == 0){
			let offset = readN(v, 1, 2);
			if(offset > 0){
				dest[0] |= offset;
			}
		}
		dest[1].push(...v.slice(4, -1));
	}
	return result;
}

function main(hex){
	const data = parseHex(hex);
	const time = performance.now();
	findUSB(raw_send => {
		//const packeCount = await raw_send([0, 0xfe], 3);//[0,1,5]
		//const packeSize = await raw_send([0, 0xff], 4);//[0,2,64,0] LE
		const sendFn = createSendFn(TaskExecutor(5))(raw_send);
		sendFn([0x8a, 0]);//open
		for(let batch of cutData(data, 62)){
			sendFn([0x8c, batch.length, ...batch]);//write
		}
		sendFn([0x8b]);//close
		return sendFn([0x89]);//reset
	}).then(
		() => console.log('finish', Math.round(performance.now() - time) / 1000),
		() => console.log('no device')
	);
}
