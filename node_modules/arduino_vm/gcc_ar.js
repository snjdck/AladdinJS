'use strict';

const fs = require('fs');
const {basename} = require('path');
const {getSectionList} = require('./elf_to_raw');

function decode(file){
	for(let prev=0;;){
		let next = file.indexOf(0x0A, prev);
		if(next < 0)break;
		let text = file.toString('utf8', prev, next);
		if(text.startsWith('/') && text.endsWith("`")){
			let info = [
				text.slice(0, 16),
				text.slice(16, 28),
				text.slice(28, 34),
				text.slice(34, 40),
				text.slice(40, 48),
				text.slice(48, 58),
			].map(v => v.trim());

			const size = Number(info[5]);
			console.log(prev, text, new Date(info[1] * 1000).toString())
			if(info[0] == '//'){
				console.log(file.toString('utf8', next+1, next+1+size))
			}
			if(info[0] == '/'){
				let count = file.readUint32BE(next+1);
				let index = next+1+4*(count+1);
				for(let i=0; i<count; ++i){
					let now = file.indexOf(0, index);
					console.log(file.readUint32BE(next+5+i*4), file.toString('utf8', index, now))
					index = now + 1;
				}
			}
			next += size;
		}
		prev = next + 1;
	}
}

function encodeName(item){
	return Buffer.from(`${item[0].padEnd(16)}${item[1].padEnd(12)}${item[2].padEnd(6)}${item[3].padEnd(6)}${item[4].padEnd(8)}${item[5].padEnd(10)}\`\n`);
}

function castUint32(value){
	let buffer = Buffer.allocUnsafe(4);
	buffer.writeUint32BE(value);
	return buffer;
}

function getMethodInfo(buffer){
	const section = getSectionList(buffer).find(({name}) => name.startsWith('.gnu.lto_.symtab.'));
	const result = [];
	const data = buffer.slice(section.sh_offset, section.sh_offset+section.sh_size)
	let prev = 0;
	for(;;){
		const index = data.indexOf(0, prev);
		if(index < 0)break;
		if(data[index+2] == 0){
			result.push(data.toString('utf8', prev, index));
		}
		prev = index + 16;
	}
	return result;
}

function encode(fileList){
	const result = [Buffer.from('!<arch>\n')];
	const fileDataList = fileList.map(v => fs.readFileSync(v));
	const methodList = fileDataList.map(getMethodInfo);
	const methodListFlat = methodList.slice(0, fileList.length).flat();
	let temp;
	temp = Buffer.from(methodListFlat.map(v => v+'\x00').join(''));
	result.push(encodeName(['/',(new Date().getTime() * 0.001).toFixed(),'0','0','0',String(4+methodListFlat.length*4+temp.length)]));
	result.push(castUint32(methodListFlat.length), Buffer.allocUnsafe(4 * methodListFlat.length), temp);
	if(temp.length % 2)result.push(Buffer.from('\n'));
	temp = Buffer.from(fileList.map(v => basename(v)+'/\n').join(''));
	result.push(encodeName(['//','','','','',String(temp.length)]), temp);
	if(temp.length % 2)result.push(Buffer.from('\n'));
	let nameOffset = 0;
	let methodOffset = 0;
	for(let i=0; i<fileList.length; ++i){
		const name = fileList[i]
		const resultLength = result.reduce((s,v)=>s+v.length, 0);
		methodList[i].forEach((_, j) => result[3].writeUint32BE(resultLength, (j+methodOffset) * 4));
		const {mtimeMs, size} = fs.statSync(name);
		result.push(encodeName([`/${nameOffset}`, (mtimeMs * 0.001).toFixed(),'0','0','100666', String(size)]));
		result.push(fileDataList[i]);
		if(size % 2)result.push(Buffer.from('\n'));
		nameOffset += basename(name).length + 2;
		methodOffset += methodList[i].length;
	}
	return Buffer.concat(result);
}

exports.encode = encode;
exports.decode = decode;
