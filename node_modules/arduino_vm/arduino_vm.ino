
#define OP_JUMP 1
#define OP_JUMP_IF 2
#define OP_PUSH 3
#define OP_CALL 4
#define OP_SET 5
#define OP_GET 6
#define OP_INVOKE 7
#define OP_RETURN 8
#define OP_DEFINE 9

#define FN_INCREASE 5
#define FN_DECREASE 2
#define FN_IS_NOT_NEGATIVE 3
#define FN_DUPLICATE 4

#define FN_ADD_INT 11
#define FN_ADD_FLOAT 12
#define FN_CAST_INT_TO_FLOAT 13
#define FN_CAST_FLOAT_TO_INT 14

#define FN_DELAY 1
#define FN_READ_DIGITAL 52
#define FN_WRITE_DIGITAL 0
#define FN_READ_ANALOG 54
#define FN_WRITE_ANALOG 55

#define MAX_VAR_COUNT 20

union Value {
	char i8[4];
	byte u8[4];
	int i16[2];
	unsigned int u16[2];
	long i32;
	unsigned long u32;
	float f32;
};

struct Instruction {
	byte type;
	Value data;
};

class Scope {
public:
	Scope():prev(0){}
	void copyVariableTo(Scope *dest) const {
		memcpy(dest->variable, this->variable, sizeof(Value) * MAX_VAR_COUNT);
	}
public:
	Scope *prev;
	int ip;
	int sp;
protected:
	Value variable[MAX_VAR_COUNT];
};

class Context : public Scope {
public:
	Context(Instruction *instruction){
		start = instruction;
		ip = sp = 0;
		scope = 0;
	}
	Instruction* instruction() const {
		return start + ip;
	}
	void push(Value value){
		valueStack[sp++] = value;
	}
	Value pop(){
		return valueStack[--sp];
	}
	Value get(int index) const {
		return variable[index];
	}
	void set(int index, Value value){
		variable[index] = value;
	}
	Value arg(int index) const {
		return valueStack[sp+index];
	}
	Value* args() const {
		return valueStack + sp;
	}
	void pushScope(byte argCount, byte retCount){
		Scope *scope = new Scope();
		scope->prev = this->scope;
		this->copyVariableTo(scope);
		while(argCount > 0)this->set(--argCount, this->pop());
		scope->sp = this->sp + retCount;
		scope->ip = this->ip;
		this->scope = scope;
	}
	void popScope(){
		Scope * const prev = scope->prev;
		scope->copyVariableTo(this);
		this->sp = scope->sp;
		this->ip = scope->ip + 1;
		delete scope;
		scope = prev;
	}
	uint16_t getFnAddress(uint16_t fnID){
		uint16_t offset = 0;
		while(fnID-- > 0){
			offset += (start + offset)->data.i32;
		}
		return offset;
	}
private:
	Value valueStack[128];
	Instruction *start;
	Scope *scope;
};

void exec(Instruction* start, int count)
{
	for(Context ctx(start); ctx.ip < count;){
		Instruction *instruction = ctx.instruction();
		handleInstruction(&ctx, instruction->type, instruction->data);
	}
}

void handleInstruction(Context *ctx, byte type, Value data){
	if(type == OP_CALL){
		byte argCount = data.u8[2];
		byte retCount = data.u8[3];
		byte fnID = data.u16[0];
		ctx->sp -= argCount;
		handleInvoke(fnID, ctx->args());
		ctx->sp += retCount;
		ctx->ip += 1;
		return;
	}
	switch(type){
		case OP_DEFINE:
		case OP_JUMP:
			ctx->ip += data.i32;
			break;
		case OP_JUMP_IF:
			ctx->ip += ctx->pop().i32 ? data.i32 : 1;
			break;
		case OP_PUSH:
			ctx->push(data);
			ctx->ip += 1;
			break;
		case OP_SET:
			ctx->set(data.i32, ctx->pop());
			ctx->ip += 1;
			break;
		case OP_GET:
			ctx->push(ctx->get(data.i32));
			ctx->ip += 1;
			break;
		case OP_INVOKE:
			ctx->pushScope(data.u8[2], data.u8[3]);
			ctx->ip = ctx->getFnAddress(data.u16[0]) + 1;
			break;
		case OP_RETURN:
			ctx->popScope();
			break;
		default:
			ctx->ip += 1;
	}
}

void handleInvoke(byte fnID, Value *args){
	switch(fnID){
	case FN_WRITE_DIGITAL:
		digitalWrite(args[0].i32, args[1].i32);
		break;
	case FN_WRITE_ANALOG:
		analogWrite(args[0].i32, args[1].i32);
		break;
	case FN_READ_DIGITAL:
		args->i32 = digitalRead(args->i32);
		break;
	case FN_READ_ANALOG:
		args->i32 = analogRead(args->i32);
		break;
	case FN_DELAY:
		delay(args->i32);
		break;
	case FN_ADD_FLOAT:
		args[0].f32 += args[1].f32;
		break;
	case FN_ADD_INT:
		args[0].i32 += args[1].i32;
		break;
	case FN_INCREASE:
		args->i32 += 1;
		break;
	case FN_DECREASE:
		args->i32 -= 1;
		break;
	case FN_IS_NOT_NEGATIVE:
		args->i32 = args->i32 >= 0;
		break;
	case FN_DUPLICATE:
		args[1].i32 = args[0].i32;
		break;
	case FN_CAST_INT_TO_FLOAT:
		args->f32 = args->i32;
		break;
	case FN_CAST_FLOAT_TO_INT:
		args->i32 = args->f32;
		break;
	}
}

unsigned long timestamp;
bool uploadMode = false;

void setup(){
	Serial.begin(115200);
	eeprom_busy_wait();
	timestamp = millis() + 2000;
	//*
	byte code[] = {
		9, 7, 0, 0, 0,//define fn and jump 7

		6, 0, 0, 0, 0,//get local 0
		6, 1, 0, 0, 0,//get local 1
		4, 0, 0, 2, 0,//call 0 with 2 args ret 0 args(digitalWrite)
		3, 0, 2, 0, 0,//push 512
		4, 1, 0, 1, 0,//call 1 with 1 args ret 0 args(delay)

		8, 0, 0, 0, 0,//return
//============================
		9, 8, 0, 0, 0,//define fn and jump 8

		6, 0, 0, 0, 0,//get local 0
		3, 1, 0, 0, 0,//push 1
		7, 0, 0, 2, 0,//invoke fn 0 with 2 args ret 0 args

		6, 0, 0, 0, 0,//get local 0
		3, 0, 0, 0, 0,//push 0
		7, 0, 0, 2, 0,//invoke fn 0 with 2 args ret 0 args

		8, 0, 0, 0, 0,//return
//============================

		3, 3, 0, 0, 0,//push 3 (pin)
		7, 1, 0, 1, 0,//invoke fn 1 with 1 args ret 0 args

		3, 4, 0, 0, 0,//push 4 (pin)
		7, 1, 0, 1, 0,//invoke fn 1 with 1 args ret 0 args

		3, 14, 0, 0, 0,//push 14 (pin)
		7, 1, 0, 1, 0,//invoke fn 1 with 1 args ret 0 args

		3, 13, 0, 0, 0,//push 13 (pin)
		7, 1, 0, 1, 0,//invoke fn 1 with 1 args ret 0 args

		1, 0xf8, 0xff, 0xff, 0xff,//jump -8
	};
	exec((Instruction*)code, sizeof(code) / sizeof(Instruction));
	for(;;);
	//*/
}

void loop(){
	if(millis() < timestamp)return;
	if(uploadMode){
		upload();
	}else if(Serial.available() > 0){
		uploadMode = true;
	}else{
		run();
	}
}

void run(){
	Instruction code[200];
	unsigned int len = eeprom_read_word(0);
	eeprom_read_block(code, 2, len);
	exec(code, len / sizeof(Instruction));
	for(;;);
}

void upload(){
	const byte head_len = 8;

	static bool head_mode = true;
	static uint16_t packet_len = 0;
	static uint16_t offset = 0;

	if(head_mode){
		if(Serial.available() < head_len)return;
		head_mode = false;
		byte buffer[head_len];
		Serial.readBytes(buffer, head_len);
		if(strcmp(buffer, "write") != 0)run();
		packet_len = buffer[6] + buffer[7] * 256;
		eeprom_write_word(0, packet_len);
	}else if(offset >= packet_len){
		run();
	}else if(Serial.available() > 0){
		eeprom_write_byte(2 + offset++, Serial.read());
	}
}
