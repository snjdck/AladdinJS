
#define OP_JUMP 1
#define OP_JUMP_IF 2
#define OP_PUSH 3
#define OP_INVOKE 4
#define OP_SET 5
#define OP_GET 6

union Value {
	char i8[4];
	byte u8[4];
	int i16[2];
	unsigned int u16[2];
	long i32;
	unsigned long u32;
	float f32;
};

struct Instruction {
	byte type;
	Value data;
};

class Context {
public:
	Context():ip(0),sp(0){}
	void push(Value value){
		stack[sp++] = value;
	}
	Value pop(){
		return stack[--sp];
	}
	Value get(int index){
		return variable[index];
	}
	void set(int index, Value value){
		variable[index] = value;
	}
	Value arg(int index){
		return stack[sp+index];
	}
	Value* args(){
		return stack + sp;
	}
public:
	int ip;
	int sp;
private:
	Value stack[128];
	Value variable[20];
};

void exec(Instruction* start, int count)
{
	for(Context ctx; ctx.ip < count;){
		Instruction *instruction = start + ctx.ip;
		handleInstruction(&ctx, instruction->type, instruction->data);
	}
}

void handleInstruction(Context *ctx, byte type, Value data){
	if(type == OP_INVOKE){
		byte argCount = data.u8[2];
		byte retCount = data.u8[3];
		byte fnID = data.u16[0];
		ctx->sp -= argCount;
		handleInvoke(fnID, ctx->args());
		ctx->sp += retCount;
		ctx->ip += 1;
		return;
	}
	switch(type){
		case OP_JUMP:
			ctx->ip += data.i32;
			break;
		case OP_JUMP_IF:
			ctx->ip += ctx->pop().i32 ? data.i32 : 1;
			break;
		case OP_PUSH:
			ctx->push(data);
			ctx->ip += 1;
			break;
		case OP_SET:
			ctx->set(data.i32, ctx->pop());
			ctx->ip += 1;
			break;
		case OP_GET:
			ctx->push(ctx->get(data.i32));
			ctx->ip += 1;
			break;
		default:
			ctx->ip += 1;
	}
}

void handleInvoke(byte fnID, Value *args){
	switch(fnID){
	case 0:
		digitalWrite(args[0].i32, args[1].i32);
		break;
	case 4:
		analogWrite(args[0].i32, args[1].i32);
		break;
	case 2:
		args->i32 = digitalRead(args->i32);
		break;
	case 3:
		args->i32 = analogRead(args->i32);
		break;
	case 1:
		delay(args->i32);
		break;
	case 5:
		args[0].f32 += args[1].f32;
		break;
	case 6:
		args[0].i32 += args[1].i32;
		break;
	case 7:
		args->i32 += 1;
		break;
	case 8:
		args->i32 -= 1;
		break;
	case 9:
		args->i32 = args->i32 >= 0;
		break;
	case 10:
		args[1].i32 = args[0].i32;
		break;
	}
}

unsigned long timestamp;
bool uploadMode = false;

void setup(){
	timestamp = millis() + 1000;
	Serial.begin(115200);
	eeprom_busy_wait();
	/*
	byte code[] = {
		3, 4, 0, 0, 0,
		3, 1, 0, 0, 0,
		4, 0, 0, 2, 0,
		3, 232, 3, 0, 0,
		4, 1, 0, 1, 0,

		3, 4, 0, 0, 0,
		3, 0, 0, 0, 0,
		4, 0, 0, 2, 0,
		3, 232, 3, 0, 0,
		4, 1, 0, 1, 0,
		1, 0xf6, 0xff, 0xff, 0xff
	};
	eeprom_write_word(0, sizeof(code));
	eeprom_write_block(code, 2, sizeof(code));
	*/
	
}

void loop(){
	if(millis() < timestamp)return;
	if(uploadMode){
		upload();
	}else if(Serial.available() > 0){
		uploadMode = true;
	}else{
		run();
	}
}

void run(){
	Serial.println("run");
	Instruction code[200];
	unsigned int len = eeprom_read_word(0);
	eeprom_read_block(code, 2, len);
	exec(code, len / sizeof(Instruction));
	for(;;);
}

void upload(){
	Serial.println("upload");

	const byte head_len = 8;
	const byte checksum_offset = 5;
	const byte size_offset = 6;

	const  byte buffer_len = 1024;
	static byte buffer[buffer_len];
	static byte buffer_index = 0;

	int available = Serial.available();
	if(available <= 0)return;
	int recv_count = Serial.readBytes(buffer + buffer_index, available);
	if(recv_count <= 0)return;
	buffer_index += recv_count;

	if(buffer_index < head_len)return;
	if(strcmp(buffer, "write") != 0)run();

	unsigned int packet_len = *(unsigned int*)(buffer+size_offset);
	unsigned int body_len = packet_len - head_len;
	if(buffer_index < packet_len)return;

	if(buffer[checksum_offset] != checksum(buffer+head_len, body_len))run();

	eeprom_write_word(0, body_len);
	eeprom_write_block(buffer + head_len, 2, body_len);
}

byte checksum(byte *data, int len)
{
	int sum = 0;
	for(int i=0; i<len; ++i)
		sum += data[i];
	return sum & 0xFF;
}
