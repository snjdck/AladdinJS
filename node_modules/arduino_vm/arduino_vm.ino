
#define OP_JUMP 1
#define OP_JUMP_IF 2
#define OP_PUSH 3
#define OP_INVOKE 4
#define OP_SET 5
#define OP_GET 6

#define FN_INCREASE 5
#define FN_DECREASE 2
#define FN_IS_NOT_NEGATIVE 3
#define FN_DUPLICATE 4

#define FN_ADD_INT 11
#define FN_ADD_FLOAT 12
#define FN_CAST_INT_TO_FLOAT 13
#define FN_CAST_FLOAT_TO_INT 14

#define FN_DELAY 1
#define FN_READ_DIGITAL 52
#define FN_WRITE_DIGITAL 0
#define FN_READ_ANALOG 54
#define FN_WRITE_ANALOG 55

union Value {
	char i8[4];
	byte u8[4];
	int i16[2];
	unsigned int u16[2];
	long i32;
	unsigned long u32;
	float f32;
};

struct Instruction {
	byte type;
	Value data;
};

class Context {
public:
	Context():ip(0),sp(0){}
	void push(Value value){
		stack[sp++] = value;
	}
	Value pop(){
		return stack[--sp];
	}
	Value get(int index){
		return variable[index];
	}
	void set(int index, Value value){
		variable[index] = value;
	}
	Value arg(int index){
		return stack[sp+index];
	}
	Value* args(){
		return stack + sp;
	}
public:
	int ip;
	int sp;
private:
	Value stack[128];
	Value variable[20];
};

void exec(Instruction* start, int count)
{
	for(Context ctx; ctx.ip < count;){
		Instruction *instruction = start + ctx.ip;
		handleInstruction(&ctx, instruction->type, instruction->data);
	}
}

void handleInstruction(Context *ctx, byte type, Value data){
	if(type == OP_INVOKE){
		byte argCount = data.u8[2];
		byte retCount = data.u8[3];
		byte fnID = data.u16[0];
		ctx->sp -= argCount;
		handleInvoke(fnID, ctx->args());
		ctx->sp += retCount;
		ctx->ip += 1;
		return;
	}
	switch(type){
		case OP_JUMP:
			ctx->ip += data.i32;
			break;
		case OP_JUMP_IF:
			ctx->ip += ctx->pop().i32 ? data.i32 : 1;
			break;
		case OP_PUSH:
			ctx->push(data);
			ctx->ip += 1;
			break;
		case OP_SET:
			ctx->set(data.i32, ctx->pop());
			ctx->ip += 1;
			break;
		case OP_GET:
			ctx->push(ctx->get(data.i32));
			ctx->ip += 1;
			break;
		default:
			ctx->ip += 1;
	}
}

void handleInvoke(byte fnID, Value *args){
	switch(fnID){
	case FN_WRITE_DIGITAL:
		digitalWrite(args[0].i32, args[1].i32);
		break;
	case FN_WRITE_ANALOG:
		analogWrite(args[0].i32, args[1].i32);
		break;
	case FN_READ_DIGITAL:
		args->i32 = digitalRead(args->i32);
		break;
	case FN_READ_ANALOG:
		args->i32 = analogRead(args->i32);
		break;
	case FN_DELAY:
		delay(args->i32);
		break;
	case FN_ADD_FLOAT:
		args[0].f32 += args[1].f32;
		break;
	case FN_ADD_INT:
		args[0].i32 += args[1].i32;
		break;
	case FN_INCREASE:
		args->i32 += 1;
		break;
	case FN_DECREASE:
		args->i32 -= 1;
		break;
	case FN_IS_NOT_NEGATIVE:
		args->i32 = args->i32 >= 0;
		break;
	case FN_DUPLICATE:
		args[1].i32 = args[0].i32;
		break;
	case FN_CAST_INT_TO_FLOAT:
		args->f32 = args->i32;
		break;
	case FN_CAST_FLOAT_TO_INT:
		args->i32 = args->f32;
		break;
	}
}

unsigned long timestamp;
bool uploadMode = false;

void setup(){
	Serial.begin(115200);
	eeprom_busy_wait();
	timestamp = millis() + 2000;
}

void loop(){
	if(millis() < timestamp)return;
	if(uploadMode){
		upload();
	}else if(Serial.available() > 0){
		uploadMode = true;
	}else{
		run();
	}
}

void run(){
	Instruction code[200];
	unsigned int len = eeprom_read_word(0);
	eeprom_read_block(code, 2, len);
	exec(code, len / sizeof(Instruction));
	for(;;);
}

void upload(){
	const byte head_len = 8;
	const byte checksum_offset = 5;
	const byte size_offset = 6;

	const  byte buffer_len = 64;
	static byte buffer[buffer_len];
	static byte buffer_index = 0;

	int available = Serial.available();
	if(available <= 0)return;
	int recv_count = Serial.readBytes(buffer + buffer_index, available);
	if(recv_count <= 0)return;

	buffer_index += recv_count;

	if(buffer_index < head_len)return;
	byte checksum_value = buffer[checksum_offset];
	buffer[checksum_offset] = 0;
	if(strcmp(buffer, "write") != 0)run();

	unsigned int packet_len = *(unsigned int*)(buffer+size_offset);
	unsigned int body_len = packet_len - head_len;
	if(buffer_index < packet_len)return;

	if(checksum_value != checksum(buffer+head_len, body_len))run();

	eeprom_write_word(0, body_len);
	eeprom_write_block(buffer + head_len, 2, body_len);

	exec((Instruction*)(buffer + head_len), body_len / sizeof(Instruction));
	for(;;);
}

byte checksum(byte *data, int len)
{
	int sum = 0;
	for(int i=0; i<len; ++i)
		sum += data[i];
	return sum & 0xFF;
}
