
#define OP_JUMP 1
#define OP_JUMP_IF 2
#define OP_PUSH 3
#define OP_INVOKE 4
#define OP_SET 5
#define OP_GET 6

#define FN_INCREASE 5
#define FN_DECREASE 2
#define FN_IS_NOT_NEGATIVE 3
#define FN_DUPLICATE 4

#define FN_ADD_INT 11
#define FN_ADD_FLOAT 12
#define FN_CAST_INT_TO_FLOAT 13
#define FN_CAST_FLOAT_TO_INT 14

#define FN_DELAY 1
#define FN_READ_DIGITAL 52
#define FN_WRITE_DIGITAL 0
#define FN_READ_ANALOG 54
#define FN_WRITE_ANALOG 55

union Value {
	char i8[4];
	byte u8[4];
	int i16[2];
	unsigned int u16[2];
	long i32;
	unsigned long u32;
	float f32;
};

struct Instruction {
	byte type;
	Value data;
};

class Context {
public:
	Context():ip(0),sp(0){}
	void push(Value value){
		stack[sp++] = value;
	}
	Value pop(){
		return stack[--sp];
	}
	Value get(int index){
		return variable[index];
	}
	void set(int index, Value value){
		variable[index] = value;
	}
	Value arg(int index){
		return stack[sp+index];
	}
	Value* args(){
		return stack + sp;
	}
public:
	int ip;
	int sp;
private:
	Value stack[128];
	Value variable[20];
};

void exec(Instruction* start, int count)
{
	for(Context ctx; ctx.ip < count;){
		Instruction *instruction = start + ctx.ip;
		handleInstruction(&ctx, instruction->type, instruction->data);
	}
}

void handleInstruction(Context *ctx, byte type, Value data){
	if(type == OP_INVOKE){
		byte argCount = data.u8[2];
		byte retCount = data.u8[3];
		byte fnID = data.u16[0];
		ctx->sp -= argCount;
		handleInvoke(fnID, ctx->args());
		ctx->sp += retCount;
		ctx->ip += 1;
		return;
	}
	switch(type){
		case OP_JUMP:
			ctx->ip += data.i32;
			break;
		case OP_JUMP_IF:
			ctx->ip += ctx->pop().i32 ? data.i32 : 1;
			break;
		case OP_PUSH:
			ctx->push(data);
			ctx->ip += 1;
			break;
		case OP_SET:
			ctx->set(data.i32, ctx->pop());
			ctx->ip += 1;
			break;
		case OP_GET:
			ctx->push(ctx->get(data.i32));
			ctx->ip += 1;
			break;
		default:
			ctx->ip += 1;
	}
}

void handleInvoke(byte fnID, Value *args){
	switch(fnID){
	case FN_WRITE_DIGITAL:
		digitalWrite(args[0].i32, args[1].i32);
		break;
	case FN_WRITE_ANALOG:
		analogWrite(args[0].i32, args[1].i32);
		break;
	case FN_READ_DIGITAL:
		args->i32 = digitalRead(args->i32);
		break;
	case FN_READ_ANALOG:
		args->i32 = analogRead(args->i32);
		break;
	case FN_DELAY:
		delay(args->i32);
		break;
	case FN_ADD_FLOAT:
		args[0].f32 += args[1].f32;
		break;
	case FN_ADD_INT:
		args[0].i32 += args[1].i32;
		break;
	case FN_INCREASE:
		args->i32 += 1;
		break;
	case FN_DECREASE:
		args->i32 -= 1;
		break;
	case FN_IS_NOT_NEGATIVE:
		args->i32 = args->i32 >= 0;
		break;
	case FN_DUPLICATE:
		args[1].i32 = args[0].i32;
		break;
	case FN_CAST_INT_TO_FLOAT:
		args->f32 = args->i32;
		break;
	case FN_CAST_FLOAT_TO_INT:
		args->i32 = args->f32;
		break;
	}
}

unsigned long timestamp;
bool uploadMode = false;

void setup(){
	Serial.begin(115200);
	eeprom_busy_wait();
	timestamp = millis() + 2000;
}

void loop(){
	if(millis() < timestamp)return;
	if(uploadMode){
		upload();
	}else if(Serial.available() > 0){
		uploadMode = true;
	}else{
		run();
	}
}

void run(){
	Instruction code[200];
	unsigned int len = eeprom_read_word(0);
	eeprom_read_block(code, 2, len);
	exec(code, len / sizeof(Instruction));
	for(;;);
}

void upload(){
	const byte head_len = 8;

	static bool head_mode = true;
	static uint16_t packet_len = 0;
	static uint16_t offset = 0;

	if(head_mode){
		if(Serial.available() < head_len)return;
		head_mode = false;
		byte buffer[head_len];
		Serial.readBytes(buffer, head_len);
		if(strcmp(buffer, "write") != 0)run();
		packet_len = buffer[6] + buffer[7] * 256;
		eeprom_write_word(0, packet_len);
	}else if(offset >= packet_len){
		run();
	}else if(Serial.available() > 0){
		eeprom_write_byte(2 + offset++, Serial.read());
	}
}
