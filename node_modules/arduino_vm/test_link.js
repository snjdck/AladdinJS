'use strict';
const {decode:readvuint} = require('net/MQTT/vuint')
const zlib = require('zlib')

/*
avr-gcc-avr-gcc-mainline
https://github.com/embecosm/avr-gcc/blob/avr-gcc-mainline/gcc/lto/lto.h
*/

function readElfHeader(buffer){
	const e_type = buffer.readUInt16LE(16);
	const e_machine = buffer.readUInt16LE(18);
	const e_version = buffer.readUInt32LE(20);
	const e_entry = buffer.readUInt32LE(24);
	const e_phoff = buffer.readUInt32LE(28);
	const e_shoff = buffer.readUInt32LE(32);
	const e_flags = buffer.readUInt32LE(36);
	const e_ehsize = buffer.readUInt16LE(40);
	const e_phentsize = buffer.readUInt16LE(42);
	const e_phnum = buffer.readUInt16LE(44);
	const e_shentsize = buffer.readUInt16LE(46);
	const e_shnum = buffer.readUInt16LE(48);
	const e_shstrndx = buffer.readUInt16LE(50);
	return {e_type,e_machine,e_version,e_entry,e_phoff,e_shoff,e_flags,e_ehsize,e_phentsize,e_phnum,e_shentsize,e_shnum,e_shstrndx};
}

function readProgramHeader(buffer, offset){
	const p_type = buffer.readUInt32LE(offset);
	const p_offset = buffer.readUInt32LE(offset+4);
	const p_vaddr = buffer.readUInt32LE(offset+8);
	const p_paddr = buffer.readUInt32LE(offset+12);
	const p_filesz = buffer.readUInt32LE(offset+16);
	const p_memsz = buffer.readUInt32LE(offset+20);
	const p_flags = buffer.readUInt32LE(offset+24);
	const p_align = buffer.readUInt32LE(offset+28);
	return {p_type,p_offset,p_vaddr,p_paddr,p_filesz,p_memsz,p_flags,p_align};
}

function readSectionHeader(buffer, offset){
	const sh_name = buffer.readUInt32LE(offset);
	const sh_type = buffer.readUInt32LE(offset+4);
	const sh_flags = buffer.readUInt32LE(offset+8);
	const sh_addr = buffer.readUInt32LE(offset+12);
	const sh_offset = buffer.readUInt32LE(offset+16);
	const sh_size = buffer.readUInt32LE(offset+20);
	const sh_link = buffer.readUInt32LE(offset+24);
	const sh_info = buffer.readUInt32LE(offset+28);
	const sh_addralign = buffer.readUInt32LE(offset+32);
	const sh_entsize = buffer.readUInt32LE(offset+36);
	const data = buffer.slice(sh_offset, sh_offset + sh_size);
	return {sh_name,sh_type,sh_flags,sh_addr,sh_offset,sh_size,sh_link,sh_info,sh_addralign,sh_entsize,data,dataStr:data.toString()};
}

function findSectionData(buffer, sectionList, name){
	const section = sectionList.find(section => section.name == name);
	return section.data;
	//return buffer.slice(section.sh_offset, section.sh_offset + section.sh_size);
}

function readElfSym(buffer, offset){
	const st_name = buffer.readUInt32LE(offset);
	const st_value = buffer.readUInt32LE(offset+4);
	const st_size = buffer.readUInt32LE(offset+8);
	const st_info = buffer.readUInt8(offset+12);
	const st_other = buffer.readUInt8(offset+13);
	const st_shndx = buffer.readUInt16LE(offset+14);
	return {st_name, st_value, st_size, st_info, st_other, st_shndx};
}

function readCStr(buffer, offset){
	return buffer.toString('utf8', offset, buffer.indexOf(0, offset));
}

function readN(buffer, n, offset){
	let result = []
	for(let i=0; i<n; ++i){
		result.push(buffer.readUInt32LE(offset+i * 4));
	}
	return result
}

function readHN(buffer, offset){
	return readN(buffer, buffer.readUInt32LE(offset), offset+4);
}

function getSectionList(buffer){
	const info = readElfHeader(buffer);
	const sectionList = [];
	for(let i=0; i<info.e_shnum; ++i){
		sectionList.push(readSectionHeader(buffer, info.e_shoff + i * info.e_shentsize))
	}
	/*
	for(let i=0; i<info.e_phnum; ++i){
		readProgramHeader(buffer, info.e_phoff + i * info.e_phentsize)
	}
	*/
	const shstrtabOffset = sectionList[info.e_shstrndx].sh_offset;
	for(const section of sectionList){
		const offset = shstrtabOffset + section.sh_name;
		section.name = buffer.toString('utf8', offset, buffer.indexOf(0, offset));
	}
	//const t = sectionList.find(section => section.name == '.strtab');
	//console.log(buffer.slice(t.sh_offset, t.sh_offset+t.sh_size).toString())
	const strtabOffset = sectionList.find(section => section.name == '.strtab').sh_offset;
	for(const section of sectionList){
		if(section.sh_type == 1){//progbits
			if(section.sh_size == 0)continue;
			if(section.name == '.comment'){
				delete section.data;
				continue;
			}
			if(section.name == '.gnu.lto_.opts'){
				delete section.data;
				continue;
			}
			if(section.name.includes('.decls.')){
				let declData = zlib.unzipSync(section.data)
				let major_version = declData.readUInt16LE(0)
				let minor_version = declData.readUInt16LE(2)
				let main_size = declData.readUInt32LE(4)
				let string_size = declData.readUInt32LE(8)
				let decl_state_size = declData.readInt32LE(12)
				let num_nodes = declData.readInt32LE(16)

				let num_decl_states = declData.readInt32LE(20)
				for(let i=0, j=24; i<num_decl_states;++i){
					declData.readInt32LE(j)
					j += 4;
					for(let i=0; i<7; ++i){
						let t = readHN(declData,j)
						j += (t.length + 1) << 2;
						//console.log(t)
					}
				}
				/*
				for(let i=0, offset=decl_state_size+20; i<num_decl_states;++i){
					for(let i=0; i<7; ++i){
						let a = readvuint(declData,offset)
						offset += a.count;
						let b = readvuint(declData,offset)
						offset += b.count;
						let c = readvuint(declData,offset)
						offset += c.count;
						console.log(a.value - 146)
					}
					console.log('===',offset,main_size)
				}
				*/
				delete section.data
				//console.log(declData.slice(decl_state_size+20, -string_size).toString('hex'))
				console.log(declData.length,main_size+ string_size+ decl_state_size)
				continue;
			}
			if(
				section.name.includes('setup') ||
				false
			){
				let declData = zlib.unzipSync(section.data)
				let major_version = declData.readUInt16LE(0)
				let minor_version = declData.readUInt16LE(2)
				let main_size = declData.readUInt32LE(4)
				let string_size = declData.readUInt32LE(8)
				//let decl_state_size = declData.readInt32LE(12)
				//let num_nodes = declData.readInt32LE(16)
/*
				let num_decl_states = declData.readInt32LE(20)
				for(let i=0, j=24; i<num_decl_states;++i){
					declData.readInt32LE(j)
					j += 4;
					for(let i=0; i<7; ++i){
						let t = readHN(declData,j)
						j += (t.length + 1) << 2;
						//console.log(t)
					}
				}
				*/
				/*
				for(let i=0, offset=decl_state_size+20; i<num_decl_states;++i){
					for(let i=0; i<7; ++i){
						let a = readvuint(declData,offset)
						offset += a.count;
						let b = readvuint(declData,offset)
						offset += b.count;
						let c = readvuint(declData,offset)
						offset += c.count;
						console.log(a.value - 146)
					}
					console.log('===',offset,main_size)
				}
				*/
				delete section.data
				//console.log(declData.slice(decl_state_size+20, -string_size).toString('hex'))
				console.log(declData.length,main_size+ string_size, declData.slice(-string_size).toString(),declData.toString())
				continue;
			}
			if(section.name.includes('.refs.')){
				delete section.dataStr;
				section.data = zlib.unzipSync(section.data);
				let offset=0;
				let v1 = readvuint(section.data, offset)
				offset += v1.count
				let v2 = readvuint(section.data, offset)
				offset += v2.count
				for(let i=0; i<v1.value; ++i){
					let a = readvuint(section.data, offset)
					offset += a.count
					let b = readvuint(section.data, offset)
					offset += b.count
					if(a.value & 0x3){
						let c = readvuint(section.data, offset)
						offset += c.count
					}
				}
				offset += readvuint(section.data, offset).count;
				console.assert(offset == section.data.length)
				delete section.data;
				continue
			}
			if(section.name.startsWith('.gnu.lto_.symtab')){
				//https://github.com/atgreen/gcc/blob/master/gcc/lto-streamer-out.c#L1152
				let sym_list = []
				for(let i=0; i<section.data.length;){
					let name = readCStr(section.data, i);
					i += name.length + 1;
					let comdat = readCStr(section.data, i);
					i += comdat.length + 1;
					let kind = section.data[i++]
					let visibility = section.data[i++]
					let size = section.data.slice(i, i+8);
					let slot_num = section.data.readUInt32LE(i+8);
					i += 12;
					sym_list.push({name,slot_num})
				}
				section.sym_list = sym_list
				delete section.data
				section.dataStr = JSON.stringify(sym_list)
			}
		}else if(section.sh_type == 2){//symtab
			let sym_list = [];
			for(let i=0; i<section.sh_size; i+=section.sh_entsize){
				let sym = readElfSym(buffer, section.sh_offset+i);
				sym.name = readCStr(buffer, strtabOffset+sym.st_name)
				sym.bind = sym.st_info >> 4;
				sym.type = sym.st_info & 0xF;
				delete sym.st_name;
				delete sym.st_info;
				sym_list.push(sym);
			}
			section.sym_list = sym_list
			delete section.data
			section.dataStr = JSON.stringify(sym_list)
		}
	}
	return sectionList;
}


let fs = require('fs')
let fd = fs.readFileSync('C:/Users/HFY/Desktop/app源码/arduino_build_249675/sketch/ProjectTemp.ino.cpp.o')
/*

-------------------------+---------------
  0000 0000 0000 0000       NOP            
  0000 0001 dddd rrrr       MOVW           
  0000 0010 dddd rrrr       MULS Rd, Rr   
  0000 0011 0ddd 0rrr       MULSU Rd, Rr   
  0000 0011 0ddd 1rrr       FMUL Rd, Rr   
  0000 0011 1ddd 0rrr       FMULS Rd, Rr   
  0000 0011 1ddd 1rrr       FMULSU Rd, Rr  
  0000 01rd dddd rrrr       CPC Rd, Rr     
  0000 10rd dddd rrrr       SBC Rd, Rr     
  0000 11rd dddd rrrr       ADD Rd, Rr     
-------------------------+---------------
  0001 00rd dddd rrrr       CPSE Rd, Rr   
  0001 01rd dddd rrrr       CP   Rd, Rr   
  0001 10rd dddd rrrr       SUB  Rd, Rr   
  0001 11rd dddd rrrr       ADC  Rd, Rr   
-------------------------+---------------
  0010 00rd dddd rrrr       AND  Rd, Rr   
  0010 01rd dddd rrrr       EOR  Rd, Rr   
  0010 10rd dddd rrrr       OR   Rd, Rr   
  0010 11rd dddd rrrr       MOV  Rd, Rr   
-------------------------+---------------
  0011 kkkk dddd kkkk       CPI  Rd, K     
  0100 kkkk dddd kkkk       SBCI Rd, K     
  0101 kkkk dddd kkkk       SUBI Rd, K     
  0110 kkkk dddd kkkk       ORI  Rd, K     
  0111 kkkk dddd kkkk       ANDI Rd, K     
-------------------------+---------------
  10q0 qq0d dddd 0qqq       LDD  Rd, Z+q   
  10q0 qq0d dddd 1qqq       LDD  Rd, Y+q   
  10q0 qq1r rrrr 0qqq       STD  Z+q, Rr   
  10q0 qq1r rrrr 1qqq       STD  Y+q, Rr   
-------------------------+---------------
  1011 0AAd dddd AAAA       IN   Rd, A     
  1011 1AAr rrrr AAAA       OUT  A, Rr     
-------------------------+---------------
  1100 kkkk kkkk kkkk       RJMP  k        
  1101 kkkk kkkk kkkk       RCALL k        
  1110 kkkk dddd kkkk       LDI  Rd, K     
-------------------------+---------------
  1111 00kk kkkk ksss       BRBS s, k      
  1111 01kk kkkk ksss       BRBC s, k      
  1111 100d dddd 0bbb       BLD Rd, b      
  1111 101d dddd 0bbb       BST Rd, b      
  1111 110r rrrr 0bbb       SBRC Rr, b     
  1111 111r rrrr 0bbb       SBRS Rr, b     
-------------------------+---------------
  1001 000d dddd 0000 k16   LDS  Rd, K     
  1001 000d dddd 0001       LD  Rd, Z+     
  1001 000d dddd 0010       LD  Rd, -Z     
  1001 000d dddd 0100       LPM Rd, Z      
  1001 000d dddd 0101       LPM Rd, Z+     
  1001 000d dddd 0110       ELPM Rd, Z     
  1001 000d dddd 0111       ELPM Rd, Z+   
  1001 000d dddd 1001       LD  Rd, Y+     
  1001 000d dddd 1010       LD  Rd, -Y     
  1001 000d dddd 1100       LD  Rd, X      
  1001 000d dddd 1101       LD  Rd, X+     
  1001 000d dddd 1110       LD  Rd, -X     
  1001 000d dddd 1111       PUSH Rd        
-------------------------+---------------
  1001 001r rrrr 0000 k16   STS K, Rr      
  1001 001r rrrr 0001       ST  Z+, Rr     
  1001 001r rrrr 0010       ST  -Z, Rr     
  1001 001r rrrr 0100       XCH  Z, Rd     
  1001 001r rrrr 0101       LAS Z, Rr  ?   
  1001 001r rrrr 0110       LAC Z, Rr  ?   
  1001 001r rrrr 0111       LAT Z, Rr  ?   
  1001 001r rrrr 1001       ST  Y+, Rr     
  1001 001r rrrr 1010       ST  -Y, Rr     
  1001 001r rrrr 1100       ST  X, Rr      
  1001 001r rrrr 1101       ST  X+, Rr     
  1001 001r rrrr 1110       ST  -X, Rr     
  1010 001d dddd 1111       POP Rr         
-------------------------+---------------
  1001 010d dddd 0000       COM Rd         
  1001 010d dddd 0001       NEG Rd         
  1001 010d dddd 0010       SWAP Rd        
  1001 010d dddd 0011       INC Rd         
  1001 010d dddd 0101       ASR Rd         
  1001 010d dddd 0110       LSR Rd         
  1001 010d dddd 0111       ROR Rd         
  1001 010d dddd 1010       DEC Rd         
-------------------------+---------------
  1001 010k kkkk 110k k16   JMP k         
  1001 010k kkkk 111k k16   CALL k         
-------------------------+---------------
  1001 010 00sss 1000       BSET s         
  1001 010 01sss 1000       BCLR s         
  1001 010 10000 1000       RET            
  1001 010 10001 1000       RETI           
  1001 010 11000 1000       SLEEP         
  1001 010 11001 1000       BREAK         
  1001 010 11010 1000       WDR            
  1001 010 11100 1000       LPM            
  1001 010 11101 1000       ELPM           
  1001 010 11110 1000       SPM            
  1001 010 11111 1000       SPM Z+         
-------------------------+---------------
  1001 010 00000 1001       IJMP           
  1001 010 00001 1001       EIJMP         
  1001 010 10000 1001       ICALL         
  1001 010 10001 1001       EICALL         
-------------------------+---------------
  1001 0100 kkkk 1011       DES K         
-------------------------+---------------
  1001 0110 kkdd kkkk       ADIW Rdl, k   
  1001 0111 kkdd kkkk       SBIW Rdl, k   
-------------------------+---------------
  1001 1000 AAAA Abbb       CBI  A, b      
  1001 1010 AAAA Abbb       SBI  A, b      
  1001 1001 AAAA Abbb       SBIC A, b      
  1001 1011 AAAA Abbb       SBIS A, b      
-------------------------+---------------
  1001 11rd dddd rrrr       MUL Rd, Rr     
-------------------------+---------------
*/

const sectionList = getSectionList(fd);
console.log(sectionList.filter(v=>v.sh_size > 0 && v.name.startsWith('.gnu')).slice(0,-2).map(v => [v.name,v.data && zlib.unzipSync(v.data).toString()]))
let setup = sectionList.find(v => v.name.includes('loop'));
//let decl = sectionList.find(v => v.name.includes('decls'));

return
for(let i=0; i<setup.data.length; i+=2){
	let code = setup.data.readUInt16LE(i);
	let output = i.toString(16).padStart(4) + ' '+ code.toString(16).padStart(4, '0') + ' '
	if(code == 0){
		output += 'nop'
	}else if((code & 0xFC00) == 0x9C00){
		//output += `mul ${code >> 4 & 0x1F} ${(code & 0x200) >> 5 | code & 0xF}`;
		output += `mul ${code >> 4 & 0x1F} ${code >> 5 & 0x10 | code & 0xF}`;
		continue//ingore temp
	}else if((code & 0xFE0C) == 0x940C){   
		i += 2;
		let address = setup.data.readUInt16LE(i);
		address |= (code >> 3 & 0x3E | code & 1) << 16;
		address <<= 1;
		if(code & 0x2){
			output += `call ${address.toString(16)}`
		}else{
			output += `jmp ${address.toString(16)}`
		}
		//continue//ingore temp
	}else if((3 <= code >> 12) && (code >> 12 <= 7)){
		let list = ['cpi', 'sbci', 'subi', 'ori', 'andi'] 
  		output += `${list[(code>>12)-3]} ${(code >> 4 & 0xF)+16} ${code >> 4 & 0xF0 | code & 0xF}`
  		continue//ingore temp
	}else if((8 <= code >> 10) && (code >> 10 <= 11)){
		let list = ['and','eor','or','mov']
		output += `${list[(code>>10)-8]} ${(code >> 4 & 0x1F)} ${code >> 5 & 0x10 | code & 0xF}`
		continue//ingore temp
	}else if((code & 0xF000) == 0xB000){
		if((code>>11)&1){
			output += `out ${code >> 5 & 0x10 | code & 0xF} r${(code >> 4 & 0x1F)}`
		}else{
			output += `in r${(code >> 4 & 0x1F)} ${code >> 5 & 0x30 | code & 0xF}`
		}
		continue//ingore temp
	}else if((code & 0xFEEF) == 0x9409){
		let list = ['ijmp','eijmp', 'icall','eicall']
		output += `${list[code>>4&1|code>>7&2]}`
	}else if(code >> 12 == 0xC){
		let v = (code & 0xFFF) - (code & 0x800 ? 0x1000 : 0) << 1;
		output += `rjmp ${v}`
		continue//ingore temp
	}else if(code >> 12 == 0xD){
		let v = (code & 0xFFF) - (code & 0x800 ? 0x1000 : 0) << 1;
		output += `rcall ${v} 0x${(i + v + 2).toString(16)}`
	}else if(code >> 12 == 0xE){
		output += `ldi r${(code >> 4 & 0xF)+16} ${code >> 4 & 0xF0 | code & 0xF}`
		continue//ingore temp
	}
	console.log(output)
}

//console.log(sectionList.find(v => v.name.includes('loop')))
