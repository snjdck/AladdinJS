'use strict';

async function recordMicrophone(){
	const stream = await navigator.mediaDevices.getUserMedia({audio:true});
	const bufferSize = 16384;
	const context = new AudioContext();
	const microphone = context.createMediaStreamSource(stream);
	const recorder = context.createScriptProcessor(bufferSize, 1, 1);
	const list = [];//element type = Float32Array
	recorder.onaudioprocess = evt => list.push(evt.inputBuffer.getChannelData(0).slice());

	microphone.connect(recorder);
	recorder.connect(context.destination);

	return function(){
		microphone.disconnect();
		recorder.disconnect();
		context.close();
		const compress = Math.floor(context.sampleRate / 16000);
		const result = new Int16Array(bufferSize * list.length / compress);
		for(let i=0, n=result.length; i<n; ++i){
			const index = i * compress;
			const value = list[Math.floor(index / bufferSize)][index % bufferSize];
			result[i] = Math.max(-1, Math.min(1, value)) * (value < 0 ? 0x8000 : 0x7FFF);
		}
		return result;
	}
}

function encodeWAV(data){
	const buffer = Buffer.alloc(44 + data.length);
	buffer.write('RIFF', 0);
	buffer.writeUInt32LE(36 + data.length, 4);
	buffer.write('WAVE', 8);
	buffer.write('fmt ', 12);
	buffer.writeUInt32LE(16, 16);
	buffer.writeUInt16LE(1, 20);//format = 1(pcm)
	buffer.writeUInt16LE(1, 22);//channel = 1
	buffer.writeUInt32LE(16000, 24);//sampleRate
	buffer.writeUInt32LE(32000, 28);//byteRate = channel * sampleRate * (sampleBits / 8)
	buffer.writeUInt16LE(2, 32);//blockAlign = channel * (sampleBits / 8)
	buffer.writeUInt16LE(16, 34);//sampleBits
	buffer.write('data', 36);
	buffer.writeUInt32LE(data.length, 40);
	data.copy(buffer, 44);
	return buffer;
}

exports.recordMicrophone = recordMicrophone;
exports.encodeWAV = encodeWAV;
