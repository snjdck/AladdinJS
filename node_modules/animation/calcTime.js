
function calcTime(time, duration, {reverse=false, rewind=false, repeat=true}){
	if(duration <= 0)return 0;
	if(repeat){
		time = rewind && (time / duration & 1) ? duration - time % duration : time % duration;
	}else if(rewind){
		time = time > duration ? duration - (time - duration) : time;
	}
	return reverse ? duration - time : time;
	//return Math.max(0, Math.min(duration, reverse ? duration - time : time));
}
/*
const PlayAnimationAction = updateFn => (animation, timeScale, flags) => function*(target){
	const count = flags.repeat ? Infinity : flags.rewind ? 2 : 1;
	const duration = animation.duration;
	for(let time=0;;){
		updateFn(target, animation, calcTime(time, duration, flags));
		if(time >= duration * count)break;
		time = (yield) * timeScale;
	}
};
*/

function findTarget(list, time){
	for(let i=0, n=list.length-1; i<=n; ++i){
		const test = list[i];
		if(i < n && time > test.duration){
			time -= test.duration;
			continue;
		}
		return [test, time];
	}
}

const reduceFn = (v, a) => v + a.duration;
const PlayAnimationListAction = updateFn => (animationList, timeScale, flags) => function*(target){
	const count = flags.repeat ? Infinity : flags.rewind ? 2 : 1;
	const duration = animationList.reduce(reduceFn, 0);
	for(let time=0;;){
		updateFn(target, ...findTarget(animationList, calcTime(time, duration, flags)));
		if(time >= duration * count)break;
		time = (yield) * timeScale;
	}
};

function parseModeArg(mode){
	mode = mode.split('-');
	const reverse = mode.includes('reverse');
	const repeat = mode.includes('repeat');
	const rewind = mode.includes('rewind');
	return {reverse, repeat, rewind};
}

exports.PlayAnimationListAction = PlayAnimationListAction;
exports.parseModeArg = parseModeArg;
