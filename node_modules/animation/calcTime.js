
function calcTime(time, duration, {reverse=false, rewind=false, repeat=true}){
	if(repeat){
		time = rewind && (time / duration & 1) ? duration - time % duration : time % duration;
	}else if(rewind){
		time = time > duration ? duration - (time - duration) : time;
	}
	return Math.max(0, Math.min(duration, reverse ? duration - time : time));
}
/*
const PlayAnimationAction = updateFn => (animation, timeScale, flags) => function*(target){
	const count = flags.repeat ? Infinity : flags.rewind ? 2 : 1;
	const duration = animation.duration;
	for(let time=0;;){
		updateFn(target, animation, calcTime(time, duration, flags));
		if(time >= duration * count)break;
		time = (yield) * timeScale;
	}
};
*/
const reduceFn = (v, a) => v + a.duration;
const PlayAnimationListAction = updateFn => (animationList, timeScale, flags) => function*(target){
	const count = flags.repeat ? Infinity : flags.rewind ? 2 : 1;
	const duration = animationList.reduce(reduceFn, 0);
	for(let time=0;;){
		let aniTime = calcTime(time, duration, flags);
		for(let animation of animationList){
			if(aniTime > animation.duration){
				aniTime -= animation.duration;
				continue;
			}
			updateFn(target, animation, aniTime);
			break;
		}
		if(time >= duration * count)break;
		time = (yield) * timeScale;
	}
};

function parseModeArg(mode){
	mode = mode.split('-');
	const reverse = mode.includes('reverse');
	const repeat = mode.includes('repeat');
	const rewind = mode.includes('rewind');
	return {reverse, repeat, rewind};
}

exports.PlayAnimationListAction = PlayAnimationListAction;
exports.parseModeArg = parseModeArg;
