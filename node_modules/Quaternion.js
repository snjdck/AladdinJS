class Quaternion
{
	static slerp(a, b, percent, result){
		var x1 = a.x, y1 = a.y, z1 = a.z, w1 = a.w;
		var x2 = b.x, y2 = b.y, z2 = b.z, w2 = b.w;
		
		var dot = x1*x2 + y1*y2 + z1*z2 + w1*w2;
		
		if(dot < 0){
			dot = -dot;
			x2 = -x2;
			y2 = -y2;
			z2 = -z2;
			w2 = -w2;
		}
		
		if(dot < 0.95){//正常插值
			var angle = Math.acos(dot);
			var s = 1 / Math.sin(angle);
			var s1 = s * Math.sin(angle * (1 - percent));
			var s2 = s * Math.sin(angle * percent);
			
			result.x = x1*s1 + x2*s2;
			result.y = y1*s1 + y2*s2;
			result.z = z1*s1 + z2*s2;
			result.w = w1*s1 + w2*s2;
		}else{//线性插值
			result.x = x1 + (x2-x1) * percent;
			result.y = y1 + (y2-y1) * percent;
			result.z = z1 + (z2-z1) * percent;
			result.w = w1 + (w2-w1) * percent;
			
			result.normalize();
		}
	}

	static fromAxisAngle(axis, angle){
		var halfAngle = angle * 0.5;
		var sin = Math.sin(halfAngle);
		return new Quaternion(
			axis.x * sin,
			axis.y * sin,
			axis.z * sin,
			Math.cos(halfAngle)
		);
	}

	constructor(x=0, y=0, z=0, w=1){
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}

	identity(){
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.w = 1;
	}

	setTo(x, y, z, w){
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}

	copyFrom(other){
		this.x = other.x;
		this.y = other.y;
		this.z = other.z;
		this.w = other.w;
	}

	normalize(){
		var factor = 1 / Math.sqrt(x*x + y*y + z*z + w*w);
		this.x *= factor;
		this.y *= factor;
		this.z *= factor;
		this.w *= factor;
	}

	negate(){
		this.w = - this.w;
	}

	fromEulerAngles(pitch, yaw, roll){
		var halfX = 0.5 * pitch;
		var halfY = 0.5 * yaw;
		var halfZ = 0.5 * roll;
		
		var sinX = Math.sin(halfX);
		var cosX = Math.cos(halfX);
		
		var sinY = Math.sin(halfY);
		var cosY = Math.cos(halfY);
		
		var sinZ = Math.sin(halfZ);
		var cosZ = Math.cos(halfZ);
		
		this.x = sinX*cosY*cosZ - cosX*sinY*sinZ;
		this.y = sinY*cosZ*cosX + cosY*sinZ*sinX;
		this.z = sinZ*cosX*cosY - cosZ*sinX*sinY;
		this.w = cosX*cosY*cosZ + sinX*sinY*sinZ;
	}

	toEulerAngles(result){
		const {x, y, z, w} = this;
		result.x = Math.atan2(2*(w*x+y*z), 1-2*(x*x+y*y));
		result.y = Math.asin( 2*(w*y-x*z));
		result.z = Math.atan2(2*(w*z+y*x), 1-2*(z*z+y*y));
	}

	toAxisAngle(result){
		if(1 == w){
			result.x = 1;
			result.y = 0;
			result.z = 0;
			result.w = 0;
			return;
		}
		
		var halfAngle = Math.acos(this.w);
		var factor = 1 / Math.sin(halfAngle);
		
		result.x = this.x * factor;
		result.y = this.y * factor;
		result.z = this.z * factor;
		result.w = 2 * halfAngle;
	}

	prepend(other, result){
		var {x, y, z, w} = this;

		var tx = other.x;
		var ty = other.y;
		var tz = other.z;
		var tw = other.w;
		
		result.x = (w * tx) + (x * tw) + (y * tz) - (z * ty);
		result.y = (w * ty) - (x * tz) + (y * tw) + (z * tx);
		result.z = (w * tz) + (x * ty) - (y * tx) + (z * tw);
		result.w = (w * tw) - (x * tx) - (y * ty) - (z * tz);
	}

	rotateVector(v, result){
		var {x, y, z, w} = this;

		var xx = x*x;
		var yy = y*y;
		var zz = z*z;
		var ww = w*w;
		
		var xy = x*y;
		var yz = y*z;
		var xz = x*z;
		var xw = x*w;
		var yw = y*w;
		var zw = z*w;
		
		var vx = v.x;
		var vy = v.y;
		var vz = v.z;
		
		result.x = vx * (xx + ww - yy - zz) + (vy * (xy - zw) + vz * (xz + yw)) * 2;
		result.y = vy * (yy + ww - zz - xx) + (vz * (yz - xw) + vx * (xy + zw)) * 2;
		result.z = vz * (zz + ww - xx - yy) + (vx * (xz - yw) + vy * (yz + xw)) * 2;
	}

	toMatrix(result, translation){
		//复制区域--begin
		const {x, y, z, w} = this;
		
		var xx = x*x;
		var yy = y*y;
		var zz = z*z;
		var ww = w*w;
		
		var xy2 = 2*x*y;
		var xz2 = 2*x*z;
		var xw2 = 2*x*w;
		var yz2 = 2*y*z;
		var yw2 = 2*y*w;
		var zw2 = 2*z*w;
		//复制区域--end
		
		result[0]  = xx + ww - yy - zz;
		result[4]  = xy2 - zw2;
		result[8]  = xz2 + yw2;
		
		result[1]  = xy2 + zw2;
		result[5]  = yy + ww - zz - xx;
		result[9]  = yz2 - xw2;
		
		result[2]  = xz2 - yw2;
		result[6]  = yz2 + xw2;
		result[10] = zz + ww - xx - yy;
		
		result[12] = translation.x;
		result[13] = translation.y;
		result[14] = translation.z;
		
		result[3] = result[7] = result[11] = 0;
		result[15] = 1;
	}
}

module.exports = Quaternion;