"use strict";

function findPath(startNode, endNode){
	const openen = new BinHeap("f");
	const closed = [];

	startNode.g = 0;
	startNode.f = startNode.heuristic(endNode);

	let currentNode = startNode;

	while(currentNode != endNode){
		closed.push(currentNode);
		for(let testNode of currentNode.neighbours){
			if (null == testNode) continue;
			if (!currentNode.canWalkTo(testNode)) continue;
			if (closed.includes(testNode)) continue;
			
			let isTestNodeInOpen = opened.has(testNode);
			let g = currentNode.g + currentNode.heuristic(testNode);
			let f = g + testNode.heuristic(endNode);
			if(isTestNodeInOpen && f >= testNode.f){
				continue;
			}
			testNode.parent = currentNode;
			testNode.g = g;
			if(isTestNodeInOpen){
				opened.update(testNode, f);
			}else{
				testNode.f = f;
				opened.push(testNode);
			}
		}
		if(opened.isEmpty()){
			return null;
		}
		currentNode = opened.shift();
	}
	
	return buildPath(startNode, endNode);
}

function buildPath(startNode, endNode){
	let path = [endNode];
	let node = endNode;
	
	while(node != startNode){
		node = node.parent;
		path.push(node);
	}
	
	path.reverse();
	
	for(let i=0; i<path.length; ++i){
		node = path[i];
		if(!node.walkable){
			path.splice(i);
			break;
		}
	}
	
	return path;
}

class AStarGridNode{
	constructor(x, y, context){
		this.context = context;
		this.x = x;
		this.y = y;
		this.parent = null;
		this.neighbours = [];
		//f = g + h, this prop is also used in binHeap
		this.f = this.g = 0;
	}

	get data(){
		return this.context.data;
	}

	get grid(){
		return this.context.grid;
	}

	get costMultiplier(){
		return this.walkable ? 1.0 : 10000;
	}
	
	get walkable(){
		return 0 == this.data[y][x];
	}
	
	set walkable(value){
		this.setValue(value?0:1);
	}
	
	setValue(value){
		this.data[y][x] = value;
	}
	
	toString(){
		const {x, y} = this;
		return "[Node(x=" + x + ", y=" + y + ")]";
	}
	
	canWalkTo(target){
		const {x, y} = this;
		return target.walkable && grid[y][target.x].walkable && grid[target.y][x].walkable;
	}
	
	heuristic(target){
		return Euclidian(this, target);
	}
}

function createGrid(data){
	let context = {data};
	let grid = data.map((row, y) => row.map((_, x) => new AStarGridNode(x, y, context)));
	context.grid = grid;
	grid.forEach(row => row.forEach(calcNeighbours));
	return grid;
}

function calcNeighbours(node){
	const {grid, x, y, neighbours} = node;
	
	var startX = Math.max(0, x - 1);
	var startY = Math.max(0, y - 1);
	var endX = Math.min(grid[0].length - 1, x + 1);
	var endY = Math.min(grid.length - 1, y + 1);
	
	for(var i=startX; i<=endX; i++){
		for(var j=startY; j<=endY; j++){
			var test = grid[j][i];
			if(test != node){
				neighbours.push(test);
			}
		}
	}
}

const STRAIGHT_COST = 1.0;
const DIAG_COST = Math.SQRT2;

function Diagonal(a, b){
	var dx = Math.abs(a.x - b.x);
	var dy = Math.abs(a.y - b.y);
	var diag = Math.min(dx, dy);
	return DIAG_COST * diag + STRAIGHT_COST * (dx + dy - 2 * diag);
}

function Euclidian(a, b){
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return Math.hypot(dx, dy) * STRAIGHT_COST;
}

function Manhattan(a, b){
	return STRAIGHT_COST * ( Math.abs(a.x - b.x) + Math.abs(a.y - b.y) );
}

module.exports = {
	createGrid,
	findPath
};