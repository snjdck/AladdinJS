"use strict";

/**
 * 00 01
 * 10 11
 */
class QuadTree{
	constructor(parent, centerX, centerY, halfSize, minSize){
		this.bound = new AABB();
		this.hasNode = false;
		this.nodeList = null;
		this.hasItem = false;
		this.itemList = null;
		this.parent = parent;
		this.centerX = centerX;
		this.centerY = centerY;
		this.bound.setCenterAndHalfSize(centerX, centerY, 0, halfSize, halfSize, 0);
		if(halfSize > minSize){
			this.createChildren(halfSize >> 1, minSize);
		}
	}
	
	createChildren(childHalfSize, minSize){
		const {centerX, centerY} = this;
		this.hasNode = true;
		this.nodeList = [
			new QuadTree(this, centerX - childHalfSize, centerY - childHalfSize, childHalfSize, minSize),
			new QuadTree(this, centerX + childHalfSize, centerY - childHalfSize, childHalfSize, minSize),
			new QuadTree(this, centerX - childHalfSize, centerY + childHalfSize, childHalfSize, minSize),
			new QuadTree(this, centerX + childHalfSize, centerY + childHalfSize, childHalfSize, minSize)
		];
	}
	
	classifyNode(item){
		const {centerX, centerY} = this;
		let isInTopQuadrant = item.y + item.height <= centerY;
		let isInBottomQuadrant = item.y >= centerY;
		if(!(isInTopQuadrant || isInBottomQuadrant)){
			return this;
		}
		let isInLeftQuadrant = item.x + item.width <= centerX;
		let isInRightQuadrant = item.x >= centerX;
		if(!(isInLeftQuadrant || isInRightQuadrant)){
			return this;
		}
		let index = (isInTopQuadrant ? 0 : 2) | (isInLeftQuadrant ? 0 : 1);
		return this.nodeList[index];
	}
	
	findTargetTree(item){
		let targetTree = this;
		for(;;){
			if(!targetTree.hasNode)
				break;
			let testTree = targetTree.classifyNode(item);
			if(testTree == targetTree)
				break;
			targetTree = testTree;
		}
		return targetTree;
	}
		
	insert(item){
		let targetTree = this.findTargetTree(item);
		if(targetTree.hasItem){
			targetTree.itemList.push(item);
		}else{
			targetTree.itemList = [item];
			targetTree.hasItem = true;
		}
		let nodeBound = item.getBound();
		if(nodeBound.halfSizeZ <= 0){
			return;
		}
		do{
			targetTree.bound.mergeZ(nodeBound);
			targetTree = targetTree.parent;
		}while(targetTree != null);
	}
	
	getObjectsInFrustum(viewFrustum, result){
		let queue = [this];
		while(queue.length > 0){
			let currentNode = queue.pop();
			switch(viewFrustum.classify(currentNode.bound)){
				case ClassifyResult.INTERSECT:
					if(currentNode.hasItem){
						for(let item of currentNode.itemList){
							if(viewFrustum.classify(item.getBound()) <= 0){
								result.push(item);
							}
						}
					}
					if(currentNode.hasNode){
						queue.push(...currentNode.nodeList);
					}
					break;
				case ClassifyResult.CONTAINS:
					currentNode.collectObjsRecursively(result);
					break;
			}
		}
	}
	
	collectObjsRecursively(items){
		let queue = [this];
		while(queue.length > 0){
			let currentNode = queue.pop();
			if(currentNode.hasNode) queue.push(...currentNode.nodeList);
			if(currentNode.hasItem) items.push(...currentNode.itemList);
		}
	}
}

module.exports = QuadTree;