'use strict';

const {createListGetter} = require('utils/cache');

class ItemSlot
{
	constructor(){
		this.itemList = [];
		this.price = 0;
	}

	clear(){
		this.itemList.length = 0;
		this.price = 0;
	}

	add(item){
		this.itemList.push(item);
		this.price += item.price;
	}

	copyFrom(target){
		this.itemList.length = 0;
		this.itemList.push(...target.itemList);
		this.price = target.price;
	}
}

const slotList = createListGetter(() => new ItemSlot());

const Pack = logic => (itemList, capacity) => {
	if(null == itemList || itemList.length < 1)return;
	for(let i=0; i<=capacity; ++i)slotList(i).clear();
	for(let item of itemList)logic(slotList, item, capacity);
	return slotList(capacity);
}

function onZeroOne(slotList, item, capacity){
	for(let totalWeight=capacity; totalWeight>=item.weight; --totalWeight){
		let itemSlotNotUse = slotList(totalWeight);
		let itemSlotUse = slotList(totalWeight-item.weight);
		if(itemSlotNotUse.price >= itemSlotUse.price + item.price)continue;
		itemSlotNotUse.copyFrom(itemSlotUse);
		itemSlotNotUse.add(item);
	}
}

function onUnbounded(slotList, item, capacity){
	for(let totalWeight=item.weight; totalWeight<=capacity; ++totalWeight){
		let itemSlotNotUse = slotList(totalWeight);
		let itemSlotUse = slotList(totalWeight-item.weight);
		if(itemSlotNotUse.price >= itemSlotUse.price + item.price)continue;
		itemSlotNotUse.copyFrom(itemSlotUse);
		itemSlotNotUse.add(item);
	}
}

function*split(n){
	for(let v=1; v<n; v<<=1){
		yield v;
		n -= v;
	}
	yield n;
}

exports.ZeroOnePack   = Pack(onZeroOne);
exports.UnboundedPack = Pack(onUnbounded);
