const Render2D = require("Render2D");
const Render3D = require("Render3D");

const Scene2D = require("Scene2D");
const Scene3D = require("Scene3D");

class View3D
{
	constructor(){
		var canvas = document.getElementById("canvas");
		var gl = canvas.getContext("webgl2");
		
		gl.__program__ = {};
		gl.render2d = new Render2D(gl);
		gl.render3d = new Render3D(gl);

		gl.clearColor(0.0, 0.0, 0.0, 1.0);
		gl.clearDepth(1.0);
		gl.clearStencil(0);
		gl.viewport(0, 0, canvas.width, canvas.height);

		this.gl = gl;
		this.scene3d = new Scene3D();
		this.scene2d = new Scene2D();

		this.paused = false;
		this.timeScale = 1;

		this.onTick = this.onTick.bind(this);
		
		this.timestamp = performance.now();
		requestAnimationFrame(this.onTick);
	}

	onTick(timestamp){
		requestAnimationFrame(this.onTick);
		if(this.paused){
			return;
		}
		const timeElapsed = (timestamp - this.timestamp) * this.timeScale;
		this.timestamp = timestamp;
		const gl = this.gl;
		this.updateScene(timeElapsed);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		this.drawScene();
	}

	updateScene(timeElapsed){
		this.scene3d.update(timeElapsed);
		this.scene2d.update(timeElapsed);
	}

	drawScene(){
		this.scene3d.draw(this.gl);
		this.scene2d.draw(this.gl);
	}

	registerProgram(...nameList){
		const fs = require("fs");
		for(var name of nameList){
			var vertexSource   = fs.readFileSync(`shaders/${name}.vs`, "utf8");
			var fragmentSource = fs.readFileSync(`shaders/${name}.fs`, "utf8");
			var program = newProgram(this.gl, vertexSource, fragmentSource);
			this.gl.__program__[name] = program;
			program.name = name;
		}
	}
}

module.exports = View3D;

function newShader(gl, source, type){
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
		var info = gl.getShaderInfoLog(shader);
		alert(info);
		throw new Error(info);
	}
	return shader;
}

function newProgram(gl, vertexSource, fragmentSource){
	var program = gl.createProgram();
	gl.attachShader(program, newShader(gl, vertexSource,   gl.VERTEX_SHADER));
	gl.attachShader(program, newShader(gl, fragmentSource, gl.FRAGMENT_SHADER));
	gl.linkProgram(program);
	if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
		var info = gl.getProgramInfoLog(program);
		alert(info);
		throw new Error(info);
	}
	return program;
}

function createDomTexture(id){
	var gl = this;
	var image = document.getElementById(id);

	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	texture.width = image.width;
	texture.height = image.height;

	return texture;
}

function createSampler(gl){
	//gl.bindSampler(0, sampler);
	var sampler = gl.createSampler();
	gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	return sampler;
}

WebGLRenderingContext.prototype.createDomTexture = createDomTexture;
WebGL2RenderingContext.prototype.createDomTexture = createDomTexture;