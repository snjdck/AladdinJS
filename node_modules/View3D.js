"use strict";

const Render2D = require("Render2D");
const Render = require("Render");

const Scene2D = require("Scene2D");
const Scene3D = require("Scene3D");

const MouseManager = require("./MouseManager");

class View3D
{
	constructor(canvas, width=canvas.width, height=canvas.height){
		let gl = canvas.getContext("webgl2");
		printWebGLInfo(gl);

		this.width = width;
		this.height = height;

		this.canvas = canvas;
		this.gl = gl;
		this.scene3d = new Scene3D();
		this.scene2d = new Scene2D(width, height);
		this.mouseMgr = new MouseManager(this);
		
		gl.__program__ = {};
		gl.mouseMgr = this.mouseMgr;
		gl.render2d = new Render2D(gl);
		gl.render = new Render(gl);

		gl.clearDepth(1);
		gl.clearStencil(0);
		gl.viewport(0, 0, canvas.width, canvas.height);

		this.paused = false;
		this.timeScale = 1;

		this.onTick = this.onTick.bind(this);
		
		this.timestamp = performance.now();
		requestAnimationFrame(this.onTick);
	}

	onTick(timestamp){
		requestAnimationFrame(this.onTick);
		if(this.paused){
			return;
		}
		const {gl, mouseMgr} = this;
		const timeElapsed = (timestamp - this.timestamp) * this.timeScale;
		this.timestamp = timestamp;
		
		this.updateScene(timeElapsed);

		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		this.drawScene("normal");

		mouseMgr.update();
	}

	updateScene(timeElapsed){
		this.scene3d.update(timeElapsed);
		this.scene2d.update(timeElapsed);
	}

	drawScene(mode){
		this.scene3d.draw(this.gl, mode);
		this.scene2d.draw(this.gl, mode);
	}

	registerProgram(...nameList){
		for(var name of nameList){
			let [vn, fn] = name.split("&", 2);
			let vertexSource   = loadSource(`${vn}.vs`);
			let fragmentSource = loadSource(`${fn}.fs`);
			let program = newProgram(this.gl, vertexSource, fragmentSource);
			this.gl.__program__[name] = program;
			program.name = name;
		}
	}
}

module.exports = View3D;

function loadSource(path){
	let fs = require("fs");
	let source = fs.readFileSync(`shaders/${path}`, "utf8");
	return source.replace(/^#include\s*<(.+)>$/gm, function(){
		return loadSource(arguments[1]);
	});
}

function newShader(gl, source, type){
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
		var info = gl.getShaderInfoLog(shader);
		alert(info);
		throw new Error(info);
	}
	return shader;
}

function newProgram(gl, vertexSource, fragmentSource){
	var program = gl.createProgram();
	gl.attachShader(program, newShader(gl, vertexSource,   gl.VERTEX_SHADER));
	gl.attachShader(program, newShader(gl, fragmentSource, gl.FRAGMENT_SHADER));
	gl.linkProgram(program);
	if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
		var info = gl.getProgramInfoLog(program);
		alert(info);
		throw new Error(info);
	}
	return program;
}

function createDomTexture(id){
	var gl = this;
	var image = document.getElementById(id);

	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	texture.width = image.width;
	texture.height = image.height;

	return texture;
}

function createSampler(gl){
	//gl.bindSampler(0, sampler);
	var sampler = gl.createSampler();
	gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	return sampler;
}

WebGLRenderingContext.prototype.createDomTexture = createDomTexture;
WebGL2RenderingContext.prototype.createDomTexture = createDomTexture;

function printWebGLInfo(gl){
	//language: GLSL ES 3.00
	let keyList = [
	"MAX_RENDERBUFFER_SIZE",
	"MAX_TEXTURE_SIZE",
	"MAX_VERTEX_ATTRIBS",
	"MAX_VERTEX_UNIFORM_VECTORS",
	"MAX_FRAGMENT_UNIFORM_VECTORS",
	"MAX_VERTEX_TEXTURE_IMAGE_UNITS",
	"MAX_TEXTURE_IMAGE_UNITS",
	"MAX_VARYING_VECTORS",
	"MAX_DRAW_BUFFERS"
	];
	console.log(new Map(keyList.map(key => [key, gl.getParameter(gl[key])])));
}