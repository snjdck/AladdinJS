"use strict";

/*
[x, y, z, 1] * matrix4x4 * matrix4x4
*/
const Quaternion = require("./Quaternion");
const Vector3D = require("./Vector3D");

const tempVector = new Vector3D();

/* 缩放,旋转,偏移 */
class Matrix3D{
	static Interpolate(a, b, f, result){
		Vector3D.Interpolate(a.translation, b.translation, f, result.translation);
		Quaternion.Slerp(a.rotation, b.rotation, f, result.rotation);
		result.scale = a.scale * (1 - f) + b.scale * f;
	}

	static concat(left, right, result){
		let {rotation:rotationL, translation:translationL, scale:scaleL} = left;
		let {rotation:rotationR, translation:translationR, scale:scaleR} = right;
		rotationR.rotateVector(translationL, tempVector);
		translationR.add(tempVector.scaleBy(scaleR), result.translation);
		rotationR.prepend(rotationL, result.rotation);
		result.scale = scaleL * scaleR;
	}

	static invert(matrix, result){
		let {rotation, translation} = result;
		let scale = 1 / matrix.scale;
		matrix.translation.scaleBy(-scale, translation);
		matrix.rotation.negate(rotation);
		rotation.rotateVector(translation, translation);
		result.scale = scale;
	}

	constructor(){
		this.rotation = new Quaternion();
		this.translation = new Vector3D();
		this.scale = 1;
	}

	identity(){
		this.translation.setTo(0, 0, 0);
		this.rotation.setTo(0, 0, 0, 1);
		this.scale = 1;
	}
	
	copyFrom(source){
		this.translation.copyFrom(source.translation);
		this.rotation.copyFrom(source.rotation);
		this.scale = source.scale;
	}

	append(other, result=this){
		Matrix3D.concat(this, other, result);
	}
	
	prepend(other, result=this){
		Matrix3D.concat(other, this, result);
	}
	
	invert(result=this){
		Matrix3D.invert(this, result);
	}

	interpolate(to, f, result){
		return Matrix3D.Interpolate(this, to, f, result);
	}

	upload(gl, address){
		//this.rotation.toMatrix(buffer, this.translation);
		//gl.uniformMatrix4fv(address, false, buffer);
		let {rotation, translation} = this;
		buffer[0] = rotation.x;
		buffer[1] = rotation.y;
		buffer[2] = rotation.z;
		buffer[3] = rotation.w;
		buffer[4] = translation.x;
		buffer[5] = translation.y;
		buffer[6] = translation.z;
		buffer[7] = this.scale;
		gl.uniform4fv(address, buffer);
	}

	copyToArray(list, offset=0){
		let {rotation, translation} = this;
		rotation.copyToArray(list, offset);
		translation.copyToArray(list, offset + 4);
		list[offset+7] = this.scale;
	}
}

const buffer = new Float32Array(8);

module.exports = Matrix3D;