<style>
body{
	margin: 0;
	background-color: dimgray;
}
#editor-canvas {
	border: 1px solid gray;
	background-color: white;
	position: absolute;
	left: 100px;
	top: 100px;
}
#editor-canvas.is-composing {
	border-color: red;
}
</style>
<canvas id="editor-canvas"></canvas>
<script>

let currentLineNo = 0;
const FONT_SIZE = 40;

const canvas = document.getElementById('editor-canvas');
const ctx = canvas.getContext('2d');
ctx.textBaseline = 'top';
ctx.font = `${FONT_SIZE}px Consolas`;
const editContext = new EditContext();
canvas.editContext = editContext;

const calcTextWidth = v => v ? ctx.measureText(v).width : 0;

function calcXY(offset){
	const list = editContext.text.slice(0, offset).split('\n');
	return [calcTextWidth(list.at(-1)), list.length-1];
}

function calcRangeXY(start, end){
	const list1 = editContext.text.slice(0, Math.min(start, end)).split('\n');
	const list2 = editContext.text.slice(0, Math.max(start, end)).split('\n');
	const result = [];
	for(let y=list1.length-1, n=list2.length; y<=n; ++y){
		const offset = calcTextWidth(list1[y]);
		result.push([offset, y, calcTextWidth(list2[y]) - offset]);
	}
	return result;
}

const getCurrLineStart = offset => {
	let index = editContext.text.lastIndexOf('\n', offset-1);
	return index < 0 ? 0 : index+1;
}

const getCurrLineEnd = offset => {
	let index = editContext.text.indexOf('\n', offset);
	return index < 0 ? editContext.text.length : index;
}

function showText(){
	console.log(editContext.selectionStart, editContext.selectionEnd)
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	const {selectionStart, selectionEnd} = editContext;
	if(selectionStart != selectionEnd){
		ctx.fillStyle = 'yellow';
		for(let [x, y, width] of calcRangeXY(selectionStart, selectionEnd)){
			ctx.fillRect(x, y * FONT_SIZE, width, FONT_SIZE);
		}
		ctx.fillStyle = 'black';
	}
	let y = 0;
	let offset = 0;
	for(let text of editContext.text.replaceAll('\t', ' '.repeat(4)).split('\n')){
		ctx.fillText(text, 0, y * FONT_SIZE);
		if(offset <= selectionStart && selectionStart <= offset + text.length){
			const info = ctx.measureText(editContext.text.slice(offset, selectionStart));
			ctx.fillRect(info.width, y * FONT_SIZE, 1, FONT_SIZE);//caret
		}
		offset += text.length + 1;
		++y;
	}
}

editContext.addEventListener('textformatupdate', evt => {
	for(let format of evt.getTextFormats()){
		const list = editContext.text.slice(0, format.rangeStart).split('\n');
		const {width, alphabeticBaseline} = ctx.measureText(list.at(-1));
		const y = (list.length - 1) * FONT_SIZE - alphabeticBaseline;
		ctx.beginPath();
		ctx.moveTo(width, y);
		ctx.lineTo(ctx.measureText(list.at(-1) + editContext.text.slice(format.rangeStart, format.rangeEnd)).width, y);
		ctx.stroke();
	}
});
editContext.addEventListener('characterboundsupdate', function(){
	function computeCharacterBound(offset){
		const list = editContext.text.slice(0, offset).split('\n');
		const widthBeforeChar = ctx.measureText(list.at(-1)).width;
		const charX = canvas.offsetLeft + widthBeforeChar;
		const charY = canvas.offsetTop + (list.length-1) * FONT_SIZE;
		return DOMRect.fromRect({
			x: charX,
			y: charY,
			width: ctx.measureText(editContext.text[offset]).width,
			height: FONT_SIZE,
		});
	}
	return evt => {
		const charBounds = [];
		for (let offset=evt.rangeStart; offset<evt.rangeEnd; offset++){
			charBounds.push(computeCharacterBound(offset));
		}
		editContext.updateCharacterBounds(evt.rangeStart, charBounds);
	}
}());
editContext.addEventListener('textupdate', (evt) => {
	showText();
});
editContext.addEventListener('compositionstart', (event) => {
	canvas.classList.add('is-composing');
});
editContext.addEventListener('compositionend', (event) => {
	canvas.classList.remove('is-composing');
});


const calcPositionWithXY = function(){
	const reduceFn = (a, b) => a + b.length + 1;
	const calcCharCount = v => v.reduce(reduceFn, 0);
	return function({offsetX, offsetY}){
		const list = editContext.text.split('\n')
		const y = Math.floor(offsetY / FONT_SIZE);
		if(y >= list.length)return editContext.text.length;
		const text = list[y];
		let lastWidth = 0;
		for(let i=0; i<text.length; ++i){
			const {width} = ctx.measureText(text.slice(0, i+1));
			if(offsetX <= width){
				const result = calcCharCount(list.slice(0, y)) + i;
				if(offsetX > 0.5 * (width + lastWidth)){
					return result + 1;
				}
				return result;
			}
			lastWidth = width;
		}
		return calcCharCount(list.slice(0, y+1)) - 1;
	}
}();


function onPointerMove(evt){
	const offset = calcPositionWithXY(evt);
	editContext.updateSelection(editContext.selectionStart, offset);
	showText();
}

function onPointerUp(evt){
	canvas.releasePointerCapture(evt.pointerId);
	canvas.removeEventListener('pointermove', onPointerMove);
	canvas.removeEventListener('pointerup', onPointerUp);
}

canvas.addEventListener('pointerdown', evt => {
	canvas.setPointerCapture(evt.pointerId);
	canvas.addEventListener('pointermove', onPointerMove);
	canvas.addEventListener('pointerup', onPointerUp);
	ctx.fillRect(evt.offsetX, evt.offsetY, 10, 10)
	const offset = calcPositionWithXY(evt);
	editContext.updateSelection(offset, offset);
	showText();
})
let caretOffset = 0;
function insertText(text){
	editContext.updateText(editContext.selectionStart, editContext.selectionEnd, text);
	const offset = editContext.selectionStart + text.length;
	editContext.updateSelection(offset, offset);
	showText();
}
document.addEventListener('keydown', evt => {
	//console.log(evt.key, evt.code);
	const keyCode = evt.code;
	if(keyCode == 'Tab'){
		evt.preventDefault();
		insertText('\t');
	}else if(keyCode == 'Enter'){
		insertText('\n');
	}else if(keyCode == 'ArrowUp'){
		const offset = editContext.selectionStart;
		const prevLineEnd = editContext.text.lastIndexOf('\n', offset-1);
		if(prevLineEnd < 0)return;
		const prevLineStart = getCurrLineStart(prevLineEnd);
		const width = offset - (prevLineEnd + 1);
		const v = Math.min(prevLineStart + width, prevLineEnd);
		editContext.updateSelection(v, v);
		showText();
	}else if(keyCode == 'ArrowDown'){
		const offset = editContext.selectionStart;
		let nextLineStart = editContext.text.indexOf('\n', offset);
		if(nextLineStart < 0)return;
		nextLineStart++;
		const nextLineEnd = getCurrLineEnd(nextLineStart);
		const currLineStart = getCurrLineStart(offset);
		const width = offset - currLineStart;
		const v = Math.min(nextLineStart + width, nextLineEnd);
		editContext.updateSelection(v, v);
		showText();
	}else if(keyCode == 'ArrowLeft'){
		if(editContext.selectionStart > 0){
			let offset = editContext.selectionStart - 1;
			editContext.updateSelection(offset, offset);
			showText();
		}
	}else if(keyCode == 'ArrowRight'){
		if(editContext.selectionStart < editContext.text.length){
			let offset = editContext.selectionStart + 1;
			editContext.updateSelection(offset, offset);
			showText();
		}
	}else if(keyCode == 'Home'){
		let value = 0;
		if(!evt.ctrlKey){
			const prevLineEnd = editContext.text.lastIndexOf('\n', editContext.selectionStart-1);
			if(prevLineEnd >= 0){
				value = prevLineEnd + 1;
			}
		}
		if(editContext.selectionStart != value || editContext.selectionEnd != value){
			editContext.updateSelection(value, value);
			showText();
		}
	}else if(keyCode == 'End'){
		let value = editContext.text.length;
		if(!evt.ctrlKey){
			const currLineEnd = editContext.text.indexOf('\n', editContext.selectionStart);
			if(currLineEnd >= 0){
				value = currLineEnd;
			}
		}
		if(editContext.selectionStart != value || editContext.selectionEnd != value){
			editContext.updateSelection(value, value);
			showText();
		}
	}else if(keyCode == 'KeyA'){
		if(!evt.ctrlKey)return;
		if(editContext.selectionStart != 0 || editContext.selectionEnd != editContext.text.length){
			editContext.updateSelection(0, editContext.text.length);
			showText();
		}
	}else if(keyCode == 'KeyC'){
		if(!evt.ctrlKey)return;
		navigator.clipboard.writeText(editContext.text.substring(editContext.selectionStart, editContext.selectionEnd));
	}else if(keyCode == 'KeyV'){
		if(!evt.ctrlKey)return;
		navigator.clipboard.readText().then(insertText);
	}
})

</script>