<style>
body{
	margin: 0;
	background-color: dimgray;
}
#editor-canvas {
	border: 1px solid gray;
	background-color: white;
	position: absolute;
	left: 100px;
	top: 100px;
}
#editor-canvas.is-composing {
	border-color: red;
}
</style>
<canvas id="editor-canvas"></canvas>
<script>

let currentLineNo = 0;
const FONT_SIZE = 40;

const canvas = document.getElementById('editor-canvas');
const ctx = canvas.getContext('2d');
ctx.textBaseline = 'top';
ctx.font = `${FONT_SIZE}px Consolas`;
const editContext = new EditContext();
canvas.editContext = editContext;

function calcXY(offset){
	const list = editContext.text.slice(0, offset).split('\n');
	const {width} = ctx.measureText(list.at(-1));
	return [width, (list.length-1) * FONT_SIZE];
}

function showText(){
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	let y = 0;
	let offset = 0;
	const {selectionStart} = editContext;
	for(let text of editContext.text.replaceAll('\t', ' '.repeat(4)).split('\n')){
		ctx.fillText(text, 0, y * FONT_SIZE);
		if(offset <= selectionStart && selectionStart <= offset + text.length){
			const info = ctx.measureText(editContext.text.slice(offset, selectionStart));
			ctx.fillRect(info.width, y * FONT_SIZE, 1, FONT_SIZE);//caret
		}
		offset += text.length + 1;
		++y;
	}
}

editContext.addEventListener('textformatupdate', evt => {
	for(let format of evt.getTextFormats()){
		const list = editContext.text.slice(0, format.rangeStart).split('\n');
		const {width, alphabeticBaseline} = ctx.measureText(list.at(-1));
		const y = (list.length - 1) * FONT_SIZE - alphabeticBaseline;
		ctx.beginPath();
		ctx.moveTo(width, y);
		ctx.lineTo(ctx.measureText(list.at(-1) + editContext.text.slice(format.rangeStart, format.rangeEnd)).width, y);
		ctx.stroke();
	}
});
editContext.addEventListener('characterboundsupdate', function(){
	function computeCharacterBound(offset){
		const list = editContext.text.slice(0, offset).split('\n');
		const widthBeforeChar = ctx.measureText(list.at(-1)).width;
		const charX = canvas.offsetLeft + widthBeforeChar;
		const charY = canvas.offsetTop + (list.length-1) * FONT_SIZE;
		return DOMRect.fromRect({
			x: charX,
			y: charY,
			width: ctx.measureText(editContext.text[offset]).width,
			height: FONT_SIZE,
		});
	}
	return evt => {
		const charBounds = [];
		for (let offset=evt.rangeStart; offset<evt.rangeEnd; offset++){
			charBounds.push(computeCharacterBound(offset));
		}
		editContext.updateCharacterBounds(evt.rangeStart, charBounds);
	}
}());
editContext.addEventListener('textupdate', (evt) => {
	showText();
});
editContext.addEventListener('compositionstart', (event) => {
	canvas.classList.add('is-composing');
});
editContext.addEventListener('compositionend', (event) => {
	canvas.classList.remove('is-composing');
});

canvas.addEventListener('mousedown', evt => {
	const {offsetX, offsetY} = evt;
	let list = editContext.text.split('\n')
	let y = Math.floor(offsetY / FONT_SIZE);
	ctx.fillRect(evt.offsetX, evt.offsetY, 10, 10)
	let result;
	if(y < list.length){
		let text = list[y];
		let lastWidth = 0;
		for(let i=0; i<text.length; ++i){
			let {width} = ctx.measureText(text.slice(0, i+1));
			if(offsetX <= width){
				result = list.slice(0, y).reduce((a, b) => a + b.length + 1, 0) + i;
				if(offsetX > 0.5 * (width + lastWidth)){
					result++;
				}
				break;
			}
			lastWidth = width;
		}
		if(result == null){
			result = list.slice(0, y+1).reduce((a, b) => a + b.length + 1, 0) - 1;
		}
	}else{
		result = editContext.text.length;
	}
	editContext.updateSelection(result, result);
	showText();
})
let caretOffset = 0;
function insertText(text){
	editContext.updateText(editContext.selectionStart, editContext.selectionEnd, text);
	const offset = editContext.selectionStart + text.length;
	editContext.updateSelection(offset, offset);
	showText();
}
document.addEventListener('keydown', evt => {
	//console.log(evt.key, evt.code);
	const keyCode = evt.code;
	if(keyCode == 'Tab'){
		evt.preventDefault();
		insertText('\t');
	}else if(keyCode == 'KeyV'){
		if(!evt.ctrlKey)return;
		navigator.clipboard.readText().then(v => {
			insertText(v);
		});
	}else if(keyCode == 'Enter'){
		insertText('\n');
	}else if(keyCode == 'ArrowUp'){
		const offset = editContext.selectionStart;
		const prevLineEnd = editContext.text.lastIndexOf('\n', offset-1);
		if(prevLineEnd < 0)return;
		let prevLineStart = editContext.text.lastIndexOf('\n', prevLineEnd-1);
		prevLineStart = prevLineStart < 0 ? 0 : prevLineStart + 1;
		const width = offset - (prevLineEnd + 1);
		const v = Math.min(prevLineStart + width, prevLineEnd);
		editContext.updateSelection(v, v);
		showText();
	}else if(keyCode == 'ArrowDown'){
		const offset = editContext.selectionStart;
		let nextLineStart = editContext.text.indexOf('\n', offset);
		if(nextLineStart < 0)return;
		nextLineStart++;
		let nextLineEnd = editContext.text.indexOf('\n', nextLineStart);
		nextLineEnd = nextLineEnd < 0 ? editContext.text.length : nextLineEnd;
		let currLineStart = editContext.text.lastIndexOf('\n', offset-1);
		currLineStart = currLineStart < 0 ? 0 : currLineStart + 1;
		const width = offset - currLineStart;
		const v = Math.min(nextLineStart + width, nextLineEnd);
		editContext.updateSelection(v, v);
		showText();
	}else if(keyCode == 'ArrowLeft'){
		if(editContext.selectionStart > 0){
			let offset = editContext.selectionStart - 1;
			editContext.updateSelection(offset, offset);
			showText();
		}
	}else if(keyCode == 'ArrowRight'){
		if(editContext.selectionStart < editContext.text.length){
			let offset = editContext.selectionStart + 1;
			editContext.updateSelection(offset, offset);
			showText();
		}
	}else if(keyCode == 'Home'){
		let value = 0;
		if(!evt.ctrlKey){
			const prevLineEnd = editContext.text.lastIndexOf('\n', editContext.selectionStart-1);
			if(prevLineEnd >= 0){
				value = prevLineEnd + 1;
			}
		}
		if(editContext.selectionStart != value || editContext.selectionEnd != value){
			editContext.updateSelection(value, value);
			showText();
		}
	}else if(keyCode == 'End'){
		let value = editContext.text.length;
		if(!evt.ctrlKey){
			const currLineEnd = editContext.text.indexOf('\n', editContext.selectionStart);
			if(currLineEnd >= 0){
				value = currLineEnd;
			}
		}
		if(editContext.selectionStart != value || editContext.selectionEnd != value){
			editContext.updateSelection(value, value);
			showText();
		}
	}
})

</script>