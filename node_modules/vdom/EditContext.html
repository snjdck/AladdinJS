<style>
body{
	margin: 0;
}
#editor-canvas {
  border: 5px solid green;
  background-color: pink;
  position: absolute;
  left: 100px;
  top: 100px;
}
#editor-canvas.is-composing {
  border-color: red;
}
</style>
<canvas id="editor-canvas"></canvas>
<script>

const lineList = [''];
let currentLineNo = 0;

const canvas = document.getElementById("editor-canvas");
const editContext = new EditContext();
canvas.editContext = editContext;

function showText(){
	console.log(lineList)
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	for(let i=0; i<lineList.length; ++i){
		ctx.fillText(lineList[i], 0, i * FONT_SIZE);
	}
}

editContext.addEventListener("textformatupdate", evt => {
	for(let format of evt.getTextFormats()){
		let a = ctx.measureText(editContext.text.slice(0, format.rangeStart))
		let b = ctx.measureText(editContext.text.slice(0, format.rangeEnd))
		ctx.beginPath()
		ctx.moveTo(a.width, (currentLineNo+1)*FONT_SIZE-6);
		ctx.lineTo(b.width, (currentLineNo+1)*FONT_SIZE-6);
		ctx.stroke();
	}
});

editContext.addEventListener("textupdate", (evt) => {
	console.log('textupdate', evt.text)
	lineList[currentLineNo] = editContext.text;
	showText();
});
editContext.addEventListener("compositionstart", (event) => {
	canvas.classList.add("is-composing");
});

editContext.addEventListener("compositionend", (event) => {
	canvas.classList.remove("is-composing");
});

document.addEventListener('keydown', evt => {
	//console.log(evt.code)
	if(evt.key == 'Backspace'){
		if(editContext.selectionStart > 0)return;
		if(currentLineNo == 0)return;
		evt.preventDefault();
		let lastLine = lineList[currentLineNo-1];
		editContext.updateText(0, 0, lastLine);
		editContext.updateSelection(lastLine.length, lastLine.length);
		lineList[currentLineNo-1] += lineList[currentLineNo];
		lineList.splice(currentLineNo, 1);
		--currentLineNo;
		showText();
	}else if(evt.key == 'Enter'){
		lineList[currentLineNo] = editContext.text.slice(0, editContext.selectionStart);
		lineList.splice(++currentLineNo, 0, editContext.text.slice(editContext.selectionStart))
		editContext.updateText(0, editContext.selectionStart, '');
		editContext.updateSelection(0, 0);
		showText();
	}else if(evt.key == 'ArrowUp'){
		if(currentLineNo <= 0)return;
		--currentLineNo;
		editContext.updateText(0, editContext.text.length, lineList[currentLineNo]);
		if(editContext.selectionStart > editContext.text.length){
			editContext.updateSelection(editContext.text.length, editContext.text.length);
		}
	}else if(evt.key == 'ArrowDown'){
		if(currentLineNo >= lineList.length-1)return;
		++currentLineNo;
		editContext.updateText(0, editContext.text.length, lineList[currentLineNo]);
		if(editContext.selectionStart > editContext.text.length){
			editContext.updateSelection(editContext.text.length, editContext.text.length);
		}
	}else if(evt.key == 'ArrowLeft'){
		if(editContext.selectionStart > 0){
			let offset = editContext.selectionStart - 1;
			editContext.updateSelection(offset, offset);
		}else if(currentLineNo > 0){
			--currentLineNo;
			editContext.updateText(0, editContext.text.length, lineList[currentLineNo]);
			editContext.updateSelection(editContext.text.length, editContext.text.length);
		}
	}else if(evt.key == 'ArrowRight'){
		if(editContext.selectionStart < editContext.text.length){
			let offset = editContext.selectionStart + 1;
			editContext.updateSelection(offset, offset);
		}else if(currentLineNo < lineList.length-1){
			++currentLineNo;
			editContext.updateText(0, editContext.text.length, lineList[currentLineNo]);
			editContext.updateSelection(0, 0);
		}
	}
})

const FONT_SIZE = 40;
const FONT = `${FONT_SIZE}px Consolas`;

const ctx = canvas.getContext("2d");
ctx.textBaseline = 'top';
ctx.font = FONT;

function computeCharacterBound(offset) {
	const widthBeforeChar = ctx.measureText(editContext.text.substring(0, offset)).width;

	const charX = canvas.offsetLeft + widthBeforeChar;
	const charY = canvas.offsetTop;

	return DOMRect.fromRect({
		x: charX,
		y: charY + currentLineNo * FONT_SIZE,
		width: ctx.measureText(editContext.text[offset]).width,
		height: FONT_SIZE,
	});
}

editContext.addEventListener("characterboundsupdate", evt => {
	const charBounds = [];
	for (let offset = evt.rangeStart; offset < evt.rangeEnd; offset++) {
		charBounds.push(computeCharacterBound(offset));
	}
	editContext.updateCharacterBounds(evt.rangeStart, charBounds);
});

</script>