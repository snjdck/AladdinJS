<style>
body{
	margin: 0;
}
.editor {
	overflow: auto;
	counter-reset: line;
	white-space: pre;
	tab-size: 4;
	--padding: 4px;
	font-family: Consolas;
}
.editor > * {
	display: table-row;
	text-indent: var(--padding);
}
.editor > ::before {
	display: table-cell;
	content: counter(line);
	counter-increment: line;
	position: sticky;
	left: 0;
	text-align: right;
	padding-right: var(--padding);
	border-right: 1px solid gray;
	background-color: #ccc;
	color: #666;
}
</style>
<style>
::highlight(operator) {
	color: #ff0000;
}
::highlight(string) {
	color: #00bcd4;
}
::highlight(literal) {
	color: #8600fc;
}
::highlight(keywords) {
	color: #9e9e9e;
}
::highlight(args) {
	color: #00ff00;
}
</style>

<script src="./acorn.js"></script>
<script>

const handler = {
	Program: 'BlockStatement',
	BlockStatement(node, ctx){
		node.body.forEach(v => this(v, ctx));
	},
	Identifier(node, ctx){
		if(ctx.argsFlag){
			ctx.args.push(node);
		}else if(node.name == 'undefined'){
			ctx.literal.push(node);
		}
	},
	FunctionDeclaration(node, ctx){
		ctx.keywords.push({start: node.start, end: node.id?.start ?? ctx.input.indexOf('(', node.start)});
		ctx.argsFlag = true;
		node.params.forEach(v => this(v, ctx));
		ctx.argsFlag = false;
		this(node.body, ctx);
	},
	FunctionExpression: 'FunctionDeclaration',
	ArrowFunctionExpression(node, ctx){
		let index = ctx.input.indexOf('=>', node.start);
		ctx.keywords.push({start: index, end: index+2});
		if(node.async){
			ctx.keywords.push({start: node.start, end: node.start+5});
		}
		ctx.argsFlag = true;
		node.params.forEach(v => this(v, ctx));
		ctx.argsFlag = false;
		this(node.body, ctx);
	},
	AwaitExpression: 'ReturnStatement',
	YieldExpression: 'ReturnStatement',
	ThrowStatement: 'ReturnStatement',
	ReturnStatement(node, ctx){
		if(node.argument){
			ctx.operator.push({start:node.start, end:node.argument.start});
			this(node.argument, ctx);
		}else{
			ctx.operator.push(node);
		}
	},
	ExpressionStatement(node, ctx){
		this(node.expression, ctx);
	},
	CallExpression(node, ctx){
		this(node.callee, ctx);
		node.arguments.forEach(v => this(v, ctx));
	},
	SpreadElement(node, ctx){
		ctx.operator.push({start:node.start,end:node.argument.start});
		this(node.argument, ctx);
	},
	RestElement: 'SpreadElement',
	MemberExpression(node, ctx){
		this(node.object, ctx);
		this(node.property, ctx);
	},
	EmptyStatement(node, ctx){
	},
	UnaryExpression(node, ctx){
		this(node.argument, ctx);
		ctx.operator.push({start:node.start, end:node.argument.start});
	},
	BinaryExpression(node, ctx){
		this(node.left, ctx);
		this(node.right, ctx);
		ctx.operator.push({start:node.left.end, end:node.right.start});
	},
	AssignmentExpression: 'BinaryExpression',
	LogicalExpression: 'BinaryExpression',
	Literal(node, ctx){
		if(typeof node.value == 'string'){
			ctx.str.push(node);
		}else{
			ctx.literal.push(node);
		}
	},
	VariableDeclaration(node, ctx){
		node.declarations.forEach(v => this(v, ctx));
		ctx.keywords.push({start:node.start,end:node.declarations[0].start});
	},
	VariableDeclarator(node, ctx){
		if(node.init){
			this(node.init, ctx);
			ctx.operator.push({start:node.id.end, end:node.init.start});
		}
	},
	ConditionalExpression(node, ctx){
		ctx.operator.push({start:node.test.end, end:node.consequent.start});
		ctx.operator.push({start:node.consequent.end, end:node.alternate.start});
		this(node.test, ctx);
		this(node.consequent, ctx);
		this(node.alternate, ctx);
	},
	IfStatement(node, ctx){
		ctx.operator.push({start:node.start, end:ctx.input.indexOf('(', node.start)});
		this(node.test, ctx);
		this(node.consequent, ctx);
		if(node.alternate){
			ctx.operator.push({start:node.consequent.end, end:node.alternate.start});
			this(node.alternate, ctx);
		}
	},
	WhileStatement(node, ctx){
		ctx.operator.push({start:node.start, end:ctx.input.indexOf('(', node.start)});
		this(node.test, ctx);
		this(node.body, ctx);
	},
	DoWhileStatement(node, ctx){
		ctx.operator.push({start:node.start, end:node.body.start});
		ctx.operator.push({start:node.body.end, end:ctx.input.indexOf('(', node.body.end)});
		this(node.test, ctx);
		this(node.body, ctx);
	},
	ForStatement(node, ctx){
		this(node.init, ctx);
		this(node.test, ctx);
		this(node.update, ctx);
		this(node.body, ctx);
		ctx.operator.push({start:node.start,end:ctx.input.indexOf('(', node.start)});
	},
	ForInStatement(node, ctx){
		this(node.right, ctx);
		this(node.left, ctx);
		this(node.body, ctx);
		ctx.operator.push({start:node.start,end:ctx.input.indexOf('(', node.start)});
		ctx.operator.push({start:node.left.end,end:node.right.start});
	},
	ForOfStatement: 'ForInStatement',
	BreakStatement(node, ctx){
		if(node.label){
			ctx.operator.push({start: node.start, end: node.label.start});
		}else{
			ctx.operator.push(node);
		}
	},
	ContinueStatement: 'BreakStatement',
	LabeledStatement(node, ctx){
		this(node.body, ctx);
	},
	UpdateExpression(node, ctx){
		this(node.argument, ctx);
		if(node.prefix){
			ctx.operator.push({start:node.start, end:node.argument.start});
		}else{
			ctx.operator.push({start:node.argument.end, end:node.end});
		}
	},
	ArrayExpression(node, ctx){
		node.elements.forEach(v => this(v, ctx));
	},
	ObjectExpression(node, ctx){
		node.properties.forEach(v => this(v, ctx));
	},
	Property(node, ctx){
		this(node.key, ctx);
		this(node.value, ctx);
	},
	NewExpression(node, ctx){
		ctx.operator.push({start: node.start, end: node.callee.start});
		this(node.callee, ctx);
		node.arguments.forEach(v => this(v, ctx));
	},
	DebuggerStatement(node, ctx){
		ctx.operator.push(node);
	},
	ThisExpression(node, ctx){
		ctx.args.push(node);
	},
	SequenceExpression(node, ctx){
		node.expressions.forEach(v => this(v, ctx));
	},
	SwitchStatement(node, ctx){
		ctx.operator.push({start:node.start, end:node.start+6});//switch
		this(node.discriminant, ctx);
		node.cases.forEach(v => this(v, ctx));
	},
	SwitchCase(node, ctx){
		if(node.test){
			ctx.operator.push({start:node.start, end:node.test.start});
			this(node.test, ctx);
		}else{
			ctx.operator.push({start:node.start, end:node.start+7});//default
		}
		node.consequent.forEach(v => this(v, ctx));
	},
	TryStatement(node, ctx){
		ctx.operator.push({start: node.start, end: node.block.start});
		this(node.block, ctx);
		if(node.handler){
			ctx.operator.push({start: node.handler.start, end: node.handler.start+5});
			this(node.handler, ctx);
		}
		if(node.finalizer){
			ctx.operator.push({start: (node.handler ?? node.block).end, end: node.finalizer.start});
			this(node.finalizer, ctx);
		}
	},
	CatchClause(node, ctx){
		this(node.body, ctx);
	},
	TemplateLiteral(node, ctx){
		node.quasis.forEach(v => this(v, ctx));
		node.expressions.forEach(v => this(v, ctx));
	},
	TemplateElement(node, ctx){
		ctx.str.push(node);
	},
	TaggedTemplateExpression(node, ctx){
		ctx.keywords.push(node.tag);
		this(node.quasi, ctx);
	}
};

function walk(node, ctx){
	console.log(node);
	let fn = handler[node.type];
	while(typeof fn == 'string'){
		fn = handler[fn];
	}
	fn.call(walk, node, ctx);
	return ctx;
}


document.addEventListener('DOMContentLoaded', () => {
	loadData(`
		abc:{
			console.log(100,'2')
			break abc
		}
		document.addEventListener('DOMContentLoaded', async () => 0);
		document.addEventListener('DOMContentLoaded', () => {});
		document.addEventListener('DOMContentLoaded', async text => {});
		let c = \`efsfsdfsfsdfsd\${100}sdfsd\`
		let d = abc\`efsfsdfsfsdfsd\${100}sdfsd\`
switch(2){
	case    '1'   :print(0);break
	default     :

}
		try{

		}catch  {

		}finally{

		}

		try{

		} finally {

		}

		try{

		}   catch(e){

		}   finally  {

		}
document.addEventListener('DOMContentLoaded', (a, b, c, ...srga) => {
	loadData()
	return
	return new Cls()
	return  -1 + !0 + ~5
});

async function loadData(text, ...args){
	document.body.innerHTML = '';
	await console.log(100,200,true,false,null,undefined,3.12)

	const div = document.createElement('div');
	div.setAttribute('class', 'editor');
	document.body.appendChild(div);

	for(let code in text.split('\\n')){
		break;
		continue;
		let child = div.appendChild(document.createElement('code'));
		let span = child.appendChild(document.createElement('span'));
		span.textContent = code || '\\n';
	}
	for(let code of text.split('\\n'));
	for(let i=0; i<10; ++i){

	}
	for(let i=0; i<10; i--){

	}
	while(1){

	}

	do{

	} while ( 0 );

	if(0){}else if(0?5:7){}else{}
		if(0){
			console.log(...[], a['b'],a.b)
		}

	function *a(){
		yield
		yield 1
		yield * 0
		throw 0
	}
	(function(a,b){this;debugger;a={a:1,b:2,c(a,b,c,...d){
	}}})
}


`)
});

function loadData(text){
	let info = walk(acorn.parse(text), {input:text, str:[],args:[],operator:[],keywords:[],literal:[]})
	console.log(info)
	document.body.innerHTML = '';

	const div = document.createElement('div');
	div.setAttribute('class', 'editor');
	document.body.appendChild(div);

	const textNodeList = [];

	for(let code of text.match(/.*\n/g)){
		let child = div.appendChild(document.createElement('div'));
		let span = child.appendChild(document.createElement('span'));
		span.textContent = code;
		textNodeList.push(span.firstChild);
	}

	CSS.highlights.clear();
	CSS.highlights.set("literal", createHighlight(textNodeList, info.literal));
	CSS.highlights.set("string", createHighlight(textNodeList, info.str));
	CSS.highlights.set("operator", createHighlight(textNodeList, info.operator));
	CSS.highlights.set("keywords", createHighlight(textNodeList, info.keywords));
	CSS.highlights.set("args", createHighlight(textNodeList, info.args));
}

function createHighlight(textNodeList, list){
	let result = [];
	let offset = 0;
	for(let node of textNodeList){
		for(let {start, end} of list){
			if(offset >= end)continue;
			if(offset + node.textContent.length <= start)continue;
			const range = new Range();
			range.setStart(node, start - offset);
			range.setEnd(node, end - offset);
			result.push(range);
		}
		offset += node.textContent.length;
	}
	return new Highlight(...result);
}


</script>