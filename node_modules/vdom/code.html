<style>
body{
	margin: 0;
}
.editor {
	overflow: auto;
	counter-reset: line;
	white-space: pre;
	tab-size: 4;
	--padding: 4px;
}
.editor > * {
	display: table-row;
	text-indent: var(--padding);
}
.editor > ::before {
	display: table-cell;
	content: counter(line);
	counter-increment: line;
	position: sticky;
	left: 0;
	text-align: right;
	padding-right: var(--padding);
	border-right: 1px solid gray;
	background-color: #ccc;
	color: #666;
}
</style>
<style>
	
::highlight(let) {
	color: red;
}
</style>


<script>

document.addEventListener('DOMContentLoaded', () => {
	loadData(`
document.addEventListener('DOMContentLoaded', () => {
	loadData()
});

function loadData(text){
	document.body.innerHTML = '';

	const div = document.createElement('div');
	div.setAttribute('class', 'editor');
	document.body.appendChild(div);

	for(let code of text.split('\\n')){
		let child = div.appendChild(document.createElement('code'));
		let span = child.appendChild(document.createElement('span'));
		span.textContent = code || '\\n';
	}
}
`)
});

function loadData(text){
	document.body.innerHTML = '';

	const div = document.createElement('div');
	div.setAttribute('class', 'editor');
	document.body.appendChild(div);

	const textNodeList = [];

	for(let code of text.split('\n')){
		let child = div.appendChild(document.createElement('code'));
		let span = child.appendChild(document.createElement('span'));
		if(code){
			span.textContent = code;
			textNodeList.push(span.firstChild);
		}else{
			span.textContent = '\n';
		}
	}

	CSS.highlights.clear();
	CSS.highlights.set("let", createHighlight(textNodeList, /\b(?:let|for|of|function)\b/g, v => v[0].length));
}

function createHighlight(textNodeList, pattern, lengthFn){
	return new Highlight(...textNodeList.map(v => Array.from(v.textContent.matchAll(pattern), info => {
		const range = new Range();
		range.setStart(v, info.index);
		range.setEnd(v, info.index + lengthFn(info));
		return range;
	})).flat());
}


</script>