'use strict';

const defaultTranslateFn = v => v;
const defaultMatchPattern = /%\{\s*(\w+)\s*\}/g;

const calcTemplateString = function(){
	const fn = function*(args){
		yield args[0][0];
		for(let i=1, n=args.length; i<n; ++i){
			yield args[i];
			yield args[0][i];
		}
	}
	return args => Array.from(fn(args)).join('');
}()

const createTranslateFn = function(){
	const createReplaceFn = fn => (text, key) => fn(key) ?? key;//or text?
	return function(fn, matchPattern=defaultMatchPattern){
		const replaceFn = createReplaceFn(fn);
		return value => value.toString().replace(matchPattern, replaceFn);
	}
}()

function createElement(newFn, translateFn=defaultTranslateFn){
	const stack = [[]];
	const addChild = child => stack[stack.length-1].push(child);
	function tag(type, props, endFlag=false){
		if(type.$$typeof?.description === 'react.element'){
			addChild(type);
		}else if(Array.isArray(type)){
			addChild(translateFn(calcTemplateString(arguments)));
		}else if(props === true){
			addChild(newFn(type));
		}else if(endFlag){
			addChild(newFn(type, props));
		}else{
			stack.push([type, props]);
		}
	}
	function end(type){
		const args = stack.pop();
		console.assert(!type || type === args[0]);
		addChild(newFn(...args));
	}
	return factory => function(...args){
		const layer = stack.length-1;
		const index = stack[layer].length;
		factory.call(this, tag, end, ...args);
		console.assert(layer + 1 === stack.length);
		console.assert(index + 1 === stack[layer].length);
		return stack[layer].pop();
	}
}

exports.createElement = createElement;
exports.createTranslateFn = createTranslateFn;
