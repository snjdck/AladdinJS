'use strict';

const calcTemplateString = function(){
	const fn = function*(args){
		yield args[0][0];
		for(let i=1, n=args.length; i<n; ++i){
			yield args[i];
			yield args[0][i];
		}
	}
	return args => Array.from(fn(args)).join('');
}()

const createElement = function(){
	const newFn = React.createElement;
	const stack = [[]];
	const addChild = child => stack[stack.length-1].push(child);
	function tag(type, props, endFlag=false){
		if(React.isValidElement(type)){
			addChild(type);
		}else if(Array.isArray(type)){
			addChild(calcTemplateString(arguments));
		}else if(props === true){
			addChild(newFn(type));
		}else if(endFlag){
			addChild(newFn(type, props));
		}else{
			stack.push([type, props]);
		}
	}
	function end(type){
		const args = stack.pop();
		console.assert(!type || type === args[0]);
		addChild(newFn(...args));
	}
	return factory => function(...args){
		const layer = stack.length-1;
		const index = stack[layer].length;
		factory.call(this, tag, end, ...args);
		console.assert(layer + 1 === stack.length);
		console.assert(index + 1 === stack[layer].length);
		return stack[layer].pop();
	}
}()

const createTranslateFn = function(){
	const defaultMatchPattern = /%\{\s*(\w+)\s*\}/g;
	const createReplaceFn = fn => (text, key) => fn(key) ?? key;//or text?
	return function(fn, matchPattern=defaultMatchPattern){
		const replaceFn = createReplaceFn(fn);
		return value => value.toString().replace(matchPattern, replaceFn);
	}
}()

exports.createElement = createElement;
exports.createTranslateFn = createTranslateFn;
