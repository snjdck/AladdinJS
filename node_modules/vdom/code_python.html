<style>
body{
	margin: 0;
}
.editor {
	overflow: auto;
	counter-reset: line;
	white-space: pre;
	tab-size: 4;
	--padding: 4px;
	font-family: Consolas;
}
.editor > * {
	display: table-row;
	text-indent: var(--padding);
}
.editor > ::before {
	display: table-cell;
	content: counter(line);
	counter-increment: line;
	position: sticky;
	left: 0;
	text-align: right;
	padding-right: var(--padding);
	border-right: 1px solid gray;
	background-color: #ccc;
	color: #666;
}
</style>
<style>
::highlight(operator) {
	color: #ff0000;
}
::highlight(string) {
	color: #00bcd4;
}
::highlight(literal) {
	color: #8600fc;
}
::highlight(keywords) {
	color: #9e9e9e;
}
::highlight(args) {
	color: #00ff00;
}
</style>

<script src="./skulpt.js"></script>
<script>

let handler = {
	stmt(node, ctx){
		node.children.forEach(v => this(v, ctx));
	},
	tfpdef(node, ctx){
		ctx.argsFlag = true;
		node.children.forEach(v => this(v, ctx));
		ctx.argsFlag = false;
	},
	typedargslist:'stmt',
	funcdef:'stmt',
	file_input:'stmt',
	compound_stmt :'stmt',
	simple_stmt :'stmt',
	small_stmt :'stmt',
	expr_stmt :'stmt',
	exprlist :'stmt',
	testlist_star_expr :'stmt',
	testlist :'stmt',
	test :'stmt',
	or_test :'stmt',
	and_test :'stmt',
	not_test :'stmt',
	comparison :'stmt',
	expr :'stmt',
	xor_expr :'stmt',
	and_expr :'stmt',
	shift_expr :'stmt',
	arith_expr :'stmt',
	term :'stmt',
	factor :'stmt',
	power :'stmt',
	atom_expr :'stmt',
	atom:'stmt',
	trailer :'stmt',
	arglist :'stmt',
	argument :'stmt',
	parameters :'stmt',
	suite :'stmt',
	pass_stmt:'stmt',
	if_stmt:'stmt',
	while_stmt:'stmt',
	flow_stmt :'stmt',
	break_stmt:'stmt',
	continue_stmt :'stmt',
	for_stmt:'stmt',
	testlist_comp :'stmt',
	dictorsetmaker :'stmt',
	return_stmt :'stmt',
	comp_for :'stmt',
	T_NUMBER(node, ctx){
		ctx.literal.push(node);
	},
	T_STRING(node, ctx){
		ctx.str.push(node);
	},
	T_NEWLINE(node, ctx){
	},
	T_NAME(node, ctx){
		if(ctx.argsFlag){
			ctx.args.push(node);
			return;
		}
		switch(node.value){
			case 'if':
			case 'else':
			case 'True':
			case 'def':
				ctx.keywords.push(node);
				break;
			case 'for':
			case 'in':
			case 'while':
			case 'pass':
			case 'break':
			case 'continue':
			case 'return':
				ctx.operator.push(node);
				break;
		}
	},
	T_EQUAL(node, ctx){
		ctx.operator.push(node);
	},
	T_INDENT :'T_NEWLINE',
	T_DEDENT:'T_NEWLINE',
	T_ENDMARKER :'T_NEWLINE',
	T_LPAR :'T_NEWLINE',
	T_RPAR :'T_NEWLINE',
	T_LSQB  :'T_NEWLINE',
	T_RSQB  :'T_NEWLINE',
	T_LBRACE  :'T_NEWLINE',
	T_RBRACE  :'T_NEWLINE',
	T_COLON :'T_NEWLINE',
	T_COMMA :'T_NEWLINE',
	T_SEMI :'T_NEWLINE',
	T_PLUS:'T_EQUAL',
	T_MINUS: 'T_EQUAL',
	T_STAR: 'T_EQUAL',
	T_SLASH: 'T_EQUAL',
	T_VBAR: 'T_EQUAL',
	T_AMPER: 'T_EQUAL',
	T_LESS: 'T_EQUAL',
	T_GREATER: 'T_EQUAL',
	T_DOT: 'T_NEWLINE',
	T_PERCENT: 'T_EQUAL',
	T_EQEQUAL: 'T_EQUAL',
	T_NOTEQUAL: 'T_EQUAL',
	T_LESSEQUAL: 'T_EQUAL',
	T_GREATEREQUAL: 'T_EQUAL',
	T_TILDE: 'T_EQUAL',
	T_CIRCUMFLEX: 'T_EQUAL',
	T_LEFTSHIFT: 'T_EQUAL',
	T_RIGHTSHIFT: 'T_EQUAL',
	T_DOUBLESTAR: 'T_EQUAL',
	T_PLUSEQUAL: 'T_EQUAL',
	T_MINEQUAL: 'T_EQUAL',
	T_STAREQUAL: 'T_EQUAL',
	T_SLASHEQUAL: 'T_EQUAL',
	T_PERCENTEQUAL: 'T_EQUAL',
	T_AMPEREQUAL: 'T_EQUAL',
	T_VBAREQUAL: 'T_EQUAL',
	T_CIRCUMFLEXEQUAL: 'T_EQUAL',
	T_LEFTSHIFTEQUAL: 'T_EQUAL',
	T_RIGHTSHIFTEQUAL: 'T_EQUAL',
	T_DOUBLESTAREQUAL: 'T_EQUAL',
	T_DOUBLESLASH: 'T_EQUAL',
	T_DOUBLESLASHEQUAL: 'T_EQUAL',
	T_AT: 'T_EQUAL',
	T_ATEQUAL: 'T_EQUAL',
	T_RARROW(node, ctx){
		ctx.keywords.push(node);
	},
	T_ELLIPSIS: 'T_RARROW',
	T_AWAIT: 'T_EQUAL',
	T_ASYNC: 'T_EQUAL'
}

/*
var EXACT_TOKEN_TYPES = {
    // "<>": tokens.T_NOTEQUAL, Only in py2
    "!=": tokens.T_NOTEQUAL,
    "%": tokens.T_PERCENT,
    "%=": tokens.T_PERCENTEQUAL,
    "&": tokens.T_AMPER,
    "&=": tokens.T_AMPEREQUAL,
    "(": tokens.T_LPAR,
    ")": tokens.T_RPAR,
    "*": tokens.T_STAR,
    "**": tokens.T_DOUBLESTAR,
    "**=": tokens.T_DOUBLESTAREQUAL,
    "*=": tokens.T_STAREQUAL,
    "+": tokens.T_PLUS,
    "+=": tokens.T_PLUSEQUAL,
    ",": tokens.T_COMMA,
    "-": tokens.T_MINUS,
    "-=": tokens.T_MINEQUAL,
    "->": tokens.T_RARROW,
    ".": tokens.T_DOT,
    "...": tokens.T_ELLIPSIS,
    "/": tokens.T_SLASH,
    "//": tokens.T_DOUBLESLASH,
    "//=": tokens.T_DOUBLESLASHEQUAL,
    "/=": tokens.T_SLASHEQUAL,
    ":": tokens.T_COLON,
    // ":=": tokens.T_COLONEQUAL, // currently not listed in tokens
    ";": tokens.T_SEMI,
    "<": tokens.T_LESS,
    "<<": tokens.T_LEFTSHIFT,
    "<<=": tokens.T_LEFTSHIFTEQUAL,
    "<=": tokens.T_LESSEQUAL,
    "=": tokens.T_EQUAL,
    "==": tokens.T_EQEQUAL,
    ">": tokens.T_GREATER,
    ">=": tokens.T_GREATEREQUAL,
    ">>": tokens.T_RIGHTSHIFT,
    ">>=": tokens.T_RIGHTSHIFTEQUAL,
    "@": tokens.T_AT,
    "@=": tokens.T_ATEQUAL,
    "[": tokens.T_LSQB,
    "]": tokens.T_RSQB,
    "^": tokens.T_CIRCUMFLEX,
    "^=": tokens.T_CIRCUMFLEXEQUAL,
    "{": tokens.T_LBRACE,
    "|": tokens.T_VBAR,
    "|=": tokens.T_VBAREQUAL,
    "}": tokens.T_RBRACE,
    "~": tokens.T_TILDE,
};
*/

function walk(node, ctx){
	let name;
	if(!node.children){
		node.start = ctx.lineList[node.lineno-1] + node.col_offset;
		node.end = node.start + node.value.length;
		node.type = Sk.token.tok_name[node.type];
		name = node.type;
		console.log(node)
	}else{
		name = Sk.ParseTables.number2symbol[node.type];
		console.log(name,node.children.map(v => Sk.ParseTables.number2symbol[v.type] ?? (Sk.token.tok_name[v.type] + '(' + v.value + ')')))
	}
	let fn = handler[name];
	if(!fn){
		console.log('!!!!!!!!!!',name,node)
		return ctx
	}
	while(typeof fn == 'string'){
		fn = handler[fn];
	}
	fn.call(walk, node, ctx);
	return ctx;
}


document.addEventListener('DOMContentLoaded', () => {
	loadData(`
#adsfsdfsdf
a = True if 0 else 100 + 2 - (3 / 4) * 5 // 6 ** 8;
a = [x for x in range(10)]
a = (x for x in range(10))
a = {(x,y) for x,y in range(10)}
b= [1,2,3]
c = {7,8,9}
d = {'aa':0}
def a(t1, t2, t3, *aa, **bb):
	'sdfasdfasd'
	pass
	return 1, 2
print(100, 'abc')

if True:

	pass

while True:
	continue
	break
	pass
for i in range(10):
	pass
`)
});

function loadData(text){
	Sk.configure({
		__future__: Sk.python3
	});
	
	document.body.innerHTML = '';

	const div = document.createElement('div');
	div.setAttribute('class', 'editor');
	document.body.appendChild(div);

	const textNodeList = [];

	for(let code of text.match(/.*\n|.+$/g)){
		let child = div.appendChild(document.createElement('div'));
		let span = child.appendChild(document.createElement('span'));
		textNodeList.push(span.appendChild(document.createTextNode(code)));
	}


	const lineList = [0];
	for(let node of textNodeList){
		lineList.push(lineList.at(-1) + node.length)
	}

	let parse = Sk.parse('', text);
	console.log(parse, Sk.ParseTables, Sk.token.tok_name)
	//let ast = Sk.astFromParse(parse.cst, '', parse.flags);
	let info = walk(parse.cst, {input:text, str:[],args:[],operator:[],keywords:[],literal:[],lineList})
	console.log(info)

	CSS.highlights.clear();
	CSS.highlights.set("literal", createHighlight(textNodeList, info.literal));
	CSS.highlights.set("string", createHighlight(textNodeList, info.str));
	CSS.highlights.set("operator", createHighlight(textNodeList, info.operator));
	CSS.highlights.set("keywords", createHighlight(textNodeList, info.keywords));
	CSS.highlights.set("args", createHighlight(textNodeList, info.args));
}

function createHighlight(textNodeList, list){
	let result = [];
	let offset = 0;
	for(let node of textNodeList){
		const offsetEnd = offset + node.length;
		for(let {start, end} of list){
			if(offsetEnd <= start || end <= offset)continue;
			const range = new Range();
			range.setStart(node, Math.max(offset, start) - offset);
			range.setEnd(node, Math.min(offsetEnd, end) - offset);
			result.push(range);
		}
		offset = offsetEnd;
	}
	return new Highlight(...result);
}


</script>