'use strict';

/*
parentNode.insertBefore(newNode, referenceNode);
patch with key
*/

const componentTag = Symbol();

function createElement(element){
	if(element instanceof Element){
		element[componentTag]?.componentDidMount?.();
		return element.render();
	}
	return document.createTextNode(element);
}
function setAttr(element, props){
	for(const name in props){
		const value = props[name];
		if(name.startsWith('on')){
			element[name.toLowerCase()] = value;
			//element.addEventListener(name.slice(2), value);
		}else{
			element.setAttribute(name, value);
		}
	}
	return element;
}

function renderDOM(dom, tree){
	let oldTree = tree.calc();
	const root = oldTree.render();
	dom.appendChild(root);
	setInterval(() => {
		let newTree = tree.calc();
		dfsWalk(root, diff(oldTree, newTree));
		oldTree = newTree;
	}, 100);
}

class Component{
	setState(){

	}
}
function isComponent(klazz){
	for(;klazz; klazz=Object.getPrototypeOf(klazz)){
		if(klazz === Component){
			return true;
		}
	}
	return false;
}

class Element
{
	static New(tagName, props, children){
		return new this(tagName, props, children);
	}

	static Create(tagName, props, children){
		if(typeof tagName != 'function'){
			return new this(tagName, props, children);
		}
		if(!isComponent(tagName)){
			return tagName(props);
		}
		const component = new tagName(props);
		const element = component.render();
		element[componentTag] = component;
		return element;
	}

	constructor(tagName, props, children){
		this.tagName = tagName;
		this.props = props || {};
		this.children = children || [];

		this.key = props && props.key;
	}

	calc(){
		const {tagName, props, children} = this;
		return this.constructor.Create(tagName, props, children.map(child => {
			if(typeof child == 'string')
				return child;
			return child.calc();
		}));
	}

	render(){
		const {tagName, props, children} = this;
		const element = setAttr(document.createElement(tagName), props);
		for(const child of children){
			element.appendChild(createElement(child));
		}
		return element;
	}
/*
	createElement(){
		const {tagName, props} = this;
		return setAttr(document.createElement(tagName), props);
		
		let element;
		switch(typeof tagName){
			case 'function':
				if(isComponent(tagName)){
					let component = this.component = new tagName(props);
					component.componentDidMount();
					element = component.render().render();
				}else{
					element = tagName(props).render();
				}
				break;
			case 'string':
				element = setAttr(document.createElement(tagName), props);
				break;
		}
		return element;
		
	}
	*/
}

function calcChildCount(root){
	let result = 0;
	for(const child of root.children){
		++result;
		if(child instanceof Element){
			result += calcChildCount(child);
		}
	}
	return result;
}

function findChildIndex(root, node){
	let result = 0;
	for(const child of root.children){
		++result;
		if(child == node)return result;
		if(child instanceof Element){
			result += calcChildCount(child);
		}
	}
	return result;
}

function diff(oldNode, newNode){
	const result = [];
	_diff.call(result, oldNode, newNode, 0);
	return result;
}
function _diff(oldNode, newNode, baseIndex){
	const result = this;
	if(!(oldNode instanceof Element)){//oldNode is String
		if(newNode instanceof Element){
			result.push({
				type: 'replace',
				id: baseIndex,
				node: newNode,
			});
		}else if(newNode == null){
			result.push({
				type: 'reorder',
				op: 'remove',
				id: baseIndex,
			});
		}else if(oldNode != newNode){
			result.push({
				type: 'text',
				id: baseIndex,
				value: newNode,
			});
		}
		return baseIndex;
	}
	//oldNode is Element
	if(!(newNode instanceof Element) || oldNode.tagName != newNode.tagName){
		if(newNode){
			result.push({
				type: 'replace',
				id: baseIndex,
				node: newNode,
			});
		}else{
			result.push({
				type: 'reorder',
				op: 'remove',
				id: baseIndex,
				component: oldNode[componentTag]
			});
		}
		return baseIndex + calcChildCount(oldNode);
	}
	//oldNode & newNode is Element, tagName equal
	const propsPatches = diffProps(oldNode, newNode);
	if(propsPatches){
		result.push({
			type: 'props',
			id: baseIndex,
			props: propsPatches
		});
	}
	for(let i=oldNode.children.length; i<newNode.children.length; ++i){
		const node = newNode.children[i];
		result.push({
			type: 'reorder',
			op: 'add',
			id: baseIndex,
			node,
			component: node[componentTag]
		});
	}
	for(let i=0; i<oldNode.children.length; ++i){
		let a = oldNode.children[i];
		let b = newNode.children[i];
		baseIndex = _diff.call(this, a, b, baseIndex + 1);
	}
	return baseIndex;
}

function diffProps(oldNode, newNode){
	const oldProps = oldNode.props;
	const newProps = newNode.props;

	const propsPatches = Object.create(null);
	let isSame = true;

	for(const key in oldProps){
		const newValue = newProps[key];
		if(newValue === oldProps[key])continue;
		isSame = false;
		propsPatches[key] = newValue;
	}

	for(const key in newProps){
		if(oldProps.hasOwnProperty(key))continue;
		isSame = false;
		propsPatches[key] = newProps[key];
	}

	return isSame ? null : propsPatches;
}

function dfsWalk(node, patchList, index=0){
	const data = patchList.filter(v => v.id === index);
	if(node.hasChildNodes()){
		const childNodes = Array.from(node.childNodes);
		for(let i=0; i<childNodes.length; ++i){
			index = dfsWalk(childNodes[i], patchList, ++index);
		}
	}
	if(data.length > 0){
		data.forEach(applyPatch.bind(null, node));
	}
	return index;
}

function applyPatch(node, data){
	switch(data.type){
		case 'replace':
			node.parentNode.replaceChild(createElement(data.node), node);
			break;
		case 'props':
			setAttr(node, data.props);
			break;
		case 'text':
			node.textContent = data.value;
			break;
		case 'reorder':
			if(data.op == 'add'){
				node.appendChild(createElement(data.node));
			}else{
				data.component?.componentWillUnmount();
				node.parentNode.removeChild(node);
			}
			break;
	}
	console.log(node, data)
}
