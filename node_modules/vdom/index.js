'use strict';

/*

parentNode.insertBefore(newNode, referenceNode);

*/

class Element
{
	constructor(tagName, props, children){
		this.tagName = tagName;
		this.props = props || {};
		this.children = children || [];

		this.key = props && props.key;

		let count = 0;
		for(const child of children){
			++count;
			if(child instanceof Element){
				count += child.count;
			}
		}
		this.count = count;
	}

	render(){
		const {tagName, props, children} = this;

		const element = document.createElement(tagName);

		for(const name in props){
			element.setAttribute(name, props[name]);
		}

		for(const child of children){
			const childElement = (child instanceof Element) ? child.render() : document.createTextNode(child);
			element.appendChild(childElement);
		}

		return element;
	}
}

function collectChildren(node, result=[]){
	result.push(node);
	for(const child of node.children){
		if(child instanceof Element){
			collectChildren(child, result);
		}else{
			result.push(child);
		}
	}
	return result;
}

function diff(oldNode, newNode, baseIndex=0, subIndex=0, result=[]){
	if(oldNode === newNode)return result;
	if(newNode == null){
		result.push({
			type: 'reorder',
			op: 'remove',
			id:baseIndex,
			index: subIndex,
		})
		return result;
	}
	if(oldNode instanceof Element && newNode instanceof Element){
		if(oldNode.tagName != newNode.tagName){
			result.push({
				type: 'replace',
				id:baseIndex,
				node: newNode,
			});
			return result;
		}
		const propsPatches = diffProps(oldNode, newNode);
		if(propsPatches){
			result.push({
				type: 'props',
				id:baseIndex,
				props: propsPatches
			})
		}
		const parentIndex = baseIndex;
		++baseIndex;
		const len = Math.max(oldNode.children.length, newNode.children.length);
		for(let i=0; i<oldNode.children.length; ++i){
			let a = oldNode.children[i];
			let b = newNode.children[i];
			diff(a, b, baseIndex, i, result);
			baseIndex += a.count ? a.count + 1 : 1;
		}
		for(let i=oldNode.children.length; i<newNode.children.length; ++i){
			result.push({
				type: 'reorder',
				op: 'add',
				id:parentIndex,
				node: newNode.children[i]
			})
		}
	}else if(oldNode instanceof Element || newNode instanceof Element){
		result.push({
			type: 'replace',
			id:baseIndex,
			oldNode,
			newNode,
		});
	}else if(oldNode != newNode){
		result.push({
			type: 'text',
			id: baseIndex,
			value: newNode,
		});
	}
	return result;
}

function diffProps(oldNode, newNode){
	const oldProps = oldNode.props;
	const newProps = newNode.props;

	const propsPatches = Object.create(null);
	let isSame = true;

	for(const key in oldProps){
		const newValue = newProps[key];
		if(newValue === oldProps[key])continue;
		isSame = false;
		propsPatches[key] = newValue;
	}

	for(const key in newProps){
		if(oldProps.hasOwnProperty(key))continue;
		isSame = false;
		propsPatches[key] = newProps[key];
	}

	return isSame ? null : propsPatches;
}

function dfsWalk(node, patchList, index=0){
	const data = patchList.find(v => v.id === index);
	const len = node.childNodes ? node.childNodes.length : 0;
	for(let i=0; i<len; ++i){
		index = dfsWalk(node.childNodes[i], patchList, ++index);
	}
	if(data)applyPatch(node, data);
	return index;
}

function applyPatch(node, data){
	switch(data.type){
		case 'replace':
			node.parentNode.replaceChild(data.node.render(), node);
			break;
		case 'props':
			for(let key in data.props){
				node.setAttribute(key, data.props[key]);
			}
			break;
		case 'text':
			node.textContent = data.value;
			break;
		case 'reorder':
			if(data.op == 'add'){
				node.appendChild(data.node.render());
			}else{
				node.parentNode.removeChild(node);
			}
			break;
	}
	console.log(node, data)
}

const tree = new Element('div', {id:'virtual-container'}, [
	new Element('p', null, ['virtual dom']),
	new Element('div', null, ['before update']),
	new Element('ul', null, [
		new Element('li', {class: 'item'}, ['item 1']),
		new Element('li', {class: 'item'}, ['item 2']),
		new Element('li', {class: 'item'}, ['item 3']),
	]),
])

const newTree = new Element('div', {id:'virtual-container'}, [
	new Element('h3', null, ['virtual dom']),
	new Element('div', null, ['after update']),
	new Element('ul', {class:'marginLeft10'}, [
		new Element('li', {class: 'item'}, ['item 1']),
		//new Element('li', {class: 'item'}, ['item 2']),
		new Element('li', {class: 'item'}, ['item 3']),
	]),
	new Element('p', null, ['new div']),
])


console.log(collectChildren(tree))
console.log(diff(tree, newTree))

const root = tree.render();
document.getElementById("virtualDom").appendChild(root);
setTimeout(() => {
	dfsWalk(root, diff(tree, newTree))

}, 500)