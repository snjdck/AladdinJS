'use strict';

/*
parentNode.insertBefore(newNode, referenceNode);
patch with key
*/

const createElement = v => v instanceof Element ? v.render() : document.createTextNode(v);
function setAttr(element, props){
	for(const name in props){
		element.setAttribute(name, props[name]);
	}
	return element;
}

class Element
{
	constructor(tagName, props, children){
		this.tagName = tagName;
		this.props = props || {};
		this.children = children || [];

		this.key = props && props.key;
	}

	render(){
		const element = this.createElement();
		for(const child of this.children){
			element.appendChild(createElement(child));
		}
		return element;
	}

	createElement(){
		const {tagName, props} = this;
		let element;
		switch(typeof tagName){
			case 'function':
				element = tagName(props).render();
				break;
			case 'string':
				element = setAttr(document.createElement(tagName), props);
				break;
		}
		return element;
	}
}

function calcChildCount(node){
	let result = 0;
	for(const child of node.children){
		++result;
		if(child instanceof Element){
			result += calcChildCount(child);
		}
	}
	return result;
}

function diff(oldNode, newNode){
	const result = [];
	_diff.call(result, oldNode, newNode, 0);
	return result;
}
function _diff(oldNode, newNode, baseIndex){
	const result = this;
	if(!(oldNode instanceof Element)){//oldNode is String
		if(newNode instanceof Element){
			result.push({
				type: 'replace',
				id: baseIndex,
				node: newNode,
			});
		}else if(newNode == null){
			result.push({
				type: 'reorder',
				op: 'remove',
				id: baseIndex,
			});
		}else if(oldNode != newNode){
			result.push({
				type: 'text',
				id: baseIndex,
				value: newNode,
			});
		}
		return baseIndex;
	}
	//oldNode is Element
	if(!(newNode instanceof Element) || oldNode.tagName != newNode.tagName){
		if(newNode){
			result.push({
				type: 'replace',
				id: baseIndex,
				node: newNode,
			});
		}else{
			result.push({
				type: 'reorder',
				op: 'remove',
				id: baseIndex,
			});
		}
		return baseIndex + calcChildCount(oldNode);
	}
	//oldNode & newNode is Element, tagName equal
	const propsPatches = diffProps(oldNode, newNode);
	if(propsPatches){
		result.push({
			type: 'props',
			id: baseIndex,
			props: propsPatches
		});
	}
	for(let i=oldNode.children.length; i<newNode.children.length; ++i){
		result.push({
			type: 'reorder',
			op: 'add',
			id: baseIndex,
			node: newNode.children[i]
		});
	}
	for(let i=0; i<oldNode.children.length; ++i){
		let a = oldNode.children[i];
		let b = newNode.children[i];
		baseIndex = _diff.call(this, a, b, baseIndex + 1);
	}
	return baseIndex;
}

function diffProps(oldNode, newNode){
	const oldProps = oldNode.props;
	const newProps = newNode.props;

	const propsPatches = Object.create(null);
	let isSame = true;

	for(const key in oldProps){
		const newValue = newProps[key];
		if(newValue === oldProps[key])continue;
		isSame = false;
		propsPatches[key] = newValue;
	}

	for(const key in newProps){
		if(oldProps.hasOwnProperty(key))continue;
		isSame = false;
		propsPatches[key] = newProps[key];
	}

	return isSame ? null : propsPatches;
}

function dfsWalk(node, patchList, index=0){
	const data = patchList.filter(v => v.id === index);
	const len = node.childNodes ? node.childNodes.length : 0;
	for(let i=0; i<len; ++i){
		index = dfsWalk(node.childNodes[i], patchList, ++index);
	}
	if(data.length > 0){
		data.forEach(applyPatch.bind(null, node));
	}
	return index;
}

function applyPatch(node, data){
	switch(data.type){
		case 'replace':
			node.parentNode.replaceChild(createElement(data.node), node);
			break;
		case 'props':
			setAttr(node, data.props);
			break;
		case 'text':
			node.textContent = data.value;
			break;
		case 'reorder':
			if(data.op == 'add'){
				node.appendChild(data.node.render());
			}else{
				node.parentNode.removeChild(node);
			}
			break;
	}
	console.log(node, data)
}
