const {gen_vuint} = require('./utils');
const memarg = [2, 0];//align, offset

const op = {
	unreachable:0x00,
	nop:0x01,
	block:0x02,
	loop:0x03,
	if:0x04,
	else:0x05,
	end: 0x0B,//	 	 	 
	br: 0x0C,//	[t∗1 t?]→[t∗2]	
	br_if: 0x0D,//	[t? i32]→[t?]	
	br_table: 0x0E,//	[t∗1 t? i32]→[t∗2]	
	return: [0x0F],//	[t∗1 t?]→[t∗2]	
	call: 0x10,//	[t∗1]→[t∗2]	
	call_indirect: 0x11,//	[t∗1 i32]→[t∗2]	
	drop: 0x1A,//	[t]→[]	
	select: 0x1B,//	[t t i32]→[t]	
	select_t: 0x1C,//	[t t i32]→[t]	
	local:{
		get:i => [0x20, ...gen_vuint(i)],//	[]→[t]	
		set:i => [0x21, ...gen_vuint(i)],//	[t]→[]	
		tee:i => [0x22, ...gen_vuint(i)],//	[t]→[t]	
	},
	/*global:{
		get:0x23,//	[]→[t]	
		set:0x24,//	[t]→[]	
	},
	table:{
		get:0x25,//	[]→[t]	
		set:0x26,//	[t]→[]	
	},
	memory:{
		size: 0x3F,//	[]→[i32]	
		grow: 0x40,//	[i32]→[i32]	
	},
	ref:{
		null: 0xD0,//	[]→[nullref]	
		is_null: 0xD1,//	[anyref]→[i32]	
		func: 0xD2,//	[]→[funcref]
	},*/
	i32:{
		const: v => [0x41, ...gen_vuint(v)],

		load: [0x28, ...memarg],//load 4 bytes as i32
		load8_s: 0x2C,//	[i32]→[i32]	load 1 byte and sign-extend i8 to i32
		load8_u: 0x2D,//	[i32]→[i32]	load 1 byte and zero-extend i8 to i32
		load16_s: 0x2E,//	[i32]→[i32]	load 2 bytes and sign-extend i16 to i32
		load16_u: 0x2F,//	[i32]→[i32]	load 2 bytes and zero-extend i16 to i32

		store: [0x36, ...memarg],// (no conversion) store 4 bytes
		store8: 0x3A,//	[i32 i32]→[]	wrap i32 to i8 and store 1 byte
		store16: 0x3B,//	[i32 i32]→[]	wrap i32 to i16 and store 2 bytes

		eqz:0x45,
		eq: 0x46,	
		ne: 0x47,
		lt_s: 0x48,//	[i32 i32]→[i32]	
		lt_u: 0x49,//	[i32 i32]→[i32]	
		gt_s: 0x4A,//	[i32 i32]→[i32]	
		gt_u: 0x4B,//	[i32 i32]→[i32]	
		le_s: 0x4C,//	[i32 i32]→[i32]	
		le_u: 0x4D,//	[i32 i32]→[i32]	
		ge_s: 0x4E,//	[i32 i32]→[i32]	
		ge_u: 0x4F,//	[i32 i32]→[i32]	
		clz: 0x67,//	[i32]→[i32]	
		ctz: 0x68,//	[i32]→[i32]	
		popcnt: 0x69,//	[i32]→[i32]	
		add: [0x6A],//	[i32 i32]→[i32]	
		sub: [0x6B],//	[i32 i32]→[i32]	
		mul: [0x6C],//	[i32 i32]→[i32]	
		div_s: 0x6D,//	[i32 i32]→[i32]	
		div_u: 0x6E,//	[i32 i32]→[i32]	
		rem_s: 0x6F,//	[i32 i32]→[i32]	
		rem_u: 0x70,//	[i32 i32]→[i32]	
		and: 0x71,//	[i32 i32]→[i32]	
		or: 0x72,//	[i32 i32]→[i32]	
		xor: 0x73,//	[i32 i32]→[i32]	
		shl: 0x74,//	[i32 i32]→[i32]	
		shr_s: 0x75,//	[i32 i32]→[i32]	
		shr_u: 0x76,//	[i32 i32]→[i32]	
		rotl: 0x77,//	[i32 i32]→[i32]	
		rotr: 0x78,//	[i32 i32]→[i32]	
		wrap_i64: 0xA7,//	[i64]→[i32]	
		trunc_f32_s: 0xA8,//	[f32]→[i32]	
		trunc_f32_u: 0xA9,//	[f32]→[i32]	
		trunc_f64_s: 0xAA,//	[f64]→[i32]	
		trunc_f64_u: 0xAB,//	[f64]→[i32]	
		reinterpret_f32: 0xBC,//	[f32]→[i32]	
	},
	f32:{
		const: 0x43,
		load: 0x2A,
		store: 0x38,
		eq: 0x5B,
		ne: 0x5C,
		lt: 0x5D,//	[f32 f32]→[i32]	
		gt: 0x5E,//	[f32 f32]→[i32]	
		le: 0x5F,//	[f32 f32]→[i32]	
		ge: 0x60,//	[f32 f32]→[i32]	
		abs: 0x8B,//	[f32]→[f32]	
		neg: 0x8C,//	[f32]→[f32]	
		ceil: 0x8D,//	[f32]→[f32]	
		floor: 0x8E,//	[f32]→[f32]	
		trunc: 0x8F,//	[f32]→[f32]	
		nearest: 0x90,//	[f32]→[f32]	
		sqrt: 0x91,//	[f32]→[f32]	
		add: 0x92,//	[f32 f32]→[f32]	
		sub: 0x93,//	[f32 f32]→[f32]	
		mul: 0x94,//	[f32 f32]→[f32]	
		div: 0x95,//	[f32 f32]→[f32]	
		min: 0x96,//	[f32 f32]→[f32]	
		max: 0x97,//	[f32 f32]→[f32]	
		copysign: 0x98,//	[f32 f32]→[f32]	
		convert_i32_s: 0xB2,//	[i32]→[f32]	
		convert_i32_u: 0xB3,//	[i32]→[f32]	
		convert_i64_s: 0xB4,//	[i64]→[f32]	
		convert_i64_u: 0xB5,//	[i64]→[f32]	
		demote_f64: 0xB6,//	[f64]→[f32]	
		reinterpret_i32: 0xBE,//	[i32]→[f32]	
	},
	/*i64:{
		const: 0x42,

		load: 0x29,
		load8_s: 0x30,//	[i32]→[i64]	
		load8_u: 0x31,//	[i32]→[i64]	
		load16_s: 0x32,//	[i32]→[i64]	
		load16_u: 0x33,//	[i32]→[i64]	
		load32_s: 0x34,//	[i32]→[i64]	
		load32_u: 0x35,//	[i32]→[i64]	

		store: 0x37,
		store8: 0x3C,//	[i32 i64]→[]	
		store16: 0x3D,//	[i32 i64]→[]	
		store32: 0x3E,//	[i32 i64]→[]


		eqz:0x50,
		eq: 0x51,
		ne: 0x52,
		lt_s: 0x53,//	[i64 i64]→[i32]	
		lt_u: 0x54,//	[i64 i64]→[i32]	
		gt_s: 0x55,//	[i64 i64]→[i32]	
		gt_u: 0x56,//	[i64 i64]→[i32]	
		le_s: 0x57,//	[i64 i64]→[i32]	
		le_u: 0x58,//	[i64 i64]→[i32]	
		ge_s: 0x59,//	[i64 i64]→[i32]	
		ge_u: 0x5A,//	[i64 i64]→[i32]	
		clz: 0x79,//	[i64]→[i64]	
		ctz: 0x7A,//	[i64]→[i64]	
		popcnt: 0x7B,//	[i64]→[i64]	
		add: 0x7C,//	[i64 i64]→[i64]	
		sub: 0x7D,//	[i64 i64]→[i64]	
		mul: 0x7E,//	[i64 i64]→[i64]	
		div_s: 0x7F,//	[i64 i64]→[i64]	
		div_u: 0x80,//	[i64 i64]→[i64]	
		rem_s: 0x81,//	[i64 i64]→[i64]	
		rem_u: 0x82,//	[i64 i64]→[i64]	
		and: 0x83,//	[i64 i64]→[i64]	
		or: 0x84,//	[i64 i64]→[i64]	
		xor: 0x85,//	[i64 i64]→[i64]	
		shl: 0x86,//	[i64 i64]→[i64]	
		shr_s: 0x87,//	[i64 i64]→[i64]	
		shr_u: 0x88,//	[i64 i64]→[i64]	
		rotl: 0x89,//	[i64 i64]→[i64]	
		rotr: 0x8A,//	[i64 i64]→[i64]	
		extend_i32_s: 0xAC,//	[i32]→[i64]	
		extend_i32_u: 0xAD,//	[i32]→[i64]	
		trunc_f32_s: 0xAE,//	[f32]→[i64]	
		trunc_f32_u: 0xAF,//	[f32]→[i64]	
		trunc_f64_s: 0xB0,//	[f64]→[i64]	
		trunc_f64_u: 0xB1,//	[f64]→[i64]	
		reinterpret_f64: 0xBD,//	[f64]→[i64]	
	},
	f64:{
		const: 0x44,
		load: 0x2B,
		store: 0x39,
		eq: 0x61,
		ne: 0x62,
		lt: 0x63,//	[f64 f64]→[i32]	
		gt: 0x64,//	[f64 f64]→[i32]	
		le: 0x65,//	[f64 f64]→[i32]	
		ge: 0x66,//	[f64 f64]→[i32]	
		abs: 0x99,//	[f64]→[f64]	
		neg: 0x9A,//	[f64]→[f64]	
		ceil: 0x9B,//	[f64]→[f64]	
		floor: 0x9C,//	[f64]→[f64]	
		trunc: 0x9D,//	[f64]→[f64]	
		nearest: 0x9E,//	[f64]→[f64]	
		sqrt: 0x9F,//	[f64]→[f64]	
		add: 0xA0,//	[f64 f64]→[f64]	
		sub: 0xA1,//	[f64 f64]→[f64]	
		mul: 0xA2,//	[f64 f64]→[f64]	
		div: 0xA3,//	[f64 f64]→[f64]	
		min: 0xA4,//	[f64 f64]→[f64]	
		max: 0xA5,//	[f64 f64]→[f64]	
		copysign: 0xA6,//	[f64 f64]→[f64]	
		convert_i32_s: 0xB7,//	[i32]→[f64]	
		convert_i32_u: 0xB8,//	[i32]→[f64]	
		convert_i64_s: 0xB9,//	[i64]→[f64]	
		convert_i64_u: 0xBA,//	[i64]→[f64]	
		promote_f32: 0xBB,//	[f32]→[f64]	
		reinterpret_i64: 0xBF,//	[i64]→[f64]	
	}*/
};
/*
const keyList = ['i32', 'i64', 'f32', 'f64'];
for(let key of new Set(keyList.map(v => Object.keys(op[v])).reduce((a, b) => a.concat(b), []))){
	console.assert(!(key in op));
	let list = keyList.map(v => op[v][key] && v).filter(Boolean);
	if(list.length <= 1){
		op[key] = op[list[0]][key];
		continue;
	}
	op[key] = {};
	list.forEach(k => op[key][k] = op[k][key]);
}
*/
module.exports = op;
