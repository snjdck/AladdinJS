const {write_u32v, write_i32v} = require('./utils');

const memarg1 = [0, 0];//align, offset
const memarg2 = [1, 0];//align, offset
const memarg4 = [2, 0];//align, offset
const memarg8 = [3, 0];//align, offset
const memarg16 = [4, 0];//align, offset

const defSimdOp = (code, ...args) => [0xFD, ...write_u32v(code), ...args];

const sharedBuffer = new ArrayBuffer(4);
const uint8Array = new Uint8Array(sharedBuffer);
const floatArray = new Float32Array(sharedBuffer);
const castFloat32 = v => (floatArray[0] = v, uint8Array);

const op = {
	unreachable:0x00,
	nop:0x01,
	block: (type=0x40) => [0x02, type],
	loop: (type=0x40) => [0x03, type],
	if: (type=0x40) => [0x04, type],
	else:[0x05],
	end: [0x0B],//	 	 	 
	br: (depth=0) => [0x0C, ...write_u32v(depth)],//	[t∗1 t?]→[t∗2]	
	br_if: (depth=0) => [0x0D, ...write_u32v(depth)],//	[t? i32]→[t?]	
	br_table: 0x0E,//	[t∗1 t? i32]→[t∗2]	
	return: [0x0F],//	[t∗1 t?]→[t∗2]	
	call: i => [0x10, ...write_u32v(i)],//	[t∗1]→[t∗2]	
	call_indirect: 0x11,//	[t∗1 i32]→[t∗2]	
	drop: [0x1A],//	[t]→[]	
	select: 0x1B,//	[t t i32]→[t]	
	select_t: 0x1C,//	[t t i32]→[t]	
	local:{
		get:i => [0x20, ...write_u32v(i)],//	[]→[t]	
		set:i => [0x21, ...write_u32v(i)],//	[t]→[]	
		tee:i => [0x22, ...write_u32v(i)],//	[t]→[t]	
	},
	/*global:{
		get:0x23,//	[]→[t]	
		set:0x24,//	[t]→[]	
	},
	table:{
		get:0x25,//	[]→[t]	
		set:0x26,//	[t]→[]	
	},
	memory:{
		size: 0x3F,//	[]→[i32]	
		grow: 0x40,//	[i32]→[i32]	
	},
	ref:{
		null: 0xD0,//	[]→[nullref]	
		is_null: 0xD1,//	[anyref]→[i32]	
		func: 0xD2,//	[]→[funcref]
	},*/
	i32:{
		const: v => [0x41, ...write_i32v(v)],

		load: [0x28, ...memarg4],//load 4 bytes as i32
		load8_s: 0x2C,//	[i32]→[i32]	load 1 byte and sign-extend i8 to i32
		load8_u: 0x2D,//	[i32]→[i32]	load 1 byte and zero-extend i8 to i32
		load16_s: 0x2E,//	[i32]→[i32]	load 2 bytes and sign-extend i16 to i32
		load16_u: 0x2F,//	[i32]→[i32]	load 2 bytes and zero-extend i16 to i32

		store: [0x36, ...memarg4],// (no conversion) store 4 bytes
		store8: [0x3A, ...memarg1],//	[i32 i32]→[]	wrap i32 to i8 and store 1 byte
		store16: [0x3B, ...memarg2],//	[i32 i32]→[]	wrap i32 to i16 and store 2 bytes

		eqz:[0x45],
		eq: [0x46],	
		ne: [0x47],
		lt_s: [0x48],//	[i32 i32]→[i32]	
		lt_u: [0x49],//	[i32 i32]→[i32]	
		gt_s: [0x4A],//	[i32 i32]→[i32]	
		gt_u: [0x4B],//	[i32 i32]→[i32]	
		le_s: [0x4C],//	[i32 i32]→[i32]	
		le_u: [0x4D],//	[i32 i32]→[i32]	
		ge_s: [0x4E],//	[i32 i32]→[i32]	
		ge_u: [0x4F],//	[i32 i32]→[i32]	
		clz: 0x67,//	[i32]→[i32]	
		ctz: 0x68,//	[i32]→[i32]	
		popcnt: 0x69,//	[i32]→[i32]	
		add: [0x6A],//	[i32 i32]→[i32]	
		sub: [0x6B],//	[i32 i32]→[i32]	
		mul: [0x6C],//	[i32 i32]→[i32]	
		div_s: 0x6D,//	[i32 i32]→[i32]	
		div_u: 0x6E,//	[i32 i32]→[i32]	
		rem_s: 0x6F,//	[i32 i32]→[i32]	
		rem_u: 0x70,//	[i32 i32]→[i32]	
		and: 0x71,//	[i32 i32]→[i32]	
		or: 0x72,//	[i32 i32]→[i32]	
		xor: 0x73,//	[i32 i32]→[i32]	
		shl: [0x74],//	[i32 i32]→[i32]	
		shr_s: [0x75],//	[i32 i32]→[i32]	
		shr_u: [0x76],//	[i32 i32]→[i32]	
		rotl: 0x77,//	[i32 i32]→[i32]	
		rotr: 0x78,//	[i32 i32]→[i32]	
		wrap_i64: 0xA7,//	[i64]→[i32]	
		trunc_f32_s: 0xA8,//	[f32]→[i32]	
		trunc_f32_u: 0xA9,//	[f32]→[i32]	
		trunc_f64_s: 0xAA,//	[f64]→[i32]	
		trunc_f64_u: 0xAB,//	[f64]→[i32]	
		reinterpret_f32: 0xBC,//	[f32]→[i32]	
	},
	f32:{
		const: v => [0x43, ...castFloat32(v)],
		load: [0x2A, ...memarg4],
		store: [0x38, ...memarg4],
		eq: [0x5B],
		ne: [0x5C],
		lt: [0x5D],//	[f32 f32]→[i32]	
		gt: [0x5E],//	[f32 f32]→[i32]	
		le: [0x5F],//	[f32 f32]→[i32]	
		ge: [0x60],//	[f32 f32]→[i32]	
		abs: [0x8B],//	[f32]→[f32]	
		neg: [0x8C],//	[f32]→[f32]	
		ceil: [0x8D],//	[f32]→[f32]	
		floor: [0x8E],//	[f32]→[f32]	
		trunc: [0x8F],//	[f32]→[f32]	
		nearest: [0x90],//	[f32]→[f32]	
		sqrt: [0x91],//	[f32]→[f32]	
		add: [0x92],//	[f32 f32]→[f32]	
		sub: [0x93],//	[f32 f32]→[f32]	
		mul: [0x94],//	[f32 f32]→[f32]	
		div: [0x95],//	[f32 f32]→[f32]	
		min: [0x96],//	[f32 f32]→[f32]	
		max: [0x97],//	[f32 f32]→[f32]	
		copysign: [0x98],//	[f32 f32]→[f32]	
		convert_i32_s: 0xB2,//	[i32]→[f32]	
		convert_i32_u: 0xB3,//	[i32]→[f32]	
		convert_i64_s: 0xB4,//	[i64]→[f32]	
		convert_i64_u: 0xB5,//	[i64]→[f32]	
		demote_f64: 0xB6,//	[f64]→[f32]	
		reinterpret_i32: 0xBE,//	[i32]→[f32]	
	},
	/*i64:{
		const: 0x42,

		load: 0x29,
		load8_s: 0x30,//	[i32]→[i64]	
		load8_u: 0x31,//	[i32]→[i64]	
		load16_s: 0x32,//	[i32]→[i64]	
		load16_u: 0x33,//	[i32]→[i64]	
		load32_s: 0x34,//	[i32]→[i64]	
		load32_u: 0x35,//	[i32]→[i64]	

		store: 0x37,
		store8: 0x3C,//	[i32 i64]→[]	
		store16: 0x3D,//	[i32 i64]→[]	
		store32: 0x3E,//	[i32 i64]→[]


		eqz:0x50,
		eq: 0x51,
		ne: 0x52,
		lt_s: 0x53,//	[i64 i64]→[i32]	
		lt_u: 0x54,//	[i64 i64]→[i32]	
		gt_s: 0x55,//	[i64 i64]→[i32]	
		gt_u: 0x56,//	[i64 i64]→[i32]	
		le_s: 0x57,//	[i64 i64]→[i32]	
		le_u: 0x58,//	[i64 i64]→[i32]	
		ge_s: 0x59,//	[i64 i64]→[i32]	
		ge_u: 0x5A,//	[i64 i64]→[i32]	
		clz: 0x79,//	[i64]→[i64]	
		ctz: 0x7A,//	[i64]→[i64]	
		popcnt: 0x7B,//	[i64]→[i64]	
		add: 0x7C,//	[i64 i64]→[i64]	
		sub: 0x7D,//	[i64 i64]→[i64]	
		mul: 0x7E,//	[i64 i64]→[i64]	
		div_s: 0x7F,//	[i64 i64]→[i64]	
		div_u: 0x80,//	[i64 i64]→[i64]	
		rem_s: 0x81,//	[i64 i64]→[i64]	
		rem_u: 0x82,//	[i64 i64]→[i64]	
		and: 0x83,//	[i64 i64]→[i64]	
		or: 0x84,//	[i64 i64]→[i64]	
		xor: 0x85,//	[i64 i64]→[i64]	
		shl: 0x86,//	[i64 i64]→[i64]	
		shr_s: 0x87,//	[i64 i64]→[i64]	
		shr_u: 0x88,//	[i64 i64]→[i64]	
		rotl: 0x89,//	[i64 i64]→[i64]	
		rotr: 0x8A,//	[i64 i64]→[i64]	
		extend_i32_s: 0xAC,//	[i32]→[i64]	
		extend_i32_u: 0xAD,//	[i32]→[i64]	
		trunc_f32_s: 0xAE,//	[f32]→[i64]	
		trunc_f32_u: 0xAF,//	[f32]→[i64]	
		trunc_f64_s: 0xB0,//	[f64]→[i64]	
		trunc_f64_u: 0xB1,//	[f64]→[i64]	
		reinterpret_f64: 0xBD,//	[f64]→[i64]	
	},
	f64:{
		const: 0x44,
		load: 0x2B,
		store: 0x39,
		eq: 0x61,
		ne: 0x62,
		lt: 0x63,//	[f64 f64]→[i32]	
		gt: 0x64,//	[f64 f64]→[i32]	
		le: 0x65,//	[f64 f64]→[i32]	
		ge: 0x66,//	[f64 f64]→[i32]	
		abs: 0x99,//	[f64]→[f64]	
		neg: 0x9A,//	[f64]→[f64]	
		ceil: 0x9B,//	[f64]→[f64]	
		floor: 0x9C,//	[f64]→[f64]	
		trunc: 0x9D,//	[f64]→[f64]	
		nearest: 0x9E,//	[f64]→[f64]	
		sqrt: 0x9F,//	[f64]→[f64]	
		add: 0xA0,//	[f64 f64]→[f64]	
		sub: 0xA1,//	[f64 f64]→[f64]	
		mul: 0xA2,//	[f64 f64]→[f64]	
		div: 0xA3,//	[f64 f64]→[f64]	
		min: 0xA4,//	[f64 f64]→[f64]	
		max: 0xA5,//	[f64 f64]→[f64]	
		copysign: 0xA6,//	[f64 f64]→[f64]	
		convert_i32_s: 0xB7,//	[i32]→[f64]	
		convert_i32_u: 0xB8,//	[i32]→[f64]	
		convert_i64_s: 0xB9,//	[i64]→[f64]	
		convert_i64_u: 0xBA,//	[i64]→[f64]	
		promote_f32: 0xBB,//	[f32]→[f64]	
		reinterpret_i64: 0xBF,//	[i64]→[f64]	
	}*/
	/*
	v8x16.swizzle(a: v128, s: v128) -> v128
	def S.swizzle(a, s):
	    result = S.New()
	    for i in range(S.Lanes):
	        if s[i] < S.lanes:
	            result[i] = a[s[i]]
	        else:
	            result[i] = 0
	    return result

	v8x16.shuffle(a: v128, b: v128, imm: ImmLaneIdx32[16]) -> v128
	def S.shuffle(a, b, s):
		result = S.New()
		for i in range(S.Lanes):
		    if s[i] < S.lanes:
		        result[i] = a[s[i]]
		    else:
		        result[i] = b[s[i] - S.lanes]
		return result
	*/
	v128:{
		load:  defSimdOp(0x00, ...memarg16),
		store: defSimdOp(0x01, ...memarg16),
		const: (...v) => defSimdOp(0x02, ...v),//length = 16
		not: defSimdOp(0x4c),
		and: defSimdOp(0x4d),
		or: defSimdOp(0x4e),
		xor: defSimdOp(0x4f),
		bitselect: defSimdOp(0x50),//or(and(a, c), and(b, not(c)))
		andnot: defSimdOp(0xd8),//and(a, not(b))
	},
	v8x16:{
		load_splat: defSimdOp(0xc2),
		swizzle: defSimdOp(0xc0),
		shuffle: (...v) => defSimdOp(0xc1, ...v),//v = LaneIdx32[16]
	},
	v16x8:{
		load_splat: defSimdOp(0xc3),
	},
	v32x4:{
		load_splat: defSimdOp(0xc4),
	},
	v64x2:{
		load_splat: defSimdOp(0xc5),
	},
	i8x16:{
		splat: defSimdOp(0x04),
		extract_lane_s: i => defSimdOp(0x05, i),
		extract_lane_u: i => defSimdOp(0x06, i),
		replace_lane: i => defSimdOp(0x07, i),
		eq: defSimdOp(0x18),
		ne: defSimdOp(0x19),
		lt_s: defSimdOp(0x1a),
		lt_u: defSimdOp(0x1b),
		gt_s: defSimdOp(0x1c),
		gt_u: defSimdOp(0x1d),
		le_s: defSimdOp(0x1e),
		le_u: defSimdOp(0x1f),
		ge_s: defSimdOp(0x20),
		ge_u: defSimdOp(0x21),
		neg: defSimdOp(0x51),
		any_true: defSimdOp(0x52),
		all_true: defSimdOp(0x53),
		shl: defSimdOp(0x54),
		shr_s: defSimdOp(0x55),
		shr_u: defSimdOp(0x56),
		add: defSimdOp(0x57),
		add_saturate_s: defSimdOp(0x58),
		add_saturate_u: defSimdOp(0x59),
		sub: defSimdOp(0x5a),
		sub_saturate_s: defSimdOp(0x5b),
		sub_saturate_u: defSimdOp(0x5c),
		narrow_i16x8_s: defSimdOp(0xc6),
		narrow_i16x8_u: defSimdOp(0xc7),
	},
	i16x8:{
		load8x8_s: defSimdOp(0xd2, ...memarg1),
		load8x8_u: defSimdOp(0xd3, ...memarg1),
		splat: defSimdOp(0x08),
		extract_lane_s: i => defSimdOp(0x09, i),
		extract_lane_u: i => defSimdOp(0x0A, i),
		replace_lane: i => defSimdOp(0x0B, i),
		eq: defSimdOp(0x22),
		ne: defSimdOp(0x23),
		lt_s: defSimdOp(0x24),
		lt_u: defSimdOp(0x25),
		gt_s: defSimdOp(0x26),
		gt_u: defSimdOp(0x27),
		le_s: defSimdOp(0x28),
		le_u: defSimdOp(0x29),
		ge_s: defSimdOp(0x2a),
		ge_u: defSimdOp(0x2b),
		neg: defSimdOp(0x62),
		any_true: defSimdOp(0x63),
		all_true: defSimdOp(0x64),
		shl: defSimdOp(0x65),
		shr_s: defSimdOp(0x66),
		shr_u: defSimdOp(0x67),
		add: defSimdOp(0x68),
		add_saturate_s: defSimdOp(0x69),
		add_saturate_u: defSimdOp(0x6a),
		sub: defSimdOp(0x6b),
		sub_saturate_s: defSimdOp(0x6c),
		sub_saturate_u: defSimdOp(0x6d),
		mul: defSimdOp(0x6e),
		narrow_i32x4_s: defSimdOp(0xc8),
		narrow_i32x4_u: defSimdOp(0xc9),
		widen_low_i8x16_s: defSimdOp(0xca),
		widen_high_i8x16_s: defSimdOp(0xcb),
		widen_low_i8x16_u: defSimdOp(0xcc),
		widen_high_i8x16_u: defSimdOp(0xcd),
	},
	i32x4:{
		load16x4_s: defSimdOp(0xd4, ...memarg2),
		load16x4_u: defSimdOp(0xd5, ...memarg2),
		splat: defSimdOp(0x0C),
		extract_lane: i => defSimdOp(0x0D, i),
		replace_lane: i => defSimdOp(0x0E, i),
		eq: defSimdOp(0x2c),
		ne: defSimdOp(0x2d),
		lt_s: defSimdOp(0x2e),
		lt_u: defSimdOp(0x2f),
		gt_s: defSimdOp(0x30),
		gt_u: defSimdOp(0x31),
		le_s: defSimdOp(0x32),
		le_u: defSimdOp(0x33),
		ge_s: defSimdOp(0x34),
		ge_u: defSimdOp(0x35),
		neg: defSimdOp(0x73),
		any_true: defSimdOp(0x74),
		all_true: defSimdOp(0x75),
		shl: defSimdOp(0x76),
		shr_s: defSimdOp(0x77),
		shr_u: defSimdOp(0x78),
		add: defSimdOp(0x79),
		sub: defSimdOp(0x7c),
		mul: defSimdOp(0x7f),
		trunc_sat_f32x4_s: defSimdOp(0xab),
		trunc_sat_f32x4_u: defSimdOp(0xac),
		widen_low_i16x8_s: defSimdOp(0xce),
		widen_high_i16x8_s: defSimdOp(0xcf),
		widen_low_i16x8_u: defSimdOp(0xd0),
		widen_high_i16x8_u: defSimdOp(0xd1),
	},
	i64x2:{
		load32x2_s: defSimdOp(0xd6, ...memarg4),
		load32x2_u: defSimdOp(0xd7, ...memarg4),
		splat: defSimdOp(0x0F),
		extract_lane: i => defSimdOp(0x10, i),
		replace_lane: i => defSimdOp(0x11, i),
		neg: defSimdOp(0x84),
		shl: defSimdOp(0x87),
		shr_s: defSimdOp(0x88),
		shr_u: defSimdOp(0x89),
		add: defSimdOp(0x8a),
		sub: defSimdOp(0x8d),
		mul: defSimdOp(0x90),
		trunc_sat_f64x2_s: defSimdOp(0xad),
		trunc_sat_f64x2_u: defSimdOp(0xae),
	},
	f32x4:{
		splat: defSimdOp(0x12),
		extract_lane: i => defSimdOp(0x13, i),
		replace_lane: i => defSimdOp(0x14, i),
		eq: defSimdOp(0x40),
		ne: defSimdOp(0x41),
		lt: defSimdOp(0x42),
		gt: defSimdOp(0x43),
		le: defSimdOp(0x44),
		ge: defSimdOp(0x45),
		abs: defSimdOp(0x95),
		neg: defSimdOp(0x96),
		sqrt:defSimdOp(0x97),
		add: defSimdOp(0x9a),
		sub: defSimdOp(0x9b),
		mul: defSimdOp(0x9c),
		div: defSimdOp(0x9d),
		min: defSimdOp(0x9e),
		max: defSimdOp(0x9f),
		convert_i32x4_s: defSimdOp(0xaf),
		convert_i32x4_u: defSimdOp(0xb0),
	},
	f64x2:{
		splat: defSimdOp(0x15),
		extract_lane: i => defSimdOp(0x16, i),
		replace_lane: i => defSimdOp(0x17, i),
		eq: defSimdOp(0x46),
		ne: defSimdOp(0x47),
		lt: defSimdOp(0x48),
		gt: defSimdOp(0x49),
		le: defSimdOp(0x4a),
		ge: defSimdOp(0x4b),
		abs: defSimdOp(0xa0),
		neg: defSimdOp(0xa1),
		sqrt:defSimdOp(0xa2),
		add: defSimdOp(0xa5),
		sub: defSimdOp(0xa6),
		mul: defSimdOp(0xa7),
		div: defSimdOp(0xa8),
		min: defSimdOp(0xa9),
		max: defSimdOp(0xaa),
		convert_i64x2_s: defSimdOp(0xb1),
		convert_i64x2_u: defSimdOp(0xb2),
	},
};

/*
const keyList = ['i32', 'i64', 'f32', 'f64'];
for(let key of new Set(keyList.map(v => Object.keys(op[v])).reduce((a, b) => a.concat(b), []))){
	console.assert(!(key in op));
	let list = keyList.map(v => op[v][key] && v).filter(Boolean);
	if(list.length <= 1){
		op[key] = op[list[0]][key];
		continue;
	}
	op[key] = {};
	list.forEach(k => op[key][k] = op[k][key]);
}
*/
module.exports = op;
