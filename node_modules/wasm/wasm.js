
const {gen_vuint} = require('./utils');
const NUM_TYPE = require('./num_type');

const SECTION_TYPE = {
	//custom: 0,
	type: 1,
	import: 2,
	function: 3,
	table: 4,
	memory: 5,
	global: 6,
	export: 7,
	start: 8,
	element: 9,
	code: 10,
	data: 11,
};

const EXTERNAL_KIND = {
	func: 0,
	table: 1,
	memory: 2,
	global: 3,
};

const REF_TYPE = {
	funcref: 0x70,
	anyref: 0x6F,
	func: 0x60,
	block: 0x40,
}

function genType(funcTypeList){
	const result = gen_vuint(funcTypeList.length);
	for(let {argList, retType} of funcTypeList){
		result.push(0x60);//type function
		result.push(...gen_vuint(argList.length));
		result.push(...argList.map(v => NUM_TYPE[v[1]]));
		if(retType){
			result.push(1, NUM_TYPE[retType]);
		}else{
			result.push(0);
		}
	}
	return result;
}

function genFunc(funcList, funcTypeList){
	const result = gen_vuint(funcList.length);
	for(let {sign} of funcList){
		result.push(...gen_vuint(funcTypeList.findIndex(v => v.sign == sign)));
	}
	return result;
}

function genMem(memoryList){
	const result = gen_vuint(memoryList.length)
	for(let {initSize, maxSize} of memoryList){
		if(maxSize){
			result.push(1, ...gen_vuint(initSize), ...gen_vuint(maxSize));
		}else{
			result.push(0, ...gen_vuint(initSize));
		}
	}
	return result;
}

const genExport = function(){
	function doGen(result, list, kind, offset=0){
		let count = 0;
		for(let i=0, n=list.length; i<n; ++i){
			const item = list[i];
			if(!item.exportFlag)continue;
			++count;
			const name = Buffer.from(item.exportName);
			result.push(...gen_vuint(name.length), ...name, kind, ...gen_vuint(offset+i));
		}
		return count;
	}
	return function(funcList, memoryList, importList){
		let count = 0;
		const result = [];
		count += doGen(result, funcList, EXTERNAL_KIND.func, importList.length);
		count += doGen(result, memoryList, EXTERNAL_KIND.memory);
		result.unshift(...gen_vuint(count));
		return result;
	}
}()

function genCode(funcList, funcNameDict){
	const result = gen_vuint(funcList.length);
	for(let {locals, bodyFn, context} of funcList){
		let ins = gen_vuint(locals.length);
		for(let [k, v] of locals){
			ins.push(...gen_vuint(v.length), NUM_TYPE[k]);
		}
		context.funcIndex = name => funcNameDict[name];
		ins.push.apply(ins, bodyFn(context).flat());
		//bodyFn(context).forEach(v => ins.push(...v));
		ins.push(0x0B);//op.end
		result.push(...gen_vuint(ins.length), ...ins);
	}
	return result;
}

function genImport(importList, funcTypeList){
	const result = gen_vuint(importList.length);
	const kind = 0;//function
	for(let item of importList){
		const mod = Buffer.from(item.mod);
		const name = Buffer.from(item.name);
		result.push(
			...gen_vuint(mod.length), ...mod,
			...gen_vuint(name.length), ...name,
			kind,
			...gen_vuint(funcTypeList.findIndex(v => v.sign == item.sign))
		);
	}
	return result;
}

const genFuncSign = (argList, retType) => `(${argList.map(v => v[1])})=>(${retType || ''})`;

function addSec(result, type, data){
	if(data.length == 0)return;
	if(data.length == 1 && data[0] == 0)return;
	result.push(type, ...gen_vuint(data.length), ...data);
}

const sectionProto = {
	export(alias){
		this.exportFlag = true;
		this.exportName = alias || this.name;
		return this;
	}
};

exports.func = function(){
	const pattern = /(\w+)\(([\w,:]*)\)(?::(\w+)|)/;
	return function(define, localDef, bodyFn){
		const locals = localDef ? Object.entries(localDef) : [];
		const info = pattern.exec(define);
		const name = info[1];
		const argList = info[2] ? info[2].split(',').map(v => v.split(':')) : [];
		const retType = info[3];
		const context = Object.create(null);
		let localIndex = 0;
		argList.forEach(v => context[v[0]] = localIndex++);
		locals.forEach(kv => kv[1].forEach(v => context[v] = localIndex++));
		return Object.assign(Object.create(sectionProto), {
			type: SECTION_TYPE.function,
			sign: genFuncSign(argList, retType),
			name, argList, retType, locals,
			bodyFn, context
		})
	}
}()

exports.mem = function(name, initSize, maxSize){
	return Object.assign(Object.create(sectionProto), {
		type: SECTION_TYPE.memory,
		name, initSize, maxSize
	})
}

exports.import = function(){
	const pattern = /(\w+)\.(\w+)\(([\w,]*)\)(?::(\w+)|)/;
	return function(define, alias){
		let info = pattern.exec(define);
		let mod = info[1];
		let name = info[2];
		let argList = info[3] ? info[3].split(',').map((v, i) => [i.toString(), v]) : [];
		let retType = info[4];
		alias = alias || (mod + '.' + name);
		return {
			type: SECTION_TYPE.import,
			sign: genFuncSign(argList, retType),
			mod, name, argList, retType, alias
		}
	}
}()

exports.generate = function(...sectionList){
	const importList = sectionList.filter(v => v.type == SECTION_TYPE.import);
	const memoryList = sectionList.filter(v => v.type == SECTION_TYPE.memory);
	const funcList = sectionList.filter(v => v.type == SECTION_TYPE.function);
	const funcTypeList = funcList.concat(importList).filter(function({sign}){
		if(sign in this)return;
		return this[sign] = true;
	}, Object.create(null));
	const result = [0, ...Buffer.from('asm'), 1, 0, 0, 0];
	addSec(result, SECTION_TYPE.type, genType(funcTypeList));
	addSec(result, SECTION_TYPE.import, genImport(importList, funcTypeList));
	addSec(result, SECTION_TYPE.function, genFunc(funcList, funcTypeList));
	addSec(result, SECTION_TYPE.memory, genMem(memoryList));
	addSec(result, SECTION_TYPE.export, genExport(funcList, memoryList, importList));
	addSec(result, SECTION_TYPE.code, genCode(funcList, function(funcNameDict){
		importList.forEach(({alias}, i) => funcNameDict[alias] = i);
		funcList.forEach(({name}, i) => funcNameDict[name] = i + importList.length);
		return funcNameDict;
	}(Object.create(null))));
	return new Uint8Array(result);
}

exports.printList = list => list.map(v => '0x' + v.toString(16).padStart(2, '0')).join(', ');
