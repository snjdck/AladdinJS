

const op = {
	unreachable:0x00,
	nop:0x01,
	block:0x02,
	loop:0x03,
	if:0x04,
	else:0x05,
	end: 0x0B,//	 	 	 
	br: 0x0C,//	[t∗1 t?]→[t∗2]	
	br_if: 0x0D,//	[t? i32]→[t?]	
	br_table: 0x0E,//	[t∗1 t? i32]→[t∗2]	
	return: 0x0F,//	[t∗1 t?]→[t∗2]	
	call: 0x10,//	[t∗1]→[t∗2]	
	call_indirect: 0x11,//	[t∗1 i32]→[t∗2]	
	drop: 0x1A,//	[t]→[]	
	select: 0x1B,//	[t t i32]→[t]	
	select_t: 0x1C,//	[t t i32]→[t]	
	local:{
		get:0x20,//	[]→[t]	
		set:0x21,//	[t]→[]	
		tee:0x22,//	[t]→[t]	
	},
	global:{
		get:0x23,//	[]→[t]	
		set:0x24,//	[t]→[]	
	},
	table:{
		get:0x25,//	[]→[t]	
		set:0x26,//	[t]→[]	
	},
	memory:{
		size: 0x3F,//	[]→[i32]	
		grow: 0x40,//	[i32]→[i32]	
	},
	ref:{
		null: 0xD0,//	[]→[nullref]	
		is_null: 0xD1,//	[anyref]→[i32]	
		func: 0xD2,//	[]→[funcref]
	},
	i32:{
		const: 0x41,
		load: 0x28,
		store: 0x36,
		load8_s: 0x2C,//	[i32]→[i32]	
		load8_u: 0x2D,//	[i32]→[i32]	
		load16_s: 0x2E,//	[i32]→[i32]	
		load16_u: 0x2F,//	[i32]→[i32]	
		store8: 0x3A,//	[i32 i32]→[]	
		store16: 0x3B,//	[i32 i32]→[]	
		eqz:0x45,
		eq: 0x46,	
		ne: 0x47,
		lt_s: 0x48,//	[i32 i32]→[i32]	
		lt_u: 0x49,//	[i32 i32]→[i32]	
		gt_s: 0x4A,//	[i32 i32]→[i32]	
		gt_u: 0x4B,//	[i32 i32]→[i32]	
		le_s: 0x4C,//	[i32 i32]→[i32]	
		le_u: 0x4D,//	[i32 i32]→[i32]	
		ge_s: 0x4E,//	[i32 i32]→[i32]	
		ge_u: 0x4F,//	[i32 i32]→[i32]	
		clz: 0x67,//	[i32]→[i32]	
		ctz: 0x68,//	[i32]→[i32]	
		popcnt: 0x69,//	[i32]→[i32]	
		add: 0x6A,//	[i32 i32]→[i32]	
		sub: 0x6B,//	[i32 i32]→[i32]	
		mul: 0x6C,//	[i32 i32]→[i32]	
		div_s: 0x6D,//	[i32 i32]→[i32]	
		div_u: 0x6E,//	[i32 i32]→[i32]	
		rem_s: 0x6F,//	[i32 i32]→[i32]	
		rem_u: 0x70,//	[i32 i32]→[i32]	
		and: 0x71,//	[i32 i32]→[i32]	
		or: 0x72,//	[i32 i32]→[i32]	
		xor: 0x73,//	[i32 i32]→[i32]	
		shl: 0x74,//	[i32 i32]→[i32]	
		shr_s: 0x75,//	[i32 i32]→[i32]	
		shr_u: 0x76,//	[i32 i32]→[i32]	
		rotl: 0x77,//	[i32 i32]→[i32]	
		rotr: 0x78,//	[i32 i32]→[i32]	
		wrap_i64: 0xA7,//	[i64]→[i32]	
		trunc_f32_s: 0xA8,//	[f32]→[i32]	
		trunc_f32_u: 0xA9,//	[f32]→[i32]	
		trunc_f64_s: 0xAA,//	[f64]→[i32]	
		trunc_f64_u: 0xAB,//	[f64]→[i32]	
		reinterpret_f32: 0xBC,//	[f32]→[i32]	
	},
	i64:{
		const: 0x42,
		load: 0x29,
		store: 0x37,
		load8_s: 0x30,//	[i32]→[i64]	
		load8_u: 0x31,//	[i32]→[i64]	
		load16_s: 0x32,//	[i32]→[i64]	
		load16_u: 0x33,//	[i32]→[i64]	
		load32_s: 0x34,//	[i32]→[i64]	
		load32_u: 0x35,//	[i32]→[i64]	
		store8: 0x3C,//	[i32 i64]→[]	
		store16: 0x3D,//	[i32 i64]→[]	
		store32: 0x3E,//	[i32 i64]→[]
		eqz:0x50,
		eq: 0x51,
		ne: 0x52,
		lt_s: 0x53,//	[i64 i64]→[i32]	
		lt_u: 0x54,//	[i64 i64]→[i32]	
		gt_s: 0x55,//	[i64 i64]→[i32]	
		gt_u: 0x56,//	[i64 i64]→[i32]	
		le_s: 0x57,//	[i64 i64]→[i32]	
		le_u: 0x58,//	[i64 i64]→[i32]	
		ge_s: 0x59,//	[i64 i64]→[i32]	
		ge_u: 0x5A,//	[i64 i64]→[i32]	
		clz: 0x79,//	[i64]→[i64]	
		ctz: 0x7A,//	[i64]→[i64]	
		popcnt: 0x7B,//	[i64]→[i64]	
		add: 0x7C,//	[i64 i64]→[i64]	
		sub: 0x7D,//	[i64 i64]→[i64]	
		mul: 0x7E,//	[i64 i64]→[i64]	
		div_s: 0x7F,//	[i64 i64]→[i64]	
		div_u: 0x80,//	[i64 i64]→[i64]	
		rem_s: 0x81,//	[i64 i64]→[i64]	
		rem_u: 0x82,//	[i64 i64]→[i64]	
		and: 0x83,//	[i64 i64]→[i64]	
		or: 0x84,//	[i64 i64]→[i64]	
		xor: 0x85,//	[i64 i64]→[i64]	
		shl: 0x86,//	[i64 i64]→[i64]	
		shr_s: 0x87,//	[i64 i64]→[i64]	
		shr_u: 0x88,//	[i64 i64]→[i64]	
		rotl: 0x89,//	[i64 i64]→[i64]	
		rotr: 0x8A,//	[i64 i64]→[i64]	
		extend_i32_s: 0xAC,//	[i32]→[i64]	
		extend_i32_u: 0xAD,//	[i32]→[i64]	
		trunc_f32_s: 0xAE,//	[f32]→[i64]	
		trunc_f32_u: 0xAF,//	[f32]→[i64]	
		trunc_f64_s: 0xB0,//	[f64]→[i64]	
		trunc_f64_u: 0xB1,//	[f64]→[i64]	
		reinterpret_f64: 0xBD,//	[f64]→[i64]	
	},
	f32:{
		const: 0x43,
		load: 0x2A,
		store: 0x38,
		eq: 0x5B,
		ne: 0x5C,
		lt: 0x5D,//	[f32 f32]→[i32]	
		gt: 0x5E,//	[f32 f32]→[i32]	
		le: 0x5F,//	[f32 f32]→[i32]	
		ge: 0x60,//	[f32 f32]→[i32]	
		abs: 0x8B,//	[f32]→[f32]	
		neg: 0x8C,//	[f32]→[f32]	
		ceil: 0x8D,//	[f32]→[f32]	
		floor: 0x8E,//	[f32]→[f32]	
		trunc: 0x8F,//	[f32]→[f32]	
		nearest: 0x90,//	[f32]→[f32]	
		sqrt: 0x91,//	[f32]→[f32]	
		add: 0x92,//	[f32 f32]→[f32]	
		sub: 0x93,//	[f32 f32]→[f32]	
		mul: 0x94,//	[f32 f32]→[f32]	
		div: 0x95,//	[f32 f32]→[f32]	
		min: 0x96,//	[f32 f32]→[f32]	
		max: 0x97,//	[f32 f32]→[f32]	
		copysign: 0x98,//	[f32 f32]→[f32]	
		convert_i32_s: 0xB2,//	[i32]→[f32]	
		convert_i32_u: 0xB3,//	[i32]→[f32]	
		convert_i64_s: 0xB4,//	[i64]→[f32]	
		convert_i64_u: 0xB5,//	[i64]→[f32]	
		demote_f64: 0xB6,//	[f64]→[f32]	
		reinterpret_i32: 0xBE,//	[i32]→[f32]	
	},
	f64:{
		const: 0x44,
		load: 0x2B,
		store: 0x39,
		eq: 0x61,
		ne: 0x62,
		lt: 0x63,//	[f64 f64]→[i32]	
		gt: 0x64,//	[f64 f64]→[i32]	
		le: 0x65,//	[f64 f64]→[i32]	
		ge: 0x66,//	[f64 f64]→[i32]	
		abs: 0x99,//	[f64]→[f64]	
		neg: 0x9A,//	[f64]→[f64]	
		ceil: 0x9B,//	[f64]→[f64]	
		floor: 0x9C,//	[f64]→[f64]	
		trunc: 0x9D,//	[f64]→[f64]	
		nearest: 0x9E,//	[f64]→[f64]	
		sqrt: 0x9F,//	[f64]→[f64]	
		add: 0xA0,//	[f64 f64]→[f64]	
		sub: 0xA1,//	[f64 f64]→[f64]	
		mul: 0xA2,//	[f64 f64]→[f64]	
		div: 0xA3,//	[f64 f64]→[f64]	
		min: 0xA4,//	[f64 f64]→[f64]	
		max: 0xA5,//	[f64 f64]→[f64]	
		copysign: 0xA6,//	[f64 f64]→[f64]	
		convert_i32_s: 0xB7,//	[i32]→[f64]	
		convert_i32_u: 0xB8,//	[i32]→[f64]	
		convert_i64_s: 0xB9,//	[i64]→[f64]	
		convert_i64_u: 0xBA,//	[i64]→[f64]	
		promote_f32: 0xBB,//	[f32]→[f64]	
		reinterpret_i64: 0xBF,//	[i64]→[f64]	
	}
};
void function(){
	const keyList = ['i32', 'i64', 'f32', 'f64'];
	for(let key of new Set(keyList.map(v => Object.keys(op[v])).reduce((a, b) => a.concat(b), []))){
		console.assert(!(key in op));
		let list = keyList.map(v => op[v][key] && v).filter(Boolean);
		if(list.length <= 1){
			op[key] = op[list[0]][key];
			continue;
		}
		op[key] = {};
		list.forEach(k => op[key][k] = op[k][key]);
	}
}();





/*
	 

 	 	 

//*/

//https://www.jianshu.com/p/695c103333df

const FILE_HEAD = function(){
	let buffer = Buffer.alloc(8);
	buffer.writeUInt32LE(0x6d736100, 0);//magic number = asm
	buffer.writeUInt32LE(0x00000001, 4);//version = 1
	return buffer;
}();

const SECTION_TYPE = {
	type: 1,
	import: 2,
	function: 3,
	table: 4,
	memory: 5,
	global: 6,
	export: 7,
	start: 8,
	element: 9,
	code: 10,
	data: 11,
};

const NUM_TYPE = {
	i32: 0x7F,
	i64: 0x7E,
	f32: 0x7D,
	f64: 0x7C,
};

const REF_TYPE = {
	funcref: 0x70,
	anyref: 0x6F,
}

const SECTION_HANDLER = [null, genTypeSection, genImportSection, genFuncSection, null, null, null, genExportSection, null, null, genCodeSection];

const genWasm = sectionList => Buffer.concat([FILE_HEAD, ...sectionList.map(genSection)]);

function genSection(section){
	const {type} = section;
	const data = SECTION_HANDLER[type](section);
	return Buffer.concat([
		Buffer.alloc(1, type),
		Buffer.from(gen_vuint(data.length)),
		data
	]);
}

function genTypeSection({funcTypeList}){
	const result = [];
	result.push(...gen_vuint(funcTypeList.length));
	for(let {argTypes, retTypes} of funcTypeList){
		result.push(0x60);
		result.push(...gen_vuint(argTypes.length));
		result.push(...argTypes.map(v => NUM_TYPE[v]));
		result.push(...gen_vuint(retTypes.length));
		result.push(...retTypes.map(v => NUM_TYPE[v]));
	}
	return Buffer.from(result);
}

function genImportSection({importList}){
	const result = [];
	result.push(...gen_vuint(importList.length));
	for(let {name} of importList){
		result.push(...gen_vuint(name.length));
		result.push(...name.split('').map(v => v.charCodeAt()));
	}
	return Buffer.from(result);
}

function genFuncSection({entryList}){
	const result = [];
	result.push(...gen_vuint(entryList.length));
	for(let entry of entryList){
		result.push(...gen_vuint(entry));
	}
	return Buffer.from(result);
}

function genExportSection({exportList}){
	const result = [];
	result.push(...gen_vuint(exportList.length));
	for(let {name, kind, index} of exportList){
		result.push(...gen_vuint(name.length));
		result.push(...name.split('').map(v => v.charCodeAt()));
		result.push(kind);
		result.push(...gen_vuint(index));
	}
	return Buffer.from(result);
}

function genCodeSection({codeList}){
	/*
	body size
	local count
	locals
	code
	end
	*/
	const result = [];
	result.push(...gen_vuint(codeList.length));
	for(let insList of codeList){
		let ins = [];
		insList.forEach(v => ins.push(...v));
		let body = [0x00, ...ins, 0x0B];
		result.push(...gen_vuint(body.length));
		result.push(...body);
	}
	return Buffer.from(result);
}

function gen_vuint(value){
	const result = [];
	do{
		let byte = value & 0x7F;
		value >>= 7;
		result.push(value ? byte | 0x80 : byte);
	}while(value);
	return result;
}

const printList = list => list.map(v => '0x' + v.toString(16).padStart(2, '0')).join(', ');

function genTestCode(byteList, code){
	return `WebAssembly.compile(new Uint8Array([${
		byteList.join()
	}])).then(module=>{const instance = new WebAssembly.Instance(module);\n${code}\n});`;
}

const text = Array.from(genWasm([
{
	type:SECTION_TYPE.type,
	funcTypeList:[{
		argTypes:['i32', 'i32'],
		retTypes:['i32']
	},{
		argTypes:['i32'],
		retTypes:['i32']
	}]
}, {
	type: SECTION_TYPE['function'],
	entryList: [0, 1]
},{
	type: SECTION_TYPE['export'],
	exportList:[{
		name:'add',
		kind:0,
		index:0
	},{
		name:'square',
		kind:0,
		index:1
	}]
},{
	type:SECTION_TYPE.code,
	codeList:[
		[
		[op.local.get, 0],
		[op.local.get, 1],
		[op.i32.add],
		[op.return],
		],
		[
		[op.local.get, 0],
		[op.local.get, 0],
		[op.i32.mul],
		[op.return],
		]
	]
}
]));
console.log(printList( text))
console.log(genTestCode( text, `
const {add, square} = instance.exports
	console.log('2 + 4 =', add(2, 4))
	console.log('3^2 =', square(3))
	console.log('(2 + 5)^2 =', square(add(2+5)))

	`))
