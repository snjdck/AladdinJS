
const op = require('./op');

const SECTION_TYPE = {
	//custom: 0,
	type: 1,
	import: 2,
	function: 3,
	table: 4,
	memory: 5,
	global: 6,
	export: 7,
	start: 8,
	element: 9,
	code: 10,
	data: 11,
};

const EXTERNAL_KIND = {
	func: 0,
	table: 1,
	memory: 2,
	global: 3,
};

const NUM_TYPE = {
	i32: 0x7F,
	i64: 0x7E,
	f32: 0x7D,
	f64: 0x7C,
};

const REF_TYPE = {
	funcref: 0x70,
	anyref: 0x6F,
	func: 0x60,
	block: 0x40,
}

function gen_vuint(value){
	const result = [];
	do{
		let byte = value & 0x7F;
		value >>= 7;
		result.push(value ? byte | 0x80 : byte);
	}while(value);
	return result;
}

function genType(funcTypeList){
	const result = gen_vuint(funcTypeList.length);
	for(let {argList, retType} of funcTypeList){
		result.push(0x60);//type function
		result.push(...gen_vuint(argList.length));
		result.push(...argList.map(v => NUM_TYPE[v[1]]));
		if(retType){
			result.push(1, NUM_TYPE[retType]);
		}else{
			result.push(0);
		}
	}
	return result;
}

function genFunc(funcList, funcTypeList){
	const result = gen_vuint(funcList.length);
	for(let {sign} of funcList){
		result.push(...gen_vuint(funcTypeList.findIndex(v => v.sign == sign)));
	}
	return result;
}

function genMem(memoryList){
	const result = gen_vuint(memoryList.length)
	for(let {initSize, maxSize} of memoryList){
		if(maxSize){
			result.push(1, ...gen_vuint(initSize), ...gen_vuint(maxSize));
		}else{
			result.push(0, ...gen_vuint(initSize));
		}
	}
	return result;
}

const genExport = function(){
	function doGen(result, list, kind){
		let count = 0;
		for(let i=0, n=list.length; i<n; ++i){
			const item = list[i];
			if(!item.exportFlag)continue;
			++count;
			const name = Buffer.from(item.name);
			result.push(...gen_vuint(name.length), ...name, kind, ...gen_vuint(i));
		}
		return count;
	}
	return function(funcList, memoryList){
		let count = 0;
		const result = [];
		count += doGen(result, funcList, EXTERNAL_KIND.func);
		count += doGen(result, memoryList, EXTERNAL_KIND.memory);
		result.unshift(...gen_vuint(count));
		return result;
	}
}()

function genCode(funcList){
	const result = gen_vuint(funcList.length);
	for(let {body} of funcList){
		let ins = [0];//local count
		body.forEach(v => ins.push(...v));
		ins.push(op.end);
		result.push(...gen_vuint(ins.length), ...ins);
	}
	return result;
}

const addSec = (result, type, data) => result.push(type, ...gen_vuint(data.length), ...data);

const sectionProto = {
	export(){
		this.exportFlag = true;
		return this;
	}
};

exports.func = function(name, argList, retType, body){
	return Object.assign(Object.create(sectionProto), {
		type: SECTION_TYPE.function,
		sign: `(${argList.map(v => v[1])})=>(${retType || ''})`,
		name, argList, retType, body
	})
}

exports.mem = function(name, initSize, maxSize){
	return Object.assign(Object.create(sectionProto), {
		type: SECTION_TYPE.memory,
		name, initSize, maxSize
	})
}

exports.generate = function(...sectionList){
	const memoryList = sectionList.filter(v => v.type == SECTION_TYPE.memory);
	const funcList = sectionList.filter(v => v.type == SECTION_TYPE.function);
	const funcTypeList = funcList.filter(function({sign}){
		if(sign in this)return;
		return this[sign] = true;
	}, Object.create(null));
	const result = [0, ...Buffer.from('asm'), 1, 0, 0, 0];
	addSec(result, SECTION_TYPE.type, genType(funcTypeList));
	addSec(result, SECTION_TYPE.function, genFunc(funcList, funcTypeList));
	addSec(result, SECTION_TYPE.memory, genMem(memoryList));
	addSec(result, SECTION_TYPE.export, genExport(funcList, memoryList));
	addSec(result, SECTION_TYPE.code, genCode(funcList));
	//return new Uint8Array(result);
	return result;
}

exports.printList = list => list.map(v => '0x' + v.toString(16).padStart(2, '0')).join(', ');

exports.genTestCode = function(byteList, code){
	return `WebAssembly.compile(new Uint8Array([${
		byteList.join()
	}])).then(module=>{const instance = new WebAssembly.Instance(module);\n${code}\n});`;
}
