
const {gen_vuint} = require('./utils');

const SECTION_TYPE = {
	//custom: 0,
	type: 1,
	import: 2,
	function: 3,
	table: 4,
	memory: 5,
	global: 6,
	export: 7,
	start: 8,
	element: 9,
	code: 10,
	data: 11,
};

const EXTERNAL_KIND = {
	func: 0,
	table: 1,
	memory: 2,
	global: 3,
};

const NUM_TYPE = {
	i32: 0x7F,
	i64: 0x7E,
	f32: 0x7D,
	f64: 0x7C,
};

const REF_TYPE = {
	funcref: 0x70,
	anyref: 0x6F,
	func: 0x60,
	block: 0x40,
}

function genType(funcTypeList){
	const result = gen_vuint(funcTypeList.length);
	for(let {argList, retType} of funcTypeList){
		result.push(0x60);//type function
		result.push(...gen_vuint(argList.length));
		result.push(...argList.map(v => NUM_TYPE[v[1]]));
		if(retType){
			result.push(1, NUM_TYPE[retType]);
		}else{
			result.push(0);
		}
	}
	return result;
}

function genFunc(funcList, funcTypeList){
	const result = gen_vuint(funcList.length);
	for(let {sign} of funcList){
		result.push(...gen_vuint(funcTypeList.findIndex(v => v.sign == sign)));
	}
	return result;
}

function genMem(memoryList){
	const result = gen_vuint(memoryList.length)
	for(let {initSize, maxSize} of memoryList){
		if(maxSize){
			result.push(1, ...gen_vuint(initSize), ...gen_vuint(maxSize));
		}else{
			result.push(0, ...gen_vuint(initSize));
		}
	}
	return result;
}

const genExport = function(){
	function doGen(result, list, kind, offset=0){
		let count = 0;
		for(let i=0, n=list.length; i<n; ++i){
			const item = list[i];
			if(!item.exportFlag)continue;
			++count;
			const name = Buffer.from(item.name);
			result.push(...gen_vuint(name.length), ...name, kind, ...gen_vuint(offset+i));
		}
		return count;
	}
	return function(funcList, memoryList, importList){
		let count = 0;
		const result = [];
		count += doGen(result, funcList, EXTERNAL_KIND.func, importList.length);
		count += doGen(result, memoryList, EXTERNAL_KIND.memory);
		result.unshift(...gen_vuint(count));
		return result;
	}
}()

function genCode(funcList){
	const result = gen_vuint(funcList.length);
	for(let {body} of funcList){
		let ins = [0];//local count
		body.forEach(v => ins.push(...v));
		ins.push(0x0B);//op.end
		result.push(...gen_vuint(ins.length), ...ins);
	}
	return result;
}

function genImport(importList, funcTypeList){
	const result = gen_vuint(importList.length);
	const kind = 0;//function
	for(let item of importList){
		const mod = Buffer.from(item.mod);
		const name = Buffer.from(item.name);
		result.push(
			...gen_vuint(mod.length), ...mod,
			...gen_vuint(name.length), ...name,
			kind,
			...gen_vuint(funcTypeList.findIndex(v => v.sign == item.sign))
		);
	}
	return result;
}

function genFuncSign(argList, retType){
	return `(${argList.map(v => Array.isArray(v) ? v[1] : v)})=>(${retType || ''})`;
}

function addSec(result, type, data){
	if(data.length == 0)return;
	if(data.length == 1 && data[0] == 0)return;
	result.push(type, ...gen_vuint(data.length), ...data);
}

const sectionProto = {
	export(){
		this.exportFlag = true;
		return this;
	}
};

exports.func = function(name, argList, retType, body){
	return Object.assign(Object.create(sectionProto), {
		type: SECTION_TYPE.function,
		sign: genFuncSign(argList, retType),
		name, argList, retType, body
	})
}

exports.mem = function(name, initSize, maxSize){
	return Object.assign(Object.create(sectionProto), {
		type: SECTION_TYPE.memory,
		name, initSize, maxSize
	})
}

exports.import = function(mod, name, argList, retType){
	return {
		type: SECTION_TYPE.import,
		sign: genFuncSign(argList, retType),
		mod, name, argList, retType
	}
}

exports.generate = function(...sectionList){
	const importList = sectionList.filter(v => v.type == SECTION_TYPE.import);
	const memoryList = sectionList.filter(v => v.type == SECTION_TYPE.memory);
	const funcList = sectionList.filter(v => v.type == SECTION_TYPE.function);
	const funcTypeList = funcList.concat(importList).filter(function({sign}){
		if(sign in this)return;
		return this[sign] = true;
	}, Object.create(null));
	const result = [0, ...Buffer.from('asm'), 1, 0, 0, 0];
	addSec(result, SECTION_TYPE.type, genType(funcTypeList));
	addSec(result, SECTION_TYPE.import, genImport(importList, funcTypeList));
	addSec(result, SECTION_TYPE.function, genFunc(funcList, funcTypeList));
	addSec(result, SECTION_TYPE.memory, genMem(memoryList));
	addSec(result, SECTION_TYPE.export, genExport(funcList, memoryList, importList));
	addSec(result, SECTION_TYPE.code, genCode(funcList));
	//return new Uint8Array(result);
	return result;
}

exports.printList = list => list.map(v => '0x' + v.toString(16).padStart(2, '0')).join(', ');

exports.genTestCode = function(byteList, code){
	return `WebAssembly.instantiate(new Uint8Array([${
		byteList.join()
	}]), {Math}).then(({instance})=>{\n${code}\n});`;
}
