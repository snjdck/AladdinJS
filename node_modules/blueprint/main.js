//CSS.paintWorklet.addModule("shape.js");

function doDrag(dragTarget, panelTarget, onUpdate){
	function onMouseMove(evt){
		panelTarget.style.left = parseInt(panelTarget.style.left) + evt.movementX + 'px';
		panelTarget.style.top = parseInt(panelTarget.style.top) + evt.movementY + 'px';
		onUpdate.call(panelTarget, evt);
	}
	function onMouseDown(evt){
		//if(evt.target != evt.currentTarget)return;
		panelTarget.parentNode.appendChild(panelTarget);
		dragTarget.setPointerCapture(evt.pointerId);
		dragTarget.addEventListener('pointermove', onMouseMove);
		dragTarget.addEventListener('pointerup', onMouseUp);
	}
	function onMouseUp(evt){
		dragTarget.removeEventListener('pointermove', onMouseMove);
		dragTarget.removeEventListener('pointerup', onMouseUp);
	}
	dragTarget.addEventListener('pointerdown', onMouseDown);
	return () => dragTarget.removeEventListener('pointerdown', onMouseDown);
}


const calcOutputPt = rect => [rect.right, (rect.top + rect.bottom) * 0.5];
const calcInputPt = rect => [rect.left, (rect.top + rect.bottom) * 0.5];

/*
offset = pt2 - pt1
C1 = pt1 + 3 * delta * t + 3*(offset - 3 * delta) * t^2 - 2*(offset - 3 * delta) * t^3
*/
function calcLinkPath(outputSlot, inputSlot){
	const [outputX, outputY] = calcOutputPt(outputSlot);
	const [inputX, inputY] = calcInputPt(inputSlot);
	
	if(inputX > outputX){
		const offsetX = Math.max(Math.abs(inputX - outputX) * 0.3, 50);
		const offsetY = (inputY - outputY) * 0.05;
		return `path("M${outputX},${outputY} C${outputX+offsetX},${outputY-offsetY} ${inputX-offsetX},${inputY+offsetY} ${inputX},${inputY}")`;
	}

	const centerX = (outputX + inputX) * 0.5;
	const centerY = (outputY + inputY) * 0.5;

	const offsetX = Math.max(Math.abs(inputX - outputX) * 0.05, 20);
	const offsetY = (inputY - outputY) * 0.4;
	return `path("M${outputX},${outputY} C${outputX+offsetX},${outputY} ${outputX+offsetX},${centerY-offsetY} ${centerX},${centerY} S${inputX-offsetX},${inputY} ${inputX},${inputY}")`;
}

function createLinkLine(color, dashFlag){
	const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
	g.classList.add('blueprint-linkline');
	if(dashFlag)g.classList.add('dash');
	const bg = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	g.appendChild(bg);
	g.appendChild(line);
	line.setAttribute('stroke', color);
	return document.querySelector('#svgContainer').appendChild(g);
}

function listenMouseEvent(target){
	function onMouseDown(evt){
		let slot = evt.target;
		let type = slot.getAttribute('slot');
		if(!(type == 'input' || type == 'output'))return;
		if(type == 'output' && slot.dataset.type == 'expression'){
			//输出表达式可以输出多个值
		}else if(slot.dataset.connected == '1' || slot.dataset.type == 'field'){
			return;
		}
		const line = createLinkLine('white', slot.dataset.type == 'statement');
		let linkTarget;
		function onMouseMove(evt){
			let query;
			if(type == 'output'){
				if(slot.dataset.type == 'statement'){
					query = `blueprint-block > [slot="input"][data-type="statement"]:not([data-connected="1"])`;
				}else{
					query = `blueprint-block > [slot="input"][data-type="expression"]:not([data-connected="1"])`;
				}
			}else{//input
				if(slot.dataset.type == 'statement'){
					query = `blueprint-block > [slot="output"][data-type="statement"]:not([data-connected="1"])`;
				}else{
					query = `blueprint-block > [slot="output"][data-type="expression"]`;//输出表达式可以输出多个值
				}
			}
			let list = Array.from(document.querySelectorAll(query)).filter(v => v.parentNode != slot.parentNode);
			let f = type == 'input' ? calcOutputPt : calcInputPt;
			let distanceList = Array.from(list, v => f(v.getBoundingClientRect())).map(v => Math.hypot(evt.x - v[0], evt.y - v[1]));
			let min = Infinity
			let result;
			for(let i=0; i<distanceList.length; ++i){
				if(distanceList[i] > min)continue;
				min = distanceList[i];
				result = list[i]
			}
			let rectA = slot.getBoundingClientRect();
			let rectB;
			if(!result || min > 20){
				rectB = DOMRect.fromRect(evt);
				linkTarget = null;
			}else{
				rectB = result.getBoundingClientRect();
				linkTarget = result;
			}
			if(type == 'input'){
				line.style.setProperty('--d', calcLinkPath(rectB, rectA));
			}else{
				line.style.setProperty('--d', calcLinkPath(rectA, rectB));
			}
		}
		function onMouseUp(evt){
			window.removeEventListener('pointermove', onMouseMove);
			window.removeEventListener('pointerup', onMouseUp);
			if(linkTarget){
				if(type == 'input'){
					line.input = linkTarget;
					line.output = slot;
				}else{
					line.input = slot;
					line.output = linkTarget;
				}
				linkTarget.dataset.connected = 1;
				slot.dataset.connected = 1;
				listenContextMenu(line, 'linkline-menu', key => {
					switch(key){
					case 'delete':
						line.input.dataset.connected = 0;
						line.output.dataset.connected = 0;
						line.remove();
						break;
					}
				});
			}else{
				line.style.display = 'none';
				showMenu('blockList-menu', evt, async key => {
					if(!key){
						line.remove();
						return;
					}
						line.style.display = 'inline';
						let block = blockDict[key].cloneNode(true);
						block.style.left = evt.x + 'px';
						block.style.top = evt.y + 'px';
						target.parentNode.appendChild(block);
						linkTarget = block.querySelector(calcAnotherSlotQuery(slot));
						if(!linkTarget)return;
						onMouseUp(evt);
						let rectA = slot.getBoundingClientRect();
						let rectB = linkTarget.getBoundingClientRect();
						if(type == 'input'){
							line.style.setProperty('--d', calcLinkPath(rectB, rectA));
						}else{
							line.style.setProperty('--d', calcLinkPath(rectA, rectB));
						}

				}, menu => {
					for(let item of menu.querySelectorAll('[data-key]')){
						let block = blockDict[item.dataset.key];
						if(!block.querySelector(calcAnotherSlotQuery(slot))){
							item.parentNode.remove();
						}
					}
					for(;;){
						for(let item of menu.querySelectorAll('ul:not(:has(>li))')){
							item.remove();
						}
						let result = menu.querySelectorAll('div:not([data-key]):not(:has(+ul))');
						if(result.length == 0)break;
						for(let item of result){
							item.parentNode.remove();
						}
					}
				});
			}
		}
		window.addEventListener('pointermove', onMouseMove);
		window.addEventListener('pointerup', onMouseUp);
	}
	target.addEventListener('pointerdown', onMouseDown);
	return () => target.removeEventListener('pointerdown', onMouseDown);
}

function calcAnotherSlotQuery(slot){
	if(slot.getAttribute('slot') == 'output'){
		if(slot.dataset.type == 'statement'){
			return `[slot="input"][data-type="statement"]`;
		}else{
			return `[slot="input"][data-type="expression"]`;
		}
	}else{//input
		if(slot.dataset.type == 'statement'){
			return `[slot="output"][data-type="statement"]`;
		}else{
			return `[slot="output"][data-type="expression"]`;
		}
	}
}

function showMenu(menuID, position, handler, filter){
	const menu = menuDict[menuID].cloneNode(true);
	filter?.(menu);
	document.body.appendChild(menu);
	menu.style.left = 2 + position.x + 'px';
	menu.style.top = position.y + 'px';
	let key;
	function onToggle({newState}){
		if(newState == 'closed'){
			window.removeEventListener('pointerdown', onEvent);
			menu.removeEventListener('toggle', onToggle);
			menu.remove();
			handler(key, position);
		}
	}
	function onEvent(evt){
		if(menu.contains(evt.target)){
			if(evt.button != 0)return;
			key = evt.target.dataset.key;
		}
		menu.hidePopover();
	}
	window.addEventListener('pointerdown', onEvent);
	menu.addEventListener('toggle', onToggle);
	menu.showPopover();
}

function listenContextMenu(target, menuID, handler){
	target.addEventListener('contextmenu', evt => {
		evt.preventDefault();
		evt.stopPropagation();
		showMenu(menuID, evt, handler);
	});
}


const blockDict = {};
const menuDict = {};

document.addEventListener('DOMContentLoaded', async()=>{
	window.addEventListener('contextmenu', evt => evt.preventDefault());
	//console.log('aa')
	//document.body.addEventListener()
	const layerBlock = document.querySelector('.blueprint-root > .layerBlock');
	//*
	listenContextMenu(document.querySelector('.blueprint-root > svg:first-child'), 'blockList-menu', (key, position) => {
		if(!key)return;
		let block = blockDict[key].cloneNode(true);
		block.style.left = position.x + 'px';
		block.style.top = position.y + 'px';
		layerBlock.appendChild(block);
	});
	//*/
	await loadNodeList('assets/blocks.html', blockDict);
	await loadNodeList('assets/menus.html', menuDict);
	new MutationObserver(function(mutationList, observer){
		for(let mutation of mutationList){
			for(let block of mutation.removedNodes){
				block.signalLinkSlot();
				block.signalCancelDrag();
			}
			for(let block of mutation.addedNodes){
				block.signalLinkSlot = listenMouseEvent(block);
				block.signalCancelDrag = doDrag(block.shadowRoot.querySelector('.title'), block, updateLinkLines);
			}
		}
	}).observe(layerBlock, {childList:true, characterData:false});
	new MutationObserver(function(mutationList, observer){
		for(let {target} of mutationList){
			if(target.slot == 'input' && target.dataset.type == 'expression'){
				let input = target.querySelector('input');
				if(!input)continue;
				input.disabled = target.dataset.connected == '1';
			}
		}
	}).observe(layerBlock, {attributeFilter:['data-connected'], subtree:true, characterData:false});
});

function updateLinkLines(){
	for(let line of document.querySelectorAll('#svgContainer > g.blueprint-linkline')){
		if(line.input.parentNode != this && line.output.parentNode != this)continue;
		let rectA = line.input.getBoundingClientRect();
		let rectB = line.output.getBoundingClientRect();
		line.style.setProperty('--d', calcLinkPath(rectA, rectB));
	}
}

async function loadHtml(path){
	const response = await fetch(path);
	const text = await response.text();
	const parser = new DOMParser();
	return parser.parseFromString(text, 'text/html');
}

async function loadNodeList(path, dict){
	for(let node of (await loadHtml(path)).querySelectorAll('body > [data-id]')){
		dict[node.dataset.id] = node;
	}
}
//https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/d#lineto_%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4
