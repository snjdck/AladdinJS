//CSS.paintWorklet.addModule("shape.js");

function doDrag(dragTarget, panelTarget, onUpdate){
	function onMouseMove(evt){
		panelTarget.style.left = parseInt(panelTarget.style.left) + evt.movementX + 'px';
		panelTarget.style.top = parseInt(panelTarget.style.top) + evt.movementY + 'px';
		onUpdate?.(evt);
	}
	dragTarget.addEventListener('pointerdown', evt => {
		panelTarget.parentNode.appendChild(panelTarget);
		dragTarget.setPointerCapture(evt.pointerId);
		dragTarget.addEventListener('pointermove', onMouseMove);
	});
	dragTarget.addEventListener('pointerup', evt => {
		dragTarget.removeEventListener('pointermove', onMouseMove);
	});
}


const calcOutputPt = rect => [rect.right, (rect.top + rect.bottom) * 0.5];
const calcInputPt = rect => [rect.left, (rect.top + rect.bottom) * 0.5];

/*
offset = pt2 - pt1
C1 = pt1 + 3 * delta * t + 3*(offset - 3 * delta) * t^2 - 2*(offset - 3 * delta) * t^3
*/
function calcLinkPath(outputSlot, inputSlot){
	const [outputX, outputY] = calcOutputPt(outputSlot);
	const [inputX, inputY] = calcInputPt(inputSlot);
	
	if(inputX > outputX){
		const offsetX = Math.max(Math.abs(inputX - outputX) * 0.3, 50);
		const offsetY = (inputY - outputY) * 0.05;
		return `M${outputX},${outputY} C${outputX+offsetX},${outputY-offsetY} ${inputX-offsetX},${inputY+offsetY} ${inputX},${inputY}`;
	}

	const centerX = (outputX + inputX) * 0.5;
	const centerY = (outputY + inputY) * 0.5;

	const offsetX = Math.max(Math.abs(inputX - outputX) * 0.05, 20);
	const offsetY = (inputY - outputY) * 0.4;
	return `M${outputX},${outputY} C${outputX+offsetX},${outputY} ${outputX+offsetX},${centerY-offsetY} ${centerX},${centerY} S${inputX-offsetX},${inputY} ${inputX},${inputY}`;
}

function createLinkLine(color, dashFlag){
	const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	line.setAttribute('stroke', color);
	line.classList.add('blueprint-linkline');
	if(dashFlag)line.classList.add('dash');
	return document.querySelector('#svgContainer').appendChild(line);
}

customElements.define("blueprint-statement", class extends HTMLElement {
 	//static observedAttributes = [];

	constructor(){
		super();
		const template = document.getElementById("my-element").content;
		const shadowRoot = this.attachShadow({mode: "open"});
		shadowRoot.appendChild(template.cloneNode(true));

		doDrag(this.shadowRoot.querySelector('.title'), this, evt => {
			for(let line of document.querySelectorAll('#svgContainer > path')){
				if(line.input.parentNode != this && line.output.parentNode != this)continue;
				let rectA = line.input.getBoundingClientRect();
				let rectB = line.output.getBoundingClientRect();
				line.setAttribute('d', calcLinkPath(rectA, rectB));
			}
		});

		this.addEventListener('pointerdown', evt => {
			let slot = evt.target;
			let type = slot.getAttribute('slot');
			if(!(type == 'input' || type == 'output'))return;
			if(type == 'output' && slot.dataset.statement != '1'){
				//输出表达式可以输出多个值
			}else if(slot.dataset.connected == '1'){
				return;
			}
			const line = createLinkLine('white', slot.dataset.statement == '1');
			let linkTarget;
			function onMouseMove(evt){
				let query;
				if(type == 'output'){
					if(slot.dataset.statement == '1'){
						query = `blueprint-statement > [slot="input"][data-statement="1"]:not([data-connected="1"])`;
					}else{
						query = `blueprint-statement > [slot="input"]:not([data-statement="1"]):not([data-connected="1"])`;
					}
				}else{//input
					if(slot.dataset.statement == '1'){
						query = `blueprint-statement > [slot="output"][data-statement="1"]:not([data-connected="1"])`;
					}else{
						query = `blueprint-statement > [slot="output"]:not([data-statement="1"])`;//输出表达式可以输出多个值
					}
				}
				let list = Array.from(document.querySelectorAll(query)).filter(v => v.parentNode != slot.parentNode);
				let f = type == 'input' ? calcOutputPt : calcInputPt;
				let distanceList = Array.from(list, v => f(v.getBoundingClientRect())).map(v => Math.hypot(evt.x - v[0], evt.y - v[1]));
				let min = Infinity
				let result;
				for(let i=0; i<distanceList.length; ++i){
					if(distanceList[i] > min)continue;
					min = distanceList[i];
					result = list[i]
				}
				let rectA = slot.getBoundingClientRect();
				let rectB = result.getBoundingClientRect();
				if(min > 20){
					rectB = DOMRect.fromRect(evt);
					linkTarget = null;
				}else{
					linkTarget = result;
				}
				if(type == 'input'){
					line.setAttribute('d', calcLinkPath(rectB, rectA));
				}else{
					line.setAttribute('d', calcLinkPath(rectA, rectB));
				}
			}
			function onMouseUp(evt){
				window.removeEventListener('pointermove', onMouseMove);
				window.removeEventListener('pointerup', onMouseUp);
				if(linkTarget){
					if(type == 'input'){
						line.input = linkTarget;
						line.output = slot;
					}else{
						line.input = slot;
						line.output = linkTarget;
					}
					linkTarget.dataset.connected = 1;
					slot.dataset.connected = 1;
					line.addEventListener('contextmenu', evt => {
						evt.preventDefault();
					})
				}else{
					line.remove();
				}
			}
			window.addEventListener('pointermove', onMouseMove);
			window.addEventListener('pointerup', onMouseUp);
		})
	}

	connectedCallback(){}
	disconnectedCallback(){}
	adoptedCallback(){}
	attributeChangedCallback(name, oldValue, newValue){}
});

document.addEventListener('DOMContentLoaded', () =>{
	console.log('aa')
	//document.body.addEventListener()
});
//https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/d#lineto_%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4