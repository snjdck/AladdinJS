//CSS.paintWorklet.addModule("shape.js");

function doDrag(dragTarget, panelTarget, onUpdate){
	function onMouseMove(evt){
		panelTarget.style.left = parseInt(panelTarget.style.left) + evt.movementX + 'px';
		panelTarget.style.top = parseInt(panelTarget.style.top) + evt.movementY + 'px';
		onUpdate?.(evt);
	}
	dragTarget.addEventListener('pointerdown', evt => {
		panelTarget.parentNode.appendChild(panelTarget);
		dragTarget.setPointerCapture(evt.pointerId);
		dragTarget.addEventListener('pointermove', onMouseMove);
	});
	dragTarget.addEventListener('pointerup', evt => {
		dragTarget.removeEventListener('pointermove', onMouseMove);
	});
}


const calcOutputPt = rect => [rect.right, (rect.top + rect.bottom) * 0.5];
const calcInputPt = rect => [rect.left, (rect.top + rect.bottom) * 0.5];

/*
offset = pt2 - pt1
C1 = pt1 + 3 * delta * t + 3*(offset - 3 * delta) * t^2 - 2*(offset - 3 * delta) * t^3
*/
function calcLinkPath(outputSlot, inputSlot){
	const [outputX, outputY] = calcOutputPt(outputSlot);
	const [inputX, inputY] = calcInputPt(inputSlot);
	
	if(inputX > outputX){
		const offsetX = Math.max(Math.abs(inputX - outputX) * 0.3, 50);
		const offsetY = (inputY - outputY) * 0.05;
		return `path("M${outputX},${outputY} C${outputX+offsetX},${outputY-offsetY} ${inputX-offsetX},${inputY+offsetY} ${inputX},${inputY}")`;
	}

	const centerX = (outputX + inputX) * 0.5;
	const centerY = (outputY + inputY) * 0.5;

	const offsetX = Math.max(Math.abs(inputX - outputX) * 0.05, 20);
	const offsetY = (inputY - outputY) * 0.4;
	return `path("M${outputX},${outputY} C${outputX+offsetX},${outputY} ${outputX+offsetX},${centerY-offsetY} ${centerX},${centerY} S${inputX-offsetX},${inputY} ${inputX},${inputY}")`;
}

function createLinkLine(color, dashFlag){
	const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
	g.classList.add('blueprint-linkline');
	if(dashFlag)g.classList.add('dash');
	const bg = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	g.appendChild(bg);
	g.appendChild(line);
	line.setAttribute('stroke', color);
	return document.querySelector('#svgContainer').appendChild(g);
}

function listenMouseEvent(target){
	target.addEventListener('pointerdown', evt => {
		let slot = evt.target;
		let type = slot.getAttribute('slot');
		if(!(type == 'input' || type == 'output'))return;
		if(type == 'output' && slot.dataset.statement != '1'){
			//输出表达式可以输出多个值
		}else if(slot.dataset.connected == '1'){
			return;
		}
		const line = createLinkLine('white', slot.dataset.statement == '1');
		let linkTarget;
		function onMouseMove(evt){
			let query;
			if(type == 'output'){
				if(slot.dataset.statement == '1'){
					query = `blueprint-block > [slot="input"][data-statement="1"]:not([data-connected="1"])`;
				}else{
					query = `blueprint-block > [slot="input"]:not([data-statement="1"]):not([data-connected="1"])`;
				}
			}else{//input
				if(slot.dataset.statement == '1'){
					query = `blueprint-block > [slot="output"][data-statement="1"]:not([data-connected="1"])`;
				}else{
					query = `blueprint-block > [slot="output"]:not([data-statement="1"])`;//输出表达式可以输出多个值
				}
			}
			let list = Array.from(document.querySelectorAll(query)).filter(v => v.parentNode != slot.parentNode);
			let f = type == 'input' ? calcOutputPt : calcInputPt;
			let distanceList = Array.from(list, v => f(v.getBoundingClientRect())).map(v => Math.hypot(evt.x - v[0], evt.y - v[1]));
			let min = Infinity
			let result;
			for(let i=0; i<distanceList.length; ++i){
				if(distanceList[i] > min)continue;
				min = distanceList[i];
				result = list[i]
			}
			let rectA = slot.getBoundingClientRect();
			let rectB = result.getBoundingClientRect();
			if(min > 20){
				rectB = DOMRect.fromRect(evt);
				linkTarget = null;
			}else{
				linkTarget = result;
			}
			if(type == 'input'){
				line.style.setProperty('--d', calcLinkPath(rectB, rectA));
			}else{
				line.style.setProperty('--d', calcLinkPath(rectA, rectB));
			}
		}
		function onMouseUp(evt){
			window.removeEventListener('pointermove', onMouseMove);
			window.removeEventListener('pointerup', onMouseUp);
			if(linkTarget){
				if(type == 'input'){
					line.input = linkTarget;
					line.output = slot;
				}else{
					line.input = slot;
					line.output = linkTarget;
				}
				linkTarget.dataset.connected = 1;
				slot.dataset.connected = 1;
				line.addEventListener('contextmenu', evt => {
					evt.preventDefault();
					let menu = document.querySelector('#linkline-menu');
					menu.style.left = 2 + evt.x + 'px';
					menu.style.top = evt.y + 'px';
					menu.style.display = 'block';
				})
			}else{
				line.remove();
			}
		}
		window.addEventListener('pointermove', onMouseMove);
		window.addEventListener('pointerup', onMouseUp);
	})
}

customElements.define("blueprint-block", class extends HTMLElement{
	constructor(){
		super();
		const template = document.getElementById("blueprint-block");
		const shadowRoot = this.attachShadow({mode: "open"});
		shadowRoot.appendChild(template.content.cloneNode(true));
		listenMouseEvent(this);
		doDrag(this.shadowRoot.querySelector('.title'), this, evt => {
			for(let line of document.querySelectorAll('#svgContainer > g.blueprint-linkline')){
				if(line.input.parentNode != this && line.output.parentNode != this)continue;
				let rectA = line.input.getBoundingClientRect();
				let rectB = line.output.getBoundingClientRect();
				line.style.setProperty('--d', calcLinkPath(rectA, rectB));
			}
		});
	}
});

document.addEventListener('DOMContentLoaded', () =>{
	//console.log('aa')
	//document.body.addEventListener()
	window.addEventListener('contextmenu', evt => {
		evt.preventDefault();
	});
	window.addEventListener('pointerdown', evt => {
		let menu = document.querySelector('#linkline-menu');
		menu.style.display = 'none';
	})
});
//https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/d#lineto_%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4