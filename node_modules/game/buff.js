//FinalizationRegistry
//structuredClone

class PropEffect
{
	constructor(key, value, flag=3){
		this.key = key;
		this.value = value;
		this.flag = flag;
	}
	onAdd(target){
		if((this.flag & 1) == 0)return;
		const {key, value} = this;
		target[key] += value;
	}
	onDel(target){
		if((this.flag & 2) == 0)return;
		const {key, value} = this;
		target[key] -= value;
	}
}

class EffectGroup
{
	constructor(effectList){
		this.effectList = effectList;
	}
	onAdd(target){
		for(let effect of this.effectList){
			effect.onAdd(target);
		}
	}
	onDel(target){
		for(let effect of this.effectList){
			effect.onDel(target);
		}
	}
}

class Buff
{
	constructor(baseEffect, tickEffect, duration=0, interval=100){
		this.duration = duration;
		this.interval = interval;
		this.baseEffect = baseEffect;
		this.tickEffect = tickEffect;
		this.index = 1;
	}
	onAdd(target){
		this.timestamp = performance.now();
		target.addEffect(this.baseEffect);
	}
	onDel(target){
		target.delEffect(this.baseEffect);
	}
	onUpdate(target){
		const {duration, interval, index} = this;
		const position = performance.now() - this.timestamp;
		if(position >= interval * index){
			++this.index;
			this.tickEffect?.onAdd(target);
		}
		if(position >= this.duration){
			target.delBuff(this);
			return;
		}
	}
}

class Unit
{
	constructor(){
		this.effectSet = new Set();
		this.buffSet = new Set();
		this.addProp('maxHp', 500);
		this.addProp('hpRate', 5);
		this.addProp('maxMp', 500);
		this.addProp('mpRate', 5);
		this.addProp('attack', 50);
		this.addProp('defend', 10);
		this.addProp('magicAttack', 50);
		this.addProp('magicDefend', 10);
		this.addProp('attackRange', 300);
		this.addProp('attackSpeed', 2);
		this.addProp('moveSpeed', 300);
		this.hp = this.maxHp;
		this.mp = this.maxMp;
	}

	addProp(key, value){
		this[key] = value;
		const key1 = key + '+';
		const key2 = key + '+%';
		this[key1] = this[key2] = 0;
		Object.defineProperty(this, '$'+key, {
			get(){
				const value = this[key];
				return value + this[key1] + value * this[key2] * 0.01;
			}
		});
	}

	addBySet(set, value){
		if(set.has(value))return;
		set.add(value);
		value.onAdd(this);
	}

	delBySet(set, value){
		if(!set.has(value))return;
		set.delete(value);
		value.onDel(this);
	}

	addEffect(effect){
		this.addBySet(this.effectSet, effect);
	}

	delEffect(effect){
		this.delBySet(this.effectSet, effect);
	}

	addBuff(buff){
		this.addBySet(this.buffSet, buff);
	}

	delBuff(buff){
		this.delBySet(this.buffSet, buff);
	}

	execBuff(method, ...args){
		for(let buff of this.buffSet){
			buff[method]?.(this, ...args);
		}
	}
}

class UnitManager
{
	constructor(){
		this.unitSet = new Set();
		setInterval(() => this.updateUnit(), 0);
	}

	updateUnit(unit){
		for(let unit of this.unitSet){
			unit.execBuff('onUpdate');
		}
	}

	addUnit(unit){
		this.unitSet.add(unit);
	}
}

let t = new Unit();
let mgr = new UnitManager()
mgr.addUnit(t);
let effectGroup = new EffectGroup([
	new PropEffect('attack+', 6),
	new PropEffect('attack+%', 10),
])
t.attack = 45;
t.addBuff(new Buff(
	effectGroup, new PropEffect('hp', -10), 6000, 1000
))
console.log(t.$attack, t.hp)
setInterval(() => {
	console.log(t.$attack, t.hp)
}, 1000);

t.execBuff('onAttack');
t.execBuff('onDefend');
t.execBuff('onBeforeKilled');//必杀完全吸收
t.execBuff('onAfterKilled');//杀死对方回复自己hp


/*

get maxStackCount(){
		return 1;
	}

	get overflowReplaceType(){
		//forbid, remove oldest
		return 0;
	}
*/
