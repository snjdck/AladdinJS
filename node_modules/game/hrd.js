'use strict';

const {collect} = require('utils/array/link');
const {flipX} = require('utils/array/rotate');

const width=4, height=5;
const A=1, B=2, C=3, D=4;

const isSuccess = v => v[13] === A && v[14] === A && v[17] === A && v[18] === A;

function cloneBuffer(stepList, data){
	const result = Buffer.from(data);
	Object.defineProperty(result, 'prev', {value:data, writable:true});
	stepList.push(result);
	return result;
}

function help5(stepList, data, index, test, offset){
	const value = data[index+offset];
	if(value != D && value != test)return;
	const result = cloneBuffer(stepList, data);
	result[index] = value;
	result[index+offset*(value == D ? 1 : 2)] = 0;
}

function checkOne(stepList, data, index){
	const x = index % width;
	const y = Math.floor(index / width);
	if(x > 0){
		help5(stepList, data, index, C, -1);
	}
	if(x < width-1){
		help5(stepList, data, index, C,  1);
	}
	if(y > 0){
		help5(stepList, data, index, B, -width);
	}
	if(y < height-1){
		help5(stepList, data, index, B,  width);
	}
}

function help0(stepList, data, a, b){
	if(data[a] !== D)return;
	const result = cloneBuffer(stepList, data);
	result[a] = 0;
	result[b] = D;
}

function help1(stepList, data, a, b, offset, test){
	if(data[a+offset] == test){
		help4(stepList, data, a, b, offset * 2);
	}else{
		help0(stepList, data, a+offset, b);
	}
}

function help2(stepList, data, a, b, offset){
	if(data[a+offset] == A && data[b+offset] == A){
		help4(stepList, data, a, b, offset * 2);
	}else if(data[a+offset] == C && data[b+offset] == C){
		help4(stepList, data, a, b, offset);
	}else{
		help0(stepList, data, a+offset, b);
		help0(stepList, data, b+offset, a);
	}
}

function help3(stepList, data, a, b, x, y, offset){
	if(data[a+offset] == A && data[b+offset] == A){
		help4(stepList, data, a, b, offset * 2);
	}else if(data[a+offset] == B && data[b+offset] == B){
		if(y == 1 && data[a-width+offset] == B)return;
		if(y == 2 && data[b+width+offset] == B)return;
		help4(stepList, data, a, b, offset);
		/*
		for(let value of findItem(height, x+offset, width, data, B, 2)){
			if(value != y)continue;
			help4(stepList, data, a, b, offset);
			break;
		}
		*/
	}else{
		help0(stepList, data, a+offset, b);
		help0(stepList, data, b+offset, a);
	}
}

function help4(stepList, data, a, b, offset){
	const result = cloneBuffer(stepList, data);
	result[a] = result[b] = data[a+offset];
	result[a+offset] = result[b+offset] = 0;
}

function checkTwo(stepList, data, a, b){
	const x = a % width;
	const y = Math.floor(a / width);
	if(x < width-1 && a + 1 == b){
		if(x > 0){
			help1(stepList, data, a, b, -1, C);
		}
		if(x < width-2){
			help1(stepList, data, b, a,  1, C);
		}
		if(y > 0){
			help2(stepList, data, a, b, -width);
		}
		if(y < height-1){
			help2(stepList, data, a, b,  width);
		}
	}else if(y < height-1 && a + width == b){
		if(y > 0){
			help1(stepList, data, a, b, -width, B);
		}
		if(y < height-2){
			help1(stepList, data, b, a,  width, B);
		}
		if(x > 0){
			help3(stepList, data, a, b, x, y, -1);
		}
		if(x < width-1){
			help3(stepList, data, a, b, x, y,  1);
		}
	}
}

function*findItem(count, from, step, data, itemValue, itemSize){
	let index = 0;
	for(let i=0; i<count; ++i){
		if(data[from+step*i] != itemValue)continue;
		if(++index % itemSize == 1){
			yield i;
		}
	}
}

function main(init){
	const tempBuffer = Buffer.alloc(20);
	const stepList = [init];
	const checkedSignSet = new Set();
	let result;
	while(stepList.length > 0){
		const data = stepList.shift();
		if(isSuccess(data)){
			result = data;
			break;
		}
		const sign = encode(data);
		if(checkedSignSet.has(sign))continue;
		checkedSignSet.add(sign);
		checkedSignSet.add(encode(flipX(data, width, height, tempBuffer)));
		const a = data.indexOf(0);
		const b = data.lastIndexOf(0);
		checkOne(stepList, data, a);
		checkOne(stepList, data, b);
		checkTwo(stepList, data, a, b);
	}
	if(!result){
		console.log('no result!');
		return;
	}
	let list = collect(result).reverse().map(data => printSign(data.toString('hex')));
	console.log(list.length)
	//require('fs').writeFileSync('./data.txt', list.length + '\n' + list.join('\n'+'-'.repeat(11)+'\n'))
}

function printSign(sign){
	return sign.match(/\w{8}/g).map(v => '|' + v + ' |').join('\n').replace(/\d{2}/g, v => ' ' + ((v === '00') ? ' ' : String.fromCharCode(Number(v) + 64)));
}

let a = Date.now();
main(Buffer.from([
	B,   A,   A,   B,
	B,   A,   A,   B,
	B,   C,   C,   B,
	B,   D,   D,   B,
	D,   0,   0,   D,
]));
console.log(Date.now() - a)

//0-space,1-solider,2-vertical,3-horizon
function encode(data){
	let result = 0;
	let count = 0;
	let useInfo = 0;
	for(let i=0; i<20; ++i){
		if(useInfo & 1 << i)continue;
		switch(data[i]){
			case B:
				useInfo |= 0x11 << i;
				result |= 2 << (count++ << 1);
				break;
			case C:
				useInfo |= 3 << i;
				result |= 3 << (count++ << 1);
				break;
			case D:
				useInfo |= 1 << i;
				result |= 1 << (count++ << 1);
				break;
			case 0:
				useInfo |= 1 << i;
				result |= 0 << (count++ << 1);
				break;
			case A:
				useInfo |= 0x33 << i;
				result |= count << 22;
				break;
		}
	}
	return result;
}

function decode(value){
	const special = value >> 22;
	const result = Buffer.alloc(20, -1);
	let offset;
	for(let i=0; i<11; ++i){
		if(special == i){
			offset = result.indexOf(-1);
			result[offset] = result[offset+1] = result[offset+width] = result[offset+width+1] = A;
		}
		switch(value >> (i << 1) & 3){
			case 0:
				result[result.indexOf(-1)] = 0;
				break;
			case 1:
				result[result.indexOf(-1)] = D;
				break;
			case 2:
				offset = result.indexOf(-1);
				result[offset] = result[offset+width] = B;
				break;
			case 3:
				offset = result.indexOf(-1);
				result[offset] = result[offset+1] = C;
				break;
		}
	}
	return result;
}

for(let a of [[
	B,   A,   A,   B,
	B,   A,   A,   B,
	B,   D,   D,   B,
	B,   D,   D,   B,
	0,   C,   C,   0,
],[
	C,   C,   D,   D,
	B,   B,   A,   A,
	B,   B,   A,   A,
	B,   B,   0,   D,
	B,   B,   0,   D,
]]){
	console.log(decode(encode(a)).compare(Buffer.from(a)) == 0)
}
