
function runAction(target, action){
	let cancelFlag = false;
	const promise = new Promise((resolve, reject) => {
		const g = action(target);
		if(globalThis.document){
			const t = document.timeline.currentTime;
			void function f(timestamp){
				if(cancelFlag)return reject();
				const {done} = g.next(timestamp - t);
				if(done)resolve();else requestAnimationFrame(f);
			}();
		}else{
			const t = performance.now();
			void function f(){
				if(cancelFlag)return reject();
				const {done} = g.next(performance.now() - t);
				if(done)resolve();else setTimeout(f, 100);
			}();
		}
	});
	promise.cancel = () => {cancelFlag = true};
	return promise;
}

const Spawn = actions => function*(target){
	const list = Array.from(actions, action => action(target));
	let lastV = 0;
	const f = (v, g) => v + g.next(lastV).done;
	while(list.reduce(f, 0) < list.length){
		lastV = yield;
	}
}

const Sequence = actions => function*(target){
	let offset = 0;
	let lastV = 0;
	for(let action of actions){
		for(let g = action(target); !g.next(lastV - offset).done;){
			lastV = yield;
		}
		offset = lastV;
	}
}

const Repeat = function(){
	const genN = function*(value, count){for(let i=0; i<count; ++i)yield value};
	return (action, count=Infinity) => Sequence(genN(action, count));
}();

const CallFunc = f => function*(target){
	const action = f(target);
	if(action instanceof Function)yield* action(target);
}

const Delay = duration => function*(){
	for(let lastV=0; lastV<duration;){
		lastV = yield;
	}
}

const ActionBuilder = function(){
	const linear = v => v;
	const interpolate = function([a, b]){return a + (b - a) * this};
	const calc = (a, b) => typeof b == 'number' ? b : Number(b) + a;
	const calcPair = (a, b) => [a, calc(a, b)];
	const sub = v => v[1] - v[0];
	return (initFn, updateFn) => ({duration, value, ease=linear, speed}) => function*(target){
		const info = Array.from(initFn(target), (v, i) => calcPair(v, value[i] ?? v));
		if(speed){
			duration = Math.hypot(...info.map(sub)) / speed * 1000;
		}
		for(let lastV=0; lastV<duration;){
			lastV = yield;
			const ratio = ease(Math.min(1, lastV / duration));
			updateFn(target, info.map(interpolate, ratio));
		}
	}
}();

module.exports = {
	runAction,
	Spawn, Sequence,
	Repeat, CallFunc,
	Delay, ActionBuilder,
};
