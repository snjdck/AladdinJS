
const linear = v => v;
const interpolate = (a, b, ratio, ease=linear) => a + (b - a) * ease(ratio);

const ActionBuilder = (initFn, updateFn, reverseFn) => class{
	constructor(duration, value, easeFn){
		this.duration = duration;
		this.value = value;
		this.easeFn = easeFn;
	}
	*exec(target){
		const {duration, value, easeFn} = this;
		const info = initFn(target, value);
		for(let time=0;;){
			const ratio = Math.min(1, time / duration);
			updateFn(target, ...info.map(([a, b]) => interpolate(a, b, ratio, easeFn)));
			if(time >= duration)break;
			time = yield;
		}
	}
	reverse(){
		const {constructor, duration, value, easeFn} = this;
		return new constructor(duration, reverseFn(value), easeFn);
	}
}

class Sequence{
	constructor(...actions){
		this.actions = actions;
	}
	get duration(){
		return this.actions.reduce((result, action) => result + action.duration, 0);
	}
	*exec(target){
		let offset = 0;
		let lastV = 0;
		for(let action of this.actions){
			for(let g = action.exec(target); !g.next(lastV - offset).done;){
				lastV = yield;
			}
			offset += action.duration;
		}
	}
	reverse(){
		const {constructor, actions} = this;
		return new constructor(...actions.map(action => action.reverse()).reverse());
	}
}

class Spawn{
	constructor(...actions){
		this.actions = actions;
	}
	get duration(){
		return Math.max(...this.actions.map(action => action.duration));
	}
	*exec(target){
		const list = this.actions.map(a => a.exec(target));
		for(let lastV=0;;){
			let n = 0;
			for(let g of list){
				n += g.next(lastV).done;
			}
			if(n == list.length)break;
			lastV = yield;
		}
	}
	reverse(){
		const {constructor, actions} = this;
		return new constructor(...actions.map(action => action.reverse()).reverse());
	}
}

class Delay{
	constructor(duration){
		this.duration = duration;
	}
	*exec(target){
		const {duration} = this;
		for(let lastV=0; lastV < duration;){
			lastV = yield;
		}
	}
	reverse(){
		return this;
	}
}

class CallFunc{
	constructor(fn){
		this.fn = fn;
	}
	get duration(){
		return 0;
	}
	*exec(target){
		this.fn.call(target, target);
	}
	reverse(){
		return this;
	}
}

class Repeat{
	constructor(action, count=Infinity){
		this.action = action;
		this.count = count;
	}
	get duration(){
		const {action, count} = this;
		return action.duration * count;
	}
	*exec(target){
		const {action, count} = this;
		let lastV = 0;
		for(let i=0; i<count; ++i){
			let offset = action.duration * i;
			for(let g = action.exec(target); !g.next(lastV - offset).done;){
				lastV = yield;
			}
		}
	}
	reverse(){
		const {constructor, action, count} = this;
		return new constructor(action.reverse(), count);
	}
}

function runAction(target, action){
	return new Promise(resolve => {
		const g = action.exec(target);
		if(globalThis.document){
			const t = document.timeline.currentTime;
			void function f(timestamp){
				const {done} = g.next(timestamp - t);
				if(done)resolve();else requestAnimationFrame(f);
			}();
		}else{
			const t = performance.now();
			void function f(){
				const {done} = g.next(performance.now() - t);
				if(done)resolve();else setTimeout(f, 100);
			}();
		}
	});
}

module.exports = {
	runAction,
	ActionBuilder,
	Sequence, Spawn,
	Delay, Repeat,
	CallFunc,
};
