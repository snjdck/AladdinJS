
const linear = v => v;
const interpolate = (a, b, ratio, ease=linear) => a + (b - a) * ease(ratio);

const ActionBuilder = (initFn, updateFn) => (duration, value, easeFn) => function*(target){
	const info = initFn(target, value);
	for(let lastV=0; lastV<duration;){
		lastV = yield;
		const ratio = Math.min(1, lastV / duration);
		updateFn(target, ...info.map(([a, b]) => interpolate(a, b, ratio, easeFn)));
	}
}

const Sequence = actions => function*(target){
	let offset = 0;
	let lastV = 0;
	for(let action of actions){
		for(let g = action(target); !g.next(lastV - offset).done;){
			lastV = yield;
		}
		offset = lastV;
	}
}

const Spawn = actions => function*(target){
	const list = Array.from(actions, action => action(target));
	let lastV = 0;
	const f = (v, g) => v + g.next(lastV).done;
	while(list.reduce(f, 0) < list.length){
		lastV = yield;
	}
}

const Repeat = function(){
	function* genN(value, count){
		for(let i=0; i<count; ++i){
			yield value;
		}
	}
	return (action, count=Infinity) => Sequence(genN(action, count));
}();

const Delay = duration => function*(){
	for(let lastV=0; lastV<duration;){
		lastV = yield;
	}
}

const CallFunc = fn => function*(target){
	const action = fn.call(target, target);
	if(action instanceof Function)yield* action(target);
}

function runAction(target, action){
	let cancelFlag = false;
	const promise = new Promise((resolve, reject) => {
		const g = action(target);
		if(globalThis.document){
			const t = document.timeline.currentTime;
			void function f(timestamp){
				if(cancelFlag)return reject();
				const {done} = g.next(timestamp - t);
				if(done)resolve();else requestAnimationFrame(f);
			}();
		}else{
			const t = performance.now();
			void function f(){
				if(cancelFlag)return reject();
				const {done} = g.next(performance.now() - t);
				if(done)resolve();else setTimeout(f, 100);
			}();
		}
	});
	promise.cancel = () => {cancelFlag = true};
	return promise;
}

module.exports = {
	ActionBuilder, CallFunc,
	Sequence, Spawn,
	Delay, Repeat,
	runAction,
};
