
import {Injector} from 'ioc';
import Msg from './Msg';
import MsgName from './MsgName';
import safeCall from 'utils/function/safeCall';
import compose from 'utils/function/compose';

class Module
{
	_injector;
	_commandDict = Object.create(null);
	_controllerDict = new Map();
	_viewSet = new Set();
	_roleSet = new Set();

	constructor(meta, injector){
		Object.defineProperty(this, "name", {value: meta.name});
		this._injector = new Injector(injector);
		this._injector.mapValue(Module, this, null);
		this._injector.mapValue(Injector, this._injector, null);
		assertMeta(meta);
		installPlugins(this, meta.plugins);
		this.meta = meta;
	}

	notify(msgName, msgData=null){
		MsgName.assert(msgName);
		let msg = new Msg(msgName, msgData);
		handleCmd(this._commandDict, msg);
		handleMsg(this._controllerDict, msg);
		handleMsg(this._viewSet, msg);
		return !msg.isDefaultPrevented();
	}

	regService(serviceInterface, serviceClass, asLocal=false){
		let injector = asLocal ? this._injector : this._injector.parent;
		injector.mapSingleton(serviceInterface, serviceClass, this._injector);
		this._roleSet.add(serviceInterface);
	}

	regModel(model, modelType=null){
		if(!modelType)modelType = model.constructor;
		this._injector.mapValue(modelType, model);
		this._roleSet.add(modelType);
	}

	delModel(modelType){
		this._injector.ummap(modelType);
	}

	regView(view){
		if(this._viewSet.has(view))return;
		this._viewSet.add(view);
		this._injector.inject(view);
		safeCall(view, "onReg");
	}

	delView(view){
		safeCall(view, "onDel");
		this._viewSet.delete(view);
	}

	regController(controllerType){
		console.assert(!this._controllerDict.has(controllerType));
		let controller = this._injector.inject(new controllerType());
		this._controllerDict.set(controllerType, controller);
		safeCall(controller, "onReg");
	}

	delController(controllerType){
		let controller = this._controllerDict.get(controllerType);
		safeCall(controller, "onDel");
		this._controllerDict.delete(controllerType);
	}

	regCommand(cmdType){
		MsgName.assert(cmdType.id);
		let cmd = this._injector.inject(new cmdType());
		Object.defineProperty(this._commandDict, cmdType.id, {value: cmd});
	}

	activateRoles(){
		for(let role of this._roleSet)
			this._injector.getInstance(role);
		this._roleSet.clear();
	}

	onStartup(){
		delete this.meta;
	}

	collectAllModels(){return this.meta.models;}
	collectAllServices(){return this.meta.services;}
	collectAllControllers(){return this.meta.controllers;}
	collectAllCommands(){return this.meta.commands;}
}

function handleCmd(dict, msg){
	let cmd = dict[msg.name];
	return cmd && cmd.exec(msg);
}

function handleMsg(dict, msg){
	for(let target of dict.values()){
		if(msg.isProcessCanceled())break;
		safeCall(target, msg.name, msg);
	}
}

function assertMeta(meta){
	console.assert(typeof meta.name === 'string', 'module must have a name!');
	console.assert(Array.isArray(meta.models), 'models must provided!');
	console.assert(Array.isArray(meta.services), 'services must provided!');
	console.assert(Array.isArray(meta.controllers), 'controllers must provided!');
}

function installPlugins(module, plugins){
	if(!plugins || plugins.length <= 0)return;
	module.notify = compose(...plugins.map(fn => fn(module)))(module.notify.bind(module));
}

export default Module;