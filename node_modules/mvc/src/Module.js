
import {Injector} from 'ioc';
import Msg from './Msg';
import MsgName from './MsgName';
import safeCall from 'utils/function/safeCall';
import compose from 'utils/function/compose';

class Module
{
	_controllerDict = Object.create(null);
	_viewSet = new Set();
	_roleSet = new Set();

	constructor(meta, injector, application){
		Object.defineProperty(this, "name", {value: meta.name});
		this._application = application;
		this._injector = new Injector(injector);
		this._injector.mapValue(Module, this, null);
		this._injector.mapValue(Injector, this._injector, null);
		installPlugins(this, meta.plugins);
		this.meta = meta;
		this._globalMsgInterested = new Set(meta.message.interested);
		this._globalMsgDispatched = new Set(meta.message.dispatched);
	}

	canDispatch(msgName){
		return this._globalMsgDispatched.has(msgName);
	}

	hasInterest(msgName){
		return this._globalMsgInterested.has(msgName);
	}

	checkConflictedMsgs(globalMsgDispatched){
		for(let v of this._globalMsgDispatched){
			if(v in globalMsgDispatched){
				console.error('msg %s from %s has been dispatched by %s!', v.valueOf(), this.name, globalMsgDispatched[v]);
				continue;
			}
			globalMsgDispatched[v] = this.name;
		}
	}

	notify(msg){
		console.assert(msg instanceof Msg, 'invalid message!', msg);
		const msgName = msg.name;
		MsgName.assert(msgName);
		if(msg.from !== this._application && this.hasInterest(msgName)){
			console.warn("%s can't notify self interested msg %o",this.name, msgName.valueOf());
		}
		if(this.hasController(msgName)){
			let controller = this._controllerDict[msgName];
			controller.exec(msg);
		}
		for(let view of this._viewSet.values()){
			if(msg.isProcessCanceled())break;
			safeCall(view, msgName, msg);
		}
		this._application.notifyAll(msgName, msg.data, this);
		return !msg.isDefaultPrevented();
	}

	regService(serviceInterface, serviceClass, asLocal=false){
		let injector = asLocal ? this._injector : this._injector.parent;
		injector.mapSingleton(serviceInterface, serviceClass, this._injector);
		this._roleSet.add(serviceInterface);
	}

	regModel(model, modelType=null){
		if(!modelType)modelType = model.constructor;
		this._injector.mapValue(modelType, model);
		this._roleSet.add(modelType);
	}

	delModel(modelType){
		this._injector.ummap(modelType);
	}

	regView(view){
		if(this._viewSet.has(view))return;
		this._viewSet.add(view);
		this._injector.inject(view);
		safeCall(view, "onReg");
	}

	delView(view){
		safeCall(view, "onDel");
		this._viewSet.delete(view);
	}

	regController(controllerType){
		let msgName = controllerType.id;
		MsgName.assert(msgName);
		if(this.hasController(msgName)){
			let before = this._controllerDict[msgName].constructor.name;
			console.warn('%s.regController(%s) again! before:%s, willset:%s', this.name, msgName.valueOf(), before, controllerType.name);
		}
		this._controllerDict[msgName] = this._injector.inject(new controllerType());
	}

	delController(msgName){
		delete this._controllerDict[msgName];
	}

	hasController(msgName){
		return msgName in this._controllerDict;
	}

	activateRoles(){
		for(let role of this._roleSet)
			this._injector.getInstance(role);
		this._roleSet.clear();
	}

	onStartup(){
		delete this.meta;
	}

	collectAllModels(){return this.meta.models;}
	collectAllServices(){return this.meta.services;}
	collectAllControllers(){return this.meta.controllers;}
}

function installPlugins(module, plugins){
	if(!plugins || plugins.length <= 0)return;
	module.notify = compose(...plugins.map(fn => fn(module)))(module.notify.bind(module));
}

export default Module;