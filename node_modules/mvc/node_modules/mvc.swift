struct MVC<MsgName: Hashable>
{
	prototal MsgSender {}

	class Msg
	{
		let name: MsgName
		let data: Any
		let from: MsgSender

		private var defaultPreventedFlag = false
		private var processCanceledFlag = false

		init(name: MsgName, data: Any, from: MsgSender)
		{
			self.name = name
			self.data = data
			self.from = from
		}

		func cancelProcess(){
			processCanceledFlag = true
		}

		func isProcessCanceled() -> Bool {
			return processCanceledFlag
		}

		func preventDefault(){
			defaultPreventedFlag = true
		}

		func isDefaultPrevented() -> Bool {
			return defaultPreventedFlag
		}

		func isFromInternal() -> Bool {
			return !(from is Module)
		}
	}

	protocol Notifier : MsgSender, IInjectable {
		var module: Module? {get set}
		func notify(_ msgName: MsgName, _ msgData: Any) -> Bool
	}

	extension Notifier {
		func onInject(_ injector: IInjector){
			module = injector.getInstance()
		}
		func notify(_ msgName: MsgName, _ msgData: Any) -> Bool {
			module!.notify(Msg(msgName, msgData, self))
			return true
		}
	}

	protocol Controller : Notifier {
		static var id : MsgName {get}
		init()
		func exec(_ msg: Msg)
	}

	struct Activator
	{
		var roleMap = [(Notifier, IInjector)]()

		register(_ role: Notifier, _ injector: IInjector){
			roleMap.append((role, injector))
		}

		activate(){
			for (role, injector) in roleMap {
				injector.getInstance(role)
			}
			roleMap.removeAll()
		}
	}

	struct Router
	{
		var msgDispatched = [MsgName:Module]()
		var msgInterested = [MsgName:Set<Module>]()

		func register(_ module: Module, _ dispatched: [MsgName], _ interested: [MsgName])
		{
			for msgName in dispatched {
				if msgDispatched[msgName] != nil {
					//console.warn('msg %s from %s has been dispatched by %s!', v.valueOf(), module.name, _msgDispatched[v].name);
				}else{
					msgDispatched[msgName] = module
				}
			}
			for msgName in interested {
				if let temp = _msgDispatched[v], temp === module {
					continue
				}
				if let set = msgInterested[v] {
					set.update(module)
				}else{
					msgInterested[v] = [module]
				}
			}
		}

		func dispatch(_ msgName: MsgName, _ msgData: Any, _ dispatcher: Module) -> Bool
		{
			guard let module = msgDispatched[msgName], module === dispatcher else {
				return false
			}
			guard let moduleList = msgInterested[msgName] else {
				return true
			}
			for module in moduleList {
				module.notify(Msg(msgName, msgData, dispatcher))
			}
			return true
		}
	}

	class Application
	{
		let injector: IInjector = Injector()
		var moduleDict = [String:Module]()
		let activator = Activator()
		let router = Router()

		var hasStartup = false
		let startupMsgName: MsgName

		init(_ startupMsgName: MsgName)
		{
			self.startupMsgName = startupMsgName
			injector.mapValueWeak(self)
			injector.mapValueWeak(injector)
		}

		func regRole(role: Any, injector: IInjector)
		{
			activator.register(role, injector)
		}

		func route(_ msgName: MsgName, _ msgData: Any, dispatcher: Module)
		{
			router.dispatch(msgName, msgData, dispatcher)
		}

		func regModule() -> Self
		{
			let module = Module(meta, injector, self)
			router.register(module, meta.message)
			moduleDict[module.name] = module
			return self
		}

		func getModule(name: String) -> Module?
		{
			return moduleDict[name]
		}

		func notifyAll(msgName: MsgName, msgData: Any = nil)
		{
			for (_, module) in moduleDict {
				module.notify(Msg(msgName, msgData, module))
			}
		}

		func startup()
		{
			if hasStartup {
				return
			}
			hasStartup = true
			onStartup()
			notifyAll(startupMsgName)
		}

		func onStartup()
		{
			for module in moduleDict.values() {
				for v in module.collectAllModels() {
					module.regModel(v[1], v[0])
				}
			}
			activator.activate()
			for module in moduleDict.values() {
				for v in module.collectAllServices() {
					module.regService(v, v)
				}
			}
			activator.activate()
			for module in moduleDict.values() {
				for v in module.collectAllControllers() {
					module.regController(v)
				}
			}
		}
	}

	class Module : MsgSender
	{
		var controllerDict = [MsgName:Controller]()
		var viewSet = Set<Any>()

		let name: String
		unowned let application: Application
		let injector: Injector

		init(meta:Any, _ parentInjector:Injector, _ application:Application)
		{
			self.name = meta.name
			self.application = application
			self.injector = Injector(parentInjector)

			injector.mapValueWeak(self)
			injector.mapValueWeak(injector)
		}

		func notify(_ msg: Msg) -> Bool
		{
			let msgName = msg.name
			controllerDict[msgName]?.exec(msg)
			for view in viewSet {
				if msg.isProcessCanceled() {
					break
				}
				view.handleMsg(msg)
			}
			if msg.isFromInternal() {
				application.route(msgName, msg.data, self)
			}
			return !msg.isDefaultPrevented()
		}

		regService<T>(_ factory: @escaping () -> T, asLocal: Bool=false)
		{
			let realInjector = asLocal ? injector : injector.parent!
			injector.mapSingleton(factory, realInjector: realInjector)
			application.regRole(T.self, injector)
		}

		regModel<T>(_ model: T)
		{
			injector.mapValue(model)
			application.regRole(T.self, injector)
		}

		delModel(modelType:Any.Type)
		{
			injector.unmap(modelType)
		}

		regView(_ view: Any)
		{
			if viewSet.contains(view) {
				return
			}
			viewSet.add(view)
			injector.inject(view)
			view.onReg()
		}

		delView(_ view: Any)
		{
			view.onDel()
			viewSet.remove(view)
		}

		regController(_ controllerType: Controller.Type)
		{
			if hasController(controllerType.id) {
				//let before = this._controllerDict[msgName].constructor.name;
				//console.warn('%s.regController(%s) again! before:%s, willset:%s', this.name, msgName.valueOf(), before, controllerType.name);
			}
			controllerDict[controllerType.id] = injector.inject(controllerType())
		}

		delController(_ msgName: MsgName)
		{
			controllerDict[msgName] = nil
		}

		hasController(_ msgName: MsgName) -> Bool
		{
			return controllerDict[msgName] != nil
		}

		collectAllModels() -> Set<IModel> {return meta.models}
		collectAllServices() -> Set<IService> {return meta.services}
		collectAllControllers() -> Set<Controller> {return meta.controllers}
	}
}

