
public protocol IInjector : AnyObject
{
	var parent: IInjector? {get set}
	func mapValue<T>(_ value: T, id:String, realInjector:IInjector?) where T: AnyObject
	func mapValue<T>(_ value: T, id:String="") where T: AnyObject
	func mapClass<T>(_ factory: @autoclosure @escaping () -> T, id:String="", realInjector:IInjector?=nil) where T:AnyObject
	func mapSingleton<T>(_ factory: @autoclosure @escaping () -> T, id:String="", realInjector:IInjector?=nil) where T:AnyObject
	func mapRule(_ key:AnyClass, _ rule:IInjectorType, _ id:String)
	func mapMetaRule(_ key:AnyClass, _ rule: IInjectorType)
	func unmap(_ key:AnyClass, id:String="")
	func getRule(_ key:String, _ id:String, inherit:Bool) -> IInjectorType?
	func getInstance<T>(_ id:String="") -> T?
	func inject(_ target: AnyObject)
}

public protocol IInjectorType : AnyObject
{
	func getValue(_ id: String) -> AnyObject
}

public protocol IInjectable : AnyObject
{
	func onInject(_ injector: IInjector)
}

class InjectionTypeClass : IInjectorType
{
	unowned let realInjector: IInjector
	let klass: () -> AnyObject

	init(_ realInjector: IInjector, _ klass: @escaping () -> AnyObject)
	{
		self.realInjector = realInjector
		self.klass = klass
	}

	func getValue(_ id: String) -> AnyObject
	{
		let value = klass()
		realInjector.inject(value)
		return value
	}
}

class InjectionTypeSingleton : IInjectorType
{
	unowned let realInjector: IInjector
	let klass: () -> AnyObject
	var value: AnyObject?

	init(_ realInjector: IInjector, _ klass: @escaping () -> AnyObject)
	{
		self.realInjector = realInjector
		self.klass = klass
	}

	func getValue(_ id: String) -> AnyObject
	{
		if value == nil {
			value = klass()
			realInjector.inject(value!)
		}
		return value!
	}
}

class InjectionTypeValue : IInjectorType
{
	weak var realInjector: IInjector?
	let value: AnyObject

	init(_ realInjector: IInjector?, _ value: AnyObject)
	{
		self.realInjector = realInjector
		self.value = value
	}

	func getValue(_ id: String) -> AnyObject
	{
		if let injector = realInjector {
			realInjector = nil
			injector.inject(value)
		}
		return value
	}
}

public class Injector : IInjector
{
	public var parent: IInjector?
	private var ruleDict = [String:[String:IInjectorType]]()
	private var metaRuleDict = [String:IInjectorType]()

	init(parent: IInjector? = nil)
	{
		self.parent = parent
	}

	public func mapValue<T>(_ value: T, id:String, realInjector:IInjector?) where T: AnyObject
	{
		mapRule(T.self, InjectionTypeValue(realInjector, value), id)
	}
	
	public func mapValue<T>(_ value: T, id:String="") where T: AnyObject
	{
		mapRule(T.self, InjectionTypeValue(self, value), id)
	}

	public func mapClass<T>(_ factory: @autoclosure @escaping () -> T, id:String="", realInjector:IInjector?=nil) where T:AnyObject
	{
		mapRule(T.self, InjectionTypeClass(realInjector ?? self, factory), id)
	}

	public func mapSingleton<T>(_ factory: @autoclosure @escaping () -> T, id:String="", realInjector:IInjector?=nil) where T:AnyObject
	{
		mapRule(T.self, InjectionTypeSingleton(realInjector ?? self, factory), id)
	}

	public func mapRule(_ key:AnyClass, _ rule:IInjectorType, _ id:String)
	{
		let key = "\(key)"
		if var dict = ruleDict[key] {
			dict[id] = rule
		}else{
			ruleDict[key] = [id: rule]
		}
	}

	public func mapMetaRule(_ key:AnyClass, _ rule: IInjectorType)
	{
		metaRuleDict["\(key)"] = rule
	}

	public func unmap(_ key:AnyClass, id:String="")
	{
		if var dict = ruleDict["\(key)"] {
			dict[id] = nil
		}
	}

	public func getRule(_ key:String, _ id:String, inherit:Bool) -> IInjectorType?
	{
		if !inherit {
			return ruleDict[key]?[id]
		}
		var injector : IInjector? = self
		while injector != nil {
			let rule = injector!.getRule(key, id, inherit:false)
			if rule != nil {
				return rule
			}
			injector = injector!.parent
		}
		return nil
	}

	public func getInstance<T>(_ id:String="") -> T?
	{
		let key = "\(T.self)"
		let rule = getRule(key, id, inherit:true) ?? metaRuleDict[key]
		if let rule = rule {
			return (rule.getValue(id) as! T)
		}
		return nil
		
	}

	public func inject(_ target: AnyObject)
	{
		if let injectable = target as? IInjectable {
			injectable.onInject(self)
		}
	}
}
