
public protocol IInjector : AnyObject
{
	var parent: IInjector? {get set}
	func mapValue<T>(_ value: T, id:String, realInjector:IInjector?)
	func mapValue<T>(_ value: T, realInjector:IInjector?)
	func mapValue<T>(_ value: T, id:String)
	func mapValue<T>(_ value: T)
	func mapClass<T>(_ factory: @escaping () -> T, id:String, realInjector:IInjector)
	func mapClass<T>(_ factory: @escaping () -> T, realInjector:IInjector)
	func mapClass<T>(_ factory: @escaping () -> T, id:String)
	func mapClass<T>(_ factory: @escaping () -> T)
	func mapSingleton<T>(_ factory: @escaping () -> T, id:String, realInjector:IInjector)
	func mapSingleton<T>(_ factory: @escaping () -> T, realInjector:IInjector)
	func mapSingleton<T>(_ factory: @escaping () -> T, id:String)
	func mapSingleton<T>(_ factory: @escaping () -> T)
	func mapRule(_ key:Any, _ rule:IInjectorType, _ id:String)
	func mapMetaRule(_ key:Any, _ rule: IInjectorType)
	func unmap(_ key:Any, id:String)
	func unmap(_ key:Any)
	func getRule(_ key:String, _ id:String) -> IInjectorType?
	func getInstance<T>(_ id:String) -> T?
	func getInstance<T>() -> T?
	@discardableResult
	func inject<T>(_ target: T) -> T
}

public protocol IInjectorType : AnyObject
{
	func getValue(_ id: String) -> Any
}

public protocol IInjectable : AnyObject
{
	func onInject(_ injector: IInjector)
}

private class InjectionTypeClass : IInjectorType
{
	unowned let realInjector: IInjector
	let klass: () -> Any
	
	init(_ realInjector: IInjector, _ klass: @escaping () -> Any)
	{
		self.realInjector = realInjector
		self.klass = klass
	}
	
	func getValue(_ id: String) -> Any
	{
		return realInjector.inject(klass())
	}
}

private class InjectionTypeSingleton : IInjectorType
{
	unowned let realInjector: IInjector
	let klass: () -> Any
	var value: Any?
	
	init(_ realInjector: IInjector, _ klass: @escaping () -> Any)
	{
		self.realInjector = realInjector
		self.klass = klass
	}
	
	func getValue(_ id: String) -> Any
	{
		if value == nil {
			value = klass()
			realInjector.inject(value!)
		}
		return value!
	}
}

private class InjectionTypeValue : IInjectorType
{
	weak var realInjector: IInjector?
	let value: Any
	
	init(_ realInjector: IInjector?, _ value: Any)
	{
		self.realInjector = realInjector
		self.value = value
	}
	
	func getValue(_ id: String) -> Any
	{
		if let injector = realInjector {
			realInjector = nil
			injector.inject(value)
		}
		return value
	}
}

public class Injector : IInjector
{
	public var parent: IInjector?
	private var ruleDict = [String:[String:IInjectorType]]()
	private var metaRuleDict = [String:IInjectorType]()
	
	init(parent: IInjector? = nil)
	{
		self.parent = parent
	}
	
	public func mapValue<T>(_ value: T, id:String, realInjector:IInjector?)
	{
		mapRule(T.self, InjectionTypeValue(realInjector, value as AnyObject), id)
	}
	
	public func mapValue<T>(_ value: T, realInjector:IInjector?)
	{
		mapValue(value, id: "", realInjector: realInjector)
	}
	
	public func mapValue<T>(_ value: T, id:String)
	{
		mapValue(value, id: id, realInjector: self)
	}
	
	public func mapValue<T>(_ value: T)
	{
		mapValue(value, id: "", realInjector: self)
	}
	
	public func mapClass<T>(_ factory: @escaping () -> T, id:String, realInjector:IInjector)
	{
		mapRule(T.self, InjectionTypeClass(realInjector, factory), id)
	}
	
	public func mapClass<T>(_ factory: @escaping () -> T, realInjector:IInjector)
	{
		mapClass(factory, id: "", realInjector: realInjector)
	}
	
	public func mapClass<T>(_ factory: @escaping () -> T, id:String)
	{
		mapClass(factory, id: id, realInjector: self)
	}
	
	public func mapClass<T>(_ factory: @escaping () -> T)
	{
		mapClass(factory, id: "", realInjector: self)
	}
	
	public func mapSingleton<T>(_ factory: @escaping () -> T, id:String, realInjector:IInjector)
	{
		mapRule(T.self, InjectionTypeSingleton(realInjector, factory), id)
	}
	
	public func mapSingleton<T>(_ factory: @escaping () -> T, realInjector:IInjector)
	{
		mapSingleton(factory, id: "", realInjector: realInjector)
	}
	
	public func mapSingleton<T>(_ factory: @escaping () -> T, id:String)
	{
		mapSingleton(factory, id: id, realInjector: self)
	}
	
	public func mapSingleton<T>(_ factory: @escaping () -> T)
	{
		mapSingleton(factory, id: "", realInjector: self)
	}
	
	public func mapRule(_ key:Any, _ rule:IInjectorType, _ id:String)
	{
		let key = "\(key)"
		if var dict = ruleDict[key] {
			dict[id] = rule
		}else{
			ruleDict[key] = [id: rule]
		}
	}
	
	public func mapMetaRule(_ key:Any, _ rule: IInjectorType)
	{
		metaRuleDict["\(key)"] = rule
	}
	
	public func unmap(_ key:Any, id:String)
	{
		if var dict = ruleDict["\(key)"] {
			dict[id] = nil
		}
	}
	
	public func unmap(_ key:Any)
	{
		unmap(key, id:"")
	}
	
	public func getRule(_ key:String, _ id:String) -> IInjectorType?
	{
		return ruleDict[key]?[id] ?? parent?.getRule(key, id)
	}
	
	public func getInstance<T>(_ id:String) -> T?
	{
		let key = "\(T.self)"
		let rule = getRule(key, id) ?? metaRuleDict[key]
		return rule == nil ? nil : (rule!.getValue(id) as! T)
	}
	
	public func getInstance<T>() -> T?
	{
		return getInstance("")
	}
	
	public func inject<T>(_ target: T) -> T
	{
		if let injectable = target as? IInjectable {
			injectable.onInject(self)
		}
		return target
	}
}
