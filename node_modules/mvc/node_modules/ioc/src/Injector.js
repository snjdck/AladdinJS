
import safeCall from 'utils/function/safeCall';
import collectAllTypes from 'utils/class/collectAllTypes';
import ArrayKeyMap from 'ds/ArrayKeyMap';

import InjectionTypeValue from './InjectionTypeValue';
import InjectionTypeClass from './InjectionTypeClass';
import InjectionTypeSingleton from './InjectionTypeSingleton';

class Injector
{
	_ruleDict = new ArrayKeyMap(2);

	constructor(parent=null){
		Object.defineProperty(this, 'parent', {value: parent, writable: true});
	}

	mapValue(key, value, realInjector=this){
		return this.mapRule(key, new InjectionTypeValue(realInjector, value));
	}

	mapClass(key, value=null, realInjector=null){
		return this.mapRule(key, new InjectionTypeClass(realInjector || this, fetchClass(key, value)));
	}

	mapSingleton(key, value=null, realInjector=null){
		return this.mapRule(key, new InjectionTypeSingleton(realInjector || this, fetchClass(key, value)));
	}

	mapRule(key, rule){
		this._ruleDict.set(key, rule);
		return rule;
	}

	mapMetaRule(key, rule){
		this._ruleDict.set([key, KeyMeta], rule);
		return rule;
	}

	unmap(key){
		this._ruleDict.delete(key);
	}

	getRule(key, inherit=true){
		if(!inherit)return this._ruleDict.get(key);
		let minor;
		for(let injector=this; injector; injector=injector.parent){
			let rule = injector.getRule(key, false);
			if(!rule)continue;
			if(rule.local && injector !== this)continue;
			if(rule.minor){
				if(!minor){
					minor = rule;
				}
				continue;
			}
			return rule;
		}
		return minor;
	}

	getInstance(type, id){
		if(id === undefined && Array.isArray(type))
			[type, id] = type;
		let rule = this.getRule([type, id]) || this.getRule([type, KeyMeta]);
		return rule && rule.getValue(this, id);
	}

	getInstanceAll(...keys){
		return keys.map(key => this.getInstance(key));
	}

	inject(target){
		let queue = Array.from(collectAllTypes(target)).filter(v => v.hasOwnProperty(InjectTag)).map(v => v[InjectTag]);
		let injection = queue.reduceRight((prev, curr) => Object.assign(prev, curr), Object.create(null));
		for(let [k, v] of Object.entries(injection))
			target[k] = this.getInstance(v);
		safeCall(target, InjectTag, this);
		return target;
	}
}

function fetchClass(key, value){
	let fn = value || Array.isArray(key) ? key[0] : key;
	if(typeof fn !== 'function')throw new Error('value must be function!');
	return fn;
}

const KeyMeta	= Symbol('meta');
const InjectTag	= Symbol('InjectorInjectTag');

export {
	InjectTag,
	Injector
};