'use strict';

class Injector
{
	constructor(parent){
		Object.defineProperty(this, '_ruleMap', {value: new Map()});
		this.parent = parent;
	}

	mapValue(key, value, realInjector=this){
		this.mapRule(key, new InjectionTypeValue(realInjector, value));
	}

	mapClass(key, value, realInjector){
		this.mapRule(key, new InjectionTypeClass(realInjector || this, value ?? key));
	}

	mapSingleton(key, value, realInjector){
		this.mapRule(key, new InjectionTypeSingleton(realInjector || this, value ?? key));
	}

	mapRule(key, rule){
		this._ruleMap.set(key, rule);
	}

	unmap(key){
		this._ruleMap.delete(key);
	}

	getRule(key){
		return this._ruleMap.get(key) ?? this.parent?.getRule(key);
	}

	getInstance(type){
		return this.getRule(type)?.getValue(this);
	}
}

Object.defineProperty(Injector.prototype, 'inject', {
	value: function(){
		const injectMapCache = new WeakMap();
		const reduceFn = (a, b) => Object.assign(a, b);
		return function(target){
			let injectMap = injectMapCache.get(target.constructor);
			if(!injectMap){
				const queue = [];
				for(let klass=target.constructor; klass; klass=Object.getPrototypeOf(klass))
					queue.push(klass[InjectTag]);
				injectMap = queue.reduceRight(reduceFn, Object.create(null));
				injectMapCache.set(target.constructor, injectMap);
			}
			for(let k in injectMap){
				target[k] = this.getInstance(injectMap[k]);
			}
			target[InjectTag]?.(this);
			return target;
		};
	}(),
	configurable: true,
	writable: true,
});

const InjectTag	= Symbol('InjectTag');

const InjectionTypeValue = require('./InjectionTypeValue');
const InjectionTypeClass = require('./InjectionTypeClass');
const InjectionTypeSingleton = require('./InjectionTypeSingleton');

exports.InjectTag = InjectTag;
exports.Injector = Injector;
