
const decodeUTF8 = (decoder => v => decoder.decode(v))(new TextDecoder());

function castBuffer({bufferView, count, type}){
	const isMat = type.startsWith('MAT');
	const isVec = isMat || type.startsWith('VEC');
	const floatCount = isMat ? 16 : isVec ? Number(type.slice(3)) : 1;
	console.assert(bufferView.length == count * floatCount << 2)
	const result = Array(count);
	if(isVec){
		for(let i=0; i<count; ++i){
			const value = Array(floatCount);
			for(let j=0; j<floatCount; ++j){
				value[j] = bufferView.readFloatLE((i * floatCount + j) << 2);
			}
			result[i] = value;
		}
	}else{
		for(let i=0; i<count; ++i){
			result[i] = bufferView.readFloatLE(i << 2);
		}
	}
	return result;
}

function parse(data){
	const magic = decodeUTF8(data.slice(0, 4));
	if(magic == 'glTF'){
		const version = data.readUInt32LE(4);
		const fileSize = data.readUInt32LE(8);
		let offset = 12;
		let result;
		while(offset < fileSize){
			const chunkSize = data.readUInt32LE(offset);
			const chunkType = data.readUInt32LE(offset+4);
			if(chunkType == 0x4E4F534A){//JSON
				result = JSON.parse(decodeUTF8(data.slice(offset + 8, offset + 8 + chunkSize)));
			}else if(chunkType == 0x004E4942){//BIN
				result.buffers[0] = data.slice(offset + 8, offset + 8 + chunkSize);
			}
			offset += 8 + chunkSize;
		}
		const bufferViews = result.bufferViews.map(({buffer, byteOffset, byteLength}) => result.buffers[buffer].slice(byteOffset, byteOffset + byteLength));
		delete result.buffers;
		delete result.bufferViews;
		result.accessors.forEach(v => v.bufferView = bufferViews[v.bufferView]);
		//const accessors = result.accessors.map(v => castBuffer(bufferViews[v.bufferView], v));
		result.meshes.forEach(({primitives}) => primitives.forEach(v => {
			v.indices = result.accessors[v.indices];
			v.material = result.materials[v.material];
			for(let k in v.attributes){
				v.attributes[k] = result.accessors[v.attributes[k]];
			}
		}));
		delete result.materials;
		result.skins.forEach(v => {
			v.inverseBindMatrices = castBuffer(result.accessors[v.inverseBindMatrices]);
			//v.joints = v.joints.map(i => result.nodes[i]);
		});
		result.animations.forEach(animation => {
			animation.samplers.forEach(v => {
				v.input = castBuffer(result.accessors[v.input]);
				v.output = castBuffer(result.accessors[v.output]);
			});
			animation.channels.forEach(v => {
				v.sampler = animation.samplers[v.sampler];
				v.target.node = result.nodes[v.target.node];
			});
			delete animation.samplers;
		});
		delete result.accessors;
		let rootNodes = result.scenes[result.scene].nodes.slice();
		rootNodes.push(...rootNodes.flatMap(i => result.nodes[i].children).filter(i => result.nodes[i].mesh != null))
		let boneNodes = result.nodes.filter((v, i) => !rootNodes.includes(i))
		boneNodes.forEach((v, i) => {
			v.boneID = i;
			v.boneName = v.name;
			v.children?.forEach(j => boneNodes[j].bonePID = i);
		});
		result.boneList = boneNodes;
		//*
		rootNodes.forEach(nodeID => {
			let v = result.nodes[nodeID]
			if(v.children){
				v.children = v.children.map(i => result.nodes[i]);
			}
			if(v.mesh != null){
				v.mesh = result.meshes[v.mesh];
			}
			if(v.skin != null){
				v.skin = result.skins[v.skin];
			}
		});
		delete result.meshes;
		delete result.skins;
		result.scenes.forEach(v => v.nodes = v.nodes.map(i => result.nodes[i]));
		delete result.nodes;
		result.scene = result.scenes[result.scene];
		//*/
		return result;
	}
}

module.exports = parse;
