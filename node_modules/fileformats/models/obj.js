
const commentPattern = /^#.*/gm;
const space = ' ';

function parseMtl(text, path){
	let materialMap = {};
	let material;
	for(let line of text.replace(commentPattern, '').split('\n')){
		if(line.startsWith('newmtl ')){
			material = {name: line.split(space)[1]};
			materialMap[material.name] = material;
			continue;
		}
		if(line.startsWith('map_Kd ')){
			material.map_Kd = path + line.split(space)[1];
			continue;
		}
	}
	return materialMap;
}

async function parse(text, path, loadFn){
	let materialMap;
	let objectList = [];
	let object;
	let group;
	for(let line of text.replace(commentPattern, '').split('\n')){
		if(!line || line.startsWith('s '))continue;
		if(line.startsWith('mtllib ')){
			materialMap = await loadFn(path + line.split(space)[1]);
			continue;
		}
		if(line.startsWith('o ')){
			object = {name: line.split(space)[1], v:[], vt:[], vn:[], g:[]};
			objectList.push(object);
			continue;
		}
		if(line.startsWith('v ')){
			const [x, y, z] = line.split(space).slice(1).map(parseFloat);
			object.v.push([x, z, y]);
			continue;
		}
		if(line.startsWith('vt ')){
			object.vt.push(line.split(space).slice(1).map(parseFloat));
			continue;
		}
		if(line.startsWith('vn ')){
			const [x, y, z] = line.split(space).slice(1).map(parseFloat);
			object.vn.push([x, z, y]);
			continue;
		}
		if(line.startsWith('g ')){
			group = {name: line.split(space)[1], f:[]};
			object.g.push(group);
			continue;
		}
		if(line.startsWith('usemtl ')){
			group.mtl = materialMap[line.split(space)[1]].map_Kd;
			continue;
		}
		if(line.startsWith('f ')){
			group.f.push(line.split(space).slice(1));
			continue;
		}
		console.log(line)
		break;
	}
	return objectList;
}

function cast(objectList){
	let subMeshList = [];
	let vOffset = 1;
	let vtOffset = 1;
	let vnOffset = 1;
	for(let object of objectList){
		let map = new Map();
		let subMesh = {};
		subMesh.texture = object.g[0].mtl;
		let position = [];
		let normal = [];
		let uv = [];
		let indexList = [];
		for(let f of object.g[0].f){
			for(let i=0; i<3; ++i){
				if(!map.has(f[i])){
					map.set(f[i], map.size);
					const [iv, ivt, ivn] = f[i].split('/');
					position.push(...object.v[iv-vOffset], 0);
					if(ivt)uv.push(...object.vt[ivt-vtOffset]);
					if(ivn)normal.push(...object.vn[ivn-vnOffset], 0);
				}
				indexList.push(map.get(f[i]));
			}
		}
		vOffset += object.v.length;
		vtOffset += object.vt.length;
		vnOffset += object.vn.length;
		subMesh.texture = object.g[0].mtl;
		subMesh.attributes = {};
		subMesh.attributes.position = new Float32Array(position);
		subMesh.attributes.uv = new Float32Array(uv);
		subMesh.attributes.normal = new Float32Array(normal);
		subMesh.attributes.index = new Uint32Array(indexList);
		subMeshList.push(subMesh);
	}
	return {subMeshList};
}

exports.parseMtl = parseMtl;
exports.parseObj = async(...args) => cast(await parse(...args));
