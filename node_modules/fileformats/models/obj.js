
const commentPattern = /^#.*/gm;
const space = /\s+/;

function parseMtl(text, path){
	let materialMap = {};
	let material;
	for(let line of text.replace(commentPattern, '').split('\n')){
		line = line.trim();
		if(line.startsWith('newmtl ')){
			material = {name: line.split(space)[1]};
			materialMap[material.name] = material;
			continue;
		}
		if(line.startsWith('map_Kd ')){
			material.map_Kd = path + line.split(space)[1];
			continue;
		}
	}
	return materialMap;
}

async function parse(text, path, loadFn){
	let materialMap;
	const v=[], vt=[], vn=[];
	const groupList = [];
	let group;
	for(let line of text.replace(commentPattern, '').split('\n')){
		line = line.trim();
		if(line.startsWith('v ')){
			const [x, y, z] = line.split(space).slice(1).map(parseFloat);
			v.push([x, z, y]);
		}else if(line.startsWith('vn ')){
			const [x, y, z] = line.split(space).slice(1).map(parseFloat);
			vn.push([x, z, y]);
		}else if(line.startsWith('vt ')){
			const [u, v] = line.split(space).slice(1).map(parseFloat);
			vt.push([u, 1-v]);
		}else if(line.startsWith('f ')){
			group.f.push(line.split(space).slice(1));
		}else if(line.startsWith('usemtl ')){
			group = {f:[]};
			group.mtl = materialMap[line.split(space)[1]].map_Kd;
			groupList.push(group);
		}else if(line.startsWith('mtllib ')){
			materialMap = await loadFn(path + line.split(space)[1]);
		}else{
			if(!line || line.startsWith('o ') || line.startsWith('g ') || line.startsWith('s '))continue;
			console.log(line);
		}
	}
	return {v, vt, vn, groupList};
}

function cast({v, vt, vn, groupList}){
	const subMeshList = [];
	const map = new Map();
	for(let group of groupList){
		map.clear();
		const position = [];
		const normal = [];
		const uv = [];
		const indexList = [];
		for(let f of group.f){
			for(let i=0; i<3; ++i){
				if(!map.has(f[i])){
					map.set(f[i], map.size);
					const [iv, ivt, ivn] = f[i].split('/');
					position.push(...v[iv-1], 0);
					if(ivt)uv.push(...vt[ivt-1]);
					if(ivn)normal.push(...vn[ivn-1], 0);
				}
				indexList.push(map.get(f[i]));
			}
		}
		const subMesh = {texture:group.mtl, attributes:{}};
		subMesh.attributes.position = new Float32Array(position);
		subMesh.attributes.uv = new Float32Array(uv);
		subMesh.attributes.normal = new Float32Array(normal);
		subMesh.attributes.index = new Uint32Array(indexList);
		subMeshList.push(subMesh);
	}
	return {subMeshList};
}

exports.parseMtl = parseMtl;
exports.parseObj = async(...args) => cast(await parse(...args));
