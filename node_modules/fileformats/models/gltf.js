
function calcCount(type){
	switch(type){
		case 'VEC4':return 4;
		case 'VEC3':return 3;
		case 'VEC2':return 2;
		case 'SCALAR':return 1;
		case 'MAT2':return 4;
		case 'MAT3':return 9;
		case 'MAT4':return 16;
	}
	console.error(type);
}

function calcType(componentType){
	switch(componentType){
		case 5120:return Int8Array;
		case 5121:return Uint8Array;
		case 5122:return Int16Array;
		case 5123:return Uint16Array;
		case 5124:return Int32Array;
		case 5125:return Uint32Array;
		case 5126:return Float32Array;
		case 5130:return Float64Array;
	}
	console.error(componentType);
}

async function parse(info, path){
	//ignore:asset,scenes,scene,samplers
	const buffers = await Promise.all(info.buffers.map(v => fetch(path + v.uri).then(v => v.arrayBuffer())));
	const textures = info.textures.map(v => info.images[v.source].uri);
	const materials = info.materials.map(v => textures[v.pbrMetallicRoughness.baseColorTexture.index]);
	const accessors = [];
	for(let v of info.accessors){
		const type = calcType(v.componentType);
		const {buffer, byteLength, byteOffset} = info.bufferViews[v.bufferView];
		accessors.push(new type(buffers[buffer], byteOffset + (v.byteOffset ?? 0), v.count * calcCount(v.type)));
	}
	const meshList = [];
	for(let v of info.meshes){
		const subMeshList = [];
		for(let primitives of v.primitives){
			//mode:0-points,1-lines,2-line-loop,3-line-strip,4-triangles,5-triangle-strip,6-triangle-fan
			const subMesh = {attributes:{}};
			subMesh.texture = path + materials[primitives.material];
			subMesh.attributes.position = accessors[primitives.attributes.POSITION];
			subMesh.attributes.normal = accessors[primitives.attributes.NORMAL];
			subMesh.attributes.uv = accessors[primitives.attributes.TEXCOORD_0];
			subMesh.attributes.index = accessors[primitives.indices];
			subMeshList.push(subMesh);
		}
		meshList.push({subMeshList});
	}
	function createNode(node, factory){
		let result;
		if(node.mesh != null){
			result = factory.mesh(meshList[node.mesh]);
		}else{
			result = factory.group();
		}
		if(node.matrix){
			const info = result.transform.constructor.decompose([
				node.matrix[0], node.matrix[4], node.matrix[ 8], node.matrix[12],
				node.matrix[1], node.matrix[5], node.matrix[ 9], node.matrix[13],
				node.matrix[2], node.matrix[6], node.matrix[10], node.matrix[14]
			]);
			console.log(node.matrix, info);
			result.scaleX = info.scale.x;
			result.scaleY = info.scale.y;
			result.scaleZ = info.scale.z;
			result.x = info.translation.x;
			result.y = info.translation.y;
			result.z = info.translation.z;
			result.rotation = result.rotation.copyFrom(info.rotation);
		}else if(node.rotation){
			result.rotation = result.rotation.setTo(...node.rotation);
		}
		return addChildren(result, node.children, factory);
	}
	function addChildren(parent, children, factory){
		if(!Array.isArray(children))return parent;
		for(let child of children){
			parent.addChild(createNode(info.nodes[child], factory));
		}
		return parent;
	}
	return {createScene(factory, scene=0){
		return addChildren(factory.group(), info.scenes[scene].nodes, factory);
	}, scenes: info.scenes.map(v => v.name)};
}

exports.parse = parse;
