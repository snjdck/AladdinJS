
function castPosition(list){
	for(let i=0, n=list.length; i<n; i+=3){
		list[i] = -list[i];
		//let y = list[i+1];
		//let z = list[i+2];
		//list[i+1] = z;
		//list[i+2] = y;
	}
	return list;
}

function calcCount(type){
	switch(type){
		case 'VEC4':return 4;
		case 'VEC3':return 3;
		case 'VEC2':return 2;
		case 'SCALAR':return 1;
		case 'MAT2':return 4;
		case 'MAT3':return 9;
		case 'MAT4':return 16;
	}
	console.error(type);
}

function calcType(componentType){
	switch(componentType){
		case 5120:return Int8Array;
		case 5121:return Uint8Array;
		case 5122:return Int16Array;
		case 5123:return Uint16Array;
		case 5124:return Int32Array;
		case 5125:return Uint32Array;
		case 5126:return Float32Array;
		case 5130:return Float64Array;
	}
	console.error(componentType);
}

async function parse(info, path){
	//ignore:asset,scenes,scene,samplers
	const buffers = await Promise.all(info.buffers.map(v => fetch(path + v.uri).then(v => v.arrayBuffer())));
	const textures = info.textures.map(v => info.images[v.source].uri);
	const materials = info.materials.map(v => textures[v.pbrMetallicRoughness.baseColorTexture.index]);
	const accessors = [];
	for(let v of info.accessors){
		const type = calcType(v.componentType);
		const {buffer, byteLength, byteOffset} = info.bufferViews[v.bufferView];
		accessors.push(new type(buffers[buffer], byteOffset + (v.byteOffset ?? 0), v.count * calcCount(v.type)));
	}
	const meshList = [];
	for(let v of info.meshes){
		const subMeshList = [];
		for(let primitives of v.primitives){
			//mode:0-points,1-lines,2-line-loop,3-line-strip,4-triangles,5-triangle-strip,6-triangle-fan
			const subMesh = {attributes:{}};
			subMesh.texture = path + materials[primitives.material];
			subMesh.attributes.position = castPosition(accessors[primitives.attributes.POSITION]);
			subMesh.attributes.normal = castPosition(accessors[primitives.attributes.NORMAL]);
			subMesh.attributes.uv = accessors[primitives.attributes.TEXCOORD_0];
			subMesh.attributes.index = accessors[primitives.indices];
			subMeshList.push(subMesh);
		}
		meshList.push({subMeshList});
	}
	function createNode(node, factory){
		let result;
		if(node.mesh != null){
			result = factory.mesh(meshList[node.mesh]);
		}else{
			result = factory.group();
		}
		if(node.matrix){
			/*console.log(node.matrix);
			result.scaleX = node.matrix[ 0];
			result.scaleY = node.matrix[ 5];
			result.scaleZ = node.matrix[10];
			result.x = node.matrix[12];
			result.y = node.matrix[13];
			result.z = node.matrix[14];*/
		}else if(node.rotation){
			const [a, b, c, d] = node.rotation;
			let rotation = result.rotation;
			rotation.setTo(-a, b, c, d);
			result.rotation = rotation;
		}
		return addChildren(result, node.children, factory);
	}
	function addChildren(parent, children, factory){
		if(!Array.isArray(children))return parent;
		for(let child of children){
			parent.addChild(createNode(info.nodes[child], factory));
		}
		return parent;
	}
	return {createScene(factory, scene=0){
		return addChildren(factory.group(), info.scenes[scene].nodes, factory);
	}, scenes: info.scenes.map(v => v.name)};
}

exports.parse = parse;
