const Animation = require('webgpu/3d/Animation');
const KeyFrame = require('webgpu/3d/KeyFrame');
const Mat3x4 = require('webgpu/math/Matrix3D');
const Vector3D = require('webgpu/math/Vector3D');
const Quaternion = require('webgpu/math/Quaternion');
const {interpolateKeyFrames} = require('animation/interpolate');

function calcNodeMatrix({rotation, translation}){
	let matrix = new KeyFrame();
	if(rotation)matrix.rotation.setTo(...rotation);
	if(translation)matrix.translation.setTo(...translation);
	return matrix;
}

const sortFn = (a, b) => a - b;

function createMatrixRawData(from, offset, result){
	for(let i=0; i<3; ++i){
		for(let j=0; j<4; ++j){
			result[i<<2|j] = from[offset+(j<<2|i)];
		}
	}
	return result;
}

function findTarget(animation, accessors, nodes, node, keyFrameTimes){
	const matrix = calcNodeMatrix(nodes[node]);
	const matrixList = Array.from(keyFrameTimes, () => new KeyFrame());
	matrixList.forEach(v => v.copyFrom(matrix));
	const channelList = animation.channels.filter(v => v.target.node == node);
	for(const {sampler, target} of channelList){
		const {input, output} = animation.samplers[sampler];
		const timeList = accessors[input];
		const dataList = accessors[output];
		const valueList = [];
		if(target.path == 'translation'){
			console.assert(timeList.length * 3 == dataList.length)
			for(let i=0, n=dataList.length; i<n; i+=3){
				valueList.push(new Vector3D(dataList[i], dataList[i+1], dataList[i+2]));
			}
			for(let i=0; i<keyFrameTimes.length; ++i){
				let vec = interpolateKeyFrames(timeList, valueList, keyFrameTimes[i], new Vector3D());
				matrixList[i].translation.copyFrom(vec);
			}
		}else if(target.path == 'rotation'){
			console.assert(timeList.length * 4 == dataList.length)
			for(let i=0, n=dataList.length; i<n; i+=4){
				valueList.push(new Quaternion(dataList[i], dataList[i+1], dataList[i+2], dataList[i+3]));
			}
			for(let i=0; i<keyFrameTimes.length; ++i){
				let matrix = matrixList[i];
				let vec = interpolateKeyFrames(timeList, valueList, keyFrameTimes[i], new Quaternion());
				matrixList[i].rotation.copyFrom(vec);
			}
		}
	}
	return matrixList;
}

function calcCount(type){
	switch(type){
		case 'VEC4':return 4;
		case 'VEC3':return 3;
		case 'VEC2':return 2;
		case 'SCALAR':return 1;
		case 'MAT2':return 4;
		case 'MAT3':return 9;
		case 'MAT4':return 16;
	}
	console.error(type);
}

function calcType(componentType){
	switch(componentType){
		case 5120:return Int8Array;
		case 5121:return Uint8Array;
		case 5122:return Int16Array;
		case 5123:return Uint16Array;
		case 5124:return Int32Array;
		case 5125:return Uint32Array;
		case 5126:return Float32Array;
		case 5130:return Float64Array;
	}
	console.error(componentType);
}

async function parse(info, path){
	//ignore:asset,scenes,scene,samplers
	console.log(Object.keys(info))
	const buffers = await Promise.all(info.buffers.map(v => fetch(path + v.uri).then(v => v.arrayBuffer())));
	const textures = info.textures?.map(v => info.images[v.source].uri);
	const materials = info.materials?.map(v => {
		if(v.pbrMetallicRoughness?.baseColorTexture){
			return path + textures[v.pbrMetallicRoughness.baseColorTexture.index];
		}
		if(v.pbrMetallicRoughness?.baseColorFactor){
			const [b, g, r, a] = v.pbrMetallicRoughness?.baseColorFactor.map(v => v * 255);
			return 'color://' + JSON.stringify([r, g, b, 128]);
		}
		return 'color://[0,255,0,128]';
	});
	const accessors = [];

	for(let v of info.accessors){
		const type = calcType(v.componentType);
		const {buffer, byteLength, byteOffset} = info.bufferViews[v.bufferView];
		accessors.push(new type(buffers[buffer], byteOffset + (v.byteOffset ?? 0), v.count * calcCount(v.type)));
	}
	const meshList = [];
	for(let v of info.meshes){
		const subMeshList = [];
		for(let primitives of v.primitives){
			//mode:0-points,1-lines,2-line-loop,3-line-strip,4-triangles,5-triangle-strip,6-triangle-fan
			const subMesh = {attributes:{}};
			subMesh.texture = primitives.material != null ? materials[primitives.material] : 'color://[255,255,0,128]';
			subMesh.attributes.position = accessors[primitives.attributes.POSITION];
			if(primitives.attributes.NORMAL != null){
				subMesh.attributes.normal = accessors[primitives.attributes.NORMAL];
			}
			if(primitives.attributes.TEXCOORD_0 != null){
				subMesh.attributes.uv = accessors[primitives.attributes.TEXCOORD_0];
			}
			subMesh.attributes.index = accessors[primitives.indices];
			if(primitives.attributes.JOINTS_0 != null){
				subMesh.attributes.boneJoints = accessors[primitives.attributes.JOINTS_0];
			}
			if(primitives.attributes.WEIGHTS_0 != null){
				subMesh.attributes.boneWeights = accessors[primitives.attributes.WEIGHTS_0];
			}
			subMeshList.push(subMesh);
		}
		meshList.push({subMeshList});
	}
	const skinList = [];
	if(info.skins){
		for(let skin of info.skins){
			const inverseBindMatrices = accessors[skin.inverseBindMatrices];
			const boneList = skin.joints.map((joint, i) => ({id:i, name:info.nodes[joint].name}));
			for(let bone of boneList){
				bone.matrix = new KeyFrame().setFromMatrixRawData(createMatrixRawData(inverseBindMatrices, bone.id << 4, []));
				const nodeIndex = skin.joints[bone.id];
				const bonePID = skin.joints.findIndex(joint => info.nodes[joint].children?.includes(nodeIndex));
				if(bonePID < 0)continue;
				bone.parent = boneList[bonePID];
			}
			skinList.push(boneList);
		}
	}
	const animationList = [];
	if(info.animations){
		for(let {name, channels, samplers} of info.animations){
			const timeSet = new Set();
			for(let {sampler} of channels){
				for(let time of accessors[samplers[sampler].input]){
					timeSet.add(time);
				}
			}
			const keyFrameTimes = Array.from(timeSet).sort(sortFn);
			const animation = new Animation(name, keyFrameTimes.at(-1), Object.create(null));
			animation.keyFrameTimes = keyFrameTimes;
			for(let bone of skinList[0]){
				const nodeIndex = info.skins[0].joints[bone.id];
				animation.trackDict[bone.id] = findTarget({channels, samplers}, accessors, info.nodes, nodeIndex, keyFrameTimes);
			}
			animationList.push(animation);
		}
	}
	
	function createNode(node, factory){
		let result;
		if(node.mesh != null){
			let mesh = meshList[node.mesh]
			if(node.skin != null){
				mesh.boneList = skinList[node.skin];
				mesh.animationList = animationList;
			}
			result = factory.mesh(mesh);
		}else{
			result = factory.group();
		}
		if(node.matrix){
			result.transform = new Mat3x4(createMatrixRawData(node.matrix, 0, new Float32Array(12)));
		}else{
			if(node.rotation){
				result.rotation = result.rotation.setTo(...node.rotation);
			}
			if(node.translation){
				result.x = node.translation[0];
				result.y = node.translation[1];
				result.z = node.translation[2];
			}
			if(node.scale){
				result.scaleX = node.scale[0];
				result.scaleY = node.scale[1];
				result.scaleZ = node.scale[2];
			}
		}
		return addChildren(result, node.children, factory);
	}
	function addChildren(parent, children, factory){
		if(!Array.isArray(children))return parent;
		for(let child of children){
			parent.addChild(createNode(info.nodes[child], factory));
		}
		return parent;
	}
	return {createScene(factory, scene=0){
		return addChildren(factory.group(), info.scenes[scene].nodes, factory);
	}, scenes: info.scenes.map(v => v.name)};
}

exports.parse = async (...args) => {
	try{
		return await parse(...args);
	}catch(error){
		console.error(error);
		return Promise.reject(error);
	}
};
