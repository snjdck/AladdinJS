"use strict"

const zlib = require("zlib");

function findDataDescriptor(ba, offset){
	let sign = 0;
	for(let mark = offset; mark < ba.length; ++mark){
		sign = sign >>> 8 | ba[mark] << 24;
		if(sign != 0x08074b50)continue;
		let sizeCompressed = ba.readUInt32LE(mark + 4);
		if(sizeCompressed != mark - offset - 4)continue;
		return sizeCompressed;
	}
	return 0;
}

function readChunk(ba, offset, result){
	const flags			 = ba.readUInt16LE(offset + 6);
	const compressMethod = ba.readUInt16LE(offset + 8);
	let sizeCompressed	 = ba.readUInt32LE(offset + 18);
	const lenFileName	 = ba.readUInt16LE(offset + 26);
	const lenExtra		 = ba.readUInt16LE(offset + 28);

	if(flags & 0x01)return;//encrypted
	const hasDataDescriptor = flags & 0x08;

	offset += 30;
	const fileName = ba.toString("utf8", offset, offset + lenFileName);
	offset += lenFileName + lenExtra;

	if(hasDataDescriptor){
		sizeCompressed = findDataDescriptor(ba, offset);
	}
	if(sizeCompressed > 0){//not directory
		const fileData = ba.slice(offset, offset + sizeCompressed);
		if(compressMethod == 8){
			result[fileName] = zlib.inflateRawSync(fileData);
		}else if(compressMethod == 0){
			result[fileName] = fileData;
		}//else can't uncompress
	}
	return 30 + lenFileName + lenExtra + sizeCompressed + (hasDataDescriptor ? 16 : 0);
}

function decode(ba){
	let offset = 0;
	let result = {};
	while(offset < ba.length && ba.readUInt32LE(offset) == 0x04034b50)
		offset += readChunk(ba, offset, result);
	return result;
}

exports.decode = decode;