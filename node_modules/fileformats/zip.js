"use strict"

const gbk = require('../utils/text/gb2312');
const crc32 = require('./crc32');
const zlib = require('zlib');

function findDataDescriptor(ba, offset){
	let sign = 0;
	for(let mark = offset; mark < ba.length; ++mark){
		sign = sign >>> 8 | ba[mark] << 24;
		if(sign != 0x08074b50)continue;
		let sizeCompressed = ba.readUInt32LE(mark + 4);
		if(sizeCompressed != mark - offset - 4)continue;
		return sizeCompressed;
	}
	return 0;
}

function readChunk(ba, offset, result){
	const flags			 = ba.readUInt16LE(offset + 6);
	const compressMethod = ba.readUInt16LE(offset + 8);
	let sizeCompressed	 = ba.readUInt32LE(offset + 18);
	const lenFileName	 = ba.readUInt16LE(offset + 26);
	const lenExtra		 = ba.readUInt16LE(offset + 28);

	if(flags & 0x01)return;//encrypted
	const hasDataDescriptor = flags & 0x08;

	offset += 30;
	const fileName = gbk.decode(ba.slice(offset, offset + lenFileName));
	offset += lenFileName + lenExtra;

	if(hasDataDescriptor){
		sizeCompressed = findDataDescriptor(ba, offset);
	}
	if(sizeCompressed > 0){//not directory
		const fileData = ba.slice(offset, offset + sizeCompressed);
		if(compressMethod == 8){
			result[fileName] = zlib.inflateRawSync(fileData);
		}else if(compressMethod == 0){
			result[fileName] = fileData;
		}//else can't uncompress
	}
	return 30 + lenFileName + lenExtra + sizeCompressed + (hasDataDescriptor ? 16 : 0);
}

function decode(ba){
	const result = {};
	let offset = 0;
	while(offset < ba.length && ba.readUInt32LE(offset) == 0x04034b50)
		offset += readChunk(ba, offset, result);
	/*
	for(let offset=0, n=ba.length; offset < n;){
		switch(ba.readUInt32LE(offset)){
			case 0x04034b50:
				offset += readChunk(ba, offset, result);
				break;
			case 0x02014b50:
				//console.log(ba.slice(offset, offset + 46));
				offset += 46 + ba.readUInt16LE(offset + 28) + ba.readUInt16LE(offset + 30) + ba.readUInt16LE(offset + 32);
				break;
			case 0x06054b50:
				//console.log(ba.slice(offset, offset + 22));
				offset += 22 + ba.readUInt16LE(offset + 20);
				break;
			default:
				console.error(ba.slice(offset));
				offset = n;
				break;
		}
	}
	//*/
	return result;
}
/*
function encode(dict){
	const result = [];
	const fileList = Object.entries(dict);
	let fileOffset = 0;
	let directorySize = 0;
	for(let i=0, n=fileList.length; i<n; ++i){
		const name = Buffer.from(gbk.encode(fileList[i][0]));
		const data = fileList[i][1];
		const dataCompressed = zlib.deflateRawSync(data);

		const header = Buffer.alloc(30);
		header.writeUInt32LE(0x04034b50, 0);
		header.writeUInt16LE(0x14, 4);
		header.writeUInt16LE(0x08, 8);
		header.writeInt32LE(crc32(data), 14);
		header.writeUInt32LE(dataCompressed.length, 18);
		header.writeUInt32LE(data.length, 22);
		header.writeUInt16LE(name.length, 26);

		const directory = Buffer.alloc(46);
		directory.writeUInt32LE(0x02014b50, 0);
		directory.writeUInt16LE(0x1f, 4);
		header.copy(directory, 6, 4, 28);
		directory.writeUInt32LE(0x20, 38);
		directory.writeUInt32LE(fileOffset, 42);

		fileOffset += header.length + name.length + dataCompressed.length;
		directorySize += directory.length + name.length;
		result.splice(i * 3, 0, header, name, dataCompressed);
		result.push(directory, name);
	}

	const directoryEnd = Buffer.alloc(22);
	directoryEnd.writeUInt32LE(0x06054b50, 0);
	directoryEnd.writeUInt16LE(fileList.length, 8);
	directoryEnd.writeUInt16LE(fileList.length, 10);
	directoryEnd.writeUInt32LE(directorySize, 12);
	directoryEnd.writeUInt32LE(fileOffset, 16);

	result.push(directoryEnd);

	return Buffer.concat(result);
}
*/
function encode(dict)
{
	const fileList = Object.entries(dict).map(([name, data]) => [Buffer.from(gbk.encode(name)), zlib.deflateRawSync(data), data]);
	const result = Buffer.alloc(fileList.reduce((size, [name, data]) => size + 76 + 2 * name.length + data.length, 22));

	let directoryOffset = fileList.reduce((size, [name, data]) => size + 30 + name.length + data.length, 0);
	let fileOffset = 0;
	
	for(const [name, data, rawData] of fileList)
	{
		result.writeUInt32LE(0x04034b50, fileOffset);
		result.writeUInt16LE(0x14, fileOffset + 4);
		result.writeUInt16LE(0x08, fileOffset + 8);
		result.writeInt32LE(crc32(rawData), fileOffset + 14);
		result.writeUInt32LE(data.length, fileOffset + 18);
		result.writeUInt32LE(rawData.length, fileOffset + 22);
		result.writeUInt16LE(name.length, fileOffset + 26);

		name.copy(result, fileOffset + 30);
		data.copy(result, fileOffset + 30 + name.length);

		result.writeUInt32LE(0x02014b50, directoryOffset);
		result.writeUInt16LE(0x1f, directoryOffset + 4);
		result.copy(result, directoryOffset + 6, fileOffset + 4, fileOffset + 28);
		result.writeUInt32LE(0x20, directoryOffset + 38);
		result.writeUInt32LE(fileOffset, directoryOffset + 42);

		name.copy(result, directoryOffset + 46);

		fileOffset += 30 + name.length + data.length;
		directoryOffset += 46 + name.length;
	}

	result.writeUInt32LE(0x06054b50, directoryOffset);
	result.writeUInt16LE(fileList.length, directoryOffset + 8);
	result.writeUInt16LE(fileList.length, directoryOffset + 10);
	result.writeUInt32LE(directoryOffset - fileOffset, directoryOffset + 12);
	result.writeUInt32LE(fileOffset, directoryOffset + 16);

	return result;
}

exports.decode = decode;
exports.encode = encode;

/*

https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt

XIII. Decryption
----------------

The encryption used in PKZIP was generously supplied by Roger
Schlafly.  PKWARE is grateful to Mr. Schlafly for his expert
help and advice in the field of data encryption.

PKZIP encrypts the compressed data stream.  Encrypted files must
be decrypted before they can be extracted.

Each encrypted file has an extra 12 bytes stored at the start of
the data area defining the encryption header for that file.  The
encryption header is originally set to random values, and then
itself encrypted, using three, 32-bit keys.  The key values are
initialized using the supplied encryption password.  After each byte
is encrypted, the keys are then updated using pseudo-random number
generation techniques in combination with the same CRC-32 algorithm
used in PKZIP and described elsewhere in this document.

The following is the basic steps required to decrypt a file:

1) Initialize the three 32-bit keys with the password.
2) Read and decrypt the 12-byte encryption header, further
   initializing the encryption keys.
3) Read and decrypt the compressed data stream using the
   encryption keys.

Step 1 - Initializing the encryption keys
-----------------------------------------

Key(0) <- 305419896
Key(1) <- 591751049
Key(2) <- 878082192

loop for i <- 0 to length(password)-1
    update_keys(password(i))
end loop

Where update_keys() is defined as:

update_keys(char):
  Key(0) <- crc32(key(0),char)
  Key(1) <- Key(1) + (Key(0) & 000000ffH)
  Key(1) <- Key(1) * 134775813 + 1
  Key(2) <- crc32(key(2),key(1) >> 24)
end update_keys

Where crc32(old_crc,char) is a routine that given a CRC value and a
character, returns an updated CRC value after applying the CRC-32
algorithm described elsewhere in this document.

Step 2 - Decrypting the encryption header
-----------------------------------------

The purpose of this step is to further initialize the encryption
keys, based on random data, to render a plaintext attack on the
data ineffective.

Read the 12-byte encryption header into Buffer, in locations
Buffer(0) thru Buffer(11).

loop for i <- 0 to 11
    C <- buffer(i) ^ decrypt_byte()
    update_keys(C)
    buffer(i) <- C
end loop

Where decrypt_byte() is defined as:

unsigned char decrypt_byte()
    local unsigned short temp
    temp <- Key(2) | 2
    decrypt_byte <- (temp * (temp ^ 1)) >> 8
end decrypt_byte

After the header is decrypted,  the last 1 or 2 bytes in Buffer
should be the high-order word/byte of the CRC for the file being
decrypted, stored in Intel low-byte/high-byte order.  Versions of
PKZIP prior to 2.0 used a 2 byte CRC check; a 1 byte CRC check is
used on versions after 2.0.  This can be used to test if the password
supplied is correct or not.

Step 3 - Decrypting the compressed data stream
----------------------------------------------

The compressed data stream can be decrypted as follows:

loop until done
    read a character into C
    Temp <- C ^ decrypt_byte()
    update_keys(temp)
    output Temp
end loop

*/