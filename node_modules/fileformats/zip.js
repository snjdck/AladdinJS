"use strict"

const zlib = require("zlib");
const assert = require("assert");

let offset;

function findDataDescriptor(ba){
	let sign = 0;
	let mark = offset;
	while(mark < ba.length){
		let char = ba[mark++];
		sign = (char << 24) | (sign >>> 8);
		if(sign != 0x08074b50){
			continue;
		}
		assert(ba.length - mark >= 12);
		let fileSize = mark - offset - 4;
		let sizeCompressed = ba.readUInt32LE(mark + 4);
		if(fileSize == sizeCompressed){
			return ba.slice(offset, mark - 4);
		}
	}
}

function readChunk(ba, result){
	offset += 4;	//sign
	offset += 2;	//version
	let flags = ba.readUInt16LE(offset);			offset += 2;
	let compressMethod = ba.readUInt16LE(offset);	offset += 2;

	assert((flags & 0x01) == 0, "zip file encrypted!");

	offset += 4;	//last modified time and date
	offset += 4;	//crc32
	let sizeCompressed = ba.readUInt32LE(offset);	offset += 4;
	offset += 4;	//sizeUncompressed

	let lenFileName = ba.readUInt16LE(offset);	offset += 2;
	let lenExtra = ba.readUInt16LE(offset);		offset += 2;

	let fileName = ba.toString("utf8", offset, offset + lenFileName);
	offset += lenFileName + lenExtra;

	let fileData;

	if(flags & 0x08){
		fileData = findDataDescriptor(ba);
		offset += fileData.length + 16;
	}else if(sizeCompressed > 0){
		fileData = ba.slice(offset, offset + sizeCompressed);
		offset += sizeCompressed;
	}else{//directory
		return;
	}
	if(compressMethod == 8){
		fileData = zlib.inflateRawSync(fileData);
	}else{
		assert(compressMethod == 0, `${compressMethod} not support!`);
	}

	result[fileName] = fileData;
}

function decode(ba){
	offset = 0;
	let result = {};
	while(offset < ba.length){
		if(ba.readUInt32LE(offset) != 0x04034b50)
			break;
		readChunk(ba, result);
	}
	return result;
}

exports.decode = decode;