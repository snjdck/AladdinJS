"use strict";

const SVG_NS = "http://www.w3.org/2000/svg";

function createElement(tag, attributes)
{
	let element = document.createElementNS(SVG_NS, tag);
	if(attributes)
		for(let key in attributes)
			element.setAttribute(key, attributes[key]);
	return element;
}

function createText(text, attributes)
{
	let element = createElement("text", attributes);
	element.innerHTML = text;
	return element;
}

const parseText = (parser => v => parser.parseFromString(v, "image/svg+xml").documentElement)(new DOMParser());
function walkSvgTree(node, enterFn, leaveFn){
	enterFn(node);
	for(let child of node.children){
		walkSvgTree(child, enterFn, leaveFn);
	}
	leaveFn(node);
}
function castAttributes({attributes}){
	const result = Object.create(null);
	for(let attr of attributes){
		result[attr.name] = attr.value;
	}
	return result;
}
const splitPts = (num => pts => pts.match(num)?.map(Number))(/-?\d+(\.\d+)?|-?\.\d+/g);
function castTransform(transform){
	if(transform.startsWith('matrix')){
		return splitPts(transform.slice(7,-1));
	}
	if(transform.startsWith('translate')){
		const [dx, dy] = splitPts(transform.slice(10,-1));
		return [1, 0, 0, 1, dx, dy];
	}
	console.warn(transform);
}
const drawSvg = function(){
	const handler = {
		g(){},
		svg(ctx, info){
			const [x, y] = splitPts(info.viewBox);
			ctx.translate(-x, -y);
		},
		defs(){
			this.defs = {};
		},
		linearGradient(ctx, {id, x1, y1, x2, y2}){
			this.gradient = this.defs[id] = ctx.createLinearGradient(x1, y1, x2, y2);
		},
		stop(ctx, info){
			this.gradient.addColorStop(info.offset, info['stop-color']);
		},
		polyline(ctx, {points}){
			const pts = splitPts(points);
			this.path = new Path2D();
			this.path.moveTo(pts[0], pts[1]);
			for(let i=2; i<pts.length; i+=2){
				this.path.lineTo(pts[i], pts[i+1]);
			}
		},
		polygon(ctx, {points}){
			const pts = splitPts(points);
			this.path = new Path2D();
			this.path.moveTo(pts[0], pts[1]);
			for(let i=2; i<pts.length; i+=2){
				this.path.lineTo(pts[i], pts[i+1]);
			}
			this.path.closePath();
		},
		line(ctx, {x1, y1, x2, y2}){
			this.path = new Path2D();
			this.path.moveTo(x1, y1);
			this.path.lineTo(x2, y2);
		},
		circle(ctx, {cx, cy, r}){
			this.path = new Path2D();
			this.path.arc(cx, cy, r, 0, Math.PI * 2);
		},
		ellipse(ctx, {cx, cy, rx, ry}){
			this.path = new Path2D();
			this.path.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
		},
		rect(ctx, {x, y, width, height, rx=0, ry=0}){
			this.path = new Path2D();
			this.path.roundRect(x, y, width, height, {x: rx, Y: ry});
		},
		path(ctx, {d}){
			this.path = new Path2D(d);
		},
		_path(ctx, {d}){
			let px = 0, py = 0;
			let lastCmd, cpx, cpy;
			ctx.beginPath();
			for(let cmd of d.match(/[MLHVCSQTAZ][^a-z]*/gi)){
				let pts = splitPts(cmd.slice(1));
				if(pts?.some(isNaN))console.log(cmd, pts);
				switch(cmd[0]){
					case 'M':
						ctx.moveTo(px=pts[0], py=pts[1]);
						for(let i=2; i<pts.length; i+=2){
							ctx.lineTo(px=pts[i], py=pts[i+1]);
						}
						break;
					case 'm':
						ctx.moveTo(px+=pts[0], py+=pts[1]);
						for(let i=2; i<pts.length; i+=2){
							ctx.lineTo(px+=pts[i], py+=pts[i+1]);
						}
						break;
					case 'L':
						for(let i=0; i<pts.length; i+=2){
							ctx.lineTo(px=pts[i], py=pts[i+1]);
						}
						break;
					case 'l':
						for(let i=0; i<pts.length; i+=2){
							ctx.lineTo(px+=pts[i], py+=pts[i+1]);
						}
						break;
					case 'H':
						for(let i=0; i<pts.length; ++i){
							ctx.lineTo(px=pts[i], py);
						}
						break;
					case 'h':
						for(let i=0; i<pts.length; ++i){
							ctx.lineTo(px+=pts[i], py);
						}
						break;
					case 'V':
						for(let i=0; i<pts.length; ++i){
							ctx.lineTo(px, py=pts[i]);
						}
						break;
					case 'v':
						for(let i=0; i<pts.length; ++i){
							ctx.lineTo(px, py+=pts[i]);
						}
						break;
					case 'C':
						for(let i=0; i<pts.length; i+=6){
							ctx.bezierCurveTo(pts[i], pts[i+1], cpx=pts[i+2], cpy=pts[i+3], px=pts[i+4], py=pts[i+5]);
						}
						break;
					case 'c':
						for(let i=0; i<pts.length; i+=6){
							ctx.bezierCurveTo(px+pts[i], py+pts[i+1], cpx=px+pts[i+2], cpy=py+pts[i+3], px+=pts[i+4], py+=pts[i+5]);
						}
						break;
					case 'S':
						for(let i=0; i<pts.length; i+=4){
							let tx, ty;
							if(lastCmd == 'C' || lastCmd == 'S'){
								tx = 2*px-cpx;
								ty = 2*py-cpy;
							}else{
								tx = px;
								ty = py;
							}
							ctx.bezierCurveTo(tx, ty, cpx=pts[i], cpy=pts[i+1], px=pts[i+2], py=pts[i+3]);
						}
						break;
					case 's':
						for(let i=0; i<pts.length; i+=4){
							let tx, ty;
							if(lastCmd == 'C' || lastCmd == 'S'){
								tx = 2*px-cpx;
								ty = 2*py-cpy;
							}else{
								tx = px;
								ty = py;
							}
							ctx.bezierCurveTo(tx, ty, cpx=px+pts[i], cpy=py+pts[i+1], px+=pts[i+2], py+=pts[i+3]);
						}
						break;
					case 'Q':
						for(let i=0; i<pts.length; i+=4){
							ctx.quadraticCurveTo(cpx=pts[i], cpy=pts[i+1], px=pts[i+2], py=pts[i+3]);
						}
						break;
					case 'q':
						for(let i=0; i<pts.length; i+=4){
							ctx.quadraticCurveTo(cpx=px+pts[i], cpy=py+pts[i+1], px+=pts[i+2], py+=pts[i+3]);
						}
						break;
					case 'T':
						for(let i=0; i<pts.length; i+=2){
							if(lastCmd == 'Q' || lastCmd == 'T'){
								cpx = 2*px-cpx;
								cpy = 2*py-cpy;
							}else{
								cpx = px;
								cpy = py;
							}
							ctx.quadraticCurveTo(cpx, cpy, px=pts[i], py=pts[i+1]);
						}
						break;
					case 't':
						for(let i=0; i<pts.length; i+=2){
							if(lastCmd == 'Q' || lastCmd == 'T'){
								cpx = 2*px-cpx;
								cpy = 2*py-cpy;
							}else{
								cpx = px;
								cpy = py;
							}
							ctx.quadraticCurveTo(cpx, cpy, px+=pts[i], py+=pts[i+1]);
						}
						break;
						/*
					case 'A':
						for(let i=0; i<pts.length; i+=7){
							ctx.ellipse();
						}
						break;
						*/
					case 'Z':
					case 'z':
						ctx.closePath();
						break;
					default:
						console.log(cmd, pts)
				}
				lastCmd = cmd[0].toUpperCase();
			}
		},
	};
	return (ctx, node) => {
		const svg = {style:{},nodes:[]};
		const styleStack = [];
		walkSvgTree(node, node => {
			const info = castAttributes(node);
			styleStack.push(svg.style = Object.assign({}, svg.style, info));
			ctx.save();
			if(info.transform)ctx.transform(...castTransform(info.transform));
			if(info.opacity)ctx.globalAlpha = info.opacity;
			if(info['stroke-width'])ctx.lineWidth = Number(info['stroke-width']);
			if(info['stroke-miterlimit'])ctx.miterLimit = Number(info['stroke-miterlimit']);
			if(info['stroke-linecap'])ctx.lineCap = info['stroke-linecap'];
			if(info['stroke-linejoin'])ctx.lineJoin = info['stroke-linejoin'];
			handler[node.localName]?.call(svg, ctx, info);
			svg.nodes.push(node.localName);
		}, node => {
			svg.nodes.pop();
			const {defs, style} = svg;
			if(svg.path){
				if(svg.nodes.at(-1) == 'defs'){
					svg.defs[node.id] = {path:svg.path, style};
				}else{
					if(style.fill != 'none'){
						if(/url\(#\w+\)/.test(style.fill)){
							ctx.fillStyle = defs[style.fill.slice(5, -1)];
						}else{
							ctx.fillStyle = style.fill;
						}
						ctx.fill(svg.path, style['fill-rule'] || 'nonzero');
					}
					if(style.stroke != 'none'){
						ctx.strokeStyle = style.stroke;
						ctx.stroke(svg.path);
					}
				}
				svg.path = null;
			}
			ctx.restore();
			styleStack.pop();
			svg.style = styleStack[styleStack.length-1];
			if(!handler[node.localName])console.warn('miss handler:', node.localName);
		});
	}
}();

module.exports = {
	createElement,
	createText,
	parseText,
	drawSvg,
};
