'use strict';

const dgram = require('dgram');
const http = require('http');
const {URL} = require('url');
const fs = require('fs');
const {basename} = require('path');
const networkInterface = require('../net/networkInterface');
const xmlEscape = require('../utils/html/escape');
const load = require('../net/load');

const multicast_ip = '239.255.255.250';
const multicast_port = 1900;

const separator = '\r\n';
const concatHead = list => list.map(v => v + separator).join('') + separator;
const splitHead = text => text.toString().trim().split(separator);

const discoverPacket = concatHead([
	`M-SEARCH * HTTP/1.1`,
	`MX: 5`,
	`ST: upnp:rootdevice`,
	`MAN: "ssdp:discover"`,
	`Host: ${multicast_ip}:${multicast_port}`,
]);

const Packet = function(){
	function createPacket(name, args){
		return `<s:Envelope s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><u:${name} xmlns:u="urn:schemas-upnp-org:service:AVTransport:1">${Object.entries(args).map(([k, v]) => `<${k}>${xmlEscape(v.toString())}</${k}>`).join('')}</u:${name}></s:Body></s:Envelope>`;
	}
	return {
		play(CurrentURI){
			return createPacket('SetAVTransportURI', {InstanceID: 0, CurrentURIMetaData: '', CurrentURI});
		},
		seek(Target, Unit='ABS_TIME'){
			return createPacket('Seek', {InstanceID: 0, Unit, Target});
		},
		pause: createPacket('Pause', {InstanceID: 0}),
		resume: createPacket('Play', {InstanceID: 0, Speed: 1}),
		stop: createPacket('Stop', {InstanceID: 0}),
	};
}();

function findScreen(){
	return new Promise(resolve => {
		//let findFlag = false;
		dgram.createSocket('udp4').on('error', function(error){
			console.log(`server error:\n${error.stack}`);
			this.close();
		}).on('message', async function(message){
			//if(findFlag)return;
			const head = splitHead(message);
			head.shift();
			const dict = new Map(head.map(v => v.split(': ')));
			if(!dict.get('SERVER').includes(' DLNADOC/'))return;
			//findFlag = true;
			this.close();
			resolve(sendPacketFactory(await getControlURL(dict.get('Location'))));
		}).on('listening', function(){
			this.addMembership(multicast_ip);
			this.setMulticastTTL(255);
			this.send(discoverPacket, multicast_port, multicast_ip);
		}).bind();
	});
}

async function getControlURL(location){
	const {origin} = new URL(location);
	const info = await load(location);
	const controlService = /<serviceType>urn:schemas-upnp-org:service:AVTransport:1<\/serviceType>(.+?)<\/service>/s.exec(info)[1];
	const controlURL = /<controlURL>(.+?)<\/controlURL>/.exec(controlService)[1];
	return origin + controlURL;
}

const sendPacketFactory = controlURL => packet => load(controlURL, {
	method: 'POST',
	headers: {
		'SOAPAction': `urn:schemas-upnp-org:service:AVTransport:1#SetAVTransportURI"`,
		'Content-Type': `text/xml; charset="utf-8"`,
	},
	body: packet
});

function generateLink(fileName, onRequest){
	return new Promise(resolve => {
		const host = networkInterface();
		//const date = new Date().toGMTString();
		//const ETag = JSON.stringify(Buffer.from(url).toString('hex'));
		http.createServer(function(request, response){
			if(decodeURI(request.url).slice(1) != fileName)return;
			onRequest(request, response);
		}).listen(0, '0.0.0.0', function(){
			const {port} = this.address();
			resolve(`http://${host}:${port}/${encodeURI(fileName)}`);
		});
	});
}

function castPath(fileName, totalLength, readFn){
	return generateLink(fileName, function(request, response){
		const {range} = request.headers;
		console.log(request.url, range);
		response.setHeader('Content-Type', 'video/mp4');
		if(range && range != 'bytes=0-'){
			let [start, end] = range.split('=')[1].split('-').map(Number);
			if(!end){
				end = totalLength - 1;
			}
			response.setHeader('Content-Length', end - start + 1);
			response.setHeader('Content-Range', `bytes ${start}-${end}/${totalLength}`);
			response.writeHead(206, 'Partial Content');
			readFn(response, start, end);
		}else{
			response.setHeader('Content-Length', totalLength);
			readFn(response, 0, totalLength - 1);
		}
	});
}

function castFilePath(url){
	return castPath(basename(url), fs.lstatSync(url).size, (response, start, end) => {
		fs.createReadStream(url, {start, end}).pipe(response);
	});
}

function castHttpPath(url){
	const {protocol, hostname, pathname} = new URL(url);
	const http = require(protocol.slice(0, -1));
	return new Promise(resolve => http.get(encodeURI(url), {headers:{Host: hostname}}, response => {
		console.log(response.headers);
		const totalLength = Number(response.headers['content-length']);
		const downloader = new Downloader(totalLength);
		response.on('data', data => downloader.append(data));
		resolve(downloader);
	})).then(downloader => castPath(decodeURI(pathname.slice(1)), downloader.buffer.length, (response, start, end) => {
		downloader.fetchToResponse(start, end, response);
	}));
}

class Downloader
{
	constructor(size){
		this.buffer = Buffer.alloc(size);
		this.length = 0;
		this.handlerSet = new Set();
	}

	append(data){
		const {buffer, length} = this;
		this.length += data.copy(buffer, length);
		this.handlerSet.forEach(fn => fn(length));
	}

	fetch(start, end, callback){
		const {buffer, length, handlerSet} = this;
		if(end < length){
			callback(buffer.slice(start, end + 1), true);
			return;
		}
		if(start < length){
			callback(buffer.slice(start, length));
		}
		function onData(prevLength){
			const finishFlag = end < length;
			callback(buffer.slice(Math.max(start, prevLength), Math.min(end + 1, length)), finishFlag);
			if(finishFlag)handlerSet.delete(onData);
		}
		handlerSet.add(onData);
		return () => handlerSet.delete(onData);
	}

	fetchToResponse(start, end, response){
		const closeFn = this.fetch(start, end, (data, done) => done ? response.end(data) : response.write(data));
		if(closeFn)response.on('close', closeFn);
	}
}

exports.findScreen = findScreen;

exports.castFilePath = castFilePath;
exports.castHttpPath = castHttpPath;

exports.Packet = Packet;
