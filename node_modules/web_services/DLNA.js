'use strict';

const dgram = require('dgram');
const http = require('http');
const {URL} = require('url');
const fs = require('fs');
const {basename} = require('path');
const EventEmitter = require('events');
const networkInterface = require('../net/networkInterface');
const xmlEscape = require('../utils/html/escape');
const load = require('../net/load');

const multicast_ip = '239.255.255.250';
const multicast_port = 1900;

const separator = '\r\n';
const concatHead = list => list.map(v => v + separator).join('') + separator;
const splitHead = text => text.toString().trim().split(separator);

const discoverPacket = concatHead([
	`M-SEARCH * HTTP/1.1`,
	`MX: 5`,
	`ST: upnp:rootdevice`,
	`MAN: "ssdp:discover"`,
	`Host: ${multicast_ip}:${multicast_port}`,
]);

const playPacket = url => `<?xml version="1.0" encoding="UTF-8"?><s:Envelope s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><u:SetAVTransportURI xmlns:u="urn:schemas-upnp-org:service:AVTransport:1"><InstanceID>0</InstanceID><CurrentURI>${xmlEscape(url)}</CurrentURI><CurrentURIMetaData></CurrentURIMetaData></u:SetAVTransportURI></s:Body></s:Envelope>`;

function playContent(url){
	let findFlag = false;
	dgram.createSocket('udp4').on('error', function(error){
		console.log(`server error:\n${error.stack}`);
		this.close();
	}).on('message', async function(message){
		if(findFlag)return;
		const head = splitHead(message);
		head.shift();
		const dict = new Map(head.map(v => v.split(': ')));
		if(!dict.get('SERVER').includes(' DLNADOC/'))return;
		findFlag = true;
		const controlURL = await getControlURL(dict.get('Location'));
		const result = await load(controlURL, {
			method: 'POST',
			headers: {
				'SOAPAction': `urn:schemas-upnp-org:service:AVTransport:1#SetAVTransportURI"`,
				'Content-Type': `text/xml; charset="utf-8"`,
			},
			body: playPacket(await url)
		});
		console.log(result);
	}).on('listening', function(){
		this.addMembership(multicast_ip);
		this.setMulticastTTL(255);
		this.send(discoverPacket, multicast_port, multicast_ip);
	}).bind();
}

async function getControlURL(location){
	const {origin} = new URL(location);
	const info = await load(location);
	const controlService = /<serviceType>urn:schemas-upnp-org:service:AVTransport:1<\/serviceType>(.+?)<\/service>/s.exec(info)[1];
	const controlURL = /<controlURL>(.+?)<\/controlURL>/.exec(controlService)[1];
	return origin + controlURL;
}

function castPath(url, fileNameFn, fn200, fn206){
	return new Promise(resolve => {
		const host = networkInterface();
		const fileName = fileNameFn(url);
		//const date = new Date().toGMTString();
		//const ETag = JSON.stringify(Buffer.from(url).toString('hex'));
		http.createServer(function(request, response){
			if(decodeURI(request.url).slice(1) != fileName)return;
			const {range} = request.headers;
			console.log(request.url, range);
			response.setHeader('Content-Type', 'video/mp4');
			if(range && range != 'bytes=0-'){
				fn206(url, response, range);
			}else{
				fn200(url, response);
			}
		}).listen(0, '0.0.0.0', function(){
			const {port} = this.address();
			resolve(`http://${host}:${port}/${encodeURI(fileName)}`);
		});
	});
}

function castFilePath(url){
	const totalLength = fs.lstatSync(url).size;
	return castPath(url, basename, (url, response) => {
		response.setHeader('Content-Length', totalLength);
		fs.createReadStream(url).pipe(response);
	}, (url, response, range) => {
		let [start, end] = range.split('=')[1].split('-').map(Number);
		if(!end)end = totalLength;
		response.setHeader('Content-Length', Math.min(totalLength, end - start + 1));
		response.setHeader('Content-Range', `bytes */${totalLength}`);
		response.writeHead(206, 'Partial Content');
		fs.createReadStream(url, {start, end}).pipe(response);
	});
}

async function castHttpPath(url){
	const {protocol, hostname, pathname} = new URL(url);
	const http = require(protocol.slice(0, -1));
	let totalLength = 0;
	let videoBuffer;
	let videoLength = 0;
	const emitter = new EventEmitter();
	await new Promise(resolve => http.get(encodeURI(url), {headers:{Host: hostname}}, response => {
		console.log(response.headers);
		totalLength = Number(response.headers['content-length']);
		videoBuffer = Buffer.alloc(totalLength);
		response.on('data', data => {
			videoLength += data.copy(videoBuffer, videoLength);
			emitter.emit('data', data);
		});
		resolve();
	}));
	return await castPath(url, url => decodeURI(pathname.slice(1)), (url, response) => {
		response.setHeader('Content-Length', totalLength);
		if(videoLength < totalLength){
			if(videoLength > 0){
				response.write(videoBuffer.slice(0, videoLength));
			}
			function onData(data){
				response.write(data);
				if(videoLength >= totalLength){
					response.end();
					emitter.off('data', onData);
				}
			}
			emitter.on('data', onData);
			response.on('close', () => emitter.off('data', onData));
		}else{
			response.end(videoBuffer);
		}
	}, (url, response, range) => {
		let [start, end] = range.split('=')[1].split('-').map(Number);
		if(!end)end = totalLength;
		response.setHeader('Content-Length', Math.min(totalLength, end - start + 1));
		response.setHeader('Content-Range', `bytes */${totalLength}`);
		response.writeHead(206, 'Partial Content');
		if(end <= videoLength){
			response.end(videoBuffer.slice(start, end));
		}else{
			if(start < videoLength){
				response.write(videoBuffer.slice(start, videoLength));
			}
			function onData(data){
				response.write(videoBuffer.slice(Math.max(start, videoLength - data.length), Math.min(end, videoLength)));
				if(videoLength >= end){
					response.end();
					emitter.off('data', onData);
				}
			}
			emitter.on('data', onData);
			response.on('close', () => emitter.off('data', onData));
		}
	});
}

exports.playContent = playContent;
exports.castFilePath = castFilePath;
exports.castHttpPath = castHttpPath;
