function overrideMethod(target, prop, newFn){
	target[prop] = newFn(target[prop]);
}

Blockly.Extensions.registerMutator('wifi_mode_mutator', {
	mutationToDom(){
		const container = Blockly.utils.xml.createElement('mutation');
		container.setAttribute('mode', this.getFieldValue('MODE'));
		return container;
	},
	domToMutation(xmlElement){
		this.updateShape_(xmlElement.getAttribute('mode'));
	},
	updateShape_(mode){
		if(mode == 'tcp' || mode == 'slave'){
			if(this.getInput('CHANNEL')){
				this.removeInput('CHANNEL');
			}
			if(!this.getInput('IP')){
				this.appendDummyInput('IP').appendField('ip地址').appendField(new Blockly.FieldTextInput("192.168.0.1"), 'IP');
			}
			if(!this.getInput('PORT')){
				this.appendDummyInput('PORT').appendField('端口').appendField(new Blockly.FieldNumber(6602, 0, 65535, 1), 'PORT');
			}
		}else if(mode == 'ap'){
			if(this.getInput('IP')){
				this.removeInput('IP');
			}
			if(this.getInput('PORT')){
				this.removeInput('PORT');
			}
			if(!this.getInput('CHANNEL')){
				this.appendDummyInput('CHANNEL').appendField('信道').appendField(new Blockly.FieldNumber(11, 0, 255, 1), 'CHANNEL');
			}
		}else if(mode == 'sta'){
			if(this.getInput('IP')){
				this.removeInput('IP');
			}
			if(this.getInput('PORT')){
				this.removeInput('PORT');
			}
			if(this.getInput('CHANNEL')){
				this.removeInput('CHANNEL');
			}
		}
	}
}, function(){
	this.getField('MODE').setValidator(function(option){
		this.getSourceBlock().updateShape_(option);
	});
});
Blockly.Extensions.register('wifi_update_output', function(){
	this.getField('WIFI_VALUE_NAME').setValidator(function(option){
		this.getSourceBlock().setOutput(true, option == '1' ? "Number" : "String");
	});
});
Blockly.Extensions.register('testAlex', function(){
	setTimeout(() => {
		const input = this.getInputTargetBlock('SENSOR_PORT');
		if(!input)return;
		input.setEditable(false);
		input.setEnabled(false);
	});
});
Blockly.Extensions.register('markAsyncFunc', function(){this.data = 'isAsyncFunc';});
Blockly.Extensions.register('markConstText', function(){this.data = 'isConstText';});
Blockly.Extensions.register('markConstNumber', function(){this.data = 'isConstNumber';});
Blockly.Extensions.register('markStatement', function(){
	this.setPreviousStatement(true, null);
	this.setNextStatement(true, null);
});
Blockly.Extensions.register('set_colours_image_recognition', function(){
	let field = this.getField("IMAGE_RECOGNITION_TYPE");
	field.setColours(['#e17373','#e08649','#5450e8','#37b80c','#24716b']);
});
Blockly.Extensions.register('sync_parent_style', function(){
	setTimeout(() => {
		this.setStyle(this.outputConnection.targetConnection.getSourceBlock().getStyleName());
	}, 0);
});
const blockTypeColorDict = {
	'Number': 'math_blocks',
	'String': 'text_blocks',
	'Array': 'list_blocks',
	'Boolean': 'logic_blocks',
};
const blockTypeBlockDict = {
	'Number': 'math_number',
	'String': 'text',
	'Array': 'lists_create_empty',
	'Boolean': 'logic_boolean',
};
const variables_sync_type_helper = callback => function(){
	function handler(id){
		const type = Blockly.getMainWorkspace().getVariableById(id).type;
		//this.setTypes_([type], type);
		callback.call(this.getSourceBlock(), type);
	}
	const fieldVar = this.getField("VAR");
	fieldVar.setValidator(handler);
	setTimeout(() => handler.call(fieldVar, fieldVar.getValue()), 0);
};
Blockly.Extensions.register('variables_set_sync_value_type', variables_sync_type_helper(function(type){
	const input = this.getInput('VALUE');
	if(input.connection.check_ && input.connection.check_.indexOf(type) >= 0){
		return;
	}
	input.setCheck(type);
	if(this.getInputTargetBlock('VALUE'))return;

	const blockType = blockTypeBlockDict[type] || 'math_number';
	const topBlocks = this.workspace.getTopBlocks();
	let block = topBlocks.find(block => block.type == blockType);
	if(!block){
		let blockDef = `<block type="${blockType}"></block>`;
		block = Blockly.Xml.domToBlock(Blockly.Xml.textToDom(blockDef), this.workspace);
	}
	block.outputConnection.connect(input.connection);
	
	//this.setStyle(blockTypeColorDict[type]);
}));
Blockly.Extensions.register('variables_get_sync_output_type', variables_sync_type_helper(function(type){
	this.setOutput(true, type);
	//this.setStyle(blockTypeColorDict[type]);
}));
Blockly.Extensions.register('fix_list_block', function(){
	const fieldVar = this.getField("LIST");
	setTimeout(() => {
		fieldVar.setTypes_(['Array'], 'Array');
		fieldVar.setValue(fieldVar.getOptions()[0][1]);
	}, 0);
});

function procedures_mutator(fn, hasOutputFn){
	const getAttributeName = v => v.getAttribute('name');
	return {
		mutationToDom(){
			const inputList = fn(this.inputList);
			const container = Blockly.utils.xml.createElement('mutation');
			//container.setAttribute('name', this.getFieldValue('NAME'));
			container.setAttribute('hasOutput', hasOutputFn(this));
			for (let i=0; i < inputList.length; ++i) {
				const input = inputList[i];
				const parameter = Blockly.utils.xml.createElement('arg');
				parameter.setAttribute('name', input.name);
				container.appendChild(parameter);
			}
			return container;
		},
		domToMutation(xmlElement){
			//xmlElement.childNodes, xmlElement.children
			this._updateShape(
				Array.from(xmlElement.children, getAttributeName),
				xmlElement.getAttribute('hasOutput') == 'true'
			);
		},
		_hasOutput(){
			return hasOutputFn(this);
		},
		_getArgList(){
			return fn(this.inputList).map(v => v.name);
		}
	};
}
Blockly.Extensions.registerMutator('procedures_definition', {
	...procedures_mutator(inputList => {
		const index = inputList.findIndex(v => v.type == Blockly.DUMMY_INPUT && v.name == 'PARAMS');
		return inputList.slice(1, index);
	}, block => block.getInput('OUTPUT') != null),
	_updateShape(argList, hasOutput){
		//this._forEachCallDo(block => block._updateShape(argList, hasOutput));
		for(let name of argList){
			this._addArgInput(name);
		}
		if(hasOutput){
			this.appendValueInput('OUTPUT').setCheck('Number').appendField('返回').setAlign(Blockly.ALIGN_RIGHT);
		}
	},
	_isNameUsed(name){
		const blockList = this.workspace.getAllBlocks(false);
		for(let i=0; i < blockList.length; ++i){
			const block = blockList[i];
			if(block == this)continue;
			if(block.type != 'procedures_definition')continue;
			if(Blockly.Names.equals(block.getFieldValue('NAME'), name))return true;
		}
		return false;
	},
	_findLegalName(name){
		if(this.isInFlyout)return name;
		if(!name){
			name = Blockly.Msg['UNNAMED_KEY'] || 'unnamed';
		}
		while(this._isNameUsed(name)){
			let pattern = name.match(/^(.*?)(\d+)$/);
			if(pattern){
				name = pattern[1] + (parseInt(pattern[2], 10) + 1);
			}else{
				name += '2';
			}
		}
		return name;
	},
	_addArgInput(name){
		const input = this.appendValueInput(name).setCheck('Number');
		this.moveInputBefore(name, 'PARAMS');
		return input;
	},
	_addArg(name){
		const input = this._addArgInput(name);
		Blockly.Xml.domToBlock(
			Blockly.Xml.textToDom(`<block type="procedures_param"><field name="NAME">${name}</field></block>`),
			this.workspace
		).outputConnection.connect(input.connection);
		this._forEachCallDo(block => block._addArg(name));
	},
	_subArg(name){
		this.getInputTargetBlock(name).dispose();
		this.removeInput(name);
		this._forEachCallDo(block => block._subArg(name));
	},
	_forEachCallDo(fn){
		const blockName = this.getFieldValue('NAME');
		const blockList = this.workspace.getAllBlocks(false);
		for(let i=0; i < blockList.length; ++i){
			const block = blockList[i];
			if(block.type != 'procedures_call')continue;
			if(!Blockly.Names.equals(block.getFieldValue('NAME'), blockName))continue;
			fn(block);
		}
	}
}, function(){
	this.getField("NAME").setValidator(function(newName){
		newName = newName.trim();
		const legalName = this.getSourceBlock()._findLegalName(newName);
		const oldName = this.getValue();
		if(oldName != newName && oldName != legalName){
			this.getSourceBlock()._forEachCallDo(block => block.setFieldValue(legalName, 'NAME'));
		}
		return legalName;
	});
	this.getField("sub_btn").setOnClickHandler(function(){
		const block = this.getSourceBlock();
		const argList = block._getArgList();
		if(argList.length <= 0)return;
		block._subArg(argList.pop());
	});
	const specArgNames = ['PARAMS', 'OUTPUT', 'SUBSTACK'];
	this.getField("add_btn").setOnClickHandler(function(){
		const block = this.getSourceBlock();
		const argList = block._getArgList();

		function callback(name){
			if(!name)return;
			name = name.trim();
			if(argList.includes(name) || specArgNames.includes(name)){
				promptVarName("变量名重复,请重新命名!");
				return;
			}
			block._addArg(name);
		}

		const promptVarName = title => Blockly.prompt(title, String.fromCharCode(97 + argList.length), callback);
		promptVarName('变量名');
	});
});
Blockly.Extensions.registerMutator('procedures_call', {
	...procedures_mutator(inputList => inputList.slice(1), block => block.outputConnection != null),
	_updateShape(argList, hasOutput){
		for(let name of argList){
			this._addArgInput(name);
		}
		if(hasOutput){
			this.setPreviousStatement(false);
			this.setNextStatement(false);
			this.setOutput(true, 'Number');
		}
	},
	_addArgInput(name){
		return this.appendValueInput(name).appendField(name).setCheck('Number');
	},
	_addArg(name){
		this._addArgInput(name);
	},
	_subArg(name){
		this.removeInput(name);
	},
	onchange(evt){
		//Blockly.Workspace.getById(evt.workspaceId)
		if(!this.workspace || this.workspace.isFlyout)return;
		if(!evt.recordUndo)return;
		if(evt.type == Blockly.Events.BLOCK_DELETE){
			const name = this.getFieldValue('NAME');
			const topBlockList = this.workspace.getTopBlocks(false);
			const defineBlock = topBlockList.find(v => v.type == 'procedures_definition' && Blockly.Names.equals(v.getFieldValue('NAME'), name));
			if(!defineBlock){
				Blockly.Events.setGroup(evt.group);
				this.dispose(true);
				Blockly.Events.setGroup(false);
			}
		}
	}
});
Blockly.Extensions.registerMutator('procedures_ifreturn', {
	mutationToDom(){
		const container = Blockly.utils.xml.createElement('mutation');
		container.setAttribute('hasReturnValue', this._hasReturnValue());
		return container;
	},
	domToMutation(xmlElement){
		this._updateShape(xmlElement.getAttribute('hasReturnValue') == 'true');
	},
	_hasReturnValue(){
		return this.getInput('VALUE').type == Blockly.INPUT_VALUE;
	},
	_updateShape(hasReturnValue){
		if(hasReturnValue == this._hasReturnValue())return;
		this.removeInput('VALUE');
		const input = hasReturnValue ? this.appendValueInput('VALUE') : this.appendDummyInput('VALUE');
		input.appendField(Blockly.Msg['PROCEDURES_DEFRETURN_RETURN']);
	},
	onchange(){
		if(this.workspace.isDragging())return;
		let legal = false;
		let block = this;
		do{
			if(block.type == 'procedures_definition'){
				legal = true;
				break;
			}
			block = block.getSurroundParent();
		}while(block);
		if(legal){
			this._updateShape(block._hasOutput());
			this.setWarningText(null);
			if(!this.isInFlyout){
				this.setEnabled(true);
			}
		}else{
			this.setWarningText(Blockly.Msg['PROCEDURES_IFRETURN_WARNING']);
			if (!this.isInFlyout && !this.getInheritedDisabled()) {
				this.setEnabled(false);
			}
		}
	}
});
Blockly.Extensions.register('procedures_param', function(){
	this.setOnChange(function(evt){
		if(this.workspace.isDragging())return;
		const name = this.getFieldValue('NAME');
		let legal = false;
		let block = this;
		do{
			if(block.type == 'procedures_definition' && block._getArgList().includes(name)){
				legal = true;
				break;
			}
			block = block.getSurroundParent();
		}while(block);
		if(legal){
			this.setWarningText(null);
			this.setEnabled(true);
		}else{
			this.setWarningText(Blockly.Msg['PROCEDURES_IFRETURN_WARNING']);
			if(!this.getInheritedDisabled()) {
				this.setEnabled(false);
			}
			if(this.getParent()){
				this.unplug();
			}
		}
	});
});
function isParamDefineBlock(block){
	if(!block)return false;
	const parent = block.getParent();
	if(!parent)return false;
	return block.type == 'procedures_param' && parent.type == 'procedures_definition' && parent.getInputTargetBlock('OUTPUT') != block
}
overrideMethod(Blockly.Connection.prototype, 'isConnectionAllowed', oldFn => function(candidate){
	return oldFn.call(this, candidate) && !(
		candidate.type == Blockly.INPUT_VALUE
		&& candidate.targetConnection
		&& isParamDefineBlock(candidate.targetConnection.getSourceBlock())
	);
});
overrideMethod(Blockly.Gesture.prototype, 'startDraggingBlock_', oldFn => function(){
	let block = this.targetBlock_;
	if(isParamDefineBlock(block)){
		const root = Blockly.utils.xml.createElement('xml');
		root.appendChild(Blockly.Xml.blockToDomWithXY(block, true));
		const blockIds = Blockly.Xml.domToWorkspace(root, block.workspace);
		block.unselect();
		block = block.workspace.getBlockById(blockIds[0]);
		block.select();
		this.targetBlock_ = block;
	}
	oldFn.call(this);
});

void function(){
	const colours = {
		"motion": {
			"primary": "#4C97FF",
			"secondary": "#4280D7",
			"tertiary": "#3373CC"
		},
		"looks": {
			"primary": "#9966FF",
			"secondary": "#855CD6",
			"tertiary": "#774DCB"
		},
		"sounds": {
			"primary": "#CF63CF",
			"secondary": "#C94FC9",
			"tertiary": "#BD42BD"
		},
		"control": {
			"primary": "#FFAB19",
			"secondary": "#EC9C13",
			"tertiary": "#CF8B17"
		},
		"event": {
			"primary": "#FFBF00",
			"secondary": "#E6AC00",
			"tertiary": "#CC9900"
		},
		"sensing": {
			"primary": "#5CB1D6",
			"secondary": "#47A8D1",
			"tertiary": "#2E8EB8"
		},
		"pen": {
			"primary": "#0fBD8C",
			"secondary": "#0DA57A",
			"tertiary": "#0B8E69"
		},
		"operators": {
			"primary": "#59C059",
			"secondary": "#46B946",
			"tertiary": "#389438"
		},
		"data": {
			"primary": "#FF8C1A",
			"secondary": "#FF8000",
			"tertiary": "#DB6E00"
		},
		// This is not a new category, but rather for differentiation
		// between lists and scalar variables.
		"data_lists": {
			"primary": "#FF661A",
			"secondary": "#FF5500",
			"tertiary": "#E64D00"
		},
		"more": {
			"primary": "#FF6680",
			"secondary": "#FF4D6A",
			"tertiary": "#FF3355"
		},
		"text": "#575E75",
		"workspace": "#F9F9F9",
		"toolboxHover": "#4C97FF",
		"toolboxSelected": "#e9eef2",
		"toolboxText": "#575E75",
		"toolbox": "#FFFFFF",
		"flyout": "#F9F9F9",
		"scrollbar": "#CECDCE",
		"scrollbarHover": '#CECDCE',
		"textField": "#FFFFFF",
		"insertionMarker": "#000000",
		"insertionMarkerOpacity": 0.2,
		"dragShadowOpacity": 0.3,
		"stackGlow": "#FFF200",
		"stackGlowSize": 4,
		"stackGlowOpacity": 1,
		"replacementGlow": "#FFFFFF",
		"replacementGlowSize": 2,
		"replacementGlowOpacity": 1,
		"colourPickerStroke": "#FFFFFF",
		// CSS colours: support RGBA
		"fieldShadow": "rgba(0,0,0,0.1)",
		"dropDownShadow": "rgba(0, 0, 0, .3)",
		"numPadBackground": "#547AB2",
		"numPadBorder": "#435F91",
		"numPadActiveBackground": "#435F91",
		"numPadText": "white", // Do not use hex here, it cannot be inlined with data-uri SVG
		"valueReportBackground": "#FFFFFF",
		"valueReportBorder": "#AAAAAA"
	};

	function register_colour(name){
		Blockly.Extensions.register('colours_' + name, function(){
			const colour = colours[name];
			this.setColour(colour.primary, colour.secondary, colour.tertiary);
		});
	}
}


Blockly.Procedures.flyoutCategory = function(){
	const argFn = v => `<arg name="${v}"></arg>`;
	const mapFn = type => block =>
`<block type="${type}">
	<field name="NAME">${block.getFieldValue('NAME')}</field>
	<mutation hasOutput="${block._hasOutput()}">
		${block._getArgList().map(argFn).join('')}
	</mutation>
</block>`;
	const mapFn1 = mapFn('procedures_call');
	//const mapFn1 = mapFn('procedures_callnoreturn');
	//const mapFn2 = mapFn('procedures_callreturn');
	return function(workspace){
		const result = [
`<block type="procedures_definition"></block>`,
`<block type="procedures_definition">
	<mutation hasOutput="true">
	</mutation>
</block>`,
`<block type="procedures_ifreturn">
	<value name="CONDITION">
		<shadow type="logic_boolean"></shadow>
	</value>
	<value name="VALUE">
		<block type="math_number"></block>
	</value>
</block>`,
/*`<block type="procedures_defnoreturn">
	<field name="NAME">${Blockly.Msg['PROCEDURES_DEFNORETURN_PROCEDURE']}</field>
</block>`,
`<block type="procedures_defreturn">
	<field name="NAME">${Blockly.Msg['PROCEDURES_DEFRETURN_PROCEDURE']}</field>
</block>`,
`<block type="procedures_ifreturn"></block>`,
		...workspace.getBlocksByType('procedures_defnoreturn').map(mapFn1),
		...workspace.getBlocksByType('procedures_defreturn').map(mapFn2)*/
		...workspace.getBlocksByType('procedures_definition').map(mapFn1)
		];
		return result.map(Blockly.Xml.textToDom);
	}
}();

Blockly.Variables.flyoutCategory = function(){
	
	const variables_get = variable =>
		 `<block type="variables_get"><field name="VAR" id="${variable.getId()}" variabletype="${variable.type}">${variable.name}</field></block>`;
	return function(workspace){
		function registerButtonCallback(key, type){
			workspace.registerButtonCallback(key, function(button){
				Blockly.Variables.createVariableButtonHandler(button.getTargetWorkspace(), undefined, type);
			});
		}
	registerButtonCallback('CREATE_VARIABLE', '');
	registerButtonCallback('CREATE_VARIABLE_NUMBER', 'Number');
	registerButtonCallback('CREATE_VARIABLE_STRING', 'String');
	registerButtonCallback('CREATE_VARIABLE_BOOLEAN', 'Boolean');
	registerButtonCallback('CREATE_VARIABLE_ARRAY', 'Array');
	const result = [
		`<button text="创建数字变量" callbackKey="CREATE_VARIABLE_NUMBER"></button>`,
		`<button text="创建文本变量" callbackKey="CREATE_VARIABLE_STRING"></button>`,
		`<button text="创建布尔变量" callbackKey="CREATE_VARIABLE_BOOLEAN"></button>`,
		`<button text="创建列表变量" callbackKey="CREATE_VARIABLE_ARRAY"></button>`,
	];

	const varList = workspace.getAllVariables().filter(variable => variable.type !== 'Array');
	const numberVarList = varList.filter(variable => variable.type === '' || variable.type === 'Number');
	const arrayVarList = workspace.getVariablesOfType('Array');

	if(varList.length > 0){
		const mostRecentVariable = varList[varList.length - 1];
		result.push(
`<label text="变量"></label>`,
`<block type="variables_set">
	<field name="VAR" id="${mostRecentVariable.getId()}" variabletype="${mostRecentVariable.type}">${mostRecentVariable.name}</field>
</block>`,
	);
	}
	
	if(numberVarList.length > 0){
		const mostRecentVariable = numberVarList[numberVarList.length - 1];
		result.push(
`<block type="math_change">
	<field name="VAR" id="${mostRecentVariable.getId()}" variabletype="${mostRecentVariable.type}">${mostRecentVariable.name}</field>
	<value name="DELTA">
		<shadow type="math_number">
			<field name="NUM">1</field>
		</shadow>
	</value>
</block>`);
	}

	varList.sort(Blockly.VariableModel.compareByName);
	result.push(...varList.map(variables_get));

	if(arrayVarList.length > 0){
		result.push(
`<label text="列表"></label>`,
`<block type="lists_deletealloflist"></block>`,
`<block type="lists_addtolist">
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_deleteoflist">
	<value name="INDEX">
		<shadow type="math_lists_index">
			<field name="NUM">1</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_replaceitemoflist">
	<value name="INDEX">
		<shadow type="math_lists_index">
			<field name="NUM">1</field>
		</shadow>
	</value>
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_insertatlist">
	<value name="INDEX">
		<shadow type="math_lists_index">
			<field name="NUM">1</field>
		</shadow>
	</value>
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_itemoflist">
	<value name="INDEX">
		<shadow type="math_lists_index">
			<field name="NUM">1</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_indexOf">
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_length"></block>`,
`<block type="lists_listcontainsitem">
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
		);
	}
	return result.map(Blockly.Xml.textToDom);
}
}();
//--------------------

let div = document.createElement('div');
document.body.appendChild(div);

let workspace = Blockly.inject(div, {
	horizontalLayout: false,
	toolboxPosition: 'start',
	media: 'media/',
	toolbox:{'kind': "categoryToolbox", contents:[]},
	grid: {
		spacing: 20,
		length: 3,
		colour: '#ccc',
		snap: true
	},
	zoom: {
		controls: true,
		wheel: true,
		startScale: 1.0,
		maxScale: 1.2,
		minScale: 0.8,
	},
	trashcan: true,
});

workspace.addChangeListener(evt => alert('change'))

function handleMsg(handler){
	window.addEventListener('message', async evt => {
		const {type, data} = evt.data;
		evt.source.postMessage({type, data: await handler[type](data)});
	});
}

handleMsg({
	defineBlocks(value){
		Blockly.defineBlocksWithJsonArray(value);
	},
	updateToolbox(value){
		workspace.updateToolbox(value);
	},
	setTheme(value){
		workspace.setTheme(Blockly.Theme.defineTheme('scratch', value));
	},
	textToWorkspace(value){
		Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(value), workspace);
	},
	workspaceToDom(){
		return Blockly.Xml.domToText(Blockly.Xml.workspaceToDom(workspace));
	},
	/*getAllVariables(){
		return Array.from(workspace.variableMap_.getAllVariables(), ({name,type}) => ({name,type}));
	},*/
});
