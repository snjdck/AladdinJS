
'use strict';

Blockly.fieldRegistry.register('field_note', class extends Blockly.FieldNumber {
	static fromJson(options){
		return new this(options['note'] ?? 0, options);
	}

	constructor(opt_value, opt_validator){
		super(opt_value, null, null, null, null, opt_validator);
	}

	configure_(config){
		super.configure_(config);
		this.spellcheck_ = false;

		this.fieldEditorWidth_ = 0;
		this.fieldEditorHeight_ = 0;
		this.pianoSVG_ = null;
		this.keySVGs_ = [];
		this.noteNameText_ = null;
		this.lowCText_ = null;
		this.highCText_ = null;
		this.displayedOctave_ = null;
		this.animationPos_ = 0;
		this.animationTarget_ = 0;
		this.mouseIsDown_ = false;
		this.mouseDownWrappers_ = [];
		this.mouseUpWrapper_ = null;
		this.mouseEnterWrappers_ = [];
		this.octaveDownMouseDownWrapper_ = null;
		this.octaveUpMouseDownWrapper_ = null;

		this.NOTE_LIST = [
		33, 35, 37, 39, 41, 44, 46, 49, 52, 55, 58, 62,
		65, 69, 73, 78, 82, 87, 93, 98, 104, 110, 117, 123,
		131, 139, 147, 156, 165, 175, 185, 196, 208, 220, 233, 247,
		262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494,
		523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988,
		1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976,
		2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,
		4186, 4435, 4699, 4978
		];

		this.INSET = 5;
		this.TOP_MENU_HEIGHT = 32 - this.INSET;
		this.EDGE_PADDING = 1;
		this.SHADOW_HEIGHT = 4;
		this.SHADOW_COLOR = '#000';
		this.SHADOW_OPACITY = 0.2;
		this.WHITE_KEY_COLOR = '#FFFFFF';
		this.BLACK_KEY_COLOR = '#323133';
		this.BLACK_KEY_STROKE = '#555555';
		this.KEY_SELECTED_COLOR = '#b0d6ff';
		this.NUM_WHITE_KEYS = 8;
		this.WHITE_KEY_HEIGHT = 72;
		this.WHITE_KEY_WIDTH = 40;
		this.BLACK_KEY_HEIGHT = 40;
		this.BLACK_KEY_WIDTH = 32;
		this.KEY_RADIUS = 6;
		this.KEY_LABEL_PADDING = 8;
		this.KEY_INFO = [
			{name: 'C', pitch: 0},
			{name: 'C♯', pitch: 1, isBlack: true},
			{name: 'D', pitch: 2},
			{name: 'E♭', pitch: 3, isBlack: true},
			{name: 'E', pitch: 4},
			{name: 'F', pitch: 5},
			{name: 'F♯', pitch: 6, isBlack: true},
			{name: 'G', pitch: 7},
			{name: 'G♯', pitch: 8, isBlack: true},
			{name: 'A', pitch: 9},
			{name: 'B♭', pitch: 10, isBlack: true},
			{name: 'B', pitch: 11},
			{name: 'C', pitch: 12}
		];
		this.MAX_NOTE = this.NOTE_LIST.length - 1;
		this.ANIMATION_FRACTION = 0.2;
		this.ARROW_SVG_PATH = 'icons/arrow_button.svg';
		this.OCTAVE_BUTTON_SIZE = 32;
	}

	widgetCreate_(){
		const htmlInput = super.widgetCreate_();
		//htmlInput.setAttribute('readonly', 'true');
		htmlInput.setAttribute('type', 'number');
		return htmlInput;
	}

	updateSize_(){
		super.updateSize_(16);
	}

	showInlineEditor_() {
		super.showInlineEditor_(true);
		this.workspace_ = this.sourceBlock_.workspace;

		// If there is an existing drop-down someone else owns, hide it immediately and clear it.
		Blockly.DropDownDiv.hideWithoutAnimation();
		Blockly.DropDownDiv.clearContent();

		// Build the SVG DOM.
		var div = Blockly.DropDownDiv.getContentDiv();

		this.fieldEditorWidth_ = this.NUM_WHITE_KEYS * this.WHITE_KEY_WIDTH + this.EDGE_PADDING;
		this.fieldEditorHeight_ = this.TOP_MENU_HEIGHT + this.WHITE_KEY_HEIGHT + this.EDGE_PADDING;

		var svg = Blockly.utils.dom.createSvgElement('svg', {
			'xmlns': 'http://www.w3.org/2000/svg',
			'xmlns:html': 'http://www.w3.org/1999/xhtml',
			'xmlns:xlink': 'http://www.w3.org/1999/xlink',
			'version': '1.1',
			'height': this.fieldEditorHeight_ + 'px',
			'width': this.fieldEditorWidth_ + 'px'
		}, div);

		// Add the white and black keys
		// Since we are adding the keys from left to right in order, they need
		// to be in two groups in order to layer correctly.
		this.pianoSVG_ = Blockly.utils.dom.createSvgElement('g', {}, svg);
		var whiteKeyGroup = Blockly.utils.dom.createSvgElement('g', {}, this.pianoSVG_);
		var blackKeyGroup = Blockly.utils.dom.createSvgElement('g', {}, this.pianoSVG_);

		// Add three piano octaves, so we can animate moving up or down an octave.
		// Only the middle octave gets bound to events.
		this.keySVGs_ = [];
		this.addPianoOctave_(-this.fieldEditorWidth_ + this.EDGE_PADDING,
				whiteKeyGroup, blackKeyGroup, null);
		this.addPianoOctave_(0, whiteKeyGroup, blackKeyGroup, this.keySVGs_);
		this.addPianoOctave_(this.fieldEditorWidth_ - this.EDGE_PADDING,
				whiteKeyGroup, blackKeyGroup, null);

		// Note name indicator at the top of the field
		this.noteNameText_ = Blockly.utils.dom.createSvgElement('text',
				{
					'x': this.fieldEditorWidth_ / 2,
					'y': this.TOP_MENU_HEIGHT / 2,
					'class': 'blocklyText',
					'text-anchor': 'middle',
					'dominant-baseline': 'middle',
				}, svg);

		// Note names on the low and high C keys
		var lowCX = this.WHITE_KEY_WIDTH / 2;
		this.lowCText_ = this.addCKeyLabel_(lowCX, svg);
		var highCX = lowCX + (this.WHITE_KEY_WIDTH *
			(this.NUM_WHITE_KEYS - 1));
		this.highCText_ = this.addCKeyLabel_(highCX, svg);

		// Horizontal line at the top of the keys
		Blockly.utils.dom.createSvgElement('line',
				{
					'stroke': this.sourceBlock_.getColourTertiary(),
					'x1': 0,
					'y1': this.TOP_MENU_HEIGHT,
					'x2': this.fieldEditorWidth_,
					'y2': this.TOP_MENU_HEIGHT
				}, svg);

		// Drop shadow at the top of the keys
		Blockly.utils.dom.createSvgElement('rect',
				{
					'x': 0,
					'y': this.TOP_MENU_HEIGHT,
					'width': this.fieldEditorWidth_,
					'height': this.SHADOW_HEIGHT,
					'fill': this.SHADOW_COLOR,
					'fill-opacity': this.SHADOW_OPACITY
				}, svg);

		// Octave buttons
		this.octaveDownButton = this.addOctaveButton_(0, true, svg);
		this.octaveUpButton = this.addOctaveButton_(
				(this.fieldEditorWidth_ + this.INSET * 2) -
				this.OCTAVE_BUTTON_SIZE, false, svg);

		this.octaveDownMouseDownWrapper_ =
			Blockly.browserEvents.bind(this.octaveDownButton, 'mousedown', this, function() {
				this.changeOctaveBy_(-1);
			});
		this.octaveUpMouseDownWrapper_ =
				Blockly.browserEvents.bind(this.octaveUpButton, 'mousedown', this,function() {
					this.changeOctaveBy_(1);
				});
		Blockly.DropDownDiv.setColour(this.sourceBlock_.getColour(),
				this.sourceBlock_.getColourTertiary());
		//Blockly.DropDownDiv.setCategory(this.sourceBlock_.getCategory());
		Blockly.DropDownDiv.showPositionedByField(this);

		this.updateSelection_();
	}

	addPianoOctave_(x, whiteKeyGroup, blackKeyGroup, keySVGarray) {
		var xIncrement, width, height, fill, stroke, group;
		x += this.EDGE_PADDING / 2;
		var y = this.TOP_MENU_HEIGHT;
		for (var i = 0; i < this.KEY_INFO.length; i++) {
			// Draw a black or white key
			if (this.KEY_INFO[i].isBlack) {
				// Black keys are shifted back half a key
				x -= this.BLACK_KEY_WIDTH / 2;
				xIncrement = this.BLACK_KEY_WIDTH / 2;
				width = this.BLACK_KEY_WIDTH;
				height = this.BLACK_KEY_HEIGHT;
				fill = this.BLACK_KEY_COLOR;
				stroke = this.BLACK_KEY_STROKE;
				group = blackKeyGroup;
			} else {
				xIncrement = this.WHITE_KEY_WIDTH;
				width = this.WHITE_KEY_WIDTH;
				height = this.WHITE_KEY_HEIGHT;
				fill = this.WHITE_KEY_COLOR;
				stroke = this.sourceBlock_.getColourTertiary();
				group = whiteKeyGroup;
			}
			var attr = {
				'd': this.getPianoKeyPath_(x, y, width, height),
				'fill': fill,
				'stroke': stroke
			};
			x += xIncrement;

			var keySVG = Blockly.utils.dom.createSvgElement('path', attr, group);

			if (keySVGarray) {
				keySVGarray[i] = keySVG;
				keySVG.setAttribute('data-pitch', this.KEY_INFO[i].pitch);
				keySVG.setAttribute('data-name', this.KEY_INFO[i].name);
				keySVG.setAttribute('data-isBlack', this.KEY_INFO[i].isBlack);

				this.mouseDownWrappers_[i] =
						Blockly.browserEvents.bind(keySVG, 'mousedown', this, this.onMouseDownOnKey_);
				this.mouseEnterWrappers_[i] =
						Blockly.browserEvents.bind(keySVG, 'mouseenter', this, this.onMouseEnter_);
			}
		}
	}
	getPianoKeyPath_(x, y, width, height) {
		return  'M' + x + ' ' + y + ' ' +
			'L' + x + ' ' + (y + height -  this.KEY_RADIUS) + ' ' +
			'Q' + x + ' ' + (y + height) + ' ' +
			(x + this.KEY_RADIUS) + ' ' + (y + height) + ' ' +
			'L' + (x + width - this.KEY_RADIUS) + ' ' + (y + height) + ' ' +
			'Q' + (x + width) + ' ' + (y + height) + ' ' +
			(x + width) + ' ' + (y + height - this.KEY_RADIUS) + ' ' +
			'L' + (x + width) + ' ' + y + ' ' +
			'L' + x +  ' ' + y;
	}
	addOctaveButton_(x, flipped, svg) {
		var group = Blockly.utils.dom.createSvgElement('g', {}, svg);
		var imageSize = this.OCTAVE_BUTTON_SIZE;
		var arrow = Blockly.utils.dom.createSvgElement('image',
				{
					'width': imageSize,
					'height': imageSize,
					'x': x - this.INSET,
					'y': -1 * this.INSET
				}, group);
		arrow.setAttributeNS(
				'http://www.w3.org/1999/xlink',
				'xlink:href',
				Blockly.mainWorkspace.options.pathToMedia + this.ARROW_SVG_PATH
		);
		Blockly.utils.dom.createSvgElement('line',
				{
					'stroke': this.sourceBlock_.getColourTertiary(),
					'x1': x - this.INSET,
					'y1': 0,
					'x2': x - this.INSET,
					'y2': this.TOP_MENU_HEIGHT - this.INSET
				}, group);
		if (flipped) {
			var translateX = -1 * this.OCTAVE_BUTTON_SIZE + (this.INSET * 2);
			group.setAttribute('transform', 'scale(-1, 1) ' +
				'translate(' + translateX + ', 0)');
		}
		return group;
	}
	addCKeyLabel_(x, svg){
		let y = this.TOP_MENU_HEIGHT + this.WHITE_KEY_HEIGHT - this.KEY_LABEL_PADDING;
		return Blockly.utils.dom.createSvgElement('text', {x, y, 'class': 'scratchNotePickerKeyLabel', 'text-anchor': 'middle'}, svg);
	}
	setCKeyLabelsVisible_(visible) {
		let value = visible ? 1 : 0;
		this.fadeSvgToOpacity_(this.lowCText_, value);
		this.fadeSvgToOpacity_(this.highCText_, value);
	}
	fadeSvgToOpacity_(svg, opacity) {
		svg.setAttribute('style', `opacity: ${opacity}; transition: opacity 0.1s;`);
	}
	onMouseDownOnKey_(e) {
		this.mouseIsDown_ = true;
		this.mouseUpWrapper_ = Blockly.browserEvents.bind(document.body, 'mouseup', this, this.onMouseUp_);
		this.selectNoteWithMouseEvent_(e);
	}
	onMouseUp_() {
		this.mouseIsDown_ = false;
		Blockly.browserEvents.unbind(this.mouseUpWrapper_);
	}
	onMouseEnter_(e) {
		if (this.mouseIsDown_) {
			this.selectNoteWithMouseEvent_(e);
		}
	}
	selectNoteWithMouseEvent_(e) {
		var newNoteNum = Number(e.target.getAttribute('data-pitch')) + this.displayedOctave_ * 12;
		this.setNoteNum_(newNoteNum);
		this.playNoteInternal_();
	}
	playNoteInternal_ () {
			this.playNote_?.(this.getValue());
	}
	changeOctaveBy_(octaves) {
		this.displayedOctave_ += octaves;
		if (this.displayedOctave_ < 0) {
			this.displayedOctave_ = 0;
			return;
		}
		var maxOctave = Math.floor(this.MAX_NOTE / 12);
		if (this.displayedOctave_ > maxOctave) {
			this.displayedOctave_ = maxOctave;
			return;
		}

		var newNote = this.NOTE_LIST.indexOf(Number(this.getText())) + (octaves * 12);
		this.setNoteNum_(newNote);

		this.animationTarget_ = this.fieldEditorWidth_ * octaves * -1;
		this.animationPos_ = 0;
		this.stepOctaveAnimation_();
		this.setCKeyLabelsVisible_(false);
	}
	stepOctaveAnimation_() {
		var absDiff = Math.abs(this.animationPos_ - this.animationTarget_);
		if (absDiff < 1) {
			this.pianoSVG_.setAttribute('transform', 'translate(0, 0)');
			this.setCKeyLabelsVisible_(true);
			this.playNoteInternal_();
			return;
		}
		this.animationPos_ += (this.animationTarget_ - this.animationPos_) *
			this.ANIMATION_FRACTION;
		this.pianoSVG_.setAttribute('transform', 'translate(' + this.animationPos_ + ',0)');
		requestAnimationFrame(this.stepOctaveAnimation_.bind(this));
	}

	setNoteNum_(noteNum) {
		noteNum = this.doClassValidation_(noteNum);
		let value = this.NOTE_LIST[noteNum];
		this.htmlInput_.value = value;
		this.setValue(value);
		this.updateSelection_();
	}

	noteNumToKeyIndex_(noteNum) {
		return Math.floor(noteNum) - (this.displayedOctave_ * 12);
	}

	updateSelection_() {
		var noteNum = this.NOTE_LIST.indexOf(Number(this.getText()));

		// If the note is outside the currently displayed octave, update it
		if (this.displayedOctave_ == null ||
				noteNum > ((this.displayedOctave_ * 12) + 12) ||
				noteNum < (this.displayedOctave_ * 12)) {
			this.displayedOctave_ = Math.floor(noteNum / 12);
		}

		var index = this.noteNumToKeyIndex_(noteNum);

		// Clear the highlight on all keys
		this.keySVGs_.forEach(svg => {
			var isBlack = svg.getAttribute('data-isBlack');
			if (isBlack === 'true') {
				svg.setAttribute('fill', this.BLACK_KEY_COLOR);
			} else {
				svg.setAttribute('fill', this.WHITE_KEY_COLOR);
			}
		});
		// Set the highlight on the selected key
		if (this.keySVGs_[index]) {
			this.keySVGs_[index].setAttribute('fill', this.KEY_SELECTED_COLOR);
			// Update the note name text
			var noteName =  this.KEY_INFO[index].name;
			this.noteNameText_.textContent = noteName + ' (' + (this.displayedOctave_ + 1) + ')';
			// Update the low and high C note names
			//var lowCNum = this.displayedOctave_ * 12;
			this.lowCText_.textContent = 'C(' + (this.displayedOctave_ + 1) + ')';
			this.highCText_.textContent = 'C(' + (this.displayedOctave_ + 2) + ')';
		}
	}
})
