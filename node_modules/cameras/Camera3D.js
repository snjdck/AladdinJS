"use strict";

const DisplayObject3D = require("../DisplayObject3D");
const DrawUnitCollector = require("../DrawUnitCollector");
const {DepthRenderTarget} = require("../rendertargets");
const {DepthMaterial} = require("../materials");
const {QuadVertexArray} = require("../vertexarrays");
const Lens = require("./Lens");
const Matrix3D = require("../Matrix3D");

const depthMaterial = new DepthMaterial();
function castToDepthDrawUnit(drawUnit){
	let clone = Object.create(drawUnit);
	clone.material = depthMaterial;
	return clone;
}

const vao = QuadVertexArray.new();

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.drawUnitCollector = new DrawUnitCollector();
		this.lens = lens;
		//camera can render to back buffer or frame buffer
		this.randerTarget = null;
		//multi cameras render order control
		this.depth = 0;
	}

	drawDepthBuffer(gl, drawUnitList){
		if(!this.geomRenderTarget){
			this.geomRenderTarget = new DepthRenderTarget(gl.render2d.width, gl.render2d.height);
		}
		this.geomRenderTarget.active(gl);
		gl.clearColor(0, 0, 0, 0);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.renderQueue.draw(this, drawUnitList);
	}

	render(root, gl, mode){
		let {drawUnitCollector} = this;
		let {drawUnitList, lightList} = drawUnitCollector;
		drawUnitCollector.clear();
		root.collectDrawUnits(drawUnitCollector, gl, mode);

		if(mode == "pick"){
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		if(lightList.length <= 0){//no lights
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		let shadowDrawUnitList = drawUnitList.filter(drawUnit => drawUnit.castShadow);
		if(shadowDrawUnitList.length <= 0){//no object cast shadows
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		shadowDrawUnitList = shadowDrawUnitList.map(castToDepthDrawUnit);
		gl.renderStateStack.save(gl.VIEWPORT, gl.FRAMEBUFFER_BINDING);
		lightList.forEach(light => light.drawShadowMap(gl, shadowDrawUnitList));
		gl.renderStateStack.load(gl.VIEWPORT);

		if(!lightList.some(light => light.hasShadows)){//no shadow cast in light's area
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		this.drawDepthBuffer(gl, drawUnitList);

		gl.renderStateStack.load(gl.FRAMEBUFFER_BINDING);
		gl.renderQueue.draw(this, drawUnitList);

		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.depthBuffer);
		
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.DST_COLOR, gl.ZERO);
		gl.disable(gl.DEPTH_TEST);
		let program = gl.programMgr.fetch("screen&shadow");
		gl.useProgram(program);
		gl.uniform1i(gl.getUniformLocation(program, "sampler0"), 0);
		gl.uniform1i(gl.getUniformLocation(program, "sampler1"), 1);
		gl.uniformMatrix4fv(gl.getUniformLocation(program, "screenMatrix1"), false, Lens.Invert(this.lens));
		gl.activeTexture(gl.TEXTURE1);
		vao.active(gl);
		for(let light of lightList){
			if(!light.hasShadows)continue;
			gl.uniformMatrix4fv(gl.getUniformLocation(program, "screenMatrix2"), false, light.camera.lens);
			this.worldTransform.append(light.camera.worldTransformInvert, matrix);
			matrix.upload(gl, gl.getUniformLocation(program, "cameraMatrix"));
			gl.bindTexture(gl.TEXTURE_2D, light.shadowRenderTarget.depthBuffer);
			vao.draw(gl);
		}
		
		gl.activeTexture(gl.TEXTURE0);
	}
}

const matrix = new Matrix3D();

module.exports = Camera3D;