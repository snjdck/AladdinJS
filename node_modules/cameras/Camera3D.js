"use strict";

const DisplayObject3D = require("../DisplayObject3D");
const DrawUnitCollector = require("../DrawUnitCollector");
const {ScreenRenderTarget, DepthRenderTarget} = require("../rendertargets");
const {DepthMaterial} = require("../materials");
const {UniformBuffer} = require("../uniformbuffers");

const depthMaterial = new DepthMaterial();
function castToDepthDrawUnit(drawUnit){
	let clone = Object.create(drawUnit);
	clone.material = depthMaterial;
	return clone;
}

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.drawUnitCollector = new DrawUnitCollector();
		this.lens = lens;
		//camera can render to back buffer or frame buffer
		this.randerTarget = null;
		//multi cameras render order control
		this.depth = 0;
		this.uniformBuffer = new UniformBuffer(4, 8, 128);
	}

	drawDepthBuffer(gl, drawUnitList){
		if(!this.geomRenderTarget){
			this.geomRenderTarget = new ScreenRenderTarget(gl.render2d.width, gl.render2d.height);
		}
		this.geomRenderTarget.active(gl);
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.renderQueue.draw(this, drawUnitList);
	}

	render(root, gl, mode){
		let {drawUnitCollector, uniformBuffer} = this;
		let {drawUnitList, lightList} = drawUnitCollector;
		drawUnitCollector.clear();
		root.collectDrawUnits(drawUnitCollector, gl, mode);

		if(mode == "pick"){
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		if(lightList.length <= 0){//no lights
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		let shadowDrawUnitList = drawUnitList.filter(drawUnit => drawUnit.castShadow);
		if(shadowDrawUnitList.length <= 0){//no object cast shadows
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		shadowDrawUnitList = shadowDrawUnitList.map(castToDepthDrawUnit);
		gl.renderStateStack.save(gl.VIEWPORT, gl.FRAMEBUFFER_BINDING);
		lightList.forEach(light => light.drawShadowMap(gl, shadowDrawUnitList));
		gl.renderStateStack.load(gl.VIEWPORT);

		if(!lightList.some(light => light.hasShadows)){//no shadow cast in light's area
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		this.drawDepthBuffer(gl, drawUnitList);

		gl.renderStateStack.load(gl.FRAMEBUFFER_BINDING);

		gl.disable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);
		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.colorBuffer);
		gl.useProgram(gl.programMgr.fetch("screen&normal"));
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.depthBuffer);
		gl.activeTexture(gl.TEXTURE0);

		gl.enable(gl.BLEND);
		gl.blendFunc(gl.DST_COLOR, gl.ZERO);
		let program = gl.programMgr.fetch("shadow/");
		gl.useProgram(program);
		gl.uniform1i(gl.getUniformLocation(program, "sampler0"), 1);
		this.worldTransform.copyToArray(uniformBuffer.floatView, 16);
		uniformBuffer.setFloatv(0, this.lens);
		uniformBuffer.active(gl);
		for(let light of lightList){
			if(!light.hasShadows)continue;
			light.camera.worldTransformInvert.copyToArray(uniformBuffer.floatView, 24);
			uniformBuffer.setFloatv(32, light.camera.lens);
			uniformBuffer.upload(gl);
			gl.bindTexture(gl.TEXTURE_2D, light.shadowRenderTarget.depthBuffer);
			gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
		}
	}
}

module.exports = Camera3D;