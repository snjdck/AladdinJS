"use strict";

const DisplayObject3D = require("../DisplayObject3D");
const DrawUnitCollector = require("../DrawUnitCollector");
const {ScreenRenderTarget, DepthRenderTarget} = require("../rendertargets");
const {UniformBuffer} = require("../uniformbuffers");
const {RenderState, DrawMode} = require("../renderers");
const {ShadowProgram} = require("../programs");

class Camera3D extends DisplayObject3D
{
	constructor(lens){
		super();
		this.drawUnitCollector = new DrawUnitCollector();
		this.lens = lens;
		this.shadowProgram = ShadowProgram.new();
		//camera can render to back buffer or frame buffer
		this.randerTarget = null;
		//multi cameras render order control
		this.depth = 0;
		this.uniformBuffer = new UniformBuffer(4, 8, 128);
	}

	drawDepthBuffer(gl, drawUnitList){
		if(!this.geomRenderTarget){
			this.geomRenderTarget = new ScreenRenderTarget(gl.render2d.width, gl.render2d.height);
		}
		this.geomRenderTarget.active(gl);
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.renderQueue.draw(this, drawUnitList);
	}

	render(root, gl, mode){
		let {drawUnitCollector, uniformBuffer} = this;
		let {drawUnitList, lightList} = drawUnitCollector;
		drawUnitCollector.clear();
		root.collectDrawUnits(drawUnitCollector, gl, mode);

		if(lightList.length <= 0){//no lights
			gl.renderQueue.draw(this, drawUnitList);
			return;
		}

		gl.renderStateStack.save(gl.VIEWPORT, gl.FRAMEBUFFER_BINDING);
		lightList.forEach(light => light.drawShadowMap(gl, root));

		gl.renderStateStack.load(gl.VIEWPORT);
		this.drawDepthBuffer(gl, drawUnitList);

		gl.renderStateStack.load(gl.FRAMEBUFFER_BINDING);

		gl.applyRenderState(RenderState.Pick2D);
		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.colorBuffer);
		gl.useProgram(gl.programMgr.fetch("screen&normal"));
		gl.render.drawScreen();

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.geomRenderTarget.depthBuffer);
		gl.activeTexture(gl.TEXTURE0);

		gl.applyRenderState(RenderState.Shadow);
		this.shadowProgram.active(gl);
		this.worldTransform.copyToArray(uniformBuffer.floatView, 16);
		uniformBuffer.setFloatv(0, this.lens);
		uniformBuffer.active(gl);
		for(let light of lightList){
			light.camera.worldTransformInvert.copyToArray(uniformBuffer.floatView, 24);
			uniformBuffer.setFloatv(32, light.camera.lens);
			uniformBuffer.upload(gl);
			gl.bindTexture(gl.TEXTURE_2D, light.shadowRenderTarget.depthBuffer);
			gl.render.drawScreen();
		}
	}
}

module.exports = Camera3D;