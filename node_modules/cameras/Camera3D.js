"use strict";

class Camera3D
{
	constructor(view3d){
		const {canvas, gl} = view3d;

		//store model world space XYZ
		this.geomColorBuffer = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.geomColorBuffer);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB32F, canvas.width, canvas.height, 0, gl.RGB, gl.FLOAT, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		this.geomDepthBuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, this.geomDepthBuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT24, canvas.width, canvas.height);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);

		this.frameBuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.geomColorBuffer, 0);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.geomDepthBuffer);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	}

	draw(){
		const lightCount = this.getLightCount();
		if(lightCount <= 0){
			return;
		}

		for(let lightIndex=0; lightIndex<lightCount; ++lightIndex){
			let light = this.lightList[lightIndex];
			light.drawShadowMap();
		}

		gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

		gl.clearColor(0, 0, 0, 0);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		//draw

		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		gl.bindTexture(gl.TEXTURE_2D, this.geomColorBuffer);
		//blend MULTIPLY

		for(let lightIndex=0; lightIndex<lightCount; ++lightIndex){
			let light = this.lightList[lightIndex];
			light.drawLight();
		}
	}
}

module.exports = Camera3D;