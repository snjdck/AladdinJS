//import Blockly from 'scratch-blocks';
//import VirtualMachine from 'scratch-vm';
import Runtime from 'scratch-vm/src/engine/runtime';
import wrapFn from 'utils/function/overrideMethod';
import * as primitives from './main/robots/primitives/Primitives2';

const threadList = [];
requestAnimationFrame(function(){
	const finishThreads = [];
	const reviveThreads = [];
	return function loop(timestamp){
		requestAnimationFrame(loop);
		const timeEnd = timestamp + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === context.yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === context.yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === context.suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				threadList.splice(threadList.indexOf(thread), 1);
				console.log('thread done!', thread.returnValue);
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

const quote = (regExp => v => `'${v.replace(regExp, "\\'")}'`)(/'/g);
const isVarName = (regExp => name => regExp.test(name))(/^[a-z_A-Z]\w*$/);
//const control_wait = seconds => new Promise(resolve => setTimeout(resolve, seconds * 1000));
//const nextFrame = () => new Promise(resolve => requestAnimationFrame(resolve));

function* control_wait(seconds){
	const timestamp = performance.now() + seconds * 1000;
	while(performance.now() < timestamp){
		yield this.yieldOneTickFlag;
	}
}

const castVarName = v => '_' + v.replace(/\W/g, c => c.charCodeAt().toString(36));
const genReturnCode = list => 'return {' + list.join() + '};';
const insertYieldFlag = (tab, code='') => `{\n${tab+'\t'}yield context.yieldFlag\n${code}${tab}}`;

const castBlockToCode = function(){
	const stringFileds = {
		'motion_goto_menu': 'TO',
		'motion_glideto_menu': 'TO',
		'motion_pointtowards_menu': 'TOWARDS',
		'looks_costume': 'COSTUME',
		'looks_backdrops': 'BACKDROP',
		'sound_sounds_menu': 'SOUND_MENU',
		'sensing_touchingobjectmenu': 'TOUCHINGOBJECTMENU',
		'sensing_distancetomenu': 'DISTANCETOMENU',
		'sensing_keyoptions': 'KEY_OPTION',
		'sensing_of_object_menu': 'OBJECT',
		'control_create_clone_of_menu': 'CLONE_OPTION',
		'event_broadcast_menu': 'BROADCAST_OPTION',
	};
	const numberFields = {
		'math_whole_number': 'NUM',
		'math_positive_number': 'NUM',
		'math_integer': 'NUM',
		'math_number': 'NUM',
		'math_angle': 'NUM',
	};
	const argFields = [
		'argument_reporter_string_number',
		'argument_reporter_boolean',
	];
	return function(blocks, blockID, offset=0){
		if(!blockID)return '';
		const tab = '\t'.repeat(offset);
		let block = blocks.getBlock(blockID);
		//console.log(block)
		let {opcode} = block;

		if(opcode in stringFileds)
			return quote(block.fields[stringFileds[opcode]].value);

		if(opcode in numberFields)
			return block.fields[numberFields[opcode]].value || 0;

		if(argFields.includes(opcode))
			return castVarName(block.fields.VALUE.value);

		if(opcode == 'procedures_definition'){
			block = blocks.getBlock(block.inputs.custom_block.block);
			let argNames = JSON.parse(block.mutation.argumentnames).map(castVarName).join();
			let nextBlockID = blocks.getNextBlock(blockID);
			let code = nextBlockID ? castBlockToCodeList(blocks, nextBlockID) : '';
			return `function* ${castVarName(block.mutation.proccode)}(${argNames}){\n${code}}\n`;
		}

		if(opcode == 'procedures_call'){
			let args = JSON.parse(block.mutation.argumentids).map(v => {
				let input = block.inputs[v];
				return input ? castBlockToCode(blocks, input.block) : 0;
			}).join();
			return tab + `yield* ${castVarName(block.mutation.proccode)}(${args})`;
		}
		
		let args = Object.create(null);
		
		for(let field of Object.values(block.fields)){
			let data;
			if(field.name == 'VARIABLE' || field.name == 'LIST'){
				data = `{id:'${field.id}',name:'${field.value}'}`;
			}else{
				data = quote(field.value);
			}
			args[field.name] = data;
		}

		for(let input of Object.values(block.inputs)){
			args[input.name] = castBlockToCode(blocks, input.block);
		}

		const keyList = Object.keys(args);
		if(keyList.length == 1){
			let key = keyList[0];
			if(opcode.endsWith(key) || opcode.toUpperCase() == key){
				return args[key];
			}
		}

		if(opcode == 'control_wait'){
			return tab + `yield* context.control_wait(${args.DURATION})`;
		}

		if(opcode == 'control_repeat'){
			let subBlock = block.inputs.SUBSTACK && block.inputs.SUBSTACK.block;
			if(!subBlock){
				return `${tab}void(${args.TIMES})`;
			}
			let code = castBlockToCodeList(blocks, block.inputs.SUBSTACK.block, offset+1);
			return tab + `for(let i=${args.TIMES};i>0;--i)` + insertYieldFlag(tab, code);
		}

		if(opcode == 'control_repeat_until'){
			let subBlock = block.inputs.SUBSTACK && block.inputs.SUBSTACK.block;
			if(!subBlock){
				opcode = 'control_wait_until';
			}else if(!args.CONDITION){
				opcode = 'control_forever';
			}else{
				let code = castBlockToCodeList(blocks, subBlock, offset+1);
				return tab + `while(!(${args.CONDITION}))` + insertYieldFlag(tab, code);
			}
		}

		if(opcode == 'control_wait_until'){
			if(!args.CONDITION){
				return tab + 'yield context.suspendFlag';
			}
			return tab + `while(!(${args.CONDITION}))` + insertYieldFlag(tab);
		}

		if(opcode == 'control_forever'){
			let subBlock = block.inputs.SUBSTACK && block.inputs.SUBSTACK.block;
			if(!subBlock){
				return tab + 'yield context.suspendFlag';
			}
			let code = castBlockToCodeList(blocks, subBlock, offset+1);
			return tab + `for(;;)` + insertYieldFlag(tab, code);
		}

		if(opcode == 'control_if'){
			if(!args.CONDITION){
				return tab + '//pass control_if';
			}
			let subBlock = block.inputs.SUBSTACK && block.inputs.SUBSTACK.block;
			if(!subBlock){
				return `${tab}void(${args.CONDITION})`;
			}
			let code = castBlockToCodeList(blocks, subBlock, offset+1);
			return `${tab}if(${args.CONDITION}){\n${code}${tab}}`;
		}

		if(opcode == 'control_if_else'){
			if(!args.CONDITION){
				args.CONDITION = false;
			}
			let subBlock1 = block.inputs.SUBSTACK && block.inputs.SUBSTACK.block;
			let subBlock2 = block.inputs.SUBSTACK2 && block.inputs.SUBSTACK2.block;
			let code1 = subBlock1 ? castBlockToCodeList(blocks, subBlock1, offset+1) : '';
			let code2 = subBlock2 ? castBlockToCodeList(blocks, subBlock2, offset+1) : '';
			return `${tab}if(${args.CONDITION}){\n${code1}${tab}}else{\n${code2}${tab}}`
		}

		args = Object.entries(args).map(([k, v]) => (isVarName(k) ? k : quote(k)) + ':' + v).join();
		opcode = isVarName(opcode) ? '.' + opcode : `['${opcode}']`;
		return tab + `yield context${opcode}({${args}},util)`;
	}
}();

function castBlockToCodeList(blocks, blockID, offset=1){
	let result = [];
	while(blockID){
		result.push(castBlockToCode(blocks, blockID, offset));
		blockID = blocks.getNextBlock(blockID);
	}
	return result.map(v => v + '\n').join('');
}

wrapFn(Runtime.prototype, 'toggleScript', oldFn => function(blockID, option){
	//return oldFn.call(this, blockID, option);
	//let code = Blockly.JavaScript.workspaceToCode(Blockly.getMainWorkspace());
	//console.log(code);
	const targets = this.targets.filter(target => target.isOriginal);
	if(!targets.some(({blocks}) => blocks.getScripts().filter(blockID => !blocks.getBlock(blockID).shadow).includes(blockID))){
		return;
	}
	
	let code = genReturnCode(targets.map(({id, blocks}) => {
		let scripts = blocks.getScripts().filter(blockID => !blocks.getBlock(blockID).shadow);
		let result = [];
		for(let blockID of scripts){
			let block = blocks.getBlock(blockID);
			if(block.opcode == 'procedures_definition')continue;
			result.push(`*['${blockID}'](){\n` + castBlockToCodeList(blocks, blockID) + '}');
		}
		result = genReturnCode(result);
		for(let blockID of scripts){
			let block = blocks.getBlock(blockID);
			if(block.opcode != 'procedures_definition')continue;
			result = castBlockToCode(blocks, blockID) + result;
		}
		return `'${id}':function(){\n` + result.replace(/^/gm, '\t') + '\n}()';
	}));
	console.log(code);
	let factoryDict = Function('context', 'util', code)(
		Object.assign(context, this._primitives, {control_wait}),
		{target:this._editingTarget}
	);
	threadList.push(factoryDict[this._editingTarget.id][blockID]());
});

wrapFn(Runtime.prototype, 'stopAll', oldFn => function(){
	oldFn.call(this);
	threadList.splice(0);
});

const context = Object.assign({net:{sendData:v=>window.serial.sendData(v)}}, primitives);
Object.defineProperty(context, 'yieldFlag', {value:Symbol()});
Object.defineProperty(context, 'yieldOneTickFlag', {value:Symbol()});
Object.defineProperty(context, 'suspendFlag', {value:Symbol()});
