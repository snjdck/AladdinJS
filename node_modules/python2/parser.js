const parse = require('./bridge');

const isStrQuote = (quoteList => v => quoteList.includes(v))(['"', "'"]);
const isDigit = (digitList => v => digitList.indexOf(v) >= 0)('0123456789');
const quote = v => "'" + v.replace(/'/g, "\\'") + "'";
const joinLines = v => v.map(v => v + '\n').join('');
const castNodeList = v => joinLines(v.map(castNode));
const mapWrap = (list, left, right) => left + list.map(castNode) + right;

function decode(data, offset=0){
	function nextID(){
		const start = offset;
		while(/\w/.test(data[offset]))
			++offset;
		return data.slice(start, offset);
	}
	function nextStr(end){
		const start = ++offset;
		while(data[offset] != end || data[offset-1] == '\\')
			++offset;
		return data.slice(start, offset++).replace(new RegExp('\\\\' + end, 'g'), end);
	}
	function nextNum(){
		const start = offset;
		while(data[offset] != ')')
			++offset;
		return data.slice(start, offset);
	}
	function readList(end, fn){
		const result = [];
		if(data[++offset] == end){
			++offset;
			return result;
		}
		for(;;){
			result.push(fn());
			if(data[offset++] == end)break;
			++offset;
		}
		return result;
	}
	function nextExp(){
		if(offset >= data.length)return;
		if(isDigit(data[offset]))return nextNum();
		if(isStrQuote(data[offset]))return nextStr(data[offset]);
		if(data[offset] == 'b' && isStrQuote(data[offset+1])){
			return nextStr(data[++offset]);
		}
		if(data[offset] == '['){
			return readList(']', nextExp);
		}
		const type = nextID();
		if(data[offset] != '(')return type;
		const args = {_type:type};
		readList(')', () => args[nextID()] = nextExp(++offset));
		return args;
	}
	return nextExp();
}
class Stack{
	constructor(valueFn){
		this.list = [null];
		this.index = 0;
		this.valueFn = valueFn;
	}
	reset(){
		this.list.length = 1;
		this.index = 0;
	}
	push(){
		let value = this.valueFn();
		this.list[++this.index] = value;
	}
	pop(){
		--this.index;
	}
	value(){
		return this.list[this.index];
	}
}

class GeneratorStack extends Stack{
	constructor(){
		super(() => false);
	}
	mark(){
		this.list[this.index] = true;
	}
}

class ScopeStack extends Stack{
	constructor(){
		super(() => Object.create(this.value()));
	}
	has(k){
		return k in this.value();
	}
	add(k){
		this.value()[k] = true;
	}
}

const generatorFlagStack = new GeneratorStack();
const scopeStack = new ScopeStack();

function calcAssignPrefix(node){
	let name = castNode(node);
	if(node._type == 'Name'){
		if(!scopeStack.has(name)){
			scopeStack.add(name)
			return 'let ' + name;
		}
	}
	return name;
}

function castFunction(node, classFlag){
	if(!classFlag)scopeStack.add(node.name);
	scopeStack.push();
	const args = castNode(node.args);
	generatorFlagStack.push();
	const body = castNodeList(node.body);
	const sign = generatorFlagStack.value() ? '*' : '';
	generatorFlagStack.pop();
	scopeStack.pop();
	const prefix = node._type.startsWith('Async') ? 'async ' : '';
	if(classFlag)return reduceDecorator(node, prefix + `function${sign}(${args}){\n${body}}`);
	return prefix + `function${sign} ${node.name}(${args}){\n${body}}\n` + addDecorator(node);
}

function calcGenerator(node){
	return `function*(){\n${castNodeList(node.generators)}yield ${castNode(node.elt)}\n}()`;
}

function castNode(node){
	const type = node._type;

	if(type == 'Module'){
		scopeStack.push();
		return castNodeList(node.body);
	}
	if(type == 'Expr')return castNode(node.value);
	if(type == 'Attribute')return castNode(node.value) + '.' + node.attr;
	if(type == 'Subscript')return castNode(node.value) + '[' + castNode(node.slice) + ']';
	if(type == 'Index')return castNode(node.value);
	if(type == 'Call')return castNode(node.func) + mapWrap(node.args, '(', ')');
	if(type == 'Name')return node.id;
	if(type == 'Str')return quote(node.s);
	if(type == 'Num')return node.n;
	if(type == 'Global'){
		return node.names;
	}
	if(type == 'Nonlocal'){
		return node.names;
	}
	if(type == 'NameConstant'){
		if(node.value == 'True')return true;
		if(node.value == 'False')return false;
		return node.value;
	}
	if(type == 'Tuple')return node.elts.length != 1 ? mapWrap(node.elts, '(', ')') : `(${castNode(node.elts[0])},)`;
	if(type == 'List')return mapWrap(node.elts, '[', ']');
	if(type == 'Set')return mapWrap(node.elts, 'new Set([', '])');
	if(type == 'Dict'){
		return 'new Map([' + node.keys.map((k, i) => `[${castNode(k)},${castNode(node.values[i])}]`) + '])';
	}
	if(type == 'comprehension'){
		const result = `for(let ${castNode(node.target)} of ${castNode(node.iter)})`;
		if(node.ifs.length == 0)return result;
		return result + `if(${node.ifs.map(castNode).join(' && ')})`;
	}
	if(type == 'GeneratorExp')return `(${calcGenerator(node)})`;
	if(type == 'ListComp')return `Array.from(${calcGenerator(node)})`;
	if(type == 'SetComp')return `new Set(${calcGenerator(node)})`;
	if(type == 'DictComp'){
		return `new Map(function*(){\n${castNodeList(node.generators)}yield [${castNode(node.key)},${castNode(node.value)}]\n}())`;
	}
	if(type == 'Assign'){
		return calcAssignPrefix(node.targets[0]) + ' = ' + castNode(node.value);
	}
	if(type == 'AnnAssign'){
		if(node.value == 'None')return '';
		return calcAssignPrefix(node.target) + ' = ' + castNode(node.value);
	}
	if(type == 'AugAssign'){
		return castNode(node.target) + ` ${castOP(node.op._type)}= ` + castNode(node.value);
	}
	if(type == 'Delete')return joinLines(node.targets.map(v => `delete ${castNode(v)}`));
	if(type == 'While')return `while(${castNode(node.test)}){\n${castNodeList(node.body)}}`;
	if(type == 'For')return `for(let ${castNode(node.target)} of ${castNode(node.iter)}){\n${castNodeList(node.body)}}`;
	if(type == 'Break')return 'break';
	if(type == 'Continue')return 'continue';
	if(type == 'Pass')return '//pass';
	if(type == 'If'){
		let result = `if(${castNode(node.test)}){\n${castNodeList(node.body)}}`;
		if(node.orelse.length == 0)
			return result;
		if(node.orelse.length == 1 && node.orelse[0]._type == 'If')
			return result + 'else ' + castNode(node.orelse[0]);
		return result + `else{\n${castNodeList(node.orelse)}}`;
	}
	if(type.startsWith('Yield')){
		generatorFlagStack.mark();
		if(node.value == 'None')return 'yield';
		const suffix = type.endsWith('From') ? '*' : '';
		return `yield${suffix} ` + castNode(node.value);
	}
	if(type == 'Await')return `await ` + castNode(node.value);
	if(type == 'Lambda'){
		scopeStack.push();
		const args = castNode(node.args);
		generatorFlagStack.push();
		const body = castNode(node.body);
		const isGenerator = generatorFlagStack.value();
		generatorFlagStack.pop();
		scopeStack.pop();
		if(isGenerator){
			return `(function*(${args}){return (${body})})`;
		}
		return `((${args}) => ${body})`;
	}
	if(type.endsWith('FunctionDef'))return castFunction(node);
	if(type == 'arguments'){
		const result = node.args.map(castNode);
		result.forEach(scopeStack.add, scopeStack);
		return result.join();
	}
	if(type == 'arg')return node.arg;
	if(type == 'Return')return 'return' + (node.value == 'None' ? '' : ' ' + castNode(node.value));
	if(type == 'IfExp')return `(${castNode(node.test)} ? ${castNode(node.body)} : ${castNode(node.orelse)})`;
	if(type == 'BinOp'){
		if(node.op._type == 'MatMult'){
			return 'MatMult(' + castNode(node.left) + ',' + castNode(node.right) + ')';
		}
		if(node.op._type == 'FloorDiv'){
			return 'Math.floor(' + castNode(node.left) + ' / ' + castNode(node.right) + ')';
		}
		return '(' + castNode(node.left) + ' ' + castOP(node.op._type) + ' ' + castNode(node.right) + ')';
	}
	if(type == 'BoolOp'){
		let [a, b] = node.values;
		return '(' + castNode(a) + ' ' + castOP(node.op._type) + ' ' + castNode(b) + ')';
	}
	if(type == 'UnaryOp'){
		return castOP(node.op._type) + castNode(node.operand);
	}
	if(type == 'Compare'){
		if(node.ops[0]._type == 'In'){
			return 'In(' + castNode(node.left) + ',' + castNode(node.comparators[0]) + ')';
		}
		if(node.ops[0]._type == 'NotIn'){
			return '(!In(' + castNode(node.left) + ',' + castNode(node.comparators[0]) + '))';
		}
		return '(' + castNode(node.left) + ' ' + castOP(node.ops[0]._type) + ' ' + castNode(node.comparators[0]) + ')';
	}
	if(type == 'With'){
		return node.items.map(({optional_vars, context_expr}, i) => [
			optional_vars == 'None' ? '_' + i : castNode(optional_vars),
			castNode(context_expr)
		]).reduceRight((result, [name, init]) => 
			`try{\nconst ${name} = ${init}.__enter__()\n${result}}finally{\n${name}.__exit__()\n}`
		, castNodeList(node.body));
	}
	if(type == 'JoinedStr')return node.values.map(castNode).join(' + ');
	if(type == 'FormattedValue')return castNode(node.value);
	if(type == 'Bytes')return `Buffer.from(${quote(node.s)})`;
	if(type == 'Raise')return 'throw ' + castNode(node.exc);
	if(type == 'Try'){
		let result = `try{\n${castNodeList(node.body)}}`;
		if(node.handlers.length){
			result += `catch(error){\n${node.handlers.map(castNode).join('else ')}}`;
		}
		if(node.finalbody.length){
			result += `finally{\n${castNodeList(node.finalbody)}}`;
		}
		return result;
	}
	if(type == 'ExceptHandler'){
		const condition = (node.type == 'None') ? 'true' : `error instanceof ${castNode(node.type)}`;
		return `if(${condition}){\n${castNodeList(node.body)}}`;
	}
	if(type == 'ClassDef'){
		scopeStack.add(node.name);
		node.body = node.body.filter(({_type}) => _type != 'Pass');
		let result;
		const __init__ = node.body.filter(v => v.name == '__init__')[0];
		if(__init__){
			__init__.name = node.name;
			result = fixMethod(__init__);
			node.body.splice(node.body.indexOf(__init__), 1);
		}else{
			result = `function ${node.name}(){}`;
		}
		const fnList = node.body.filter(v => v._type.endsWith('FunctionDef'));
		result += defineMethods(node.name + '.prototype', fnList.filter(v => v.decorator_list.map(castNode).every(isNormalDecorator)), fixMethod);
		result += defineMethods(node.name, fnList.filter(v => v.decorator_list.map(castNode).some(v => v == 'classmethod')), fixMethod);
		result += defineMethods(node.name, fnList.filter(v => v.decorator_list.map(castNode).some(v => v == 'staticmethod')), v => castFunction(v, true));
		result += joinLines(node.body.
			filter(v => v._type == 'AnnAssign' && v.value != 'None').
			map((v => `${node.name}.${castNode(v.target)} = ${castNode(v.value)}`))
		);
		result += joinLines(node.body.
			filter(v => v._type == 'Assign').
			map((v => `${node.name}.${castNode(v.targets[0])} = ${castNode(v.value)}`))
		);
		return result + addDecorator(node);
	}
	console.log('===========================', type, 'not handle!');
}

function fixMethod(method){
	const self = method.args.args.shift().arg;
	if(self != 'this'){
		method.body.unshift({_type:'Assign',targets:[{_type:'Name',id:self}],value:{_type:'Name',id:'this'}});
	}
	return castFunction(method, true);
}

function defineMethods(target, fnList, castFn){
	if(fnList.length == 0)return '';
	return `Object.defineProperties(${target}, {` + fnList.map(v => `${quote(v.name)}:{value:${castFn(v)},writable:true,configurable:true}`).join() + '})\n';
}

const isNormalDecorator = (special => v => !special.includes(v))(['staticmethod', 'classmethod']);
const reduceDecorator = (special => (node, value) => 
	node.decorator_list.map(castNode).filter(isNormalDecorator).reduceRight((result, value) => `${value}(${result})`, value)
)(['staticmethod', 'classmethod']);

function addDecorator(node){
	let {name} = node;
	let value = reduceDecorator(node, name);
	if(value == name)return '';
	return name + ' = ' + value + '\n';
}

const castOP = (dict => type => dict[type])({
	'And': '&&',
	'Or': '||',
	'Add': '+',
	'Sub': '-',
	'Mult': '*',
	'Div': '/',
	'Mod': '%',
	'Pow': '**',
	'LShift': '<<',
	'RShift': '>>',
	'BitOr': '|',
	'BitAnd': '&',
	'Not': '!',
	'UAdd': '+',
	'USub': '-',
	'Invert': '~',
	'Gt': '>',
	'GtE': '>=',
	'Lt': '<',
	'LtE': '<=',
	'Eq': '==',
	'NotEq': '!=',
	'Is': '===',
	'IsNot': '!==',
});


let data = parse(process.cwd(), 'test1.txt');
console.log(data);
console.log(JSON.stringify(decode(data)));
console.log(castNode(decode(data)));
//https://docs.python.org/3/library/ast.html