const parse = require('./bridge');

const isStrQuote = (quoteList => v => quoteList.includes(v))(['"', "'"]);
const isDigit = (digitList => v => digitList.indexOf(v) >= 0)('0123456789');
const slash = (v, q) => v.replace(new RegExp(q, 'g'), "\\" + q);
const quote = (v, q="'") => q + slash(v, q) + q;
const joinLines = v => v.map(v => v + '\n').join('');
const castNodeList = v => joinLines(v.map(castNode));
const wrap = (v, l='(', r=')') => l + v + r;
const castWrap = (v, l, r) => wrap(castNode(v), l, r);
const mapWrap = (list, l='[', r=']', sep=',') => wrap(list.map(castNode).join(sep), l, r);
const tab = text => text.replace(/^(?!$)/gm, '\t');

function decode(data, offset=0){
	function nextID(){
		const start = offset;
		while(/\w/.test(data[offset]))
			++offset;
		return data.slice(start, offset);
	}
	function nextStr(end){
		const start = ++offset;
		while(data[offset] != end || data[offset-1] == '\\')
			++offset;
		return data.slice(start, offset++).replace(new RegExp('\\\\' + end, 'g'), end);
	}
	function nextNum(){
		const start = offset;
		while(data[offset] != ')')
			++offset;
		return data.slice(start, offset);
	}
	function readList(end, fn){
		const result = [];
		if(data[++offset] == end){
			++offset;
			return result;
		}
		for(;;){
			result.push(fn());
			if(data[offset++] == end)break;
			++offset;
		}
		return result;
	}
	function nextExp(){
		if(offset >= data.length)return;
		if(isDigit(data[offset]))return nextNum();
		if(isStrQuote(data[offset]))return nextStr(data[offset]);
		if(data[offset] == 'b' && isStrQuote(data[offset+1])){
			return nextStr(data[++offset]);
		}
		if(data[offset] == '['){
			return readList(']', nextExp);
		}
		const type = nextID();
		if(data[offset] != '(')return type;
		const args = {_type:type};
		readList(')', () => args[nextID()] = nextExp(++offset));
		return args;
	}
	return nextExp();
}
class Stack{
	constructor(valueFn){
		this.list = [null];
		this.index = 0;
		this.valueFn = valueFn;
	}
	reset(){
		this.list.length = 1;
		this.index = 0;
	}
	push(){
		let value = this.valueFn();
		this.list[++this.index] = value;
	}
	pop(){
		--this.index;
	}
	value(){
		return this.list[this.index];
	}
}

class GeneratorStack extends Stack{
	constructor(){
		super(() => false);
	}
	mark(){
		this.list[this.index] = true;
	}
}

class ScopeStack extends Stack{
	constructor(){
		super(() => Object.create(null, {nonlocal:{value:Object.create(null)}}));
	}
	has(k){
		let value = this.value();
		if(!value.nonlocal[k])return k in value;
		for(let i=this.index; i > 0; --i)
			if(k in this.list[i])
				return true;
		return false;
		
	}
	add(k){
		this.value()[k] = true;
	}
	nonlocal(k){
		this.value().nonlocal[k] = true;
	}
}

const generatorFlagStack = new GeneratorStack();
const scopeStack = new ScopeStack();

function calcAssignPrefix(node){
	let name = castNode(node);
	if(node._type == 'Name'){
		if(!scopeStack.has(name)){
			scopeStack.add(name)
			return 'let ' + name;
		}
	}
	return name;
}

function castFunction(node, classFlag){
	if(!classFlag)scopeStack.add(node.name);
	scopeStack.push();
	const args = castNode(node.args);
	generatorFlagStack.push();
	const body = tab(castNodeList(node.body));
	const sign = generatorFlagStack.value() ? '*' : '';
	generatorFlagStack.pop();
	scopeStack.pop();
	const prefix = node._type.startsWith('Async') ? 'async ' : '';
	if(classFlag)return reduceDecorator(node, prefix + `function${sign}(${args}){\n${body}}`);
	return prefix + `function${sign} ${node.name}(${args}){\n${body}}\n` + addDecorator(node);
}

function castNode(node, outerOP, isRight){
	const type = node._type;

	if(type == 'Module'){
		scopeStack.push();
		return castNodeList(node.body);
	}
	if(type == 'Expr')return castNode(node.value);
	if(type == 'Attribute')return castNode(node.value) + '.' + node.attr;
	if(type == 'Call')return castNode(node.func) + mapWrap(node.args, '(', ')');
	if(type == 'Name')return node.id;
	if(type == 'Str')return quote(node.s);
	if(type == 'Num')return node.n;
	if(type == 'Subscript'){
		const sliceType = node.slice._type;
		if(sliceType == 'Index')
			return castNode(node.value) + castWrap(node.slice, '[', ']');
		if(sliceType == 'Slice')
			return castNode(node.value) + castNode(node.slice);
	}
	if(type == 'Slice'){
		const {lower, upper, step} = node;
		const result = [];
		if(lower != 'None' || upper != 'None'){
			let args = [lower == 'None' ? 0 : castNode(lower)];
			if(upper != 'None')args.push(castNode(upper));
			result.push(`.slice(${args.join()})`);
		}
		if(step != 'None'){
			result.push(`.filter(function(_, i){return i % this == 0}, ${castNode(step)})`);
		}
		return result.length == 0 ? '.slice()' : result.join('');
	}
	if(type == 'Index')return castNode(node.value);
	if(type == 'Global'){
		return node.names;
	}
	if(type == 'Nonlocal'){
		node.names.forEach(scopeStack.nonlocal, scopeStack);
		return '';
	}
	if(type == 'NameConstant'){
		if(node.value == 'True')return true;
		if(node.value == 'False')return false;
		if(node.value == 'None')return 'null';
		return node.value;
	}
	if(type == 'Tuple' || type == 'List')return mapWrap(node.elts);
	if(type == 'Set')return mapWrap(node.elts, 'new Set([', '])');
	if(type == 'Dict')return wrap(node.keys.map((k, i) => mapWrap([k, node.values[i]])), 'new Map([', '])');
	if(type == 'comprehension'){
		const result = `for(let ${castNode(node.target)} of ${castNode(node.iter)})`;
		if(node.ifs.length == 0)return result;
		return result + mapWrap(node.ifs, 'if(', ')', ' && ');
	}
	if(type == 'GeneratorExp' || type == 'ListComp' || type == 'SetComp'){
		const prefix = type == 'GeneratorExp' ? '' : type == 'ListComp' ? 'Array.from' : 'new Set';
		return prefix + `(function*(){\n${tab(castNodeList(node.generators))}\tyield ${castNode(node.elt)}\n}())`;
	}
	if(type == 'DictComp'){
		return `new Map(function*(){\n${tab(castNodeList(node.generators))}\tyield ${mapWrap([node.key, node.value])}\n}())`;
	}
	if(type == 'Assign'){
		const result = [];
		node.targets.reduceRight((value, target) => {
			result.push(`${calcAssignPrefix(target)} = ${value}`);
			return castNode(target);
		}, castNode(node.value));
		return joinLines(result);
	}
	if(type == 'AnnAssign'){
		if(node.value == 'None')return '';
		return calcAssignPrefix(node.target) + ' = ' + castNode(node.value);
	}
	if(type == 'AugAssign'){
		return castNode(node.target) + ` ${castOP(node.op._type)}= ` + castNode(node.value);
	}
	if(type == 'Delete')return joinLines(node.targets.map(v => `delete ${castNode(v)}`));
	if(type == 'While')return `while(${castNode(node.test)}){\n${tab(castNodeList(node.body))}}`;
	if(type == 'For')return `for(let ${castNode(node.target)} of ${castNode(node.iter)}){\n${tab(castNodeList(node.body))}}`;
	if(type == 'Break')return 'break';
	if(type == 'Continue')return 'continue';
	if(type == 'Pass')return '//pass';
	if(type == 'If'){
		let result = `if(${castNode(node.test)}){\n${tab(castNodeList(node.body))}}`;
		if(node.orelse.length == 0)return result;
		if(node.orelse.length == 1 && node.orelse[0]._type == 'If')
			return result + 'else ' + castNode(node.orelse[0]);
		return result + `else{\n${tab(castNodeList(node.orelse))}}`;
	}
	if(type.startsWith('Yield')){
		generatorFlagStack.mark();
		if(node.value == 'None')return fixBrackets('yield', type, outerOP, isRight);
		const suffix = type.endsWith('From') ? '*' : '';
		return fixBrackets(`yield${suffix} ${castNode(node.value, type, true)}`, type, outerOP, isRight);
	}
	if(type == 'Await')return fixBrackets(`await ${castNode(node.value, type, true)}`, type, outerOP, isRight);
	if(type == 'Lambda'){
		scopeStack.push();
		const args = castNode(node.args);
		generatorFlagStack.push();
		const body = castNode(node.body);
		const isGenerator = generatorFlagStack.value();
		generatorFlagStack.pop();
		scopeStack.pop();
		if(isGenerator){
			return `(function*(${args}){return ${body}})`;
		}
		return `((${args}) => ${body})`;
	}
	if(type.endsWith('FunctionDef'))return castFunction(node);
	if(type == 'arguments'){
		const args = node.args.map(castNode);
		const defaults = node.defaults.map(castNode);
		args.forEach(scopeStack.add, scopeStack);
		const result = args.map((v, i) => {
			let offset = i - (args.length - defaults.length);
			return offset < 0 ? v : `${v}=${defaults[offset]}`;
		});
		if(node.vararg != 'None'){
			const vararg = castNode(node.vararg);
			scopeStack.add(vararg);
			result.push(wrap(vararg, '...', ''));
		}
		return result.join();
	}
	if(type == 'Starred')return castWrap(node.value, '...', '');
	if(type == 'arg')return node.arg;
	if(type == 'Return')return 'return' + (node.value == 'None' ? '' : castWrap(node.value, ' ', ''));
	if(type == 'IfExp')return fixBrackets(`${castNode(node.test, type)} ? ${castNode(node.body, type)} : ${castNode(node.orelse, type, true)}`, type, outerOP, isRight);
	if(type == 'BinOp'){
		const op = node.op._type;
		if(op == 'MatMult')return mapWrap([node.left, node.right], 'MatMult(', ')');
		const result = castNode(node.left, op) + ` ${castOP(op)} ` + castNode(node.right, op, true);
		if(op == 'FloorDiv')return wrap(result, 'Math.floor(');
		return fixBrackets(result, op, outerOP, isRight);
	}
	if(type == 'BoolOp'){
		const op = node.op._type;
		return fixBrackets(node.values.map((v, i) => castNode(v, op, i > 0)).join(` ${castOP(op)} `), op, outerOP, isRight);
	}
	if(type == 'UnaryOp')return castOP(node.op._type) + castNode(node.operand);
	if(type == 'Compare'){
		const n = node.ops.length;
		if(n == 1){
			const op = node.ops[0]._type;
			return fixBrackets(castNode(node.left, op) + ` ${castOP(op)} ` + castNode(node.comparators[0], op, true), op, outerOP, isRight);
		}
		const result = ['let _1 = ' + castNode(node.left)];
		for(let i=0; i<n; ++i){
			const op = castOP(node.ops[i]._type);
			result.push('_2 = ' + castNode(node.comparators[i]));
			if(i == n - 1){
				result.push(`return _1 ${op} _2`);
			}else{
				result.push(`if(!(_1 ${op} _2))return false`, '_1 = _2');
			}
		}
		return wrap(tab(joinLines(result)), '(_2 => {\n', '})()');
	}
	if(type == 'With'){
		return node.items.map(({optional_vars, context_expr}, i) => [
			optional_vars == 'None' ? '_' + i : castNode(optional_vars),
			castNode(context_expr)
		]).reduceRight((result, [name, init]) => 
			`try{\n\tconst ${name} = ${init}.__enter__()\n${tab(result)}\n}finally{\n\t${name}.__exit__()\n}`
		, castNodeList(node.body));
	}
	if(type == 'JoinedStr')return wrap(node.values.map(v => (v._type == 'Str') ? slash(v.s, '`') : castNode(v)).join(''), '`', '`');
	if(type == 'FormattedValue')return castWrap(node.value, '${', '}');
	if(type == 'Bytes')return `Buffer.from(${quote(node.s)})`;
	if(type == 'Raise')return 'throw ' + castNode(node.exc);
	if(type == 'Try'){
		let result = `try{\n${tab(castNodeList(node.body))}}`;
		if(node.handlers.length){
			result += `catch(error){\n${tab(node.handlers.map(castNode).join('else '))}\n}`;
		}
		if(node.finalbody.length){
			result += `finally{\n${tab(castNodeList(node.finalbody))}}`;
		}
		return result;
	}
	if(type == 'ExceptHandler'){
		const condition = (node.type == 'None') ? 'true' : `error instanceof ${castNode(node.type)}`;
		return `if(${condition}){\n${tab(castNodeList(node.body))}}`;
	}
	if(type == 'ClassDef'){
		scopeStack.add(node.name);
		node.body = node.body.filter(({_type}) => _type != 'Pass');
		let result;
		const __init__ = node.body.filter(v => v.name == '__init__')[0];
		if(__init__){
			__init__.name = node.name;
			result = wrap(fixMethod(__init__), `let ${node.name} = `, ';');
			node.body.splice(node.body.indexOf(__init__), 1);
		}else{
			result = `function ${node.name}(){}\n`;
		}
		const fnList = node.body.filter(v => v._type.endsWith('FunctionDef'));
		result += defineMethods(node.name + '.prototype', fnList.filter(v => v.decorator_list.map(castNode).every(isNormalDecorator)), fixMethod);
		result += defineMethods(node.name, fnList.filter(v => v.decorator_list.map(castNode).some(v => v == 'classmethod')), fixMethod);
		result += defineMethods(node.name, fnList.filter(v => v.decorator_list.map(castNode).some(v => v == 'staticmethod')), v => castFunction(v, true));
		result += joinLines(node.body.
			filter(v => v._type == 'AnnAssign' && v.value != 'None').
			map((v => `${node.name}.${castNode(v.target)} = ${castNode(v.value)}`))
		);
		result += joinLines(node.body.
			filter(v => v._type == 'Assign').
			map((v => `${node.name}.${castNode(v.targets[0])} = ${castNode(v.value)}`))
		);
		return result + addDecorator(node);
	}
	console.log('===========================', type, 'not handle!');
}

function fixMethod(method){
	const self = method.args.args.shift().arg;
	if(self != 'this'){
		method.body.unshift({_type:'Assign',targets:[{_type:'Name',id:self}],value:{_type:'Name',id:'this'}});
	}
	return castFunction(method, true);
}

function defineMethods(target, fnList, castFn){
	if(fnList.length == 0)return '';
	return `Object.defineProperties(${target}, {` + fnList.map(v => `${quote(v.name)}:{value:${castFn(v)},writable:true,configurable:true}`).join() + '})\n';
}

const isNormalDecorator = (special => v => !special.includes(v))(['staticmethod', 'classmethod']);
const reduceDecorator = (special => (node, value) => 
	node.decorator_list.map(castNode).filter(isNormalDecorator).reduceRight((result, value) => `${value}(${result})`, value)
)(['staticmethod', 'classmethod']);

function addDecorator(node){
	let {name} = node;
	let value = reduceDecorator(node, name);
	if(value == name)return '';
	return name + ' = ' + value + '\n';
}

const castOP = (dict => type => dict[type])({
	'And': '&&',
	'Or': '||',
	'Add': '+',
	'Sub': '-',
	'Mult': '*',
	'Div': '/',
	'FloorDiv': '/',
	'Mod': '%',
	'Pow': '**',
	'LShift': '<<',
	'RShift': '>>',
	'BitOr': '|',
	'BitAnd': '&',
	'Not': '!',
	'UAdd': '+',
	'USub': '-',
	'Invert': '~',
	'Gt': '>',
	'GtE': '>=',
	'Lt': '<',
	'LtE': '<=',
	'Eq': '==',
	'NotEq': '!=',
	'Is': '===',
	'IsNot': '!==',
});

const Precedence_Order = {
	'And': 6,
	'Or': 5,
	'Add': 13,
	'Sub': 13,
	'Mult': 14,
	'Div': 14,
	'FloorDiv': 14,
	'Mod': 14,
	'Pow': 15,
	'LShift': 12,
	'RShift': 12,
	'BitOr': 7,
	'BitAnd': 9,
	'Not': 16,
	'UAdd': 16,
	'USub': 16,
	'Invert': 16,
	'Gt': 11,
	'GtE': 11,
	'Lt': 11,
	'LtE': 11,
	'Eq': 10,
	'NotEq': 10,
	'Is': 10,
	'IsNot': 10,
	'Await': 16,
	'Yield': 2,
	'YieldFrom': 2,
	'IfExp': 4,
}

const Right_Associativity = [2, 3, 4, 15, 16];

function needBrackets(innerOP, outerOP, isRight){
	if(Array.isArray(isRight))return false;
	innerOP = Precedence_Order[innerOP];
	outerOP = Precedence_Order[outerOP] || 0;
	return innerOP != outerOP ? innerOP < outerOP : Boolean(isRight) != Right_Associativity.includes(innerOP);
}

function fixBrackets(value, innerOP, outerOP, isRight){
	return needBrackets(innerOP, outerOP, isRight) ? wrap(value) : value;
}



//https://docs.python.org/3/library/ast.html
//https://docs.python.org/3/reference/expressions.html#operator-precedence
//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence