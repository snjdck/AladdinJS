const parse = require('./bridge');

const quoteList = ['"', "'"];
const quote = v => "'" + v.replace(/'/g, "\\'") + "'";
const castNodeList = list => list.map(castNode).map(v => v + '\n').join('');

function decode(data, offset=0){
	function nextID(){
		const start = offset;
		while(/\w/.test(data[offset]))
			++offset;
		return data.slice(start, offset);
	}
	function nextStr(end){
		const start = ++offset;
		while(data[offset] != end || data[offset-1] == '\\')
			++offset;
		return data.slice(start, offset++).replace(new RegExp('\\\\' + end, 'g'), end);
	}
	function readList(end, fn){
		const result = [];
		if(data[++offset] == end){
			++offset;
			return result;
		}
		for(;;){
			result.push(fn());
			if(data[offset++] == end)break;
			++offset;
		}
		return result;
	}
	function nextExp(){
		if(offset >= data.length)return;
		if(/\d/.test(data[offset]))return nextID();
		if(quoteList.includes(data[offset]))return nextStr(data[offset]);
		if(data[offset] == '['){
			return readList(']', nextExp);
		}
		const type = nextID();
		if(data[offset] != '(')return type;
		const args = {type};
		readList(')', () => args[nextID()] = nextExp(++offset));
		return args;
	}
	return nextExp();
}

class Stack{
	constructor(){
		this.list = [];
		this.index = 0;
	}
	reset(){
		this.list.length = this.index = 0;
	}
	push(){
		this.list[++this.index] = false;
	}
	pop(){
		--this.index;
	}
	value(){
		return this.list[this.index];
	}
	mark(){
		this.list[this.index] = true;
	}
}

const generatorFlagStack = new Stack();

function castNode(node){
	if(node.type == 'Module'){
		return castNodeList(node.body);
	}
	if(node.type == 'Expr'){
		return castNode(node.value);
	}
	if(node.type == 'Attribute'){
		return castNode(node.value) + '.' + node.attr;
	}
	if(node.type == 'Subscript'){
		return castNode(node.value) + '[' + castNode(node.slice) + ']';
	}
	if(node.type == 'Index'){
		return castNode(node.value);
	}
	if(node.type == 'Call'){
		return castNode(node.func) + '(' + node.args.map(castNode) + ')';
	}
	if(node.type == 'Name'){
		return node.id;
	}
	if(node.type == 'Str'){
		return quote(node.s);
	}
	if(node.type == 'Num'){
		return node.n;
	}
	if(node.type == 'NameConstant'){
		if(node.value == 'True')return true;
		if(node.value == 'False')return false;
		return node.value;
	}
	if(node.type == 'Tuple'){
		return '(' + node.elts.map(castNode) + (node.elts.length > 1 ? '' : ',') + ')';
	}
	if(node.type == 'List'){
		return '[' + node.elts.map(castNode) + ']';
	}
	if(node.type == 'Set'){
		return 'new Set([' + node.elts.map(castNode) + '])';
	}
	if(node.type == 'Dict'){
		return 'new Map([' + node.keys.map((k, i) => `[${castNode(k)},${castNode(node.values[i])}]`) + '])';
	}
	if(node.type == 'comprehension'){
		const result = `for(const ${castNode(node.target)} of ${castNode(node.iter)})`;
		if(node.ifs.length == 0)return result;
		return result + `if(${node.ifs.map(castNode).join(' && ')})`;
	}
	if(node.type == 'ListComp'){
		return `Array.from(function*(){\n${castNodeList(node.generators)}yield ${castNode(node.elt)}\n}())`;
	}
	if(node.type == 'SetComp'){
		return `new Set(function*(){\n${castNodeList(node.generators)}yield ${castNode(node.elt)}\n}())`;
	}
	if(node.type == 'DictComp'){
		return `new Map(function*(){\n${castNodeList(node.generators)}yield [${castNode(node.key)},${castNode(node.value)}]\n}())`;
	}
	if(node.type == 'GeneratorExp'){
		return `(function*(){\n${castNodeList(node.generators)}yield ${castNode(node.elt)}\n}())`;
	}
	if(node.type == 'Assign'){
		return castNode(node.targets[0]) + ' = ' + castNode(node.value);
	}
	if(node.type == 'Delete'){
		return 'delete ' + castNode(node.targets[0]);
	}
	if(node.type == 'While'){
		return `while(${castNode(node.test)}){\n${castNodeList(node.body)}}`;
	}
	if(node.type == 'For'){
		return `for(let ${castNode(node.target)} of ${castNode(node.iter)}){\n${castNodeList(node.body)}}`;
	}
	if(node.type == 'Break')return 'break';
	if(node.type == 'Continue')return 'continue';
	if(node.type == 'Pass')return '//pass';
	if(node.type == 'If'){
		let result = `if(${castNode(node.test)}){\n${castNodeList(node.body)}}`;
		if(node.orelse.length == 0){
			return result;
		}
		if(node.orelse.length == 1 && node.orelse[0].type == 'If'){
			return result + 'else ' + castNode(node.orelse[0]);
		}
		return result + `else{\n${castNodeList(node.orelse)}}`;
	}
	if(node.type.startsWith('Yield')){
		generatorFlagStack.mark();
		if(node.value == 'None')return 'yield';
		const suffix = node.type.endsWith('From') ? '*' : '';
		return `yield${suffix} ` + castNode(node.value);
	}
	if(node.type.startsWith('Await')){
		return `await ` + castNode(node.value);
	}
	if(node.type == 'Lambda'){
		generatorFlagStack.push();
		const body = castNode(node.body);
		const isGenerator = generatorFlagStack.value();
		generatorFlagStack.pop();
		if(isGenerator){
			return `(function*(${castNode(node.args)}){return (${body})})`;
		}
		return `(${castNode(node.args)}) => ${body}`;
	}
	if(node.type.endsWith('FunctionDef')){
		generatorFlagStack.push();
		const body = castNodeList(node.body);
		const sign = generatorFlagStack.value() ? '*' : ' ';
		generatorFlagStack.pop();
		return (node.type.startsWith('Async') ? 'async ' : '') + `function${sign}${node.name}(${castNode(node.args)}){\n${body}}\n`;
	}
	if(node.type == 'arguments'){
		return node.args.map(castNode).join();
	}
	if(node.type == 'arg'){
		return node.arg;
	}
	if(node.type == 'Return'){
		if(node.value == 'None')return 'return';
		return 'return ' + castNode(node.value);
	}
	if(node.type == 'IfExp'){
		return `(${castNode(node.test)} ? ${castNode(node.body)} : ${castNode(node.orelse)})`;
	}
	if(node.type == 'BinOp'){
		if(node.op.type == 'MatMult'){
			return 'MatMult(' + castNode(node.left) + ',' + castNode(node.right) + ')';
		}
		if(node.op.type == 'FloorDiv'){
			return 'Math.floor(' + castNode(node.left) + ' / ' + castNode(node.right) + ')';
		}
		return '(' + castNode(node.left) + ' ' + castOP(node.op.type) + ' ' + castNode(node.right) + ')';
	}
	if(node.type == 'BoolOp'){
		let [a, b] = node.values;
		return '(' + castNode(a) + ' ' + castOP(node.op.type) + ' ' + castNode(b) + ')';
	}
	if(node.type == 'UnaryOp'){
		return castOP(node.op.type) + castNode(node.operand);
	}
	if(node.type == 'Compare'){
		if(node.ops[0].type == 'In'){
			return 'In(' + castNode(node.left) + ',' + castNode(node.comparators[0]) + ')';
		}
		if(node.ops[0].type == 'NotIn'){
			return '(!In(' + castNode(node.left) + ',' + castNode(node.comparators[0]) + '))';
		}
		return '(' + castNode(node.left) + ' ' + castOP(node.ops[0].type) + ' ' + castNode(node.comparators[0]) + ')';
	}
	if(node.type == 'With'){
		return node.items.map(({optional_vars, context_expr}, i) => [
			optional_vars == 'None' ? '_' + i : castNode(optional_vars),
			castNode(context_expr)
		]).reduceRight((result, [name, init]) => 
			`try{\nconst ${name} = ${init}.__enter__()\n${result}}finally{\n${name}.__exit__()\n}`
		, castNodeList(node.body));
	}
}

const castOP = (dict => type => dict[type])({
	'And': '&&',
	'Or': '||',
	'Add': '+',
	'Sub': '-',
	'Mult': '*',
	'Div': '/',
	'Mod': '%',
	'Pow': '**',
	'LShift': '<<',
	'RShift': '>>',
	'BitOr': '|',
	'BitAnd': '&',
	'Not': '!',
	'UAdd': '+',
	'USub': '-',
	'Invert': '~',
	'Gt': '>',
	'GtE': '>=',
	'Lt': '<',
	'LtE': '<=',
	'Eq': '==',
	'NotEq': '!=',
	'Is': '===',
	'IsNot': '!==',
});


let data = parse(process.cwd(), 'test1.txt');
console.log(data);
console.log(JSON.stringify(decode(data)));
console.log(castNode(decode(data)));
//https://docs.python.org/3/library/ast.html