'use strict';

class ObjectBucket
{
	constructor(){
		this.root = new Map();
		this.keyFnList = [];
		this.updateFnList = [];
		this.sortFnList = [];
	}

	regKeyFn(keyFn, updateFn, sortFn){
		const keyCount = this.keyFnList.length;
		this.keyFnList[keyCount] = keyFn;
		this.updateFnList[keyCount] = updateFn;
		this.sortFnList[keyCount] = sortFn;
	}

	newMap(){
		return new Map();
	}

	clear(){
		this.root.clear();
	}

	add(element, override){
		const {keyFnList} = this;
		let map = this.root;
		for(let i=0, n=keyFnList.length; i<n; ++i){
			let key = keyFnList[i](element, override);
			if(!map.has(key))
				map.set(key, this.newMap());
			map = map.get(key);
		}
		map.set(element);
	}

	forEach(execFn, thisArg){
		walk.call(thisArg, this.root, execFn, this.updateFnList, this.sortFnList, 0);
	}
}

function walk(map, execFn, fnList, sortFnList, index){
	const fn = fnList[index];
	const sortFn = sortFnList[index];
	const list = sortFn ? sortFn.call(this, Array.from(map.keys())) : map.keys();
	const nextIndex = index + 1;
	if(nextIndex == fnList.length){
		for(let key of list){
			fn.call(this, key);
			execFn.call(this, Array.from(map.get(key).keys()));
		}
	}else{
		for(let key of list){
			fn.call(this, key);
			walk.call(this, map.get(key), execFn, fnList, sortFnList, nextIndex);
		}
	}
}

module.exports = ObjectBucket;
