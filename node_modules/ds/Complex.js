'use strict';

class Complex
{
	static expI(v){
		return new this(Math.cos(v), Math.sin(v));
	}

	static *generateCircle(step, n=step){
		const w = Math.PI * 2 / step;
		for(let i=0; i<n; ++i){
			yield this.expI(w * i);
		}
	}

	constructor(real=0, imag=0){
		Object.defineProperty(this, 'real', {value: real, enumerable: true});
		Object.defineProperty(this, 'imag', {value: imag, enumerable: true});
	}

	length(){
		return Math.hypot(this.real, this.imag);
	}

	conj(){
		return new Complex(this.real, -this.imag);
	}

	neg(){
		return new Complex(-this.real, -this.imag);
	}

	add(other){
		return new Complex(this.real + other.real, this.imag + other.imag);
	}

	sub(other){
		return new Complex(this.real - other.real, this.imag - other.imag);
	}

	mul(other){
		return new Complex(
			this.real * other.real - this.imag * other.imag,
			this.real * other.imag + this.imag * other.real
		);
	}

	div(other){
		const f = 1 / (other.real * other.real + other.imag * other.imag);
		return new Complex(
			(this.real * other.real + this.imag * other.imag) * f,
			(this.imag * other.real - this.real * other.imag) * f
		);
	}

	addR(value){
		return new Complex(this.real + value, this.imag);
	}

	subR(value){
		return new Complex(this.real - value, this.imag);
	}

	mulR(value){
		return new Complex(this.real * value, this.imag * value);
	}

	mulI(value=1){
		return new Complex(-this.imag * value, this.real * value);
	}

	divR(value){
		return new Complex(this.real / value, this.imag / value);
	}

	divI(value){
		return new Complex(this.imag / value, -this.real / value);
	}

	pow(n){
		let result = new Complex(1);
		for(let i=0; i<n; ++i){
			result = result.mul(this);
		}
		return result;
	}

	prod(list){
		//[x^0, x^1, x^2, ..., x^n]
		let result = new Complex();
		for(let i=list.length-1; i>=0; --i){
			result = result.mul(this).add(list[i]);
		}
		return result;
	}

	toJSON(){
		return {r:this.real, i:this.imag};
	}
}

module.exports = Complex;
