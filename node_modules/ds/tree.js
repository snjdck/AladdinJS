
class TreeNode
{
	constructor(){
		this.firstChild = null;
		this.nextSibling = null;
	}

	get lastSibling(){
		let testNode = this;
		while(testNode.nextSibling){
			testNode = testNode.nextSibling;
		}
		return testNode;
	}

	get lastChild(){
		return this.firstChild?.lastSibling;
	}

	addChild(child){
		child.nextSibling = this.firstChild;
		this.firstChild = child;
	}

	addSibling(sibling){
		sibling.nextSibling = this.nextSibling;
		this.nextSibling = sibling;
	}

	forEach(handler, self, parent){
		handler.call(self, this, parent);
		this.nextSibling?.forEach(handler, self, parent);
		this.firstChild?.forEach(handler, self, this);
		return self;
	}
}

function VisitByDepth(rootNode, handler){
	const queue = [rootNode];
	while(queue.length > 0){
		let currentNode = queue.shift();
		handler(currentNode);
		if(currentNode.leftChild){
			queue.push(currentNode.leftChild);
		}
		if(currentNode.rightChild){
			queue.push(currentNode.rightChild);
		}
	}
}
	
function VisitPreOrder(rootNode, handler){
	const stack = [rootNode];
	while(stack.length > 0){
		let currentNode = stack.pop();
		handler(currentNode);
		if(currentNode.rightChild){
			stack.push(currentNode.rightChild);
		}
		if(currentNode.leftChild){
			stack.push(currentNode.leftChild);
		}
	}
}
	
function VisitInOrder(rootNode, handler){
	const stack = [];
	let currentNode = rootNode;
	while(null != currentNode){
		stack.push(currentNode);
		currentNode = currentNode.leftChild;
		while(null == currentNode && stack.length > 0){
			currentNode = stack.pop();
			handler(currentNode);
			currentNode = currentNode.rightChild;
		}
	}
}
	
function VisitPostOrder(rootNode, handler){
	const stack = [rootNode];
	let currentNode, prevNode;
	while(stack.length > 0){
		currentNode = stack[stack.length-1];
		if(
			(null == currentNode.leftChild && null == currentNode.rightChild) ||
			(prevNode && (prevNode == currentNode.leftChild || prevNode == currentNode.rightChild))
		){
			handler(stack.pop());
			prevNode = currentNode;
		}else{
			if(currentNode.rightChild){
				stack.push(currentNode.rightChild);
			}
			if(currentNode.leftChild){
				stack.push(currentNode.leftChild);
			}
		}
	}
}