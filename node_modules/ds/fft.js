'use strict';

const Complex = require('./Complex');
const {nextPowerOf2} = require('utils/math');
const {equals} = require('utils/array');

function Range(n, step=1){
	let result = Array(n);
	for(let i=0; i<n; ++i){
		result[i] = i * step;
	}
	return result;
}

function zip(a, b, n, f){
	let result = [];
	for(let i=0; i<n; ++i){
		for(let [k, v] of f(a[i], b[i], i, n)){
			result[k] = v;
		}
	}
	return result;
}

function calc(p){
	const p0 = [], p1 = [];
	for(let i=0, n=p.length; i<n; ++i){
		if(i % 2){
			p1.push(p[i]);
		}else{
			p0.push(p[i]);
		}
	}
	return [p0, p1];
}

function zipAB(a, b, n){
	let result = Array(n << 1);
	for(let i=0; i<n; ++i){
		let ai = a[i];
		let bi = b[i];
		result[i] = ai.add(bi);
		result[i+n] = ai.sub(bi);
	}
	return result;
}

function zipABX(a, b, x){
	const n = x.length;
	const result = Array(n << 1);
	for(let i=0; i<n; ++i){
		const ai = a[i];
		const bi = b[i].mul(x[i]);
		result[i] = ai.add(bi);
		result[i+n] = ai.sub(bi);
	}
	return result;
}

const fftF3 = invertFlag => (p, size) => {
	const list = Array.from(Complex.generateCircle(size, size >> 1), invertFlag ? v => v.conj() : undefined);
	const level = Math.log2(size);
	let result = Array.from(bitTest(level), i => [p[i] ?? Complex.zero]);
	for(let i=0; i<level; ++i){
		const shift = level - i - 1;
		const temp = Range(1 << i).map(i => list[i << shift]);
		result = Range(size >> i + 1, 2).map(i => zipABX(result[i], result[i|1], temp));
	}
	if(invertFlag){
		const f = 1 / size;
		return result[0].map(v => v.mulR(f));
	}
	return result[0];
}

function fftF2(invertFlag){
	return function fn(p, size){
		if(p.length == 1)return Array(size).fill(p[0]);
		const halfLen = size >> 1;
		const [a, b] = calc(p).map(v => fn(v, halfLen));
		const list = Array.from(Complex.generateCircle(size, halfLen), invertFlag ? v => v.conj() : undefined);
		const result = zipABX(a, b, list);
		return invertFlag ? result.map(v => v.mulR(0.5)) : result;
	}
}

function fftF(invertFlag){
	return function(p, n){
		if(p.length == 1)return p;
		const result = Array.from(Complex.generateCircle(n), v => (invertFlag ? v.conj() : v).prod(p));
		return invertFlag ? result.map(v => v.divR(n)) : result;
	}
}

function factory(fft, ifft){
	const realToComplex = v => new Complex(v);
	const complexToReal = v => Math.round(v.length());//round
	return function(pa, pb){
		const size = pa.length + pb.length - 1;
		const n = nextPowerOf2(size);
		pa = fft(pa.map(realToComplex), n);
		pb = fft(pb.map(realToComplex), n);
		let pc = pa.map((v, i) => v.mul(pb[i]));
		return ifft(pc, n).slice(0,size).map(complexToReal);
	}
}

void function(){
	function test(...args){
		let result = []
		for(let [a, b] of [
			//[fftF, fftF],
			//[fftF2, fftF],
			//[fftF3, fftF],
			//[fftF, fftF2],
			[fftF2, fftF2],
			[fftF3, fftF2],
			//[fftF, fftF3],
			[fftF2, fftF3],
			[fftF3, fftF3],
		]){
			let mytest = factory(a(), b(true));
			let time = performance.now()
			result.push(mytest(...args).join(','));
			//mytest(...args);result.push((performance.now() - time).toString());
		}
		console.assert(result.every(v => v === result[0]), result.map(v => '\n'+v).join(''))
	}
	console.assert(equals(checkBase([2,3],[1,5]), [2,13,15]))
	console.assert(equals(checkBase([2,3,1],[1,0,2]), [2,3,5,6,2]))
	console.assert(equals(checkBase([0,4,3,2,1],[1,2,3,4,5]), [0, 4, 11, 20, 30, 40, 26, 14, 5]))
//*
	test([2,3],[1,5])
	test([2,3,1],[1,0,2])
	test([0,4,3,2,1],[1,2,3,4,5])
	test(Range(100),Range(101).reverse())
	test(Range(1000),Range(1001).reverse())
//*/	
	//test(Range(10000),Range(10001).reverse())
	//*/
	//console.log(Array.from(bitTest(4)));
}()

function checkBase(a, b){
	let result = Array(a.length + b.length - 1).fill(0);
	for(let i=0; i<a.length; ++i){
		for(let j=0; j<b.length; ++j){
			result[i+j] += a[i] * b[j];
		}
	}
	return result;
}

function reverse(value, count){
	let result = 0;
	for(let i=0; i<count; ++i){
		result |= (value >> i & 1) << (count - 1 - i);
	}
	return result;
}

function*bitTest(count){
	let n = 1 << count;
	for(let i=0; i<n; ++i){
		yield reverse(i, count);
	}
}