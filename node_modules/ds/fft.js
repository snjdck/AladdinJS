'use strict';

const Complex = require('./Complex');
const {nextPowerOf2} = require('utils/math');
const {equals} = require('utils/array');

function calc(p){
	const p0 = [], p1 = [];
	for(let i=0, n=p.length; i<n; ++i){
		if(i % 2){
			p1.push(p[i]);
		}else{
			p0.push(p[i]);
		}
	}
	return [p0, p1];
}

function fftF2(invertFlag){
	return function fn(p, size){
		if(p.length == 1)return Array(size).fill(p[0]);
		const halfLen = size >> 1;
		let [a, b] = calc(p).map(v => fn(v, halfLen));
		b = Array.from(Complex.generateCircle(size, halfLen), (v, i) => (invertFlag ? v.conj() : v).mul(b[i]));
		const result = [];
		for(let i=0; i<halfLen; ++i){
			result[i] = a[i].add(b[i]);
			result[i+halfLen] = a[i].sub(b[i]);
		}
		return invertFlag ? result.map(v => v.mulR(0.5)) : result;
	}
}

function fftF(invertFlag){
	return function fn(p, n){
		if(p.length == 1)return p;
		const result = Array.from(Complex.generateCircle(n), v => (invertFlag ? v.conj() : v).prod(p));
		return invertFlag ? result.map(v => v.divR(n)) : result;
	}
}

function factory(fft, ifft){
	const realToComplex = v => new Complex(v);
	const complexToReal = v => Math.round(v.length());//round
	return function(pa, pb){
		const size = pa.length + pb.length - 1;
		const n = nextPowerOf2(size);
		pa = fft(pa.map(realToComplex), n);
		pb = fft(pb.map(realToComplex), n);
		let pc = pa.map((v, i) => v.mul(pb[i]));
		return ifft(pc, n).slice(0,size).map(complexToReal);
	}
}

void function(){
	function test(...args){
		let result = []
		for(let [a, b] of [[fftF, fftF], [fftF2, fftF], [fftF, fftF2], [fftF2, fftF2]]){
			let mytest = factory(a(), b(true));
			result.push(mytest(...args).join(','));
		}
		console.assert(result.every(v => v === result[0]), result.map(v => '\n'+v).join(''))
	}
	console.assert(equals(checkBase([2,3],[1,5]), [2,13,15]))
	console.assert(equals(checkBase([2,3,1],[1,0,2]), [2,3,5,6,2]))
	console.assert(equals(checkBase([0,4,3,2,1],[1,2,3,4,5]), [0, 4, 11, 20, 30, 40, 26, 14, 5]))

	test([2,3],[1,5])
	test([2,3,1],[1,0,2])
	test([0,4,3,2,1],[1,2,3,4,5])
	//*/
	//console.log(Array.from(bitTest(4)));
}()

function checkBase(a, b){
	let result = Array(a.length + b.length - 1).fill(0);
	for(let i=0; i<a.length; ++i){
		for(let j=0; j<b.length; ++j){
			result[i+j] += a[i] * b[j];
		}
	}
	return result;
}

function reverse(value, count){
	let result = 0;
	for(let i=0; i<count; ++i){
		result |= (value >> i & 1) << (count - 1 - i);
	}
	return result;
}

function*bitTest(count){
	let n = 1 << count;
	for(let i=0; i<n; ++i){
		yield reverse(i, count);
	}
}