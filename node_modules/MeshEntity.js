"use strict";

const DisplayObject3D = require("./DisplayObject3D");
const {MeshVertexArray} = require("./vertexarrays");
const {TextureMaterial} = require("./materials");

class BoneObject extends DisplayObject3D{
	constructor(entity, boneID){
		super();
		Object.defineProperty(this, "entity", {value:entity});
		Object.defineProperty(this, "boneID", {value:boneID});
	}
	onUpdate(timeElapsed){
		this.updateBoneState();
		super.onUpdate(timeElapsed);
	}
	updateBoneState(){
		let {entity} = this;
		let {animation} = entity;
		let info = animation.trackDict[this.boneID][0];
		let {rotation, translation} = this.transform;
		rotation.fromEulerAngles(info.rotation.x, info.rotation.y, info.rotation.z);
		translation.copyFrom(info.translation);
		this.onTransformChanged();
	}
}

class SubMeshEntity extends DisplayObject3D{
	constructor(subMesh, formatList){
		super();
		this.visible = true;
		this.subMesh = subMesh;
		this.vao = new MeshVertexArray(subMesh, formatList);
		let boneCount = subMesh.boneData.length;
		this.boneMatrixList = new Float32Array(boneCount > 0 ? boneCount * 8 : 8);
	}
	collectDrawUnits(collector, gl, mode){
		let {vao, boneMatrixList, parent, subMesh} = this;
		if(this.materials.length <= 0){
			let texture = gl.textureMgr.fetch(subMesh.texture);
			if(texture){
				this.materials.push(new TextureMaterial(texture));
			}
		}
		if(mode == "pick"){
			let uid = gl.mouseMgr.pickRegister(this);
			collector.addDrawUnit({vao, boneMatrixList, material:parent.hitTestMaterial, uid});
			return;
		}
		this.updateBoneMatrixList(parent.skeleton || parent);
		for(let material of this.materials){
			collector.addDrawUnit({vao, boneMatrixList, material});
		}
	}
	updateBoneMatrixList({worldTransform, boneList}){
		if(boneList == null){
			worldTransform.copyToArray(this.boneMatrixList);
			return;
		}
		let {boneMatrixList, subMesh:{boneData}} = this;
		for(let i=boneData.length-1; i>=0; --i){
			let boneID = boneData[i];
			boneList[boneID].worldTransform.copyToArray(boneMatrixList, i << 3);
		}
	}
}

class MeshEntity extends DisplayObject3D
{
	constructor(mesh, createSkeleton=true){
		super();
		console.log(mesh);
		this.mesh = mesh;
		mesh.subMeshList.map(subMesh => this.addChild(new SubMeshEntity(subMesh, mesh.formatList)));
		if(!(createSkeleton && mesh.boneList.length > 0)){
			return;
		}
		let boneDict = new Map();
		let boneList = [];
		for(let {boneName, boneID, bonePID} of mesh.boneList){
			let bone = new BoneObject(this, boneID);
			let boneParent = bonePID < 0 ? this : boneList[bonePID];
			boneParent.addChild(bone);
			boneDict[boneName] = bone;
			boneList[boneID] = bone;
		}
		this.boneDict = boneDict;
		this.boneList = boneList;
		this.animationList = mesh.animationList;
		this.animation = this.animationList[0];
	}

	shareSkeletonWith(target){
		this.skeleton = target;
	}

	getBoneEntity(name){
		return this.boneDict[name];
	}

	bindObjectToBone(boneName, target, clearOtherObjects=true){
		let boneEntity = this.getBoneEntity(boneName);
		if(clearOtherObjects){
			boneEntity.removeAllChildren();
		}
		if(target){
			boneEntity.addChild(target);
		}
	}

	unbindObjectToBone(boneName, target){
		let boneEntity = this.getBoneEntity(boneName);
		boneEntity.removeChild(target);
	}

	collectDrawUnits(collector, gl, mode){
		if(mode == "pick" && !(this.mouseEnabled && this.hitTestMaterial)){
			return;
		}
		super.collectDrawUnits(collector, gl, mode);
	}
}

module.exports = MeshEntity;