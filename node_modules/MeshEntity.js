const DisplayObject3D = require("./DisplayObject3D");

const Matrix3D = require("Matrix3D");
var worldMatrix = new Matrix3D();

class MeshEntity extends DisplayObject3D
{
	constructor(){
		super();
		this.vertexBuffer = null;
	}

	set mesh(value){
		console.log(value);
		this._mesh = value;
		var subMesh = this._mesh.subMeshList[0];

		this.vertexData = subMesh.vertexData;
		this.byteSizePerVertex = subMesh.data32PerVertex << 2;
		this.vertexCount = this.vertexData.byteLength / this.byteSizePerVertex;

		this.indexData = subMesh.indexData;
		this.indexCount = this.indexData.byteLength >> 1;
	}

	init(gl){
		this.vertexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);

		if(this.indexCount > 0){
			this.indexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData, gl.STATIC_DRAW);
		}
	}

	draw(gl){
		if(null == this.vertexBuffer){
			this.init(gl);
		}
		var program = gl.getParameter(gl.CURRENT_PROGRAM);
		var address = gl.getUniformLocation(program, "worldMatrix");
		gl.uniformMatrix4fv(address, false, worldMatrix);

		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

		var positionIndex = gl.getAttribLocation(program, "inputPosition");
		gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, this.byteSizePerVertex, 0);

		var uvIndex = gl.getAttribLocation(program, "inputUV");
		gl.vertexAttribPointer(uvIndex, 2, gl.FLOAT, false, this.byteSizePerVertex, 24);

		gl.bindTexture(gl.TEXTURE_2D, this.texture);
		gl.activeTexture(gl.TEXTURE0);

		if(this.indexCount > 0){
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
			gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
		}else{
			gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
		}
	}
}

module.exports = MeshEntity;