"use strict";

const DisplayObject3D = require("./DisplayObject3D");
const {MeshVertexArray} = require("./vertexarrays");

class BoneObject extends DisplayObject3D{
	constructor(entity, boneID){
		super();
		Object.defineProperty(this, "entity", {value:entity});
		Object.defineProperty(this, "boneID", {value:boneID});
	}
	onUpdate(timeElapsed){
		this.updateBoneState();
		super.onUpdate(timeElapsed);
	}
	updateBoneState(){
		let {entity} = this;
		let {animation} = entity;
		let info = animation.trackDict[this.boneID][0];
		let {rotation, translation} = this.transform;
		rotation.fromEulerAngles(info.rotation.x ,info.rotation.y, info.rotation.z);
		translation.copyFrom(info.translation);
		this.onTransformChanged();
	}
}

class MeshEntity extends DisplayObject3D
{
	constructor(){
		super();
	}

	set mesh(value){
		console.log(value);
		this._mesh = value;
		this.subMesh = this._mesh.subMeshList[0];
		this.vao = new MeshVertexArray(this.subMesh, value.formatList);
		if(value.boneList.length <= 0){
			return;
		}
		this.boneMatrixList = new Float32Array(this.subMesh.boneData.length * 8);
		let boneDict = new Map();
		for(let {boneName, boneID, bonePID} of value.boneList){
			let bone = new BoneObject(this, boneID);
			let boneParent = bonePID < 0 ? this : boneDict[bonePID];
			boneDict[boneName] = bone;
			boneDict[boneID] = bone;
			boneParent.addChild(bone);
		}

		this.boneDict = boneDict;
		this.animationList = value.animationList;
		this.animation = this.animationList[0];
	}

	collectDrawUnits(collector, gl, mode){
		if(!this._mesh){
			return;
		}
		if(mode == "pick"){
			if(!(this.mouseEnabled && this.hitTestMaterial)){
				return;
			}
			let uid = gl.mouseMgr.pickRegister(this);
			collector.addDrawUnit({vao:this.vao, material:this.hitTestMaterial, worldMatrix:this.worldTransform, uid, boneMatrixList:this.collectBoneMatrixList()});
			return;
		}
		for(let material of this.materials){
			collector.addDrawUnit({vao:this.vao, material, worldMatrix:this.worldTransform, boneMatrixList:this.collectBoneMatrixList()});
		}
	}

	collectBoneMatrixList(){
		this.subMesh.boneData.forEach((boneID, index) => this.boneDict[boneID].worldTransform.copyToArray(this.boneMatrixList, index * 8));
		return this.boneMatrixList;
	}
}

module.exports = MeshEntity;