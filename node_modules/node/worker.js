'use strict';

const {Worker} = require('worker_threads');
const os = require('os');
const createTask = require('../utils/task');

module.exports = function(code, count=os.cpus().length){
	const workerCode = `const handler = ${code};const {parentPort} = require('worker_threads');parentPort.on('message', data => parentPort.postMessage(handler(data)));`;
	const workerList = [];
	for(let i=0; i<count; ++i){
		workerList.push(new Worker(workerCode, {eval: true, workerData: i}));
	}
	/*
	return (nextIndex => function(task, callback){
		const worker = workerList[nextIndex()];
		worker.on('message', (offset => function onMessage(data){
			if(offset > 0)return --offset;
			worker.off('message', onMessage);
			callback(data);
		})(worker.listenerCount('message')));
		worker.postMessage(task);
	})((i => () => i = (i + 1) % count)(-1));
	//*/
	return createTask((task, callback) => new Promise(resolve => {
		const worker = workerList.pop();
		worker.once('message', data => {
			workerList.push(worker);
			callback?.(data);
			resolve();
		});
		worker.postMessage(task);
	}), workerList.length);
}

function sequeueCallback(handler){
	const waitList = [];
	return function(task, callback){
		const ctx = {callback};
		waitList.push(ctx);
		return handler(task, data => {
			ctx.data = data;
			while(waitList[0]?.hasOwnProperty('data')){
				const {callback, data} = waitList.shift();
				callback(data);
			}
		});
	};
}
