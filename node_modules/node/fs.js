'use strict';

const {join} = require('path');
const {
	readdirSync, rmdirSync, unlinkSync,
	readFile, writeFile,
} = require('fs');

/*
function clearFolderSync(path, deleteSelf=false){
	for(const file of readdirSync(path, options)){
		const real_path = join(path, file.name);
		if(file.isDirectory()){
			clearFolderSync(real_path, true);
		}else if(file.isFile()){
			unlinkSync(real_path);
		}
	}
	if(deleteSelf)rmdirSync(path);
}
*/

const walkDir = function(){
	const options = {withFileTypes:true};
	return function(path, callback, dirFlag=0, selfFlag=false){
		if(dirFlag & 1 && selfFlag)callback(path, 1);
		for(const child of readdirSync(path, options)){
			const child_path = join(path, child.name);
			if(child.isDirectory()){
				walkDir(child_path, callback, dirFlag, true);
			}else if(child.isFile()){
				callback(child_path, 0);
			}
		}
		if(dirFlag & 2 && selfFlag)callback(path, 2);
	};
}();

function createFromDir(path, callback, selfFlag=false){
	const stack = [[]];
	walkDir(path, (path, flag) => {
		switch(flag){
			case 1:
				stack.push([]);
				break;
			case 2:
				stack[stack.length-2].push(callback(path, stack.pop()));
				break;
			default:
				stack[stack.length-1].push(callback(path));
		}
	}, 3, selfFlag);
	return selfFlag ? stack[0][0] : stack[0];
}

const createXmlFromDir = function(){
	const mapJoin = fn => list => list.map(fn).join('');
	const joinChildren = mapJoin(v => v.replace(/^/gm, '\t') + '\n');
	const joinAttr = mapJoin(([k, v]) => ` ${k}=${JSON.stringify(v)}`);
	const castAttr = attr => attr ? joinAttr(Object.entries(attr)) : '';
	return function(path, callback){
		return createFromDir(path, (path, children) => {
			const [tag, attr, text] = callback(path, children);
			if(children){
				return `<${tag}${castAttr(attr)}>\n${joinChildren(children)}</${tag}>`;
			}
			return `<${tag}${castAttr(attr)}>${text || ''}</${tag}>`;
		}, true);
	};
}();

const clearFolderSync = function(){
	const callback = (path, isDir) => (isDir ? rmdirSync : unlinkSync)(path);
	return (path, deleteSelf) => walkDir(path, callback, 2, deleteSelf);
}();

function writeFileAsync(path, data){
	return new Promise((resolve, reject) => {
		writeFile(path, data, error => error ? reject(error) : resolve());
	});
}

function readFileAsync(path, encoding=null){
	return new Promise((resolve, reject) => {
		readFile(path, {encoding}, (error, data) => error ? reject(error) : resolve(data));
	});
}
/*
function walkDir(path, callback, dirFlag=0){
	for(const file of readdirSync(path, options)){
		const real_path = join(path, file.name);
		if(file.isDirectory()){
			if(dirFlag < 0)callback(real_path, true);
			walkDir(real_path, callback, dirFlag);
			if(dirFlag > 0)callback(real_path, true);
		}else if(file.isFile()){
			callback(real_path, false);
		}
	}
}
*/
exports.clearFolderSync = clearFolderSync;
exports.writeFileAsync = writeFileAsync;
exports.readFileAsync = readFileAsync;
exports.walkDir = walkDir;
exports.createFromDir = createFromDir;
exports.createXmlFromDir = createXmlFromDir;
