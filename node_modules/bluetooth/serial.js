
const {limitSend} = require('../utils/sender');
const {loadData} = require('../utils/loader');
const {composeFactory, listenReadableStream, writeWritableStream} = require('../net/packet');
const {message} = antd;

const serialOptions = {baudrate: 115200};

const composeFn = composeFactory(
	(value, buffer) => buffer.push(...value),
	(buffer, recvCount) => (buffer.length == 2 + recvCount) && (buffer[0] == 0x14 && buffer[1+recvCount] == 0x10),
	buffer => buffer.slice(1, -1)
);

const replyFn = composeFactory(
	(value, buffer) => buffer.push(...value),
	(buffer) => buffer.length >= 6 && buffer[buffer.length-2] == 0xA && buffer[2] == buffer.length,
);

async function connectBLE(){
	const {serial} = navigator;
	if(!serial){
		console.warn('no serial');
		return;
	}
	serial.ondisconnect = evt => console.log('disconnect', evt.port);
	let list = await serial.getPorts();
	//return;
	//const port = await serial.requestPort({filters:[{vendorId:0x1A86,productId:0x7523}]});
	const port = await serial.requestPort(serialOptions);
	await port.open(serialOptions);
	await delay(2);
	
	function sendArray(v, n=0){
		writeWritableStream(port.writable, new Uint8Array(v));
		return listenReadableStream(port.readable, composeFn([], n));
	}
	window.resetBLE = async function(data, stepFn, progressFn){
		const payload = new Uint8Array(data);

		await port.setSignals({ dtr: false });
		await port.setSignals({ dtr: true });
		
		await delay(0.4);
		await sendArray([0x30, 0x20]);
		await sendArray([0x50, 0x20]);
		let address = 0;
		let addressInfo = [0x55, 0, 0, 0x20];
		const pageSize = 0x80;

		while(address < payload.length){
			let bytesSend = Math.min(pageSize, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			await sendArray([
				0x64, 0x00, bytesSend, 0x46,
				...payload.slice(address, address + bytesSend),
				0x20
			]);
			address += bytesSend;
			if(progressFn)progressFn(address / payload.length)
			/*message.info({
				key:'upload',
				duration: address < payload.length ? 0 : 3,
				content: `正在上传 ${Math.round(100 * address / payload.length)}%`
			})*/
		}

		address = 0;
		let recvData = [];
		if(stepFn)stepFn()
		while(address < payload.length){
			let bytesSend = Math.min(pageSize, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			let data = await sendArray([
				0x74, 0x00, bytesSend, 0x46,
				0x20
			], bytesSend);
			recvData.push(...data);
			address += bytesSend;
			if(progressFn)progressFn(address / payload.length)
			/*message.info({
				key:'verify',
				duration: address < payload.length ? 0 : 3,
				content: `正在验证 ${Math.round(100 * address / payload.length)}%`
			})*/
		}

		await sendArray([0x51, 0x20]);
		//server.disconnect();
		if(isEqual(payload, recvData)){
			message.success('固件上传成功');
		}else{
			message.error('固件上传失败');
		}
		
	}
	window.sendBLERawData = function(v){
		//const sendFn = () => limitSend((v, c) => writer.write(new Uint8Array(v)).then(c), v);
		writeWritableStream(port.writable, new Uint8Array(v));
		return listenReadableStream(port.readable, replyFn([])).then(buffer => {
			if(!buffer)return console.log('buffer empty');
			switch(buffer[3]){
				case 0: return;
				case 1: return buffer[4];
				case 2: return buffer[4] << 8 | buffer[5];
				case 3: return buffer.slice(4, buffer[2]-2);
			}
			console.error('buffer type error', buffer);
		}, error => console.error('listen error', error));
	}
}

const isEqual = (a, b) => a.every((v, i) => v === b[i]);

const delay = v => new Promise(resolve => setTimeout(resolve, v * 1000));

function str2ab(text){
	let list = new Uint8Array(text.length);
	list.forEach((_, i) => list[i] = text.charCodeAt(i));
	return list.buffer;
}

exports.connectBLE = connectBLE;
