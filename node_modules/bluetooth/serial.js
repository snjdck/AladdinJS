
const {limitSend} = require('../utils/sender');
const {loadData} = require('../utils/loader');
const {message} = antd;

async function connectBLE(){
	const {serial} = navigator;
	if(!serial){
		console.warn('no serial');
		return;
	}
	let list = await serial.getPorts();
	console.log(list);
	const port = await serial.requestPort({filters:[{vendorId:0x1A86,productId:0x7523}]});
	await port.open({baudrate: 115200});
	await delay(2);
	const reader = port.readable.getReader();
	const writer = port.writable.getWriter();
	//reader.releaseLock();
	//writer.releaseLock();
	function sendArray(v, n=0){
		return new Promise(resolve => {
			listen(() => reader.read(), (value, buffer) => {
				buffer.push(...value);
				if(buffer.length == 2 + n){
					if(buffer[0] == 0x14 && buffer[1+n] == 0x10){
						resolve(buffer.slice(1, -1));
						return true;
					}
				}
			}, []);
			writer.write(new Uint8Array(v));
		});
	}
	window.resetBLE = async function(){
		
		//reader.releaseLock();
		//writer.releaseLock();
		//await port.open({baudrate: 115200});
	//	let data = await loadData('./weeebot_factory_firmware.hex');
		let data = await loadData('./online_firmware_328p.hex');
		let payload = Array.from(data.trim()
			.split(/\s+/)
			.map(line => line.slice(9, -2))
			.join("")
			.match(/\w{2}/g),
			v => parseInt(v, 16)
		);
		await port.setSignals({ dtr: false });
		await port.setSignals({ dtr: true });
		//return
		await delay(0.1);
		await sendArray([0x30, 0x20]);
		await sendArray([0x50, 0x20]);
		//return;
		let address = 0;
		let addressInfo = [0x55, 0, 0, 0x20];
		const pageSize = 0x80;

		while(address < payload.length){
			let bytesSend = Math.min(pageSize, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			await sendArray([
				0x64, 0x00, bytesSend, 0x46,
				...payload.slice(address, address + bytesSend),
				0x20
			]);
			address += bytesSend;
			message.info({
				key:'upload',
				duration: address < payload.length ? 0 : 3,
				content: `正在上传 ${Math.round(100 * address / payload.length)}%`
			})
		}

		address = 0;
		let recvData = [];

		while(address < payload.length){
			let bytesSend = Math.min(pageSize, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			let data = await sendArray([
				0x74, 0x00, bytesSend, 0x46,
				0x20
			], bytesSend);
			recvData.push(...data);
			address += bytesSend;
			message.info({
				key:'verify',
				duration: address < payload.length ? 0 : 3,
				content: `正在验证 ${Math.round(100 * address / payload.length)}%`
			})
		}

		await sendArray([0x51, 0x20]);
		//server.disconnect();
		if(isEqual(payload, recvData)){
			message.success('固件上传成功');
		}else{
			message.error('固件上传失败');
		}
		
	}
	window.sendBLERawData = function(v){
		return new Promise((resolve, reject) => {
			listen(() => reader.read(), (value, buffer) => {
				buffer.push(...value);
				if(buffer.length < 6)return;
				if(buffer[buffer.length-2] != 0xA || buffer[2] != buffer.length)return;
				let result;
				switch(buffer[3]){
					case 0:
						break;
					case 1:
						result = buffer[4];
						break;
					case 2:
						result = buffer[4] << 8 | buffer[5];
						break;
					case 3:
						result = buffer.slice(4, buffer[2]-2);
						break;
					case 255:
						buffer.length = 0;
						sendFn();
						return;
					default:
						console.log('error')
				}
				resolve(result);
				return true;
			}, []);
			//const sendFn = () => limitSend((v, c) => writer.write(new Uint8Array(v)).then(c), v);
			const sendFn = () => writer.write(new Uint8Array(v));
			sendFn();
		});
	}
}

const isEqual = (a, b) => a.every((v, i) => v === b[i]);

const delay = v => new Promise(resolve => setTimeout(resolve, v * 1000));

function str2ab(text){
	let list = new Uint8Array(text.length);
	list.forEach((_, i) => list[i] = text.charCodeAt(i));
	return list.buffer;
}

function listen(readFn, callback, ...args){
	function onData({done, value}){
		if(callback(value, ...args))return;
		readFn().then(onData);
	}
	readFn().then(onData);
}


exports.connectBLE = connectBLE;
