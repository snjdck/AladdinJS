'use strict';

const {limitSend} = require('../utils/sender');
const {loadData} = require('../utils/loader');
const {message} = antd;

async function connectBLE(){
	const {bluetooth} = navigator;
	if(!bluetooth){
		message.warn('no bluetooth');
		return;
	}
	const option = {
		filters:[{namePrefix:'WeeeMake_'}],
		optionalServices:[0xf100, 0xf200]
	};
	let device;

	try{
		device = await bluetooth.requestDevice(option);
	}catch(error){
		message.error('requestDevice' + error);
		return;
	}
	
	message.info('device:' + device.name);
	let server = device.gatt;
	if(!server.connected){
		message.info('try reconnect');
		server = await server.connect();
	}
	if(!server.connected){
		return;
	}
	device.ongattserverdisconnected = async function(){
		messge.info('ongattserverdisconnected');
	}
	message.info('connect:' +  server.connected);
	let service = await server.getPrimaryService(0xf100);
	let readMod = await service.getCharacteristic(0xf102);
	let sendMod = await service.getCharacteristic(0xf101);

	let dtrService = await server.getPrimaryService(0xf200);
	let resetMod = await dtrService.getCharacteristic(0xf202);
	//await resetMod.writeValue(new Uint8Array([1]).buffer);
	readMod.oncharacteristicvaluechanged = function(evt){
		let dataView = evt.target.value;
		message.info('dataView:'+ String.fromCharCode(...new Uint8Array(dataView.buffer)))
		//if(window.onBLEData)window.onBLEData(String.fromCharCode(...new Uint8Array(dataView.buffer)));
		//console.log('msg', String.fromCharCode(...new Uint8Array(dataView.buffer)));
	}
	await readMod.startNotifications();
	message.success('success');
	//await delay(5)
	//await sendMod.writeValue(str2ab("BZ 484 500\r\n"));
	//await sendMod.writeValue(str2ab("VER\r\n"));
	//const sendArray = v => sendMod.writeValue(new Uint8Array(v).buffer);
	function listenData(callback, recvCount=0){
		const buffer = [];
		readMod.oncharacteristicvaluechanged = function(evt){
			let dataView = evt.target.value;
			let list = new Uint8Array(dataView.buffer);
			buffer.push(...list);
			if(buffer.length == 2 + recvCount){
				if(buffer[0] == 0x14 && buffer[1+recvCount] == 0x10){
					readMod.oncharacteristicvaluechanged = null;
					callback(buffer.slice(1, -1));
				}
			}
		}
	}
	const sendArray = (v, n=0) => new Promise(resolve => {
		listenData(resolve, n);
		limitSend((v, c) => sendMod.writeValue(v).then(c), new Uint8Array(v).buffer);
	})

	window.resetBLE = async function(data){
		let payload = Array.from(data.trim()
			.split(/\s+/)
			.map(line => line.slice(9, -2))
			.join("")
			.match(/\w{2}/g),
			v => parseInt(v, 16)
		);

		await resetMod.writeValue(new Uint8Array([1]).buffer);
		await resetMod.writeValue(new Uint8Array([0]).buffer);
		//return
		await delay(0.1);
		await sendArray([0x30, 0x20]);
		await sendArray([0x50, 0x20]);
		
		let address = 0;
		let addressInfo = [0x55, 0, 0, 0x20];

		while(address < payload.length){
			let bytesSend = Math.min(0x80, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			await sendArray([
				0x64, 0x00, bytesSend, 0x46,
				...payload.slice(address, address + bytesSend),
				0x20
			]);
			address += bytesSend;
			message.info({
				key:'upload',
				duration: address < payload.length ? 0 : 3,
				content: `正在上传 ${Math.round(100 * address / payload.length)}%`
			})
		}

		address = 0;
		let recvData = [];

		while(address < payload.length){
			let bytesSend = Math.min(0x80, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			let data = await sendArray([
				0x74, 0x00, bytesSend, 0x46,
				0x20
			], bytesSend);
			recvData.push(...data);
			address += bytesSend;
			message.info({
				key:'verify',
				duration: address < payload.length ? 0 : 3,
				content: `正在验证 ${Math.round(100 * address / payload.length)}%`
			})
		}

		await sendArray([0x51, 0x20]);
		
		if(isEqual(payload, recvData)){
			message.success('固件上传成功');
		}else{
			message.error('固件上传失败');
		}
	}
	window.sendBLERawData = function(v){
		return new Promise((resolve, reject) => {
			let buffer = Buffer.alloc(0);
			let result;
			readMod.oncharacteristicvaluechanged = function(evt){
				let dataView = evt.target.value;
				let data = new Uint8Array(dataView.buffer);
				buffer = Buffer.concat([buffer, data]);
				if(buffer.indexOf(0xA) < 0)return;
				switch(buffer[3]){
					case 0:
						break;
					case 1:
						result = buffer[4];
						break;
					case 2:
						result = buffer[4] << 8 | buffer[5];
						break;
					case 3:
						result = buffer.slice(4, buffer[2]-2);
						break;
					case 255:
						console.log('re send', v);
						buffer = Buffer.alloc(0);
						sendMod.writeValue(v);
						return;
					default:
						console.log('error')
				}
				console.log('recv', data, buffer, result);
				readMod.oncharacteristicvaluechanged = null;
				resolve(result);
			}

			limitSend((v, c) => sendMod.writeValue(v).then(c), v);
		});
	}
}

const isEqual = (a, b) => a.every((v, i) => v === b[i]);

const delay = v => new Promise(resolve => setTimeout(resolve, v * 1000));

function str2ab(text){
	let list = new Uint8Array(text.length);
	list.forEach((_, i) => list[i] = text.charCodeAt(i));
	return list.buffer;
}

exports.connectBLE = connectBLE;
