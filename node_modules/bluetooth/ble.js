'use strict';

const {limitSend} = require('../utils/sender');
const {loadData} = require('../utils/loader');
const {composeFactory, listenData} = require('../net/packet');
const {message} = antd;

const composeFn = composeFactory(
	(evt, buffer) => buffer.push(...new Uint8Array(evt.target.value.buffer)),
	(buffer, recvCount) => (buffer.length == 2 + recvCount) && (buffer[0] == 0x14 && buffer[1+recvCount] == 0x10),
	buffer => buffer.slice(1, -1)
);

async function connectBLE(){
	const {bluetooth} = navigator;
	if(!bluetooth){
		message.warn('no bluetooth');
		return;
	}
	const option = {
		filters:[{namePrefix:'WeeeMake_'}],
		optionalServices:[0xf100, 0xf200]
	};
	let device;

	try{
		device = await bluetooth.requestDevice(option);
	}catch(error){
		message.error('requestDevice' + error);
		return;
	}
	
	let server = device.gatt;
	if(!server.connected){
		server = await server.connect();
	}
	if(!server.connected){
		return;
	}
	device.ongattserverdisconnected = async function(){
		message.info('ongattserverdisconnected');
	}
	let service = await server.getPrimaryService(0xf100);
	let readMod = await service.getCharacteristic(0xf102);
	let sendMod = await service.getCharacteristic(0xf101);

	let dtrService = await server.getPrimaryService(0xf200);
	let resetMod = await dtrService.getCharacteristic(0xf202);

	const listenReadMod = (handler, recvCount) => listenData(readMod, 'characteristicvaluechanged', composeFn([], recvCount), handler);
	
	await readMod.startNotifications();
	message.success('蓝牙连接成功');
	
	const sendArray = (v, n=0) => new Promise(resolve => {
		listenReadMod(resolve, n);
		limitSend((v, c) => sendMod.writeValue(v).then(c), new Uint8Array(v).buffer);
	});

	const enterUploadMode = () => new Promise(resolve => {
		const timer = setInterval(() => {
			sendMod.writeValue(new Uint8Array([0x30, 0x20]).buffer);
		}, 50);
		listenReadMod(() => {
			clearInterval(timer);
			resolve();
		}, 0);
	});

	window.resetBLE = async function(data, stepFn, progressFn){
		const payload = new Uint8Array(data);

		await resetMod.writeValue(new Uint8Array([1]).buffer);
		await resetMod.writeValue(new Uint8Array([0]).buffer);
		
		await delay(0.4);
		await sendArray([0x30, 0x20]);
		await sendArray([0x50, 0x20]);
		
		let address = 0;
		let addressInfo = [0x55, 0, 0, 0x20];
		while(address < payload.length){
			let bytesSend = Math.min(0x80, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			await sendArray([
				0x64, 0x00, bytesSend, 0x46,
				...payload.slice(address, address + bytesSend),
				0x20
			]);
			address += bytesSend;
			if(progressFn)progressFn(address / payload.length)
			/*message.info({
				key:'upload',
				duration: address < payload.length ? 0 : 3,
				content: `正在上传 ${Math.round(100 * address / payload.length)}%`
			})*/
		}

		address = 0;
		let recvData = [];
		if(stepFn)stepFn()
		while(address < payload.length){
			let bytesSend = Math.min(0x80, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			let data = await sendArray([
				0x74, 0x00, bytesSend, 0x46,
				0x20
			], bytesSend);
			recvData.push(...data);
			address += bytesSend;
			if(progressFn)progressFn(address / payload.length)
			/*message.info({
				key:'verify',
				duration: address < payload.length ? 0 : 3,
				content: `正在验证 ${Math.round(100 * address / payload.length)}%`
			})*/
		}

		await sendArray([0x51, 0x20]);
		/*
		if(isEqual(payload, recvData)){
			message.success('固件上传成功');
		}else{
			message.error('固件上传失败');
		}*/
	}
	window.sendBLERawData = function(v){
		return new Promise((resolve, reject) => {
			let buffer = Buffer.alloc(0);
			let result;
			readMod.oncharacteristicvaluechanged = function(evt){
				let dataView = evt.target.value;
				let data = new Uint8Array(dataView.buffer);
				buffer = Buffer.concat([buffer, data]);
				if(buffer.indexOf(0xA) < 0)return;
				switch(buffer[3]){
					case 0:
						break;
					case 1:
						result = buffer[4];
						break;
					case 2:
						result = buffer[4] << 8 | buffer[5];
						break;
					case 3:
						result = buffer.slice(4, buffer[2]-2);
						break;
					case 255:
						console.log('re send', v);
						buffer = Buffer.alloc(0);
						sendMod.writeValue(v);
						return;
					default:
						console.log('error')
				}
				console.log('recv', data, buffer, result);
				readMod.oncharacteristicvaluechanged = null;
				resolve(result);
			}

			limitSend((v, c) => sendMod.writeValue(v).then(c), v);
		});
	}
}

const isEqual = (a, b) => a.every((v, i) => v === b[i]);

const delay = v => new Promise(resolve => setTimeout(resolve, v * 1000));

function str2ab(text){
	let list = new Uint8Array(text.length);
	list.forEach((_, i) => list[i] = text.charCodeAt(i));
	return list.buffer;
}

exports.connectBLE = connectBLE;
