'use strict';

const bluetooth = require('../webonly/bluetooth');
const {composeFactory} = require('../net/packet');
const {message} = antd;

const composeFn = composeFactory(
	(evt, buffer) => buffer.push(...new Uint8Array(evt.target.value.buffer)),
	(buffer, recvCount) => (buffer.length == 2 + recvCount) && (buffer[0] == 0x14 && buffer[1+recvCount] == 0x10),
	buffer => buffer.slice(1, -1)
);

const replyFn = composeFactory(
	(evt, buffer) => buffer.push(...new Uint8Array(evt.target.value.buffer)),
	(buffer) => buffer.length >= 6 && buffer[buffer.length-2] == 0xA && buffer[2] == buffer.length,
);

const parseReply = buffer => {
	if(!buffer)return console.log('buffer empty');
	switch(buffer[3]){
		case 0: return;
		case 1: return buffer[4];
		case 2: return buffer[4] << 8 | buffer[5];
		case 3: return buffer.slice(4, buffer[2]-2);
	}
	console.error('buffer type error', buffer);
};

const option = {
	filters:[{namePrefix:'WeeeMake_'}],
	optionalServices:[0xf100, 0xf200]
};

async function connectBLE(){
	switch(await bluetooth.check()){
		case 1:
			message.warn('no bluetooth');
			return;
		case 2:
			message.warn('bluetooth not available');
			return;
	}
	let device;
	try{
		device = await bluetooth.requestDevice(option);
	}catch(error){
		message.error(error.toString());
		return;
	}

	if(!device)return;//user not select
	if(device.gatt.connected)return;
	await device.gatt.connect();
	device.ongattserverdisconnected = function(...args){
		message.info('ongattserverdisconnected', args);
		console.log(args)
	}

	const [sendMod, readMod] = await bluetooth.getService(device.gatt, 0xf100, [0xf101, 0xf102]);
	const [resetMod] = await bluetooth.getService(device.gatt, 0xf200, [0xf202]);
	await readMod.startNotifications();
	message.success('蓝牙连接成功');

	window.sendBLERawData = arrayBuffer => new Promise((resolve, reject) => {
		bluetooth.listenNotifications(readMod, replyFn([]), buffer => resolve(parseReply(buffer)));
		bluetooth.writeValue(sendMod, arrayBuffer);
	});

	const sendArray = (array, recvCount=0) => new Promise(resolve => {
		bluetooth.listenNotifications(readMod, composeFn([], recvCount), resolve);
		bluetooth.writeValue(sendMod, new Uint8Array(array).buffer);
	});

	window.resetBLE = async function(data, stepFn, progressFn){
		const payload = new Uint8Array(data);

		await resetMod.writeValue(new Uint8Array([1]).buffer);
		await resetMod.writeValue(new Uint8Array([0]).buffer);
		await delay(0.4);
		await sendArray([0x30, 0x20]);
		await sendArray([0x50, 0x20]);
		
		let address = 0;
		let addressInfo = [0x55, 0, 0, 0x20];
		while(address < payload.length){
			let bytesSend = Math.min(0x80, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			await sendArray([
				0x64, 0x00, bytesSend, 0x46,
				...payload.slice(address, address + bytesSend),
				0x20
			]);
			address += bytesSend;
			if(progressFn)progressFn(address / payload.length)
			/*message.info({
				key:'upload',
				duration: address < payload.length ? 0 : 3,
				content: `正在上传 ${Math.round(100 * address / payload.length)}%`
			})*/
		}

		address = 0;
		let recvData = [];
		if(stepFn)stepFn()
		while(address < payload.length){
			let bytesSend = Math.min(0x80, payload.length - address);
			addressInfo[1] = (address >> 1) & 0xFF;
			addressInfo[2] = (address >> 9) & 0xFF;
			await sendArray(addressInfo);
			let data = await sendArray([
				0x74, 0x00, bytesSend, 0x46,
				0x20
			], bytesSend);
			recvData.push(...data);
			address += bytesSend;
			if(progressFn)progressFn(address / payload.length)
			/*message.info({
				key:'verify',
				duration: address < payload.length ? 0 : 3,
				content: `正在验证 ${Math.round(100 * address / payload.length)}%`
			})*/
		}

		await sendArray([0x51, 0x20]);
		/*
		if(isEqual(payload, recvData)){
			message.success('固件上传成功');
		}else{
			message.error('固件上传失败');
		}*/
	}
}

const isEqual = (a, b) => a.every((v, i) => v === b[i]);

const delay = v => new Promise(resolve => setTimeout(resolve, v * 1000));

function str2ab(text){
	let list = new Uint8Array(text.length);
	list.forEach((_, i) => list[i] = text.charCodeAt(i));
	return list.buffer;
}

exports.connectBLE = connectBLE;
