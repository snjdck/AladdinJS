

async function connectBLE(){
	const {bluetooth} = navigator;
	if(!bluetooth){
		console.warn('no bluetooth');
		return;
	}
	if(window.sendBLEData)return;
	const option = {
		filters:[{namePrefix:'WeeeMake_'}],
		optionalServices:[0xf100]
	};
	let device;

	try{
		device = await bluetooth.requestDevice(option);
	}catch(error){
		console.error('requestDevice', error);
		return;
	}
	
	console.log('device', device.name);
	let server = device.gatt;
	if(!server.connected){
		console.log('try reconnect');
		server = await server.connect();
	}
	if(!server.connected){
		return;
	}
	device.ongattserverdisconnected = async function(){
		console.log('ongattserverdisconnected');
	}
	console.log('connect', server.connected);
	let service = await server.getPrimaryService(0xf100);
	let readMod = await service.getCharacteristic(0xf102);
	let sendMod = await service.getCharacteristic(0xf101);
	/*readMod.oncharacteristicvaluechanged = function(evt){
		let dataView = evt.target.value;
		if(window.onBLEData)window.onBLEData(String.fromCharCode(...new Uint8Array(dataView.buffer)));
		//console.log('msg', String.fromCharCode(...new Uint8Array(dataView.buffer)));
	}*/
	await readMod.startNotifications();
	await delay(1);
	window.sendBLERawData = function(v){
		return new Promise((resolve, reject) => {
			let buffer = Buffer.alloc(0);
			let result;
			readMod.oncharacteristicvaluechanged = function(evt){
				let dataView = evt.target.value;
				let data = new Uint8Array(dataView.buffer);
				buffer = Buffer.concat([buffer, data]);
				if(buffer.indexOf(0xA) < 0)return;
				switch(buffer[3]){
					case 0:
						break;
					case 1:
						result = buffer[4];
						break;
					case 2:
						result = buffer[4] << 8 | buffer[5];
						break;
					case 3:
						result = buffer.slice(4, buffer[2]-2);
						break;
					case 255:
						console.log('re send', v);
						buffer = Buffer.alloc(0);
						sendMod.writeValue(v);
						return;
					default:
						console.log('error')
				}
				console.log('recv', data, buffer, result);
				readMod.oncharacteristicvaluechanged = null;
				resolve(result);
			}
			if(v.byteLength <= 20){
				sendMod.writeValue(v);
				return;
			}

			function copy(offset, count){
				let list = new Uint8Array(count);
				list.set(new Uint8Array(v, offset, count));
				return list.buffer;
			}

			(offset => function doSend(){
				if(v.byteLength - offset <= 20){
					sendMod.writeValue(copy(offset, v.byteLength - offset));
					return;
				}
				sendMod.writeValue(copy(offset, 20)).then(doSend);
				offset += 20;
			})(0)();
		});
	}
	window.sendBLEData = v => sendMod.writeValue(str2ab(v + "\r\n"));
	//await sendMod.writeValue(str2ab("BZ 484 500\r\n"));
	//await delay(1);
	//await sendMod.writeValue(str2ab("VER\r\n"));
	//console.log('send success');
}

const delay = v => new Promise(resolve => setTimeout(resolve, v * 1000));

function str2ab(text){
	let list = new Uint8Array(text.length);
	list.forEach((_, i) => list[i] = text.charCodeAt(i));
	return list.buffer;
}
