'use strict';

const {composeFactory} = require('../net/packet');

const pageSize = 0x100;
const isEqual = (a, b) => a.every((v, i) => v === b[i]);
const delay = v => new Promise(resolve => setTimeout(resolve, v * 1000));

function sendFnWrapper(sendFn){
	const index = (v => () => v = (v + 1) & 0xFF)(0);
	const checksum = v => v.reduce((s, v) => s ^ v, 0);
	return function(value){
		const buffer = Buffer.from([0x1B, index(), 0, 0, 0x0E, ...value, 0]);
		buffer.writeUInt16BE(value.length, 2);
		buffer.writeUInt8(checksum(buffer), buffer.length - 1);
		return sendFn(buffer);
	}
}

const checkerFactory = concatFn => composeFactory(
	concatFn,
	buffer => (buffer.length >= 6) && (buffer[2] << 8 | buffer[3]) == buffer.length - 6,
	buffer => buffer.slice(5, -1)
);

const loadAddress = (sendFn, value) => sendFn([0x06, 0x80, value >> 17 & 0xFF, value >> 9 & 0xFF, value >> 1 & 0xFF]);

async function doWrite(payload, sendFn, progressFn){
	for(let address=0; address < payload.length;){
		const bytesSend = Math.min(pageSize, payload.length - address);
		await loadAddress(sendFn, address);
		await sendFn([
			0x13, bytesSend >> 8, bytesSend & 0xFF, 0xc1, 0x0a, 0x40, 0x4c, 0x20, 0x00, 0x00,
			...payload.slice(address, address + bytesSend)
		]);
		address += bytesSend;
		progressFn(address / payload.length);
	}
}

async function doRead(length, sendFn, progressFn){
	const recvData = [];
	for(let address=0; address < length;){
		const bytesSend = Math.min(pageSize, length - address);
		await loadAddress(sendFn, address);
		const data = await sendFn([0x14, bytesSend >> 8, bytesSend & 0xFF, 0x20]);
		recvData.push(...data.slice(2, -1));
		address += bytesSend;
		progressFn(address / length);
	}
	return recvData;
}

/*
payload = array
resetFn = () => Promise<Void>
sendFn = (array, recvCount=0) => Promise<Array>
progressFn = (percent) => Void
//*/
async function upload(payload, resetFn, sendFn, progressFn){
	await resetFn();
	await delay(0.4);
	await sendFn([0x10, 0xc8, 0x64, 0x19, 0x20, 0x00, 0x53, 0x03, 0xac, 0x53, 0x00, 0x00]);
	await doWrite(payload, sendFn, v => progressFn(0.5 * v));
	const recvData = await doRead(payload.length, sendFn, v => progressFn(0.5 * (v + 1)));
	await sendFn([0x11, 0x01, 0x01]);
	return isEqual(payload, recvData);
}

exports.sendFnWrapper = sendFnWrapper;
exports.checkerFactory = checkerFactory;
exports.upload = upload;
