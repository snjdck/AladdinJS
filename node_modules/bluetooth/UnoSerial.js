
const ChromeSerial = require('webonly/chrome/ChromeSerial');
const {TaskQueue} = require('utils/task');
const {waitWhen} = require('utils/events');
const {composeFactory} = require('net/packet');
const {checker328p:checkerFactory, upload328p:upload} = require('./avr');

class Serial extends ChromeSerial
{
	constructor(){
		super();
		this.sendQueue = TaskQueue();
		this.on('closed', () => this.emit('packet'));
	}

	async reset(){
		await this.setControlSignals({dtr:false});
		await this.setControlSignals({dtr:true});
	}
}

function concatFn(value, buffer){
	buffer.push(...new Uint8Array(value));
	while(buffer[0] == 0)buffer.shift();//delete bluetooth extra byte
}

Serial.prototype.send = function(){
	function checksum(buffer){
		let result = 0;
		const n = buffer.length - 1;
		for(let i=0; i<n; ++i){
			result += buffer[i];
		}
		return (result & 0xFF) == buffer[n];
	}

	const replyFn = composeFactory(
		concatFn,
		buffer => buffer.length >= 6 && buffer[0] == 0x52 && buffer[2] == buffer.length && buffer[buffer.length-2] == 0xA && checksum(buffer),
		buffer => {
			switch(buffer[3]){
				case 1: return buffer[4];
				case 2: return buffer[4] << 8 | buffer[5];
				case 3: return buffer.slice(4, buffer[2]-2);
			}
		}
	);

	return function(buffer){
		return this.sendQueue(() => {
			if(!this.isConnected())return;
			const timeout = buffer[3] == 8 ? buffer.readUInt16LE(7) + 50 : 300;
			return this.send_buffer(buffer).then(() => waitWhen(this, 'data', timeout, replyFn([]))).catch(() => 0);
		});
	}
}();

Serial.prototype.upload = function(){
	const composeFn = checkerFactory(concatFn);
	return function(data, progressFn){
		return upload(
			data,
			() => this.reset(),
			(array, recvCount=0) => this.send_buffer(Uint8Array.from(array)).then(() => waitWhen(this, 'data', 500, composeFn([], recvCount))),
			progressFn,
			false
		);
	}
}();

module.exports = Serial;