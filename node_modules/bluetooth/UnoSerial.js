
const ChromeSerial = require('webonly/chrome/ChromeSerial');
const {TaskQueue} = require('utils/task');
const {waitWhen} = require('utils/events');
const {composeFactory} = require('net/packet');

function checksum(buffer){
	let result = 0;
	const n = buffer.length - 1;
	for(let i=0; i<n; ++i){
		result += buffer[i];
	}
	return (result & 0xFF) == buffer[n];
}

const replyFn = composeFactory(
	(value, buffer) => {
		buffer.push(...Uint8Array.from(value));
		while(buffer[0] == 0)buffer.shift();//delete bluetooth extra byte
	},
	buffer => buffer.length >= 6 && buffer[0] == 0x52 && buffer[2] == buffer.length && buffer[buffer.length-2] == 0xA && checksum(buffer),
	buffer => {
		switch(buffer[3]){
			case 1: return buffer[4];
			case 2: return buffer[4] << 8 | buffer[5];
			case 3: return buffer.slice(4, buffer[2]-2);
		}
	}
);

class Serial extends ChromeSerial
{
	constructor(){
		super();
		this.sendQueue = TaskQueue();
		this.on('closed', () => this.emit('packet'));
	}

	send(buffer){
		return this.sendQueue(() => {
			if(!this.isConnected())return;
			const timeout = buffer[3] == 8 ? buffer.readUInt16LE(7) + 50 : 100;
			return this.send_buffer(buffer).then(() => waitWhen(this, 'data', timeout, replyFn([]))).catch(() => 0);
		});
	}

	async reset(){
		await this.setControlSignals({dtr:false});
		await this.setControlSignals({dtr:true});
	}
}

module.exports = Serial;