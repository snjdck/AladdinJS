
const LedMatrix7x21 = require( 'LedMatrix7x21.js');
const LedMatrix5x14 = require( 'LedMatrix5x14.js');
const base_op = require('base_op.js');
const {compress, calcSize, calcArea} = require('bit.js');
//import createGetter from './createGetter';
//import pinyin from 'text/pinyin';


const createGetter = require('createGetter.js');
const pinyin = v => v;

const db = {board:'elf'};
const board_elf = 'elf';
const board_elf_mini = 'mini';
const board_elf_core = 'core';

const boards = [
	{
		name: board_elf,
		code_type: 'cpp',
		arduino_board: 'arduino:avr:uno',
		include: '#include<WeELF328P.h>',
		partno: 'atmega328p',
		programmer:'arduino',
		pins:{
			PORT_A: 9,
			PORT_B: 10,
			PORT_C: 12,
			PORT_D: 4,
			PORT_1: 14,
			PORT_2: 15,
			PORT_3: 19,
			PORT_4: 18,
			PORT_5: 17,
			PORT_6: 16,
		},
		buzzer_pin: 11,
		button_pin: 2,
		A0_pin: 14,
		motorPins:[[6,7],[5,8],[19,1],[19,2],[18,1],[18,2],[17,1],[17,2],[16,1],[16,2]]
	},
	{
		name: board_elf_mini,
		code_type: 'cpp',
		arduino_board: 'arduino:avr:uno',
		include: '#include<WeELFMini.h>',
		partno: 'atmega328p',
		programmer:'arduino',
		pins:{
			PORT_A: 19,
			PORT_B: 18,
			PORT_C: 16,
			PORT_D: 15,
		},
		buzzer_pin: 7,
		A0_pin: 14,
		motorPins:[[10,9],[5,6]]
	}
];

const {
	onewireGet,
	onewireSet,
	digitalRead,
	analogRead,
	digitalWrite,
	analogWrite,
	createPacket,
	handleRecv
} = base_op;

const castPort2Pin = (keys => argValues => {
	const board = boards.find(v => v.name == db.board);
	if(!board.pins)return argValues;
	for(let k of keys){
		let value = argValues[k];
		if(typeof value !== 'string')continue;
		if(value.startsWith('PORT_')){
			let pin = board.pins[value];
			if(pin != null){
				argValues[k] = pin;
			}else{
				console.error(board, value);
			}
		}
		break;
	}
	return argValues;
})(['SENSOR_PORT', 'BOARD_PORT', 'MOTOR_PORT', 'SERVO_PORT']);

const castStr2Bytes = value => value.toString().split('').map(v => v.charCodeAt());

function fetchRGB({R, G, B}){
	let r = Math.round(Math.max(0, Math.min(255, R)));
	let g = Math.round(Math.max(0, Math.min(255, G)));
	let b = Math.round(Math.max(0, Math.min(255, B)));
	return {r, g, b};
}

function stripZero(value){
	if(value.includes('.')){
		while(value[0] === '0'){
			value.shift();
		}
		if(value[0] === '.'){
			value.shift();
		}
	}
	return value;
}

function copyChar(dest, x, y, lib, char){
	let data = lib[char.charCodeAt()] || lib['$'.charCodeAt()];
	for(let i=0; i<6; ++i){
		let index = i + x;
		if(index < 0)continue;
		if(index >= dest.length)break;
		dest[index] = (y >= 0) ? (data[i] << y) : (data[i] >> -y);
	}
}

function send_packet_onewire_set(pin, type, ...data){
	return this.net.sendData(createPacket(
		onewireSet(pin, type, ...data)
	));
}

function send_packet_onewire_get(pin, type, count, wait, ...data){
	return this.net.sendData(createPacket(
		onewireGet(pin, type, count, wait, ...data)
	));
}

function send_packet_rgb(pin, count, index, color){
	return this.net.sendData(createPacket(
		base_op.rgb(pin, count, index, color.r, color.g, color.b)
	));
}

function send_packet_analogRead(pin){
	return this.net.sendData(createPacket(
		analogRead(pin)
	));
}

function send_packet_digitalRead(pin){
	return this.net.sendData(createPacket(
		digitalRead(pin)
	));
}

function send_packet_digitalWrite(pin, value){
	return this.net.sendData(createPacket(
		digitalWrite(pin, value)
	));
}

function send_packet_led_matrix(pin, bytes){
	let packet;
	if(bytes.length == 21){
		let area = calcArea(bytes);
		if(calcSize(area.w, area.h) > 12){
			let data = compress(bytes, 7);
			let A0_pin = boards.find(v => v.name == db.board).A0_pin;
			data[data.length-1] |= pin >= A0_pin ? (1 << 4 | pin - A0_pin) : pin;
			packet = Buffer.from(['X'.charCodeAt(), ...data]);
		}
	}
	if(!packet){
		packet = createPacket(base_op.ledMatrix(pin, bytes));
	}
	get_led_matrix_buffer(pin).set(bytes);
	return this.net.sendData(packet);
}

async function castToBool(value){
	return Boolean(await value);
}

async function onewire_get_value_2_1(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	const result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 1);
	return result[0];
}

const truncate = (v, min, max) => Math.min(max, Math.max(min, v));
const calc_rj11_speed = v => v < 0 ? (100-v/2.55) : (v/2.55);

function createMotorPacket(DC_MOTOR_INDEX, SPEED){
	const speed = truncate(Number(SPEED), -255, 255);
	const board = boards.find(v => v.name == db.board);
	let [pwmPin, dirPin] = board.motorPins[DC_MOTOR_INDEX-1];
	let dir = speed >= 0 ? 0 : 1;
	let pwm = Math.abs(speed);
	if(DC_MOTOR_INDEX > 2){
		return onewireSet(pwmPin, 2, dirPin, calc_rj11_speed(speed));
	}
	if(db.board == board_elf_mini){
		if(dir){
			[pwmPin, dirPin] = [dirPin, pwmPin];
		}else{
			dir = 1;
		}
		pwm = 255 - pwm;
	}else if(db.board == board_elf_core){
		dir = 1 - dir;
	}else if(DC_MOTOR_INDEX == 2){//elf
		dir = 1 - dir;
	}
	return Buffer.concat([digitalWrite(dirPin, dir), analogWrite(pwmPin, pwm)]);
}

const math_number = exports.math_number = ({NUM}) => {
	let v = Number(NUM);
	return isNaN(v) ? NUM : v;
};
exports.device_port =exports.sensor_port=exports.board_port=exports.led_index = ({VALUE}) => VALUE;
const math_integer = exports.math_integer = math_number;
const math_whole_number = exports.math_whole_number = math_number;
const math_positive_number = exports.math_positive_number = math_number;
const speed = exports.speed = ({SPEED}) => Number(SPEED);
const angle = exports.angle = ({ANGLE}) => Number(ANGLE);
const rgb = exports.rgb = ({RGB}) => Number(RGB);
const colour_picker = (COLOUR) => {
	//let r = parseInt(COLOUR.slice(1, 3), 16);
	//let g = parseInt(COLOUR.slice(3, 5), 16);
	//let b = parseInt(COLOUR.slice(5, 7), 16);
	let r = COLOUR >> 16 & 0xFF;
	let g = COLOUR >> 8 & 0xFF;
	let b = COLOUR & 0xFF;
	return {r,g,b};
};
//export const rgb = ({RGB}) => console.log(v);
/*
register_option('speed');
	register_option('angle');
	register_option('rgb');
	register_option('note');
	register_option('beat');
	register_option('matrix@21*7');
	register_option('matrix@14*5');
	register_option('speech-recognition-index');
	register_option('vibration-speed');
	//register_option('colour_picker', 'COLOUR');
	//register_option('math_integer', 'NUM');
*/

const weeemake_dc_motor = exports.weeemake_dc_motor = function({DC_MOTOR_INDEX, SPEED}){
	return this.net.sendData(createPacket(
		createMotorPacket(DC_MOTOR_INDEX, SPEED)
	));
}
exports.dc_motor_index = function({VALUE}){
	return Number(VALUE);
}
exports.motor_speed = function({VALUE}){
	return Number(VALUE);
}
const weeemake_dc_130_motor = exports.weeemake_dc_130_motor = function(argValues){
	const {SENSOR_PORT, SPEED} = castPort2Pin(argValues);
	const speed = truncate(Number(SPEED), -255, 255);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 2, calc_rj11_speed(speed));
}
//1,2,3,4 => F,B,L,R
const weeemake_robot_move = exports.weeemake_robot_move = function({MOVE_DIRECTION, SPEED}){
	const speed = truncate(Number(SPEED), -255, 255);
	let speeds;
	switch(Number(MOVE_DIRECTION)){
		case 2: speeds = [speed,-speed];break;
		case 3: speeds = [speed,speed];break;
		case 4: speeds = [-speed,-speed];break;
		default: speeds = [-speed,speed];
	}
	return this.net.sendData(createPacket(
		createMotorPacket(2, speeds[0]),
		createMotorPacket(1, speeds[1])
	));
}

const weeemake_vehicle_move = exports.weeemake_vehicle_move = function({LSPEED, RSPEED}){
	return this.net.sendData(createPacket(
		createMotorPacket(2, -LSPEED),
		createMotorPacket(1, RSPEED)
	));
}

const weeemake_servo = exports.weeemake_servo = function(argValues){
	let {SERVO_PORT, ANGLE} = castPort2Pin(argValues);
	return this.net.sendData(createPacket(
		base_op.servo(SERVO_PORT, ANGLE, db.board === board_elf_mini)
	));
}

const weeemake_servo_360 = exports.weeemake_servo_360 = function(argValues){
	let {SERVO_PORT, ANGLE} = castPort2Pin(argValues);
	return this.net.sendData(createPacket(
		base_op.servo_360(SERVO_PORT, ANGLE)
	));
}

const weeemake_robot_stop = exports.weeemake_robot_stop = function(){
	if(db.board == board_elf_mini || db.board == board_elf_core){
		return this.net.sendData(createPacket(
			createMotorPacket(2, 0),
			createMotorPacket(1, 0)
		));
	}
	const board = boards.find(v => v.name == db.board);
	let [M1, M2] = board.motorPins.slice(0, 2).map(v => v[0]);
	return this.net.sendData(createPacket(
		base_op.stopMotor(M1, M2)
	));
}

const weeemake_weeebot_pin_ring_rgb = exports.weeemake_weeebot_pin_ring_rgb = function({PIXEL, COLOR}){
	return send_packet_rgb.call(this, 13, 8, truncate(PIXEL, 0, 8), colour_picker(COLOR));
}

const weeemake_weeebot_pin_ring_rgb3 = exports.weeemake_weeebot_pin_ring_rgb3 = function(argValues){
	const {PIXEL} = argValues;
	return send_packet_rgb.call(this, 13, 8, truncate(PIXEL, 0, 8), fetchRGB(argValues));
}

const weeemake_elf_core_board_rgb = exports.weeemake_elf_core_board_rgb = function({PIXEL, COLOR}){
	return send_packet_rgb.call(this, 14, 2, truncate(PIXEL, 0, 2), colour_picker(COLOR));
}

const weeemake_elf_core_board_rgb3 = exports.weeemake_elf_core_board_rgb3 = function(argValues){
	const {PIXEL} = argValues;
	return send_packet_rgb.call(this, 14, 2, truncate(PIXEL, 0, 2), fetchRGB(argValues));
}

const weeemake_weeebot_board_rgb = exports.weeemake_weeebot_board_rgb = function(argValues){
	const {COLOR} = argValues;
	return send_packet_rgb.call(this, 3, 1, 1, colour_picker(COLOR));
}

const weeemake_weeebot_board_rgb3 = exports.weeemake_weeebot_board_rgb3 = function(argValues){
	return send_packet_rgb.call(this, 3, 1, 1, fetchRGB(argValues));
}

const weeemake_rgb_strip = exports.weeemake_rgb_strip = function(argValues) {
	const {SENSOR_PORT, PIXEL, COLOR} = castPort2Pin(argValues);
	return send_packet_rgb.call(this, SENSOR_PORT, 32, PIXEL, colour_picker(COLOR));
}

const weeemake_rgb3_strip = exports.weeemake_rgb3_strip = function(argValues) {
	const {SENSOR_PORT, PIXEL} = castPort2Pin(argValues);
	return send_packet_rgb.call(this, SENSOR_PORT, 32, PIXEL, fetchRGB(argValues));
}
/* data 15字节 grb顺序*/
function rgbLedRJ11(port, index, color){
	/*
	let data = Array(15).fill(0);
	if(index > 0){
		index = (index - 1) * 3;
		data[index] = color.g;
		data[index+1] = color.r;
		data[index+2] = color.b;
	}else{
		for(let i=0; i<15; i+=3){
			data[i] = color.g;
			data[i+1] = color.r;
			data[i+2] = color.b;
		}
	}
	return send_packet_onewire_set.call(this, port, 2, ...data);
	*/
	return this.net.sendData(createPacket(
		base_op.RJ11RGB(port, index, color.r, color.g, color.b)
	));
}
const weeemake_rgb_RJ11 = exports.weeemake_rgb_RJ11 = function(argValues){
	const {SENSOR_PORT, INDEX, COLOR} = castPort2Pin(argValues);
	return rgbLedRJ11.call(this, SENSOR_PORT, truncate(INDEX, 0, 5), colour_picker(COLOR));
}

const weeemake_rgb3_RJ11 = exports.weeemake_rgb3_RJ11 = function(argValues){
	const {SENSOR_PORT, INDEX} = castPort2Pin(argValues);
	return rgbLedRJ11.call(this, SENSOR_PORT, truncate(INDEX, 0, 5), fetchRGB(argValues));
}
const weeemake_weeebot_pin_light = exports.weeemake_weeebot_pin_light = function(argValues) {
	const {BOARD_PORT} = castPort2Pin(argValues);
	return send_packet_analogRead.call(this, BOARD_PORT);
}
const weeemake_weeebotMini_board_light = exports.weeemake_weeebotMini_board_light = function(){
	return send_packet_analogRead.call(this, 21);
}

const weeemake_temperature = exports.weeemake_temperature = async function(argValues) {
	const {SENSOR_PORT} = castPort2Pin(argValues);
	let result = await this.net.sendData(createPacket(
		base_op.temperature(SENSOR_PORT)
	));
	return result * 0.0625;//除以16
}
const weeemake_weeebotMini_board_sound = exports.weeemake_weeebotMini_board_sound = function(){
	return send_packet_analogRead.call(this, 17);
}
const weeemake_weeebot_pin_sound = exports.weeemake_weeebot_pin_sound = weeemake_weeebot_pin_light;
/*
function weeebot_encoder_move(argValues) {
	var port = argValues.MOTOR_PORT;
	var speed = argValues.SPEED;
	var distance = argValues.DISTANCE;
	//var cmd = "M202 " + port + " " + speed + " " + distance;
	var cmd = createCMD(202, port, speed, distance);
	console.log(cmd);
	//util.ioQuery('serial', 'sendMsg', [cmd]);
}
function weeebot_steppermove(argValues) {
	var port = argValues.MOTOR_PORT;
	var speed = argValues.SPEED;
	var distance = argValues.DISTANCE;
	//var cmd = "M203 " + port + " " + speed + " " + distance;
	var cmd = createCMD(203, port, speed, distance);
	console.log(cmd);
	//util.ioQuery('serial', 'sendMsg', [cmd]);
}
*/
const weeemake_weeebot_pin_ir = exports.weeemake_weeebot_pin_ir = async function(argValues){
	const {BOARD_PORT, IR_CODE} = castPort2Pin(argValues);
	return IR_CODE == await this.net.sendData(createPacket(
		base_op.ir(BOARD_PORT)
	));
}
const weeemake_weeebotMini_board_ir = exports.weeemake_weeebotMini_board_ir = function(argValues){
	argValues.BOARD_PORT = 2;
	return weeemake_weeebot_pin_ir.call(this, argValues);
}
const weeemake_weeebot_board_button = exports.weeemake_weeebot_board_button = async function(){
	let pin = boards.find(v => v.name == db.board).button_pin;
	return !await send_packet_digitalRead.call(this, pin);
}
const weeemake_buzzer = exports.weeemake_buzzer = function(argValues){
	let pin = boards.find(v => v.name == db.board).buzzer_pin;
	return this.net.sendData(createPacket(
		base_op.buzzer(pin, argValues.NOTE, argValues.BEAT)
	));
}
const weeemake_ultrasonic = exports.weeemake_ultrasonic = async function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 2);
	return Math.min(500, (result[0] | result[1] << 8) / 17.57);
}

const get_ultrasonic_led_buffer = createGetter(() => [0]);

const weeemake_ultrasonic_led = exports.weeemake_ultrasonic_led = function(argValues){
	const {SENSOR_PORT, ULTRASONIC_LED_INDEX, ON_OFF} = castPort2Pin(argValues);
	const buffer = get_ultrasonic_led_buffer(SENSOR_PORT);
	let value = buffer[0];
	for(let i=1; i<=2; ++i){
		if((ULTRASONIC_LED_INDEX & i) == 0)continue;
		if(ON_OFF == 1){
			value |= i;
		}else{
			value &= ~i;
		}
	}
	buffer[0] = value;
	return send_packet_onewire_set.call(this, SENSOR_PORT, 4, value);
}

const get_ultrasonic_rgb_buffer = createGetter(() => new Uint8Array(6));

function ultrasonic_rgb(SENSOR_PORT, ULTRASONIC_LED_INDEX, color){
	const value = get_ultrasonic_rgb_buffer(SENSOR_PORT);
	for(let i=1; i<=2; ++i){
		if((ULTRASONIC_LED_INDEX & i) == 0)continue;
		let k = (i - 1) * 3;
		value[k  ] = color.r;
		value[k+1] = color.g;
		value[k+2] = color.b;
	}
	return send_packet_onewire_set.call(this, SENSOR_PORT, 3, ...value);
}
const weeemake_ultrasonic_rgb = exports.weeemake_ultrasonic_rgb = function(argValues){
	const {SENSOR_PORT, ULTRASONIC_LED_INDEX, COLOR} = castPort2Pin(argValues);
	return ultrasonic_rgb.call(this, SENSOR_PORT, ULTRASONIC_LED_INDEX, colour_picker(COLOR));
}
const weeemake_ultrasonic_rgb3 = exports.weeemake_ultrasonic_rgb3 = function(argValues){
	const {SENSOR_PORT, ULTRASONIC_LED_INDEX} = castPort2Pin(argValues);
	return ultrasonic_rgb.call(this, SENSOR_PORT, ULTRASONIC_LED_INDEX, fetchRGB(argValues));
}
const weeemake_ir_avoid_led = exports.weeemake_ir_avoid_led = weeemake_ultrasonic_led;
const weeemake_ir_avoid_rgb = exports.weeemake_ir_avoid_rgb = weeemake_ultrasonic_rgb;
const weeemake_ir_avoid_rgb3 = exports.weeemake_ir_avoid_rgb3 = weeemake_ultrasonic_rgb3;

const weeemake_line_follower = exports.weeemake_line_follower = async function(argValues){
	const {SENSOR_PORT, LINE_FOLLOWER_INDEX} = castPort2Pin(argValues);
	let index = LINE_FOLLOWER_INDEX - 1;
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 2);
	return (1 - result[index] / 255) * 1023;
}

function ledMatrix7x21_showNumber(value){
	value = Math.max(Math.min(value, 9999), -999);
	let data = Array(21).fill(0);

	value = value.toString();
	value = value.slice(0, 4 + value.includes('.'));
	value = stripZero(value.split('').reverse());

	let x = 21;
	for(let char of value){
		if(char === '.'){
			data[x-1] = 0x40;
			x -= 2;
			continue;
		}
		x -= 5;
		copyChar(data, x, 0, LedMatrix7x21, char);
	}

	return data;
}

function ledMatrix5x14_showNumber(value){
	value = Math.max(Math.min(value, 999), -99);
	let data = Array(14).fill(0);

	value = value.toString();
	value = value.slice(0, 3 + value.includes('.'));
	value = stripZero(value.split('').reverse());

	let x = 14;
	for(let char of value){
		if(char === '.')continue;
		x -= 5;
		copyChar(data, x, 0, LedMatrix5x14, char);
	}

	x = 14;
	for(let char of value){
		if(char !== '.'){
			x -= 5;
			continue;
		}
		data[x-1] &= 0xF;
		data[x] = 0x10;
		data[x+1] &= 0xF;
		break;
	}

	return data;
}

const weeemake_led_matrix_number = exports.weeemake_led_matrix_number = function(argValues){
	const {LED_MATRIX_TYPE, SENSOR_PORT, NUM} = castPort2Pin(argValues);
	let fn = LED_MATRIX_TYPE == '7x21' ? ledMatrix7x21_showNumber : ledMatrix5x14_showNumber;
	return send_packet_led_matrix.call(this, SENSOR_PORT, fn(NUM));
}
const weeemake_led_matrix_time = exports.weeemake_led_matrix_time = function(argValues){
	const {LED_MATRIX_TYPE, SENSOR_PORT, HOUR, MINUTE, SHOW_COLON} = castPort2Pin(argValues);
	if(LED_MATRIX_TYPE == '5x14')return;
	let data = Array(21).fill(0);
	copyChar(data, -1, 0, LedMatrix7x21, Math.floor(HOUR * 0.1).toString());
	copyChar(data,  4, 0, LedMatrix7x21, (HOUR % 10).toString());
	copyChar(data, 11, 0, LedMatrix7x21, Math.floor(MINUTE * 0.1).toString());
	copyChar(data, 16, 0, LedMatrix7x21, (MINUTE % 10).toString());
	data[10] = Number(SHOW_COLON) ? 0x14 : 0;
	return send_packet_led_matrix.call(this, SENSOR_PORT, data);
}
const weeemake_led_matrix_string = exports.weeemake_led_matrix_string = function(argValues){
	const {LED_MATRIX_TYPE, SENSOR_PORT, STR} = castPort2Pin(argValues);
	const LedMatrix = LED_MATRIX_TYPE == '7x21' ? LedMatrix7x21 : LedMatrix5x14;
	let {X:x, Y:y} = argValues;
	let [h, w] = LED_MATRIX_TYPE.split('x').map(Number);
	if(x >= w || Math.abs(y) >= h){
		return weeemake_led_matrix_clear.call(this, argValues);
	}
	let data = Array(w).fill(0);

	for(let char of STR){
		if(x >= w)break;
		if(x > -6){
			copyChar(data, x, y, LedMatrix, char);
		}
		x += 6;
	}
	return send_packet_led_matrix.call(this, SENSOR_PORT, data);
}

function castMatrixToBytes(MATRIX, w, h){
	let data = MATRIX.split('');
	let bytes = [];
	for(let j=0; j<w; ++j){
		bytes[j] = 0;
		for(let i=0; i<h; ++i){
			if(data[i*w+j] === '1'){
				bytes[j] |= 1 << i;
			}
		}
	}
	return bytes;
}

function ledMatrix_showBitmap(SENSOR_PORT, x, y, MATRIX, w, h){
	let bytes = castMatrixToBytes(MATRIX, w, h);
	if(Math.abs(x) >= w || Math.abs(y) >= h || bytes.every(v => v == 0)){
		return weeemake_led_matrix_clear.call(this, {SENSOR_PORT});
	}
	let data = [];
	for(let i=0; i<w; ++i){
		let j = i - x;
		if(j < 0 || w <= j){
			data[i] = 0;
		}else if(y >= 0){
			data[i] = bytes[j] << y;
		}else{
			data[i] = bytes[j] >> -y;
		}
	}
	return send_packet_led_matrix.call(this, SENSOR_PORT, data);
}

const weeemake_led_matrix_bitmap_21x7 = exports.weeemake_led_matrix_bitmap_21x7 = function(argValues){
	const {SENSOR_PORT, X, Y, MATRIX} = castPort2Pin(argValues);
	return ledMatrix_showBitmap.call(this, SENSOR_PORT, X, Y, MATRIX, 21, 7);
}

const weeemake_led_matrix_bitmap_14x5 = exports.weeemake_led_matrix_bitmap_14x5 = function(argValues){
	const {SENSOR_PORT, X, Y, MATRIX} = castPort2Pin(argValues);
	return ledMatrix_showBitmap.call(this, SENSOR_PORT, X, Y, MATRIX, 14, 5);
}

exports.weeemake_led_matrix_bitmap = function(argValues){
	const {SENSOR_PORT, X, Y, MATRIX} = castPort2Pin(argValues);
	let [w, h] = MATRIX.length == 70 ? [14, 5] : [21, 7];
	return ledMatrix_showBitmap.call(this, SENSOR_PORT, X, Y, MATRIX, w, h);
}

exports["matrix@21*7"] = exports["matrix@14*5"] = args => args.MATRIX;

const get_led_matrix_buffer = createGetter(() => new Uint8Array(21));

const weeemake_led_matrix_pixel = exports.weeemake_led_matrix_pixel = function(argValues){
	const {LED_MATRIX_TYPE, SENSOR_PORT, X, Y, SHOW_HIDE} = castPort2Pin(argValues);
	const [w, h] = LED_MATRIX_TYPE == '7x21' ? [21, 7] : [14, 5];
	if(X < 0 || Y < 0 || X >= w || Y >= h)return;
	const buffer = get_led_matrix_buffer(SENSOR_PORT);
	if(SHOW_HIDE == 1){
		buffer[X] |= 1 << Y;
	}else{
		buffer[X] &= ~(1 << Y);
	}
	return send_packet_onewire_set.call(this, SENSOR_PORT, 3, X, buffer[X]);
}

const weeemake_led_matrix_clear = exports.weeemake_led_matrix_clear = function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	const buffer = get_led_matrix_buffer(SENSOR_PORT, false);
	if(buffer)buffer.fill(0);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 5);
}

const weeemake_single_line_follower = exports.weeemake_single_line_follower = async function(argValues){
	const {BOARD_PORT} = castPort2Pin(argValues);
	return 1023 - await send_packet_analogRead.call(this, BOARD_PORT);
}

const weeemake_weeebotMini_board_back_led = exports.weeemake_weeebotMini_board_back_led = function({BACK_LED_PORT, ON_OFF}){
	return send_packet_digitalWrite.call(this, BACK_LED_PORT, ON_OFF == 1);
}

const weeemake_humiture = exports.weeemake_humiture = async function(argValues){
	const {SENSOR_PORT, HUMITURE_TYPE} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 2);
	return result[HUMITURE_TYPE];
}

const weeemake_soil = exports.weeemake_soil = function(argValues){
	const {BOARD_PORT} = castPort2Pin(argValues);
	return send_packet_analogRead.call(this, BOARD_PORT);
}
const weeemake_seven_segment = exports.weeemake_seven_segment = function(argValues){
	const {SENSOR_PORT, NUM} = castPort2Pin(argValues);
	const data = Array(4).fill(0x40);
	let value = truncate(Number(NUM), -999, 9999);

	value = value.toString();
	value = value.slice(0, 4 + value.includes('.'));
	value = stripZero(value.split('').reverse());

	let k = 3, hasComma = false;
	for(let char of value){
		if(char === '-'){
			data[k] = 0x10;
			break;
		}
		if(char === '.'){
			hasComma = true;
			continue;
		}
		data[k] = parseInt(char);
		if(hasComma){
			data[k] |= 0x20;
			hasComma = false;
		}
		--k;
	}
	return send_packet_onewire_set.call(this, SENSOR_PORT, 2, ...data);
}
const weeemake_single_led = exports.weeemake_single_led = function(argValues){
	const {SENSOR_PORT, ON_OFF} = castPort2Pin(argValues);
	return send_packet_digitalWrite.call(this, SENSOR_PORT, ON_OFF == 1);
}

const weeemake_potentiometer = exports.weeemake_potentiometer = onewire_get_value_2_1;
const weeemake_pir = exports.weeemake_pir = function(argValues){
	return castToBool(onewire_get_value_2_1.call(this, argValues));
}
const weeemake_ir_avoid = exports.weeemake_ir_avoid = weeemake_pir;
const weeemake_gas_sensor = exports.weeemake_gas_sensor = onewire_get_value_2_1;
const weeemake_touch = exports.weeemake_touch = weeemake_pir;
const weeemake_led_single_line_follower = exports.weeemake_led_single_line_follower = async function(argValues){
	let result = await onewire_get_value_2_1.call(this, argValues);
	return result * 1023 / 255;
}
const weeemake_led_single_line_follower_led = exports.weeemake_led_single_line_follower_led = function(argValues){
	const {SENSOR_PORT, ON_OFF} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, ON_OFF == 1 ? 3 : 4);
}

const weeemake_tilt = exports.weeemake_tilt = async function(argValues){
	const {TILT_DIR} = argValues;
	return TILT_DIR == await onewire_get_value_2_1.call(this, argValues);
}
const weeemake_led_button = exports.weeemake_led_button = async function(argValues){
	const {BUTTON_INDEX} = argValues;
	let value = await onewire_get_value_2_1.call(this, argValues);
	return value == 1 << (BUTTON_INDEX - 1);
}
const weeemake_led_button_light = exports.weeemake_led_button_light = function(argValues){
	const {SENSOR_PORT, BUTTON_INDEX, ON_OFF} = castPort2Pin(argValues);
	let id = ON_OFF == 1 ? 3 : 4;
	let value = 1 << (BUTTON_INDEX - 1);
	return send_packet_onewire_set.call(this, SENSOR_PORT, id, value);
}

const weeemake_relay = exports.weeemake_relay = function(argValues){
	const {SENSOR_PORT, ON_OFF} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 2, ON_OFF);
}

const weeemake_water_atomizer = exports.weeemake_water_atomizer = function(argValues){
	const {SENSOR_PORT, ON_OFF} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 2, ON_OFF == 1 ? 2 : 3);
}

const weeemake_color_sensor_white_balance = exports.weeemake_color_sensor_white_balance = function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 4);
}

const weeemake_color_sensor_light = exports.weeemake_color_sensor_light = function(argValues){
	const {SENSOR_PORT, ON_OFF} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 3, ON_OFF);
}

const weeemake_mp3_do = exports.weeemake_mp3_do = function(argValues){
	const {SENSOR_PORT, MP3_FUNCTION} = castPort2Pin(argValues);
	let id = [6, 5, 9, 4][MP3_FUNCTION];
	return send_packet_onewire_set.call(this, SENSOR_PORT, id);
}

const weeemake_mp3_set_music = exports.weeemake_mp3_set_music = function(argValues){
	const {SENSOR_PORT, NUM} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 2, NUM >> 8, NUM & 0xFF);
}

const weeemake_mp3_set_volume = exports.weeemake_mp3_set_volume = function(argValues){
	const {SENSOR_PORT, NUM} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 3, NUM);
}

const weeemake_mp3_set_device = exports.weeemake_mp3_set_device = function(argValues){
	const {SENSOR_PORT, MP3_DEVICE_TYPE} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 7, MP3_DEVICE_TYPE);
}

const weeemake_mp3_is_over = exports.weeemake_mp3_is_over = async function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 8, 1);
	return result[0] > 0;
}

const oled_size_dict = Object.create(null);

const weeemake_oled_set_size = exports.weeemake_oled_set_size = function(argValues){
	const {SENSOR_PORT, OLED_SIZE} = castPort2Pin(argValues);
	oled_size_dict[SENSOR_PORT] = OLED_SIZE;
}

const weeemake_oled_show_string = exports.weeemake_oled_show_string = function(argValues){
	const {SENSOR_PORT, X, Y} = castPort2Pin(argValues);
	let {STR} = argValues;
	if(typeof STR != 'string'){
		STR = STR.toString();
	}
	const fontSize = oled_size_dict[SENSOR_PORT] || 8;
	return send_packet_onewire_set.call(this, SENSOR_PORT, 2, fontSize, X, Y, ...STR.split('').map(v => v.charCodeAt()), 0);
}

const weeemake_oled_show_number = exports.weeemake_oled_show_number = function(argValues){
	argValues.STR = argValues.NUM;
	return weeemake_oled_show_string.call(this, argValues);
}

const weeemake_oled_clear_screen = exports.weeemake_oled_clear_screen = function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 4);
}

const weeemake_color_sensor = exports.weeemake_color_sensor = async function(argValues){
	const {SENSOR_PORT, COLOR_TYPE} = castPort2Pin(argValues);
	const index = (COLOR_TYPE == 0 ? 3 : COLOR_TYPE - 1) << 1;
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 8);
	return result[index] | result[index+1] << 8;
}

const weeemake_flame_sensor = exports.weeemake_flame_sensor = async function(argValues){
	const {SENSOR_PORT, FLAME_INDEX} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 3);
	return result[FLAME_INDEX-1];
}

const weeemake_joystick = exports.weeemake_joystick = async function(argValues){
	const {SENSOR_PORT, AXIS2} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 3);
	return result[AXIS2];
}

const weeemake_limit_switch = exports.weeemake_limit_switch = function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	return castToBool(send_packet_digitalRead.call(this, SENSOR_PORT));
}

const weeemake_compass = exports.weeemake_compass = async function(argValues){
	const {SENSOR_PORT, AXIS3} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 6);
	let index = AXIS3 << 1;
	let value = result[index] << 8 | result[index+1];
	return (AXIS3 == 0) ? (value < 90 ? value + 270 : value - 90) : value;
}

/* 0-gx,1-gy,2-gz,3-gyrX,4-gyrY,5-gyrZ */
const weeemake_gyro = exports.weeemake_gyro = function(){
	const gSensitivity =  1 / 65.5;
	const factor = 180 / Math.PI;
	let timestamp = 0;
	let data = Array(6).fill(0);
	return async function(argValues){
		const {SENSOR_PORT, GYRO_VALUE_TYPE, AXIS3} = castPort2Pin(argValues);
		const buffer = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 14);
		let now = new Date().getTime();
		if(timestamp === 0){
			timestamp = now;
		}
		
		const dt = (now - timestamp) * 0.001;
		timestamp = now;
		//let bu
		const accX = buffer.readInt16BE(0);
		const accY = buffer.readInt16BE(2);
		const accZ = buffer.readInt16BE(4);
		data[3] = buffer.readInt16BE(8) * gSensitivity;
		data[4] = buffer.readInt16BE(10) * gSensitivity;
		data[5] = buffer.readInt16BE(12) * gSensitivity;
		const ax = Math.atan2(accX, Math.sqrt(accY*accY+accZ*accZ)) * factor;
		const ay = Math.atan2(accY, Math.sqrt(accX*accX+accZ*accZ)) * factor;
		//*
		if(accZ > 0){
			data[0] -= data[4] * dt;
			data[1] += data[3] * dt;
		}else{
			data[0] += data[4] * dt;
			data[1] -= data[3] * dt;
		}
		data[2] += data[5] * dt;//*/
		data[2] %= 360;
		if(data[2] > 180){
			data[2] -= 360;
		}
		data[0] = 0.98 * data[0] + 0.02 * ax;
		data[1] = 0.98 * data[1] + 0.02 * ay;
		
		let index = parseInt(AXIS3) + parseInt(GYRO_VALUE_TYPE) * 3;
		return data[index];
	}
}();

const weeemake_encoder_motor_set_origin = exports.weeemake_encoder_motor_set_origin = function(argValues){
	let {MOTOR_PORT} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, MOTOR_PORT, 4);
}

const weeemake_encoder_motor_power = exports.weeemake_encoder_motor_power = function(argValues){
	let {MOTOR_PORT, SPEED} = castPort2Pin(argValues);
	const speed = truncate(Number(SPEED), -255, 255);
	return send_packet_onewire_set.call(this, MOTOR_PORT, 2, 1, calc_rj11_speed(speed));
}

const weeemake_encoder_motor_speed = exports.weeemake_encoder_motor_speed = function(argValues){
	let {MOTOR_PORT, SPEED} = castPort2Pin(argValues);
	if(SPEED == 0){
		return send_packet_onewire_set.call(this, MOTOR_PORT, 2, 1, 0);
	}
	const speed = Math.round(SPEED * 0.49);
	return send_packet_onewire_set.call(this, MOTOR_PORT, 7, speed & 0xFF, speed >> 8);
}

const weeemake_encoder_motor_move = exports.weeemake_encoder_motor_move = function(argValues){
	let {MOTOR_PORT, SPEED} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, MOTOR_PORT, 6, 150/2.55, SPEED & 0xFF, SPEED >> 8, SPEED >> 16, SPEED >> 24);
}

const weeemake_ascii2str = exports.weeemake_ascii2str = function({VALUE}){
	return String.fromCharCode(VALUE);
}

const weeemake_str2ascii = exports.weeemake_str2ascii = function({VALUE}){
	return VALUE.charCodeAt();
}

const weeemake_raindrop = exports.weeemake_raindrop = onewire_get_value_2_1;

const weeemake_uv = exports.weeemake_uv = onewire_get_value_2_1;

const weeemake_funny_touch = exports.weeemake_funny_touch = async function(argValues){
	const {FUNNY_TOUCH_INDEX} = argValues;
	let value = await onewire_get_value_2_1.call(this, argValues);
	return (value & (1 << FUNNY_TOUCH_INDEX - 1)) > 0;
}

const weeemake_funny_touch_value = exports.weeemake_funny_touch_value = onewire_get_value_2_1;

const weeemake_barometer = exports.weeemake_barometer = async function(argValues){
	let {SENSOR_PORT, BAROMETER_TYPE} = castPort2Pin(argValues);
	let id = Number(BAROMETER_TYPE) + 2;
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, id, 4);
	return result.readUInt32LE(0) * 0.01;
}

const weeemake_PM25 = exports.weeemake_PM25 = async function(argValues){
	let {SENSOR_PORT, PM25_TYPE} = castPort2Pin(argValues);
	let id = Number(PM25_TYPE) + 3;
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, id, 2);
	return result.readUInt16BE(0);
}

const get_speech_rec_buffer = createGetter(() => new Array(30).fill(''));

const weeemake_speech_recognition_set_password = exports.weeemake_speech_recognition_set_password = function(argValues){
	let {SENSOR_PORT, INDEX, VALUE} = castPort2Pin(argValues);
	if(INDEX > 0){
		get_speech_rec_buffer(SENSOR_PORT)[INDEX] = VALUE;
	}
	VALUE = pinyin(VALUE).trim();
	let value = VALUE.toString().slice(0, 40).split('').map(v => v.charCodeAt());
	return send_packet_onewire_set.call(this, SENSOR_PORT, 2, INDEX, ...value, 0);
}

const weeemake_speech_recognition_set_keyword = exports.weeemake_speech_recognition_set_keyword = function(argValues){
	argValues.INDEX = 0;
	return weeemake_speech_recognition_set_password.call(this, argValues);
}

const weeemake_speech_recognition_set_mode = exports.weeemake_speech_recognition_set_mode = function(argValues){
	let {SENSOR_PORT, SPEECH_RECOGNITION_MODE} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 4, SPEECH_RECOGNITION_MODE-1);
}

const weeemake_speech_recognition_read = exports.weeemake_speech_recognition_read = async function(argValues){
	let {SENSOR_PORT} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 3, 1);
	return result[0];
}

const weeemake_speech_recognition_read_string = exports.weeemake_speech_recognition_read_string = async function(argValues){
	let {SENSOR_PORT} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 3, 1);
	return get_speech_rec_buffer(SENSOR_PORT)[result[0]];
}

const weeemake_gesture_recognition_read = exports.weeemake_gesture_recognition_read = async function(argValues){
	let {SENSOR_PORT, GESTURE_RECOGNITION_TYPE} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 2, 1);
	return result[0] == GESTURE_RECOGNITION_TYPE;
}

const weeemake_gesture_recognition_value = exports.weeemake_gesture_recognition_value = onewire_get_value_2_1;

const weeemake_gesture_recognition_compare = exports.weeemake_gesture_recognition_compare = function({VALUE, GESTURE_RECOGNITION_TYPE}){
	return VALUE == GESTURE_RECOGNITION_TYPE;
}

const get_image_rec_buffer = createGetter(() => new Array(4).fill(0));

const weeemake_image_recognition_set_mode = exports.weeemake_image_recognition_set_mode = function(argValues){
	let {SENSOR_PORT, IMAGE_RECOGNITION_MODE} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, IMAGE_RECOGNITION_MODE == 1 ? 8 : 3);
}

const weeemake_image_recognition_color_position = exports.weeemake_image_recognition_color_position = async function(argValues){
	let {SENSOR_PORT, IMAGE_RECOGNITION_TYPE} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 5 | IMAGE_RECOGNITION_TYPE << 5, 6);
	if(result[0] == 0xFF)return false;

	let centerX = result[0] << 8 | result[1];
	let centerY = result[2] << 8 | result[3];
	let pixels  = result[4] << 8 | result[5];
	if(centerX > 320 || centerY > 240)return false;
	get_image_rec_buffer(SENSOR_PORT).splice(0, 3, centerX, centerY, pixels);
	return true;
}

const weeemake_image_recognition_update = exports.weeemake_image_recognition_update = async function(argValues){
	const {SENSOR_PORT, IMAGE_RECOGNITION_MODE} = castPort2Pin(argValues);
	if(IMAGE_RECOGNITION_MODE == 1){
		let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0xF, 1);
		let angle = result.readInt8(0);
		if(angle == 125)return false;
		get_image_rec_buffer(SENSOR_PORT)[3] = angle;
		return true;
	}

	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 4, 6);
	if(result[0] == 0xFF)return false;
	let centerX = result[0] << 8 | result[1];
	let centerY = result[2] << 8 | result[3];
	let pixels  = result[4] << 8 | result[5];
	if(centerX > 320 || centerY > 240)return false;
	get_image_rec_buffer(SENSOR_PORT).splice(0, 3, centerX, centerY, pixels);
	return true;
}

const weeemake_image_recognition_value = exports.weeemake_image_recognition_value = function(argValues){
	let {SENSOR_PORT, IMAGE_RECOGNITION_VALUE} = castPort2Pin(argValues);
	return get_image_rec_buffer(SENSOR_PORT)[IMAGE_RECOGNITION_VALUE];
}

const weeemake_image_recognition_line_follow_angle = exports.weeemake_image_recognition_line_follow_angle = function(argValues){
	let {SENSOR_PORT} = castPort2Pin(argValues);
	return get_image_rec_buffer(SENSOR_PORT)[3];
}

const weeemake_image_recognition_set_fast_mode = exports.weeemake_image_recognition_set_fast_mode = function(argValues){
	let {SENSOR_PORT, ON_OFF} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 0x11, ON_OFF);
}

const weeemake_image_recognition_face_position = exports.weeemake_image_recognition_face_position = async function(argValues){
	let {SENSOR_PORT, IMAGE_RECOGNITION_TYPE} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0x10, 4);
	if(result[0] == 0xFF)return false;

	let centerX = result[0] << 8 | result[1];
	let centerY = result[2] << 8 | result[3];
	get_image_rec_buffer(SENSOR_PORT).splice(0, 2, centerX, centerY);
	return true;
}

const weeemake_image_recognition_set_color = exports.weeemake_image_recognition_set_color = function(argValues){
	let {SENSOR_PORT, IMAGE_RECOGNITION_COLOR_INDEX, minL,maxL,minA,maxA,minB,maxB} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 0x06, IMAGE_RECOGNITION_COLOR_INDEX-1, minL,maxL,minA,maxA,minB,maxB);
}

const weeemake_image_recognition_set_threshold = exports.weeemake_image_recognition_set_threshold = function(argValues){
	let {SENSOR_PORT, VALUE} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 0x0A, VALUE);
}

const weeemake_image_recognition_set_traffic_signs_mode = exports.weeemake_image_recognition_set_traffic_signs_mode = async function(argValues){
	let {SENSOR_PORT} = castPort2Pin(argValues);
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x06, 3, 10, 75, 25, 85, -20, 70);
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x06, 3, 20, 95, -20, 36, -50, -15);
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x0A, 100);
}

async function image_recognition_get_traffic_signs_value(argValues){
	let {SENSOR_PORT} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0x0C | 3 << 5, 15);
	if(result[0] == 0xFF)return 0;
	let pixels = result[4] << 8 | result[5];
	if(pixels <= 2000)return 0;
	let density = pixels / ((result[10] << 8 | result[11]) * (result[12] << 8 | result[13]));
	if(density <= 0.23 || density >= 0.35)return 0;
	let red_X = result[0] << 8 | result[1];
	let red_Y = result[2] << 8 | result[3];
	//console.log('---', pixels, density, red_X, red_Y);
	result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0x0C | 4 << 5, 15);
	if(result[0] == 0xFF)return 0;
	pixels = result[4] << 8 | result[5];
	if(pixels <= 2000)return 0;
	let centerX = result[0] << 8 | result[1];
	let centerY = result[2] << 8 | result[3];
	//console.log('===', pixels, Math.abs(centerX - red_X), Math.abs(centerY - red_Y));
	if(Math.abs(centerX - red_X) >= 30 || Math.abs(centerY - red_Y) >= 30)return 0;
	density = pixels / ((result[10] << 8 | result[11]) * (result[12] << 8 | result[13]));
	let rotation = result[14];
	if((density>0.57)&&(density<0.64)) return 1;
	if((density>0.51)&&(density<0.57)&&(rotation==0)) return 4;
	if((density>0.51)&&(density<0.57)&&(rotation==2)) return 3;
	if((density>0.46)&&(density<0.50)) return 5;
	if((density>0.40)&&(density<0.45)) return 2;
	return 0;
}

const weeemake_image_recognition_get_traffic_signs_value = exports.weeemake_image_recognition_get_traffic_signs_value = async function(argValues){
	let {TRAFFIC_SIGN} = argValues;
	let value = await image_recognition_get_traffic_signs_value.call(this, argValues);
	console.log(value);
	return value == TRAFFIC_SIGN;
}

const weeemake_digitalWrite = exports.weeemake_digitalWrite = function({DPIN, HIGH_LOW}){
	const {A0_pin} = boards.find(v => v.name == db.board);
	const pin = DPIN.startsWith('A') ? A0_pin + Number(DPIN.slice(1)) : Number(DPIN);
	return send_packet_digitalWrite.call(this, pin, HIGH_LOW == 1);
}

const weeemake_analogWrite = exports.weeemake_analogWrite = function({PWM_PIN, VALUE}){
	return this.net.sendData(createPacket(analogWrite(PWM_PIN, VALUE)));
}

const weeemake_digitalRead = exports.weeemake_digitalRead = function({DPIN}){
	const {A0_pin} = boards.find(v => v.name == db.board);
	const pin = DPIN.startsWith('A') ? A0_pin + Number(DPIN.slice(1)) : Number(DPIN);
	return castToBool(send_packet_digitalRead.call(this, pin));
}

const weeemake_analogRead = exports.weeemake_analogRead = function({APIN}){
	const {A0_pin} = boards.find(v => v.name == db.board);
	const pin = A0_pin + Number(APIN.slice(1));
	return send_packet_analogRead.call(this, pin);
}

const weeemake_vibration_motor = exports.weeemake_vibration_motor = function(argValues){
	const {SENSOR_PORT, SPEED} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 3, SPEED);
}

const weeemake_elf_core_board_ir_sender = exports.weeemake_elf_core_board_ir_sender = function({IR_CODE, GROUP}){
	return this.net.sendData(createPacket(
		base_op.ir_sender(12, IR_CODE, GROUP)
	));
}

const weeemake_rj11_sound = exports.weeemake_rj11_sound = weeemake_led_single_line_follower;
const weeemake_rj11_light = exports.weeemake_rj11_light = weeemake_led_single_line_follower;

const weeemake_adapter_digitalWrite = exports.weeemake_adapter_digitalWrite = function(argValues){
	const {SENSOR_PORT, ADAPTER_INDEX, HIGH_LOW} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 0xC, ADAPTER_INDEX, HIGH_LOW);
}

const weeemake_adapter_servo = exports.weeemake_adapter_servo = function(argValues){
	const {SENSOR_PORT, ADAPTER_INDEX, ANGLE} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 0x2, ADAPTER_INDEX, ANGLE);
}

const weeemake_adapter_rgb = exports.weeemake_adapter_rgb = function(argValues){
	const {SENSOR_PORT, ADAPTER_INDEX, PIXEL, R, G, B} = castPort2Pin(argValues);
	return send_packet_onewire_set.call(this, SENSOR_PORT, 0x3, ADAPTER_INDEX, PIXEL, R, G, B);
}

const weeemake_adapter_digitalRead = exports.weeemake_adapter_digitalRead = async function(argValues){
	const {SENSOR_PORT, ADAPTER_INDEX} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0xD + (ADAPTER_INDEX - 1), 1);
	return result[0];
}

const weeemake_adapter_analogRead = exports.weeemake_adapter_analogRead = async function(argValues){
	const {SENSOR_PORT, ADAPTER_INDEX} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0x8 + (ADAPTER_INDEX - 1), 2);
	return result[0];
}

const weeemake_adapter_temperature = exports.weeemake_adapter_temperature = async function(argValues){
	const {SENSOR_PORT, ADAPTER_INDEX} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0x4 + (ADAPTER_INDEX - 1), 2);
	return (result[0] | result[1] << 8) * 0.01;
}

const weeemake_usb_host = exports.weeemake_usb_host = function(){
	return false;
}

const weeemake_usb_host_joystick = exports.weeemake_usb_host_joystick = function(){
	return 0;
}

const weeemake_bluetooth_controller_button = exports.weeemake_bluetooth_controller_button = weeemake_usb_host;
const weeemake_bluetooth_controller_joystick = exports.weeemake_bluetooth_controller_joystick = weeemake_usb_host_joystick;

const get_wifi_buffer = createGetter(() => ['', 0, '']);

const weeemake_wifi_set_info = exports.weeemake_wifi_set_info = async function(argValues){
	const {SENSOR_PORT, SSID, PWD} = castPort2Pin(argValues);
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x3, ...castStr2Bytes(SSID), 0);
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x4, ...castStr2Bytes(PWD), 0);
}

const weeemake_wifi_init_slave = exports.weeemake_wifi_init_slave = async function(argValues){
	const {SENSOR_PORT, IP, PORT} = castPort2Pin(argValues);
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x2, 1);//CWMode
	await send_packet_onewire_get.call(this, SENSOR_PORT, 0x9, 1, 10);//CWJAP;
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0xE, 1);//CIPMux
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0xB, ...castStr2Bytes(IP), 0);//CIPStart
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0xC, PORT & 0xFF, PORT >> 8, 0);//CIPStart
}

const weeemake_wifi_init_tcp = exports.weeemake_wifi_init_tcp = async function(argValues){
	const {SENSOR_PORT, IP, PORT} = castPort2Pin(argValues);
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x2, 3);//CWMode
	await send_packet_onewire_get.call(this, SENSOR_PORT, 0x9, 1, 10);//CWJAP;
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0xE, 1);//CIPMux
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0xB, ...castStr2Bytes(IP), 0);//CIPStart
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0xC, PORT & 0xFF, PORT >> 8, 0);//CIPStart
}

const weeemake_wifi_init_ap = exports.weeemake_wifi_init_ap = async function(argValues){
	const {SENSOR_PORT, CHANNEL} = castPort2Pin(argValues);
	const PORT = 6602;
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x2, 2);//CWMode
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x5, CHANNEL, 2);//CWSAP
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0xE, 1);//CIPMux
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x6, PORT & 0xFF, PORT >> 8);//setPort
}

const weeemake_wifi_init_sta = exports.weeemake_wifi_init_sta = async function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	const PORT = 6602;
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x2, 1);//CWMode
	await send_packet_onewire_get.call(this, SENSOR_PORT, 0x9, 1, 10);//CWJAP;
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0xE, 1);//CIPMux
	await send_packet_onewire_set.call(this, SENSOR_PORT, 0x6, PORT & 0xFF, PORT >> 8);//setPort
}

const weeemake_wifi_write = exports.weeemake_wifi_write = async function(argValues){
	const {SENSOR_PORT, VALUE, ID} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0x7, 1, 6, ID, ...castStr2Bytes(VALUE), 0);
	return result[0] != 0;
}

const weeemake_wifi_read = exports.weeemake_wifi_read = async function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0x8, 21);
	if(result[0] == 0xFF)return false;
	let index = result.indexOf(0, 1);
	if(index < 0)return false;
	get_wifi_buffer(SENSOR_PORT).splice(1, 2, result[0], String.fromCharCode(...result.slice(1, index)));
	return true;
}

const weeemake_wifi_read_ip = exports.weeemake_wifi_read_ip = async function(argValues){
	const {SENSOR_PORT} = castPort2Pin(argValues);
	let result = await send_packet_onewire_get.call(this, SENSOR_PORT, 0xA, 20, 6);
	let index = result.indexOf(0);
	if(index < 0)return false;
	get_wifi_buffer(SENSOR_PORT)[0] = String.fromCharCode(...result.slice(0, index));
	return true;
}

const weeemake_wifi_value = exports.weeemake_wifi_value = function(argValues){
	const {SENSOR_PORT, WIFI_VALUE_NAME} = castPort2Pin(argValues);
	return get_wifi_buffer(SENSOR_PORT)[WIFI_VALUE_NAME];
}

const weeemake_wifi_check_recv_data = exports.weeemake_wifi_check_recv_data = function(argValues){
	const {SENSOR_PORT, DATA} = castPort2Pin(argValues);
	return get_wifi_buffer(SENSOR_PORT)[2] == DATA;
}
