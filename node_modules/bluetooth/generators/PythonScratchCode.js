'use strict';
const {tab} = require('utils/text');

const repeatFnFactory = (keyCond, keyDo) => function(block, {[keyCond]:count, [keyDo]:subCode}){
	let name = 'i';
	return `for ${name} in range(${count}):\n${tab(subCode ?? 'pass\n')}`;
}

const Python = {
	variables_get(block, {VAR}){
		let name = this.adjustVarName(VAR);
		return [name, this.ORDER_ATOMIC];
	},
	variables_set(block, {VAR, VALUE=0}){
		let name = this.adjustVarName(VAR);
		return this.commentStatement(`${name} = ${VALUE}`, VAR);
	},
	math_change(block, {VAR, DELTA}){
		let name = this.adjustVarName(VAR);
		return this.commentStatement(`${name} += ${DELTA}`, VAR);
	},
	procedures_call(block){
		let raw_name = block.getFieldValue('NAME');
		let defBlock = block.workspace.getTopBlocks().find(block => block.type == 'procedures_definition' && block.getFieldValue('NAME') == raw_name);
		let name = this.adjustVarName(raw_name);
		let args = defBlock._getArgList().map(id => this.valueToCode(block, id, this.ORDER_NONE) || '0');
		return this.commentStatement(`${name}(${args.join(', ')})`, raw_name);
	},
	procedures_param(block){
		let raw_name = block.getFieldValue('NAME');
		let name = this.adjustVarName(raw_name);
		return [name, this.ORDER_ATOMIC];
	}

	/*,
	procedures_callnoreturn(block){
		return this.tab() + this.procedures_callreturn(block)[0] + this.END;
	},
	procedures_callreturn(block){
		const name = this.adjustVarName(block.getFieldValue('NAME'));
		const args = block.arguments_.map((_, i) => this.valueToCode(block, 'ARG'+i, this.ORDER_NONE));
		return [`${name}(${args.join(', ')})`, this.ORDER_ATOMIC];
	},
	procedures_return(block){
		const VALUE = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		return this.tab() + `return ${VALUE}` + this.END;
	}
	*/,
	procedures_ifreturn(block, {VALUE=0, CONDITION='false'}){
		return `if ${CONDITION}:return ${VALUE}\n`;
	},
	argument_reporter_boolean:'argument_reporter_string_number',
	argument_reporter_string_number(block){
		let name = this.adjustVarName(block.getFieldValue('VALUE'));
		return [name, 0];
	},
	native_colour_picker(block, {value}){
		return [value.replace('#', '0x'), this.ORDER_ATOMIC];
	},
	colour_picker(block, {COLOUR}){
		return [COLOUR.replace('#', '0x'), this.ORDER_ATOMIC];
	},
	text(block, {TEXT=''}){
		return [JSON.stringify(TEXT), this.ORDER_ATOMIC];
	},
	logic_boolean(block, {BOOL}){
		return [BOOL == 'TRUE' ? 'True' : 'False', this.ORDER_ATOMIC]
	},
	logic_null(){
		return ['None', this.ORDER_ATOMIC];
	},
	logic_ternary(block, {IF, THEN, ELSE}){
		return [`${THEN} if ${IF} else ${ELSE}`, this.ORDER_HIGH]
	},
	math_lists_index:'math_number',
	math_angle:'math_number',
	math_integer:'math_number',
	math_positive_number:'math_number',
	math_whole_number:'math_number',
	math_number(block, {NUM:text}){
		return [isNaN(Number(text)) ? '0' : text, this.ORDER_ATOMIC];
	},
	calcListIndex(block, key='INDEX'){
		let index = this.valueToCode(block, key, this.ORDER_ADDITIVE);
		let number = Number(index);
		return isNaN(number) ? `${index} - 1` : number - 1;
	},
	
	log(block, {value=0}){
		return `print(${value})\n`;
	},
	sensing_timer(block){
		this.addInclude('import time');
		this.addVarDef(`lasttime = time.ticks_ms()`, 'lasttime');
		return ['time.ticks_diff(time.ticks_ms(), lasttime) * 0.001', ORDER_MULTIPLICATIVE];
	},
	sensing_resettimer(block){
		this.addInclude('import time');
		this.addVarDef(`lasttime = time.ticks_ms()`, 'lasttime');
		return `lasttime = time.ticks_ms()\n`;
	},
	control_wait(block, {DURATION}){
		this.addInclude('import time');
		return `time.sleep(${DURATION})\n`;
	},
	control_stop(block){
		return `while True: pass\n`;
	},
	control_wait_until: 'control_repeat_until',
	control_repeat_until(block, {SUBSTACK}, {CONDITION}){
		let condition = CONDITION.fixBrackets(this.ORDER_NOT, true);
		return `while not ${condition}:\n${tab(SUBSTACK ?? 'pass\n')}`;
	},
	control_if(block, {CONDITION, SUBSTACK}){
		return `if ${CONDITION}:\n${tab(SUBSTACK ?? 'pass\n')}`;
	},
	control_if_else(block, {CONDITION, SUBSTACK, SUBSTACK2}){
		if(/^if\x20.+:\n(\t.*\n|else:\n|elif\x20.+:\n)+$/.test(SUBSTACK2)){
			return `if ${CONDITION}:\n${tab(SUBSTACK ?? 'pass\n')}el${SUBSTACK2}`;
		}
		return `if ${CONDITION}:\n${tab(SUBSTACK ?? 'pass\n')}else:\n${tab(SUBSTACK2 ?? 'pass\n')}`;
	},
	controls_for(block, {VAR, FROM, TO, BY, DO}){
		const i = this.adjustVarName(VAR);
		return `for ${i} in range(${FROM}, ${TO}, ${BY}):\n${tab(DO ?? 'pass\n')}`;
	},
	controls_flow_statements(block, {FLOW}){
		return FLOW.toLowerCase() + ';\n';
	},
	
	controls_repeat_ext: repeatFnFactory('TIMES', 'DO'),
	control_repeat: repeatFnFactory('TIMES', 'SUBSTACK')
	/*,
	control_repeat(block){
		let tab = Python.tab();
		let count = Python.valueToCode(block, "TIMES", this.ORDER_NONE) || '0';
		let subCode = Python.statementToCodeIndent(block, 'SUBSTACK');
		let name = 'i';
		return `${tab}for(int ${name}=${count}; ${name}>0; --${name})` + (subCode ? `{\n${subCode}${tab}}\n` : this.END);
	}*/,
	control_forever(block, {SUBSTACK}){
		return `while True:\n${tab(SUBSTACK ?? 'pass\n')}`;
	},
	logic_compare: (dict => function(block, {OP}, {A, B}){
		const order = this.ORDER_RELATIONAL;
		return [`${A?.fixBrackets(order) ?? 0} ${dict[OP]} ${B?.fixBrackets(order,true) ?? 0}`, order];
	})({
		EQ:'==',
		NEQ:'!=',
		LT:'<',
		LTE:'<=',
		GT:'>',
		GTE:'>=',
	}),
	math_arithmetic: (dict => function(block, {OP}, {A, B}){
		if(OP == 'POWER'){
			return [`pow(${A.fixBrackets(this.ORDER_NONE)}, ${B.fixBrackets(this.ORDER_NONE)})`, this.ORDER_ATOMIC]
		}
		let order = (OP == 'MULTIPLY' || OP == 'DIVIDE') ? this.ORDER_MULTIPLICATIVE : this.ORDER_ADDITIVE;
		return [`${A.fixBrackets(order)} ${dict[OP]} ${B.fixBrackets(order, true)}`, order];
	})({MULTIPLY: '*', DIVIDE: '/', ADD: '+', MINUS: '-'}),

	math_single(block, {OP}, {NUM}){
		const order = OP == 'NEG' ? this.ORDER_UNARY : this.ORDER_NONE;
		NUM = NUM.fixBrackets(order);
		if(OP == 'ROOT')return [`sqrt(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'ABS')return [`abs(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'NEG')return [`- ${NUM}`, order];
		if(OP == 'LN')return [`log(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'LOG10')return [`log10(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'EXP')return [`exp(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'POW10')return [`pow(10, ${NUM})`, this.ORDER_ATOMIC];
	},
	math_trig(block, {OP}, {NUM}){
		const order = OP.indexOf('A') == 0 ? this.ORDER_NONE : this.ORDER_MULTIPLICATIVE;
		NUM = NUM.fixBrackets(order);
		if(order == this.ORDER_NONE){
			return [OP.toLowerCase() + `(${NUM}) * M_1_PI * 180.0`, this.ORDER_MULTIPLICATIVE]
		}
		return [OP.toLowerCase() + `(${NUM} * M_PI / 180.0)`, this.ORDER_ATOMIC]
	},
	math_number_property(block, {PROPERTY, DIVISOR}, {NUMBER_TO_CHECK}){
		if(PROPERTY == 'EVEN')return [
			`${NUMBER_TO_CHECK.fixBrackets(this.ORDER_MULTIPLICATIVE)} % 2 == 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'ODD')return [
			`${NUMBER_TO_CHECK.fixBrackets(this.ORDER_MULTIPLICATIVE)} % 2 == 1`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'WHOLE')return [
			`fmod(${NUMBER_TO_CHECK.fixBrackets(this.ORDER_NONE)}, 1) == 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'POSITIVE')return [
			`${NUMBER_TO_CHECK.fixBrackets(this.ORDER_RELATIONAL)} > 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'NEGATIVE')return [
			`${NUMBER_TO_CHECK.fixBrackets(this.ORDER_RELATIONAL)} < 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'DIVISIBLE_BY')return [
			`lround(${NUMBER_TO_CHECK.fixBrackets(this.ORDER_NONE)}) % lround(${DIVISOR}) == 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'PRIME'){
			return ['0', this.ORDER_ATOMIC];
		}
	},
	math_constrain(block, {VALUE, LOW, HIGH}){
		return [`constrain(${VALUE}, ${LOW}, ${HIGH})`, this.ORDER_HIGH];
	},
	math_round: (dict => function(block, {OP, NUM}){
		return [`${dict[OP]}(${NUM})`, this.ORDER_ATOMIC];
	})({
		ROUND: 'round',
		ROUNDUP: 'ceil',
		ROUNDDOWN: 'floor'
	}),
	math_modulo(block, {DIVIDEND, DIVISOR}){
		return [`fmod(${DIVIDEND}, ${DIVISOR})`, this.ORDER_ATOMIC]
	},
	math_random_int(block, {FROM}, {TO}){
		return [`random(${FROM}, ${TO.fixBrackets(this.ORDER_ADDITIVE)} + 1)`, this.ORDER_ATOMIC];
	},
	math_random_float(block){
		return [`random(1000) * 0.001`, this.ORDER_MULTIPLICATIVE];
	},
	math_atan2(block, {X, Y}){
		return [`atan2(${Y}, ${X})`, this.ORDER_ATOMIC];
	},
	math_constant(block, {CONSTANT}){
		this.addInclude('import math')
		if(CONSTANT == 'PI')return ['math.pi', this.ORDER_ATOMIC];
		if(CONSTANT == 'E')return ['math.e', this.ORDER_ATOMIC];
		if(CONSTANT == 'GOLDEN_RATIO')return ['1.618', this.ORDER_ATOMIC];
		if(CONSTANT == 'SQRT2')return ['math.sqrt(2)', this.ORDER_ATOMIC];
		if(CONSTANT == 'SQRT1_2')return ['math.sqrt(0.5)', this.ORDER_ATOMIC];
		if(CONSTANT == 'INFINITY')return ['math.inf', this.ORDER_ATOMIC];
	},
	text_length(block, {VALUE}){
		return [`len(str(${VALUE}))`, this.ORDER_HIGH];
	},
	colour_random(block){
		return [`random(0x1000000)`, this.ORDER_ATOMIC];
	},
	colour_rgb(block, _, {RED, GREEN, BLUE}){
		const order = this.ORDER_BIT_AND;
		RED = RED.fixBrackets(order);
		GREEN = GREEN.fixBrackets(order);
		BLUE = BLUE.fixBrackets(order);
		return [`(${RED} & 0xFF) * 0x10000 | (${GREEN} & 0xFF) << 8 | ${BLUE} & 0xFF`, this.ORDER_BIT_OR];
	},
	colour_blend(block, _, {COLOUR1, COLOUR2, RATIO}){
		const COLOUR1L = COLOUR1.fixBrackets(this.ORDER_ADDITIVE);
		const COLOUR1R = COLOUR1.fixBrackets(this.ORDER_ADDITIVE, true);
		COLOUR2 = COLOUR2.fixBrackets(this.ORDER_ADDITIVE);
		RATIO = RATIO.fixBrackets(this.ORDER_MULTIPLICATIVE, true);
		//bugfix COLOUR1 calc twice
		return [`${COLOUR1L} + (${COLOUR2} - ${COLOUR1R}) * ${RATIO}`, this.ORDER_ADDITIVE];
	},
	logic_operation(block, {OP}, {A, B}){
		const order = OP == 'AND' ? this.ORDER_AND : this.ORDER_OR;
		return [`${A?.fixBrackets(order) ?? false} ${OP.toLowercase()} ${B?.fixBrackets(order,true) ?? false}`, order];
	},
	logic_negate(block, _, {BOOL}){
		return [`not ${BOOL?.fixBrackets(order,true) ?? 'False'}`, this.ORDER_NOT];
	},
	/*
	operator_add(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_ADDITIVE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_ADDITIVE) || "0";
		return [`${a} + ${b}`, this.ORDER_ADDITIVE];
	},
	operator_subtract(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_ADDITIVE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_ADDITIVE) || "0";
		return [`${a} - ${b}`, this.ORDER_ADDITIVE];
	},
	operator_multiply(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_MULTIPLICATIVE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_MULTIPLICATIVE) || "0";
		return [`${a} * ${b}`, this.ORDER_MULTIPLICATIVE];
	},
	operator_divide(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_MULTIPLICATIVE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_MULTIPLICATIVE) || "1";
		return [`${a} / ${b}`, this.ORDER_MULTIPLICATIVE];
	},
	*/
	operator_mathop(block, {OPERATOR:op, NUM:v}){
		this.addInclude('import math');
		switch(op){
			case "ceiling":
				return [`math.ceil(${v})`, this.ORDER_ATOMIC];
			case "ln":
				return [`math.log(${v})`, this.ORDER_ATOMIC];
			case "log":
				return [`math.log10(${v})`, this.ORDER_ATOMIC];
			case "e ^":
				return [`math.exp(${v})`, this.ORDER_ATOMIC];
			case "10 ^":
				return [`math.pow(10, ${v})`, this.ORDER_ATOMIC];
			case "sin":
			case "cos":
			case "tan":
				return [`math.${op}(math.radians(${v}))`, this.ORDER_ATOMIC];
			case "asin":
			case "acos":
			case "atan":
				return [`math.degrees(math.${op}(${v}))`, this.ORDER_ATOMIC];
			case "abs":
				return [`math.fabs(${v})`, this.ORDER_ATOMIC];
		}
		return [`math.${op}(${v})`, this.ORDER_ATOMIC];
	},
	/*
	operator_not(block, _, {OPERAND}){
		//let v = this.valueToCode(block, "OPERAND", this.ORDER_UNARY) || '0';
		return [`!${OPERAND.fixBrackets(this.ORDER_UNARY, true)}`, this.ORDER_UNARY];
	},
	*/
	operator_mod(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_NONE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_NONE) || "1";
		return [`${a} % ${b}`, this.ORDER_MULTIPLICATIVE];
	},
	operator_round(block){
		let v = this.valueToCode(block, "NUM", this.ORDER_NONE) || "0";
		return [`round(${v})`, this.ORDER_HIGH];
	},
	operator_random(block){
		this.addInclude('import random');
		let a = this.valueToCode(block, "FROM", this.ORDER_NONE) || "0";
		let b = this.valueToCode(block, "TO", this.ORDER_ADDITIVE) || "1";
		return [`random.randint(${a}, ${b})`, this.ORDER_HIGH];
	},
	operator_join(block, {STRING1, STRING2}){
		return [`str(${STRING1}) + str(${STRING2})`, this.ORDER_ADDITIVE];
	},
	operator_letter_of(block){
		let index = this.calcListIndex(block, 'LETTER');
		let text = this.valueToCode(block, "STRING", this.ORDER_NONE);
		return [`str(${text})[${index}]`, this.ORDER_HIGH];
	},
	operator_length(block){
		let text = this.valueToCode(block, "STRING", this.ORDER_NONE);
		return [`len(str(${text}))`, this.ORDER_HIGH];
	},
	operator_contains(block){
		let a = this.valueToCode(block, "STRING1", this.ORDER_NONE);
		let b = this.valueToCode(block, "STRING2", this.ORDER_NONE);
		return [`str(${b}) in str(${a})`, this.ORDER_RELATIONAL];
	},
	lists_deleteoflist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let index = this.calcListIndex(block);
		return this.commentStatement(`${name}.removeAt(${index})`, raw_name);
	},
	lists_addtolist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		return this.commentStatement(`${name}.push(${item})`, raw_name);
	},
	lists_deletealloflist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		return this.commentStatement(`${name}.clear()`, raw_name);
	},
	lists_insertatlist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		let index = this.calcListIndex(block);
		return this.commentStatement(`${name}.insertAt(${index}, ${item})`, raw_name);
	},
	lists_replaceitemoflist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		let index = this.calcListIndex(block);
		return this.commentStatement(`${name}.replaceAt(${index}, ${item})`, raw_name);
	},
	lists_itemoflist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let index = this.calcListIndex(block);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.getValueAt(${index})`, this.ORDER_HIGH];
	},
	lists_indexOf(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.indexOf(${item}) + 1`, this.ORDER_ADDITIVE];
	},
	lists_length(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.getLength()`, this.ORDER_HIGH];
	},
	lists_listcontainsitem(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.include(${item})`, this.ORDER_HIGH];
	},
	procedures_defreturn(block, {NAME, STACK, RETURN, arg=[]}){
		if(!Array.isArray(arg)){arg = [arg];}
		const name = this.adjustVarName(NAME);
		this.addFuncDef(`double ${name}(${arg.map(v => `double ` + this.adjustVarName(v.name)).join(', ')})`, (STACK ?? '') + `return ${RETURN ?? 0};\n`);
	},
	procedures_defnoreturn(block, {NAME, STACK, arg=[]}){
		if(!Array.isArray(arg)){arg = [arg];}
		const name = this.adjustVarName(NAME);
		this.addFuncDef(`void ${name}(${arg.map(v => `double ` + this.adjustVarName(v.name)).join(', ')})`, STACK ?? '');
	}
};


module.exports = Python;
