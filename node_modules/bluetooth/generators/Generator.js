
const {createListGetter} = require('utils/cache');

class Stage {
	initStage(){
		this._stage = [];
		this.stage = createListGetter(() => Object.create(null), this._stage);
	}
	genStageCode(){
		return Object.values(this._stage).map(v => Object.values(v).join('')).join('\n');
	}
	addStage(index, code, key=code){
		this.stage(index)[key] = code;
	}
}

class Generator extends Stage {
	addInclude(text, key=text){
		this.addStage(this.STAGE_INCLUDE, text + '\n', key);
	}
	addVarDef(text, key=text){
		this.addStage(this.STAGE_VAR, text, key);
	}
	addSetupCode(text, key=text){
		this.addStage(this.STAGE_SETUP, text, key);
	}
	addLoopCode(text, key=text){
		this.addStage(this.STAGE_LOOP, text, key);
	}
	collectVarDefs(vars){
		if(!vars)return;
		for(let {'#text':name, type} of castToArray(vars)){
			if(!type)continue;
			let new_name = adjustVarName(name);
			this.addVarDef(this.commentStatement(this.onGenVarDef(new_name, type), name), new_name);
		}
	}
	blockToCode(block){
		if(!block)return '';
		let func = block.type;
		do{
			func = this.context[func];
		}while(typeof func === 'string');
		if(!func){
			if(!block.value && block.field && !Array.isArray(block.field)){
				return [block.field['#text'], this.ORDER_ATOMIC];
			}
		}
		let code;
		if(!block.disabled && func){
			const fields = Object.create(null);
			if(block.field){
				for(let field of castToArray(block.field)){
					fields[field.name] = field['#text'];
				}
			}
			const inputs = Object.create(null);
			if(block.value){
				for(let value of castToArray(block.value)){
					let input = value.block ?? value.shadow;
					let [code, order] = this.blockToCode(input);
					inputs[value.name] = {
						type: input.type,
						fixBrackets: (...args) => this.needBrackets(order, ...args) ? `(${code})` : code,
					};
					fields[value.name] = code;
				}
			}
			if(block.statement){
				for(let statement of castToArray(block.statement)){
					fields[statement.name] = this.blockToCode(statement.block);
				}
			}
			Object.assign(fields, block.mutation);
			if(this.isEventBlock(block))fields.next = this.blockToCode(block.next?.block);
			code = func.call(this, null, fields, inputs);//remove block arg
			if(this.isEventBlock(block))return code;
		}
		if(Array.isArray(code))return code;
		return (code ?? '') + this.blockToCode(block.next?.block);
	}
	init(){
		this.initStage();
	}
	workspaceToCode(workspace){
		if(!workspace.block)return '';
		this.init();
		const blockList = castToArray(workspace.block);
		blockList.filter(block => this.FUNC_BLOCK_TYPE.includes(block.type)).forEach(this.blockToCode, this);
		const code = blockList.filter(this.isEventBlock).map(this.blockToCode, this).join('');
		return this.finish(workspace, code);
	}
	isEventBlock(block){
		return block.data === 'isEventBlock';
	}
	commentStatement(code, text){
		const result = code + this.END;
		if(isNormalName(text))return result;
		return result.replace('\n', n => '\t' + this.COMMENT + text + n);
	}
}

const castToArray = v => Array.isArray(v) ? v : [v];
const isNormalName = (p => v => p.test(v))(/^\w+$/);
const removeBlanks = (p => v => v.replace(p, '_'))(/[\x20\t]+/g);
const castChar = ((p, f) => v => v.replace(p, f))(/\W/g, v => v.charCodeAt().toString(36));
const adjustVarName = v => isNormalName(v) ? '_' + v : castChar(removeBlanks(v));

Object.assign(Generator.prototype, {
	STAGE_INCLUDE: 0,
	STAGE_VAR: 1,
	STAGE_FUNC_PROTO: 2,
	STAGE_FUNC_DEF: 3,
	STAGE_SETUP: 4,
	STAGE_LOOP: 5,
	FUNC_BLOCK_TYPE: ['procedures_defreturn', 'procedures_defnoreturn', 'procedures_def'],
	isNormalName,
	adjustVarName,
});



module.exports = Generator;
