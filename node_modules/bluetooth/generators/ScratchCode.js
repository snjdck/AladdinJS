'use strict';

const Scratch = {
	variables_get(block, {VAR}){
		let name = this.adjustVarName(VAR);
		return [name, this.ORDER_ATOMIC];
	},
	variables_set(block, {VAR, VALUE=0}){
		let name = this.adjustVarName(VAR);
		return this.commentStatement(`${name} = ${VALUE}`, VAR);
	},
	math_change(block, {VAR, DELTA}){
		let name = this.adjustVarName(VAR);
		return this.commentStatement(`${name} += ${DELTA}`, VAR);
	},
	procedures_call(block){
		let raw_name = block.getFieldValue('NAME');
		let defBlock = block.workspace.getTopBlocks().find(block => block.type == 'procedures_definition' && block.getFieldValue('NAME') == raw_name);
		let name = this.adjustVarName(raw_name);
		let args = defBlock._getArgList().map(id => this.valueToCode(block, id, this.ORDER_NONE) || '0');
		return this.commentStatement(`${name}(${args.join(', ')})`, raw_name);
	},
	procedures_param(block){
		let raw_name = block.getFieldValue('NAME');
		let name = this.adjustVarName(raw_name);
		return [name, this.ORDER_ATOMIC];
	}
	argument_reporter_boolean:'argument_reporter_string_number',
	argument_reporter_string_number(block){
		let name = this.adjustVarName(block.getFieldValue('VALUE'));
		return [name, 0];
	},
	native_colour_picker(block, {value}){
		return [value.replace('#', '0x'), this.ORDER_ATOMIC];
	},
	colour_picker(block, {COLOUR}){
		return [COLOUR.replace('#', '0x'), this.ORDER_ATOMIC];
	},
	text(block, {TEXT=''}){
		return [JSON.stringify(TEXT), this.ORDER_ATOMIC];
	},
	math_lists_index:'math_number',
	math_angle:'math_number',
	math_integer:'math_number',
	math_positive_number:'math_number',
	math_whole_number:'math_number',
	math_number(block, {NUM:text}){
		return [isNaN(Number(text)) ? '0' : text, this.ORDER_ATOMIC];
	},
	controls_flow_statements(block, {FLOW}){
		return FLOW.toLowerCase() + this.END;
	},
	logic_compare: (dict => function(block, {OP}, {A, B}){
		const order = (OP == '==' || OP == '!=') ? this.ORDER_EQUAL : this.ORDER_RELATIONAL;
		return [`${A?.fixBrackets(order) ?? 0} ${dict[OP]} ${B?.fixBrackets(order,true) ?? 0}`, order];
	})({EQ:'==', NEQ:'!=', LT:'<', LTE:'<=', GT:'>', GTE:'>='}),

	math_arithmetic: (dict => function(block, {OP}, {A, B}){
		if(OP == 'POWER'){
			return [`pow(${A.fixBrackets(this.ORDER_NONE)}, ${B.fixBrackets(this.ORDER_NONE)})`, this.ORDER_ATOMIC]
		}
		let order = (OP == 'MULTIPLY' || OP == 'DIVIDE') ? this.ORDER_MULTIPLICATIVE : this.ORDER_ADDITIVE;
		return [`${A.fixBrackets(order)} ${dict[OP]} ${B.fixBrackets(order, true)}`, order];
	})({MULTIPLY: '*', DIVIDE: '/', ADD: '+', MINUS: '-'}),

	colour_rgb(block, _, {RED, GREEN, BLUE}){
		const order = this.ORDER_BIT_AND;
		RED = RED.fixBrackets(order);
		GREEN = GREEN.fixBrackets(order);
		BLUE = BLUE.fixBrackets(order);
		return [`(${RED} & 0xFF) * 0x10000 | (${GREEN} & 0xFF) << 8 | ${BLUE} & 0xFF`, this.ORDER_BIT_OR];
	},
	colour_blend(block, _, {COLOUR1, COLOUR2, RATIO}){
		const COLOUR1L = COLOUR1.fixBrackets(this.ORDER_ADDITIVE);
		const COLOUR1R = COLOUR1.fixBrackets(this.ORDER_ADDITIVE, true);
		COLOUR2 = COLOUR2.fixBrackets(this.ORDER_ADDITIVE);
		RATIO = RATIO.fixBrackets(this.ORDER_MULTIPLICATIVE, true);
		//bugfix COLOUR1 calc twice
		return [`${COLOUR1L} + (${COLOUR2} - ${COLOUR1R}) * ${RATIO}`, this.ORDER_ADDITIVE];
	},
};


module.exports = Scratch;
