import db from '../db';
import {board_k210, board_python_2in1, board_microbitV2, board_elf_esp32, board_elf_esp32_pro, board_elf_shield_microbit, board_elf_ai_handle, board_elf_weee_core} from '../boards';
import pinyin from 'text/pinyin';
import gbk from 'text/gbk';

const tabText = function(){
	const pattern = /.*\n|.+$/g;
	return text => text.replace(pattern, '\t$&');
}();

const identity = v => v;
//*
function hexToRgb(hex){
	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		R: parseInt(result[1], 16),
		G: parseInt(result[2], 16),
		B: parseInt(result[3], 16)
	} : {R:0,G:0,B:0};
}

function castMatrixCPP(matrix, w, h){
	let bytes = [];
	for(let j=0; j<w; ++j){
		bytes[j] = 0;
		for(let i=0; i<h; ++i){
			if(matrix.charAt(i*w+j) === '1'){
				bytes[j] |= 1 << i;
			}
		}
	}
	return bytes.map(v => '0x' + v.toString(16)).join(', ');
}

function castMatrix(matrix, w=5, h=5, v=9){
	let result = [];
	for(let j=0; j<h; ++j){
		let line = [];
		for(let i=0; i<w; ++i){
			let isOn = matrix.charAt(j*w+i) === '1';
			line.push(isOn ? v : '0');
		}
		result.push(line.join(''));
	}
	return `"${result.join(':')}"`;
}

const mPythonPinToIndex = function(){
	const dict = {
		'PORT_A':13,
		'PORT_B':14,
		'PORT_C':15,
		'PORT_D':16,
	}
	return port => dict[port];
}()

//*/
export default function(Arduino){
	const {ORDER_ATOMIC, ORDER_HIGH, ORDER_UNARY, ORDER_ADDITIVE, ORDER_RELATIONAL, ORDER_NONE, END} = Arduino;
	/*function option_handler(block){
		let value = block.inputList[0].fieldRow[0].text_;
		return [value, Arduino.ORDER_ATOMIC];
	}*/
	const register_option = name => Arduino[name] = block => [block.getFieldValue(name.toUpperCase()), Arduino.ORDER_ATOMIC];
	//单色led灯
	register_option('speed');
	register_option('angle');
	register_option('rgb');
	register_option('analog');
	register_option('beat');
	register_option('matrix@5*5');
	register_option('matrix@21*7');
	register_option('matrix@14*5');
	register_option('speech-recognition-index');
	register_option('microbit-matrix-index');
	register_option('microbit-matrix-value');
	register_option('rj11-rgb-index');
	Arduino['weeemake_magnet_index'] = block => [block.getFieldValue('value'), Arduino.ORDER_ATOMIC];
	Arduino['castToCStr'] = block => [`str(${Arduino.valueToCode(block, 'value', Arduino.ORDER_NONE)})`, Arduino.ORDER_ATOMIC];
	Arduino['motorSpeedRange'] = block => [block.getFieldValue('value'), Arduino.ORDER_ATOMIC];
	Arduino['buzzer-note'] = block => [block.getFieldValue('NOTE'), Arduino.ORDER_ATOMIC];
	//register_option('colour_picker', 'COLOUR');
	//register_option('math_integer', 'NUM');

	function add_helper_func(){
		let name = 'set_rgb_pixel';
		Arduino.markNameUsed(name);
		Arduino.addFuncDef(name, ['np', 'index', 'rgb'], [
			`if index == 0:`,
			Arduino.INDENT + `for i in range(len(np)):`,
			Arduino.INDENT.repeat(2) + `np[i] = rgb`,
			`else:`,
			Arduino.INDENT + `np[index-1] = rgb`
		]);
	}

	function add_helper_func_mpython(){
		let name = 'set_rgb_pixel';
		Arduino.markNameUsed(name);
		Arduino.addFuncDef(name, ['np', 'index', 'rgb'], [
			`if index == 0:`,
			Arduino.INDENT + `np.fill(rgb)`,
			`else:`,
			Arduino.INDENT + `np[index-1] = rgb`
		]);
	}

	Arduino.weeemake_generate_offline_code = block => '';

	function elf_shield_microbit_rgb(PIXEL, R, G, B){
		if(db.board == board_python_2in1 || db.board == board_elf_weee_core){
			this.addInclude('from mpython import *');
			let rgb = `(${R}, ${G}, ${B})`;
			let result = [];
			const index = Number(PIXEL);
			if(isNaN(index)){
				add_helper_func_mpython();
				result.push(`set_rgb_pixel(rgb, ${PIXEL}, ${rgb})`);
			}else if(index === 0){
				result.push(`rgb.fill(${rgb})`);
			}else{
				result.push(`rgb[${index-1}] = ${rgb}`);
			}
			result.push(`rgb.write()`);
			return result.map(v => Arduino.tab() + v + END).join('');
		}
		if(!db.isMicrobitBoard())return;

		this.addInclude('from microbit import *');
		this.addInclude('from neopixel import NeoPixel');

		let key = 'rgb_led';
		let rgb = `(${R}, ${G}, ${B})`;

		this.addVarDef(`${key} = NeoPixel(pin8, 3)`, key);
		let result = [];
		const index = Number(PIXEL);
		if(isNaN(index)){
			add_helper_func();
			result.push(`set_rgb_pixel(${key}, ${PIXEL}, ${rgb})`);
		}else if(index === 0){
			result.push(`${key}[0] = ${key}[1] = ${key}[2] = ${rgb}`);
		}else{
			result.push(`${key}[${index-1}] = ${rgb}`);
		}
		result.push(`${key}.show()`);
		
		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.string = function(block){
		return [JSON.stringify(block.getFieldValue('TEXT')), ORDER_HIGH]
	}

	Arduino.weeemake_elf_shield_microbit_rgb = function(block){
		const PIXEL = this.valueToCode(block, 'PIXEL', ORDER_NONE);
		const COLOR = this.valueToCode(block, 'COLOR', ORDER_NONE);
		let {R,G,B} = hexToRgb(COLOR);
		return elf_shield_microbit_rgb.call(this,PIXEL,R,G,B);
	}

	Arduino.weeemake_elf_shield_microbit_rgb3 = function(block){
		const PIXEL = this.valueToCode(block, 'PIXEL', ORDER_NONE);
		const R = this.valueToCode(block, 'R', ORDER_NONE);
		const G = this.valueToCode(block, 'G', ORDER_NONE);
		const B = this.valueToCode(block, 'B', ORDER_NONE);

		return elf_shield_microbit_rgb.call(this,PIXEL,R,G,B);
	}

	Arduino.weeemake_weeebotMini_board_light = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
			return [`light.read()`, ORDER_HIGH];
		}
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
			return [`light.read()`, ORDER_HIGH];
		}
		if(db.isMicrobitBoard()){
			this.addInclude('from microbit import *');
			return [`display.read_light_level()`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_weeebotMini_board_sound = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_weee_core){
			this.addInclude('from mpython import *');
			return [`sound.read()`, ORDER_HIGH];
		}
		if(db.board == board_microbitV2){
			this.addInclude('from microbit import *');
			return [`microphone.sound_level()`, ORDER_HIGH];
		}
		if(db.board == board_elf_shield_microbit){
			this.addInclude('from microbit import *');
			return [`pin2.read_analog()`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_single_led = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ON_OFF = block.getFieldValue('ON_OFF');

		if(db.board == board_elf_esp32_pro){
			const key = 'pin_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeSingleLED import *');
			Arduino.addVarDef(`${key} = WeSingleLED(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.turn_${ON_OFF == 1 ? 'on' : 'off'}()` + END;
		}

		if(db.board == board_k210){
			const key = 'pin_' + SENSOR_PORT.split('_')[1];
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from Maix import GPIO');
			Arduino.addSetupCode(`${key} = GPIO(${SENSOR_PORT} - 24, GPIO.OUT)`);
			return Arduino.tab() + `${key}.value(${ON_OFF})` + END;
		}

		if(db.board == board_python_2in1){
			const key = 'pin_' + SENSOR_PORT.split('_')[1];
			Arduino.addInclude('from mpython import *');
			Arduino.addInclude('from WePort import *');
			Arduino.addSetupCode(`${key} = MPythonPin(${mPythonPinToIndex(SENSOR_PORT)}, PinMode.OUT)`);
			return Arduino.tab() + `${key}.write_digital(${ON_OFF})` + END;
		}

		if(db.board == board_microbitV2){
			Arduino.addInclude('from WePort import *');
		}else{
			Arduino.addInclude('from elfshield import *');
		}
		
		return Arduino.tab() + `${SENSOR_PORT}.write_digital(${ON_OFF})` + END;
	}

	Arduino.weeemake_dc_motor = function(block){
		const DC_MOTOR_INDEX = block.getFieldValue('DC_MOTOR_INDEX');
		const SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			if(db.board == board_elf_esp32_pro){
				this.addInclude('from WePort import *')
			}
			const key = 'dc_' + DC_MOTOR_INDEX;
			Arduino.addInclude('from WeDCMotor import *');
			Arduino.addSetupCode(`${key} = WeDCMotor(${DC_MOTOR_INDEX})`);
			return Arduino.tab() + `${key}.run(${SPEED})` + END;
		}
		Arduino.addInclude('from microbit import *');
		Arduino.addSetupCode('motor.init()');
		return Arduino.tab() + `motor.runSpeed(${DC_MOTOR_INDEX}, ${SPEED})` + END;
	}

	Arduino.weeemake_robot_move = function(block){
		//1,2,3,4 => F,B,L,R
		const MOVE_DIRECTION = block.getFieldValue('MOVE_DIRECTION');
		let SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_elf_esp32_pro){
			if(db.board == board_elf_esp32_pro){
				this.addInclude('from WePort import *')
			}
			Arduino.addInclude('from WeDCMotor import *');
			Arduino.addSetupCode(`dc_1 = WeDCMotor(1)`);
			Arduino.addSetupCode(`dc_2 = WeDCMotor(2)`);
		}else{
			Arduino.addInclude('from microbit import *');
			Arduino.addSetupCode('motor.init()');
		}

		let needSpeedVar = !/^\w+$/.test(SPEED);
		let result = [];
		let l_sign = (MOVE_DIRECTION === '1' || MOVE_DIRECTION === '4') ? '-' : '';
		let r_sign = (MOVE_DIRECTION === '1' || MOVE_DIRECTION === '3') ? '' : '-';
		if(needSpeedVar){
			result.push(`speed = ${SPEED}`);
			SPEED = 'speed';
		}
		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_elf_esp32_pro){
			result.push(`dc_1.run(${r_sign}${SPEED})`);
			result.push(`dc_2.run(${l_sign}${SPEED})`);
		}else{
			result.push(`motor.runSpeed(1, ${r_sign}${SPEED})`);
			result.push(`motor.runSpeed(2, ${l_sign}${SPEED})`);
		}
		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.weeemake_vehicle_move = function(block){
		let LSPEED;
		let RSPEED = Arduino.valueToCode(block, 'RSPEED', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_elf_esp32_pro){
			if(db.board == board_elf_esp32_pro){
				this.addInclude('from WePort import *')
			}
			Arduino.addInclude('from WeDCMotor import *');
			Arduino.addSetupCode(`dc_1 = WeDCMotor(1)`);
			Arduino.addSetupCode(`dc_2 = WeDCMotor(2)`);
		}else{
			Arduino.addInclude('from microbit import *');
			Arduino.addSetupCode('motor.init()');
		}

		if(block.getInputTargetBlock('LSPEED').type != 'speed'){
			LSPEED = '-' + Arduino.valueToCode(block, 'LSPEED', ORDER_UNARY);
		}else{
			LSPEED = - Arduino.valueToCode(block, 'LSPEED', ORDER_NONE);
		}

		let result = [];
		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_elf_esp32_pro){
			result.push(`dc_1.run(${RSPEED})`);
			result.push(`dc_2.run(${LSPEED})`);
		}else{
			result.push(`motor.runSpeed(1, ${RSPEED})`);
			result.push(`motor.runSpeed(2, ${LSPEED})`);
		}
		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.weeemake_robot_stop = function(block){
		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_elf_esp32_pro){
			if(db.board == board_elf_esp32_pro){
				this.addInclude('from WePort import *')
			}
			Arduino.addInclude('from WeDCMotor import *');
			Arduino.addSetupCode(`dc_1 = WeDCMotor(1)`);
			Arduino.addSetupCode(`dc_2 = WeDCMotor(2)`);
			return Arduino.tab() + `dc_1.run(0)` + END + Arduino.tab() + `dc_2.run(0)` + END;
		}
		Arduino.addInclude('from microbit import *');
		Arduino.addSetupCode('motor.init()');
		let result = [`motor.runSpeed(1, 0)`, `motor.runSpeed(2, 0)`];
		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.weeemake_dc_130_motor = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'dc130_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from We130DCMotor import *');
			Arduino.addSetupCode(`${key} = We130DCMotor(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.run(${SPEED})` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `dc130motor_speed(${SENSOR_PORT}, ${SPEED})` + END;
	}

	Arduino.weeemake_servo = function(block){
		const SERVO_PORT = block.getFieldValue('SERVO_PORT');
		const ANGLE = Arduino.valueToCode(block, 'ANGLE', ORDER_NONE);

		const key = 'servo_' + SERVO_PORT.split('_').pop();
		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeServo import *');
		Arduino.addSetupCode(`${key} = WeServo(${SERVO_PORT})`);
		return Arduino.tab() + `${key}.write_angle(${ANGLE})` + END;
	}

	Arduino.weeemake_k210_timer = function(block){
		const T = block.getFieldValue('T');
		const C = block.getFieldValue('C');
		return [`${T << 2 | C}`, ORDER_ATOMIC];
	}

	Arduino.weeemake_k210_servo = function(block){
		const SERVO_PORT = block.getFieldValue('SERVO_PORT');
		const TIMER = Arduino.valueToCode(block, 'TIMER', ORDER_NONE);
		const ANGLE = Arduino.valueToCode(block, 'ANGLE', ORDER_NONE);

		const key = 'servo_' + SERVO_PORT;
		Arduino.addInclude('from WeServo import *');
		Arduino.addSetupCode(`${key} = WeServo(${SERVO_PORT}, ${TIMER})`);
		return Arduino.tab() + `${key}.write_angle(${ANGLE})` + END;
	}

	Arduino.weeemake_limit_switch = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board == board_python_2in1){
			const key = 'pin_' + SENSOR_PORT.split('_')[1];
			Arduino.addInclude('from mpython import *');
			Arduino.addInclude('from WePort import *');
			Arduino.addSetupCode(`${key} = MPythonPin(${mPythonPinToIndex(SENSOR_PORT)}, PinMode.IN)`);
			return [`${key}.read_digital()`, ORDER_HIGH];
		}

		if(db.board == board_k210){
			//Arduino.addInclude('from fpioa_manager import fm');
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from Maix import GPIO');

			const key = 'pin_' + SENSOR_PORT.split('_')[1];

			Arduino.addSetupCode(`${key} = GPIO(${SENSOR_PORT} - 24, GPIO.IN)`);
			
			return [`${key}.value()`, ORDER_HIGH];
		}

		Arduino.addInclude('from microbit import *');
		return [`${SENSOR_PORT}.read_digital()`, ORDER_HIGH];
	}

	Arduino.weeemake_elf_shield_microbit_servo = function(block){
		const MICROBIT_SERVO_INDEX = block.getFieldValue('MICROBIT_SERVO_INDEX');
		const ANGLE = Arduino.valueToCode(block, 'ANGLE', ORDER_NONE);

		if(db.board === board_microbitV2){
			Arduino.addInclude('from WeServo import *');
			const key = `servo_` + MICROBIT_SERVO_INDEX;
			Arduino.addSetupCode(`${key} = WeServo(${MICROBIT_SERVO_INDEX})`);
			return Arduino.tab() + `${key}.write_angle(${ANGLE})` + END;
		}

		if(db.board === board_elf_shield_microbit){
			Arduino.addInclude('from microbit import *');
			Arduino.addSetupCode('servo.init()');
			return Arduino.tab() + `servo.angle(${MICROBIT_SERVO_INDEX}, ${ANGLE})` + END;
		}

		return not_support_yet('microbit_servo');
	}

	Arduino.weeemake_elf_shield_microbit_servo_360 = function(block){
		const MICROBIT_SERVO_INDEX = block.getFieldValue('MICROBIT_SERVO_INDEX');
		const ANGLE = Arduino.valueToCode(block, 'ANGLE', ORDER_NONE);

		if(db.board === board_microbitV2){
			Arduino.addInclude('from WeServo import *');
			const key = `servo_` + MICROBIT_SERVO_INDEX;
			Arduino.addSetupCode(`${key} = WeServo(${MICROBIT_SERVO_INDEX}, 360)`);
			return Arduino.tab() + `${key}.write_angle(${ANGLE})` + END;
		}

		if(db.board === board_elf_shield_microbit){
			Arduino.addInclude('from microbit import *');
			Arduino.addSetupCode('servo.init()');
			return Arduino.tab() + `servo.angle360(${MICROBIT_SERVO_INDEX}, ${ANGLE})` + END;
		}

		return not_support_yet('microbit_servo_360');
	}

const IR_CODE_2_NAME = {
	0x45:'IR_CONTROLLER_A',
	0x46:'IR_CONTROLLER_B',
	0x47:'IR_CONTROLLER_C',
	0x44:'IR_CONTROLLER_D',
	0x40:'IR_CONTROLLER_UP',
	0x43:'IR_CONTROLLER_E',
	0x07:'IR_CONTROLLER_LEFT',
	0x15:'IR_CONTROLLER_OK',
	0x09:'IR_CONTROLLER_RIGHT',
	0x19:'IR_CONTROLLER_DOWN',
	0x0D:'IR_CONTROLLER_F',
	0x16:'IR_CONTROLLER_0',
	0x0C:'IR_CONTROLLER_1',
	0x18:'IR_CONTROLLER_2',
	0x5E:'IR_CONTROLLER_3',
	0x08:'IR_CONTROLLER_4',
	0x1C:'IR_CONTROLLER_5',
	0x5A:'IR_CONTROLLER_6',
	0x42:'IR_CONTROLLER_7',
	0x52:'IR_CONTROLLER_8',
	0x4A:'IR_CONTROLLER_9'
};

	Arduino.weeemake_buzzer = function(block){
		const NOTE = Arduino.valueToCode(block, 'NOTE', ORDER_NONE);
		const BEAT = Arduino.valueToCode(block, 'BEAT', ORDER_NONE);

		if(db.board == board_elf_esp32_pro){
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeBuzzer import *');
			let key = `buzzer`
			this.addVarDef(`${key} = WeBuzzer(OnBoard_Buzzer)`);
			return this.tab() + `${key}.tone(${NOTE}, ${BEAT})` + this.END;
		}

		Arduino.addInclude('import music');

		return Arduino.tab() + `music.pitch(${NOTE}, ${BEAT})` + END;
	}

	Arduino.weeemake_elf_shield_microbit_music_play = function(block){
		const MICROBIT_BUILTIN_MUSIC = block.getFieldValue('MICROBIT_BUILTIN_MUSIC');

		Arduino.addInclude('import music');

		return Arduino.tab() + `music.play(music.${MICROBIT_BUILTIN_MUSIC})` + END;
	}

	function add_k210_helper_func(){
		let name = 'set_rgb_pixel';
		Arduino.markNameUsed(name);
		Arduino.addFuncDef(name, ['ws', 'index', 'rgb'], [
			`if index == 0:`,
			Arduino.INDENT + `for i in range(32):`,
			Arduino.INDENT.repeat(2) + `ws.set_led(i, rgb)`,
			`else:`,
			Arduino.INDENT + `ws.set_led(index-1, rgb)`
		]);
	}

	function rgb_strip(SENSOR_PORT, PIXEL, R, G, B){
		let key = 'rgb_led_' + SENSOR_PORT.split('_')[1];
		let rgb = `(${R}, ${G}, ${B})`;
		if(db.board == board_k210){
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from modules import ws2812');
			Arduino.addSetupCode(`${key} = ws2812(${SENSOR_PORT}-24, 32)`);
			
			let result = [];
			const index = Number(PIXEL);
			if(index > 0){
				result.push(`${key}.set_led(${index-1}, ${rgb})`);
			}else{
				add_k210_helper_func();
				result.push(`set_rgb_pixel(${key}, ${PIXEL}, ${rgb})`);
			}
			result.push(`${key}.display()`);
			
			return result.map(v => Arduino.tab() + v + END).join('');
		}

		if(db.board == board_python_2in1 || db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
			Arduino.addInclude('from machine import Pin');
			SENSOR_PORT = `Pin(${SENSOR_PORT}, Pin.OUT)`;
		}

		if(db.board == board_elf_shield_microbit){
			Arduino.addInclude('from elfshield import *');
		}else{
			Arduino.addInclude('from WePort import *');
		}
		
		Arduino.addInclude('from neopixel import NeoPixel');

		Arduino.addVarDef(`${key} = NeoPixel(${SENSOR_PORT}, 32)`, key);
		let result = [];
		const index = Number(PIXEL);
		if(index > 0){
			result.push(`${key}[${index-1}] = ${rgb}`);
		}else{
			if(db.board == board_python_2in1 || db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
				add_helper_func_mpython();
			}else{
				add_helper_func();
			}
			result.push(`set_rgb_pixel(${key}, ${PIXEL}, ${rgb})`);
		}
		if(db.board === board_python_2in1 || db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
			result.push(`${key}.write()`);
		}else{
			result.push(`${key}.show()`);
		}
		
		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.weeemake_rgb_strip = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const PIXEL = Arduino.valueToCode(block, 'PIXEL', ORDER_NONE);
		const COLOR = Arduino.valueToCode(block, 'COLOR', ORDER_NONE);

		let {R,G,B} = hexToRgb(COLOR);

		return rgb_strip(SENSOR_PORT,PIXEL,R,G,B);
	}

	Arduino.weeemake_rgb3_strip = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const PIXEL = Arduino.valueToCode(block, 'PIXEL', ORDER_NONE);
		const R = Arduino.valueToCode(block, 'R', ORDER_NONE);
		const G = Arduino.valueToCode(block, 'G', ORDER_NONE);
		const B = Arduino.valueToCode(block, 'B', ORDER_NONE);

		return rgb_strip(SENSOR_PORT,PIXEL,R,G,B);
	}

	Arduino.weeemake_rgb_RJ11 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const INDEX = Arduino.valueToCode(block, 'INDEX', ORDER_NONE);
		const COLOR = Arduino.valueToCode(block, 'COLOR', ORDER_NONE);
		let {R,G,B} = hexToRgb(COLOR);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'rgb_RJ11_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeRGB5Module import *');
			Arduino.addSetupCode(`${key} = WeRGB5Module(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.showRGB(${INDEX}, ${R}, ${G}, ${B})` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `RGBLED_setColor(${SENSOR_PORT}, ${INDEX}, ${R}, ${G}, ${B})` + END;
	}

	Arduino.weeemake_rgb3_RJ11 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const INDEX = Arduino.valueToCode(block, 'INDEX', ORDER_NONE);
		const R = Arduino.valueToCode(block, 'R', ORDER_NONE);
		const G = Arduino.valueToCode(block, 'G', ORDER_NONE);
		const B = Arduino.valueToCode(block, 'B', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'rgb_RJ11_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeRGB5Module import *');
			Arduino.addSetupCode(`${key} = WeRGB5Module(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.showRGB(${INDEX}, ${R}, ${G}, ${B})` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `RGBLED_setColor(${SENSOR_PORT}, ${INDEX}, ${R}, ${G}, ${B})` + END;
	}

	Arduino.weeemake_line_follower = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const LINE_FOLLOWER_INDEX = block.getFieldValue('LINE_FOLLOWER_INDEX');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
			const key = 'lineFollower_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeLineFollower import *');
			Arduino.addSetupCode(`${key} = WeLineFollower(${SENSOR_PORT})`);
			return [`(${key}.updateData(), ${key}.S${LINE_FOLLOWER_INDEX})[1]`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`lineFollower_read(${SENSOR_PORT}, ${LINE_FOLLOWER_INDEX})`, ORDER_HIGH];
	}

	Arduino.weeemake_ultrasonic = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'ultrasonic_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeUltrasonicSensor import *');
			Arduino.addSetupCode(`${key} = WeUltrasonicSensor(${SENSOR_PORT})`);
			return [`${key}.distanceCM()`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`ultrasonic_getDistance(${SENSOR_PORT})`, ORDER_HIGH];
	}

	Arduino.weeemake_ultrasonic_led = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		let ULTRASONIC_LED_INDEX = block.getFieldValue('ULTRASONIC_LED_INDEX');
		const ON_OFF = block.getFieldValue('ON_OFF');

		if(ULTRASONIC_LED_INDEX === '1'){
			ULTRASONIC_LED_INDEX = '2';
		}else if(ULTRASONIC_LED_INDEX === '2'){
			ULTRASONIC_LED_INDEX = '1';
		}

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'ultrasonic_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeUltrasonicSensor import *');
			Arduino.addSetupCode(`${key} = WeUltrasonicSensor(${SENSOR_PORT})`);
			return Arduino.tab() + `#${key}.setLED(${ULTRASONIC_LED_INDEX}, ${ON_OFF})` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `ultrasonic_setLED(${SENSOR_PORT}, ${ULTRASONIC_LED_INDEX}, ${ON_OFF})` + END;
	}

	Arduino.weeemake_ultrasonic_rgb = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		let ULTRASONIC_LED_INDEX = block.getFieldValue('ULTRASONIC_LED_INDEX');
		const COLOR = Arduino.valueToCode(block, 'COLOR', ORDER_NONE);

		if(ULTRASONIC_LED_INDEX === '1'){
			ULTRASONIC_LED_INDEX = '2';
		}else if(ULTRASONIC_LED_INDEX === '2'){
			ULTRASONIC_LED_INDEX = '1';
		}

		let {R,G,B} = hexToRgb(COLOR);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'ultrasonic_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeUltrasonicSensor import *');
			Arduino.addSetupCode(`${key} = WeUltrasonicSensor(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.rgbShow(${ULTRASONIC_LED_INDEX}, ${R}, ${G}, ${B})` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `ultrasonic_setColor(${SENSOR_PORT}, ${ULTRASONIC_LED_INDEX}, ${R}, ${G}, ${B})` + END;
	}

	Arduino.weeemake_ultrasonic_rgb3 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		let ULTRASONIC_LED_INDEX = block.getFieldValue('ULTRASONIC_LED_INDEX');
		const R = Arduino.valueToCode(block, 'R', ORDER_NONE);
		const G = Arduino.valueToCode(block, 'G', ORDER_NONE);
		const B = Arduino.valueToCode(block, 'B', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'ultrasonic_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeUltrasonicSensor import *');
			Arduino.addSetupCode(`${key} = WeUltrasonicSensor(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.rgbShow(${ULTRASONIC_LED_INDEX}, ${R}, ${G}, ${B})` + END;
		}

		if(ULTRASONIC_LED_INDEX === '1'){
			ULTRASONIC_LED_INDEX = '2';
		}else if(ULTRASONIC_LED_INDEX === '2'){
			ULTRASONIC_LED_INDEX = '1';
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `ultrasonic_setColor(${SENSOR_PORT}, ${ULTRASONIC_LED_INDEX}, ${R}, ${G}, ${B})` + END;
	}

	Arduino.weeemake_k210_soil = function(block){
		const APIN = block.getFieldValue('APIN');

		//Arduino.addInclude('import esp32_nic');
		//Arduino.addSetupCode('esp = esp32_nic.init()');
		return [`nic.adc()[${APIN}]`, ORDER_HIGH];
	}
/*
	Arduino.weeemake_humiture_update = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		if(db.board == board_elf_esp32){
			this.addInclude('from machine import Pin');
			this.addInclude('import dht');
			const key = `d_${SENSOR_PORT}`;
			this.addVarDef(`${key} = dht.DHT11(Pin(${SENSOR_PORT}))`)
			return this.tab() + `${key}.measure()` + END
		}
	}
*/
	Arduino.weeemake_humiture = (list => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const HUMITURE_TYPE = block.getFieldValue('HUMITURE_TYPE');

		if(db.board == board_elf_esp32){
			this.addInclude('from machine import Pin');
			this.addInclude('from dht11 import DHT11');
			const key = `d_${SENSOR_PORT}`;
			this.addVarDef(`${key} = DHT11(Pin(${SENSOR_PORT}))`)
			return [`${key}.${HUMITURE_TYPE == 0 ? 'humidity' : 'temperature'}()`, ORDER_HIGH]
		}

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'humiture_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeHumitureSensor import *');
			Arduino.addSetupCode(`${key} = WeHumitureSensor(${SENSOR_PORT})`);
			return [`(${key}.updateData(), ${key}.${HUMITURE_TYPE == 0 ? 'humidity' : 'temperature'})[1]`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`humitureSensor_${list[HUMITURE_TYPE]}(${SENSOR_PORT})`, ORDER_HIGH];
	})(['readHumidity', 'readTemperature']);

	Arduino.weeemake_seven_segment = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const NUM = Arduino.valueToCode(block, 'NUM', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'segment7_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from We7SegmentDisplay import *');
			Arduino.addSetupCode(`${key} = We7SegmentDisplay(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.showNumber(${NUM})` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `digitalModule_showNumber(${SENSOR_PORT}, ${NUM})` + END;
	}

	Arduino.weeemake_raindrop = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		if(db.board === board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = `waterSensor_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeWaterSensor import *');
			Arduino.addSetupCode(`${key} = WeWaterSensor(${SENSOR_PORT})`);
			return [`${key}.getValue()`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_potentiometer = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board === board_microbitV2 || db.board === board_k210 || db.board == board_elf_esp32_pro){
			const key = `potentiometer_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WePotentiometer import *');
			Arduino.addSetupCode(`${key} = WePotentiometer(${SENSOR_PORT})`);
			return [`${key}.getValue()`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`potentiometer_value(${SENSOR_PORT})`, ORDER_HIGH];
	}

	Arduino.weeemake_gas_sensor = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'gas_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeGasSensor import *');
			Arduino.addSetupCode(`${key} = WeGasSensor(${SENSOR_PORT})`);
			return [`${key}.getValue()`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`gasSensor_readValue(${SENSOR_PORT})`, ORDER_HIGH];
	}

	Arduino.weeemake_relay = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ON_OFF = block.getFieldValue('ON_OFF');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'relay_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeRelay import *');
			Arduino.addSetupCode(`${key} = WeRelay(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.setStatus(${ON_OFF})` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `relayModule_set(${SENSOR_PORT}, ${ON_OFF})` + END;
	}

	Arduino.weeemake_water_atomizer = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ON_OFF = block.getFieldValue('ON_OFF');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeWaterAtomizer import *');
			let key = `waterAtomizer_` + SENSOR_PORT.split('_').pop();
			Arduino.addSetupCode(`${key} = WeWaterAtomizer(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.${ON_OFF == 1 ? 'open' : 'close'}()` + END;
		}

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `waterAtomizer_set(${SENSOR_PORT}, ${ON_OFF})` + END;
	}

	Arduino.weeemake_color_sensor_white_balance = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
			const key = 'colorSensor_' + SENSOR_PORT.split('_').pop()
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeColorSensor import *');
			Arduino.addSetupCode(`${key} = WeColorSensor(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.whiteBalance()` + END;
		}

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `colorSensor_whiteBalance(${SENSOR_PORT})` + END;
	}

	Arduino.weeemake_color_sensor_light = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ON_OFF = block.getFieldValue('ON_OFF');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
			const key = 'colorSensor_' + SENSOR_PORT.split('_').pop()
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeColorSensor import *');
			Arduino.addSetupCode(`${key} = WeColorSensor(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.setLight(${ON_OFF})` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `colorSensor_setLight(${SENSOR_PORT}, ${ON_OFF})` + END;
	}

	Arduino.weeemake_mp3_do = (list => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const MP3_FUNCTION = block.getFieldValue('MP3_FUNCTION');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'mp3_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeMP3 import *');
			Arduino.addSetupCode(`${key} = WeMP3(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.${list[MP3_FUNCTION]}()` + END;
		}

		Arduino.addInclude('from elfshield import *');

		return Arduino.tab() + `mp3_${list[MP3_FUNCTION]}(${SENSOR_PORT})` + END;
	})(['play', 'pause', 'prevMusic', 'nextMusic']);
/*
	Arduino.weeemake_mp3_play = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `mp3_play(${SENSOR_PORT})` + END;
	}

	Arduino.weeemake_mp3_pause = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `mp3_pause(${SENSOR_PORT})` + END;
	}

	Arduino.weeemake_mp3_prev_music = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `mp3_prevMusic(${SENSOR_PORT})` + END;
	}

	Arduino.weeemake_mp3_next_music = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `mp3_nextMusic(${SENSOR_PORT})` + END;
	}
*/
	Arduino.weeemake_mp3_set_music = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const NUM = Arduino.valueToCode(block, 'NUM', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'mp3_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeMP3 import *');
			Arduino.addSetupCode(`${key} = WeMP3(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.appointMusic(${NUM})` + END;
		}

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `mp3_playMusic(${SENSOR_PORT}, ${NUM})` + END;
	}

	Arduino.weeemake_mp3_set_volume = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const NUM = Arduino.valueToCode(block, 'NUM', ORDER_NONE);

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'mp3_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeMP3 import *');
			Arduino.addSetupCode(`${key} = WeMP3(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.appointVolume(${NUM})` + END;
		}

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `mp3_setVolume(${SENSOR_PORT}, ${NUM})` + END;
	}

	Arduino.weeemake_mp3_set_device = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const MP3_DEVICE_TYPE = block.getFieldValue('MP3_DEVICE_TYPE');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'mp3_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeMP3 import *');
			Arduino.addSetupCode(`${key} = WeMP3(${SENSOR_PORT})`);
			return Arduino.tab() + `${key}.appointDevice(${MP3_DEVICE_TYPE})` + END;
		}

		Arduino.addInclude('from elfshield import *');
		
		return Arduino.tab() + `mp3_setDevice(${SENSOR_PORT}, ${MP3_DEVICE_TYPE})` + END;
	}

	Arduino.weeemake_mp3_is_over = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'mp3_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeMP3 import *');
			Arduino.addSetupCode(`${key} = WeMP3(${SENSOR_PORT})`);
			return [`${key}.isOver()`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`mp3_isOver(${SENSOR_PORT})`, ORDER_HIGH];
	}

	Arduino.weeemake_elf_shield_microbit_button = function(block){
		if(db.board == board_python_2in1){
			const MICROBIT_BUTTON_INDEX = block.getFieldValue('MICROBIT_BUTTON_INDEX');
			this.addInclude('from mpython import *');
			return [`button_${MICROBIT_BUTTON_INDEX}.value() == 0`, ORDER_RELATIONAL]
		}
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const MICROBIT_BUTTON_INDEX = block.getFieldValue('MICROBIT_BUTTON_INDEX');
			this.addInclude('from AIHandle import *');
			return [`button_${MICROBIT_BUTTON_INDEX.toUpperCase()}.is_pressed()`, ORDER_HIGH];
		}
		if(db.isMicrobitBoard()){
			const MICROBIT_BUTTON_INDEX = block.getFieldValue('MICROBIT_BUTTON_INDEX');
			this.addInclude('from microbit import *');
			return [`button_${MICROBIT_BUTTON_INDEX}.is_pressed()`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_color_sensor = ((dict, list) => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const COLOR_TYPE = block.getFieldValue('COLOR_TYPE');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
			const key = 'colorSensor_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeColorSensor import *');
			Arduino.addSetupCode(`${key} = WeColorSensor(${SENSOR_PORT})`);
			return [`(${key}.updateData(), ${key}.show${list[COLOR_TYPE]}Data())[1]`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`colorSensor_read${dict[COLOR_TYPE]}(${SENSOR_PORT})`, ORDER_HIGH];
	})({'0':'Light','1':'Red','2':'Green','3':'Blue'}, ['Color', 'Red', 'Green', 'Blue'])

	Arduino.weeemake_flame_sensor = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const FLAME_INDEX = block.getFieldValue('FLAME_INDEX');

		if(db.board === board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = `flame_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeFlameSensor import *');
			Arduino.addSetupCode(`${key} = WeFlameSensor(${SENSOR_PORT})`);
			return [`(${key}.updateData(), ${key}.S${FLAME_INDEX})[1]`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`flameSensor_readValue(${SENSOR_PORT}, ${FLAME_INDEX})`, ORDER_HIGH];
	}

	Arduino.weeemake_joystick = (dict => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const AXIS2 = block.getFieldValue('AXIS2');

		if(db.board === board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = `joystick_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeJoystick import *');
			Arduino.addSetupCode(`${key} = WeJoystick(${SENSOR_PORT})`);

			if(db.board == board_elf_esp32_pro){
				return [`(${key}.updateData(), ${key}.${AXIS2 == 1 ? 'Y' : 'X'})[1]`, ORDER_HIGH];
			}
			return [`${key}.getValue(${Number(AXIS2)+1})`, ORDER_HIGH];
		}
		if(db.board === board_elf_shield_microbit){
			Arduino.addInclude('from elfshield import *');
			return [`joystick_read${dict[AXIS2]}_axis(${SENSOR_PORT})`, ORDER_HIGH];
		}
		return ['0', ORDER_ATOMIC];
	})({'0':'X','1':'Y'})

	Arduino.weeemake_elf_shield_microbit_compass = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const AXIS3 = block.getFieldValue('AXIS3');
		Arduino.addInclude('from microbit import *');
		Arduino.addSetupCode('compass.calibrate()');

		return [`compass.heading()`, ORDER_HIGH];
	}

	Arduino.weeemake_elf_shield_microbit_accelerometer = (dict => function(block){
		const AXIS3 = block.getFieldValue('AXIS3');

		if(db.board == board_python_2in1){
			Arduino.addInclude('from mpython import *')
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}else{
			Arduino.addInclude('from microbit import *');
		}

		return [`accelerometer.get_${dict[AXIS3]}()`, ORDER_HIGH];
	})({'0':'x','1':'y','2':'z'})

	Arduino.weeemake_touch = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board === board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = `touch_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeSingleTouch import *');
			Arduino.addSetupCode(`${key} = WeSingleTouch(${SENSOR_PORT})`);
			return [`${key}.getValue()`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`touchSensor_read(${SENSOR_PORT})`, ORDER_HIGH];
	}

	Arduino.weeemake_led_button = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const BUTTON_INDEX = block.getFieldValue('BUTTON_INDEX');

		if(db.board == board_microbitV2 || db.board == board_k210){
			const key = 'ledBtn_' + SENSOR_PORT.split('_')[1];
			this.addInclude('from WePort import *');
			this.addInclude('from We4LEDButton import *');
			this.addSetupCode(`${key} = We4LEDButton(${SENSOR_PORT})`);
			return [`${key}.getValue() == ${BUTTON_INDEX}`, ORDER_RELATIONAL];
		}

		Arduino.addInclude('from elfshield import *');

		return [`led4button_readKey(${SENSOR_PORT}) == ${BUTTON_INDEX}`, ORDER_RELATIONAL];
	}

	Arduino.weeemake_pir = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board == board_k210 || db.board == board_python_2in1 || db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'pir_' + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WePIRSensor import *');
			Arduino.addSetupCode(`${key} = WePIRSensor(${SENSOR_PORT})`);
			return [`${key}.getValue()`, ORDER_HIGH];
		}

		Arduino.addInclude('from elfshield import *');

		return [`PIRsensor_read(${SENSOR_PORT})`, ORDER_HIGH];
	}

	Arduino.weeemake_tilt = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const TILT_DIR = block.getFieldValue('TILT_DIR');

		if(db.board === board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = `tilt_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeTiltSwitchSensor import *');
			Arduino.addSetupCode(`${key} = WeTiltSwitchSensor(${SENSOR_PORT})`);
			return [`${key}.getValue() == ${TILT_DIR}`, ORDER_RELATIONAL];
		}

		if(db.board === board_elf_shield_microbit){
			Arduino.addInclude('from elfshield import *');
			return [`tiltSwitch_read(${SENSOR_PORT}) == ${TILT_DIR}`, ORDER_RELATIONAL];
		}

		return ['False', ORDER_ATOMIC];
	}

	Arduino.weeemake_elf_shield_microbit_display_image = function(block){
		if(!db.isMicrobitBoard())return;
		const MATRIX = this.valueToCode(block, 'MATRIX', ORDER_NONE);
		this.addInclude('from microbit import *');
		return Arduino.tab() + `display.show(Image(${castMatrix(MATRIX, 5, 5, 9)}))` + END;
	}

	Arduino.weeemake_elf_shield_microbit_display_image2 = function(block){
		if(!db.isMicrobitBoard())return;
		const MATRIX = this.valueToCode(block, 'MATRIX', ORDER_NONE);
		const BRIGHTNESS = this.valueToCode(block, 'BRIGHTNESS', Arduino.ORDER_MULTIPLICATIVE);
		this.addInclude('from microbit import *');
		return Arduino.tab() + `display.show(Image(${castMatrix(MATRIX, 5, 5, 1)}) * ${BRIGHTNESS})` + END;
	}

	Arduino.weeemake_elf_shield_microbit_display_image_builtin = function(block){
		const MICROBIT_BUILTIN_IMAGE = block.getFieldValue('MICROBIT_BUILTIN_IMAGE');
		this.addInclude('from microbit import *');
		return Arduino.tab() + `display.show(Image.${MICROBIT_BUILTIN_IMAGE})` + END;
	}

	Arduino.weeemake_elf_shield_microbit_display_text = (list => function(block){
		const MICROBIT_DISPLAY_TYPE = block.getFieldValue('MICROBIT_DISPLAY_TYPE');
		const STR = this.valueToCode(block, 'STR', ORDER_NONE);
		this.addInclude('from microbit import *');
		return Arduino.tab() + `display.${list[MICROBIT_DISPLAY_TYPE]}(str(${STR}))` + END;
	})(['show', 'scroll']);

	Arduino.weeemake_elf_shield_microbit_display_clear = function(block){
		Arduino.addInclude('from microbit import *');
		return Arduino.tab() + `display.clear()` + END;
	}
	
	Arduino.weeemake_weeebot_board_button = function(block){
		if(db.board == board_elf_esp32_pro){
			const key = 'pin_button'
			Arduino.addInclude('from WePort import *')
			Arduino.addInclude('from machine import Pin');
			Arduino.addSetupCode(`${key} = Pin(OnBoard_Button, Pin.IN)`, key);
			return [`${key}.value() == 0`, ORDER_RELATIONAL];
		}
		Arduino.addInclude('from fpioa_manager import fm');
		Arduino.addInclude('from Maix import GPIO');
		Arduino.addSetupCode(`fm.register(32, fm.fpioa.GPIOHS2)`);
		Arduino.addSetupCode(`pin6 = GPIO(GPIO.GPIOHS2, GPIO.IN)`);
		return [`pin6.value() == 0`, ORDER_RELATIONAL];
	}

	const K210_PIN_MAP = [4, 5, 21, 22, 23, 24, 32, 15, 14, 13, 12, 11, 10, 3, 30, 31];

	Arduino.weeemake_digitalRead = function(block){
		const DPIN = block.getFieldValue('DPIN');

		if(db.board == board_k210){
			const pin = K210_PIN_MAP[DPIN];
			const rpin = pin == 32 ? 2 : pin;
			this.addInclude('from fpioa_manager import fm');
			this.addInclude('from Maix import GPIO');
			this.addSetupCode(`fm.register(${pin}, fm.fpioa.GPIOHS${rpin})`);
			this.addSetupCode(`pin${DPIN} = GPIO(GPIO.GPIOHS${rpin}, GPIO.IN)`);
			return [`pin${DPIN}.value()`, ORDER_HIGH];
		}

		if(db.board == board_python_2in1){
			const key = 'pin_' + DPIN.split('_')[1];
			this.addInclude('from mpython import *');
			this.addInclude('from WePort import *');
			this.addSetupCode(`${key} = MPythonPin(${mPythonPinToIndex(DPIN)}, PinMode.IN)`);
			return [`${key}.read_digital()`, ORDER_HIGH];
		}

		if(db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
			if(db.board == board_elf_esp32_pro){
				this.addInclude('from WePort import *')
			}
			const key = 'pin_' + DPIN.split('_').pop();
			this.addInclude('from machine import Pin');
			this.addSetupCode(`${key} = Pin(${DPIN}, Pin.IN)`, key);
			return [`${key}.value()`, ORDER_HIGH];
		}
		if(db.isMicrobitBoard()){
			this.addInclude('from microbit import *');
			return [`pin${DPIN}.read_digital()`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_digitalWrite = function(block){
		const DPIN = block.getFieldValue('DPIN');
		const HIGH_LOW = block.getFieldValue('HIGH_LOW');

		if(db.board == board_k210){
			const pin = K210_PIN_MAP[DPIN];
			const rpin = pin == 32 ? 2 : pin;
			this.addInclude('from fpioa_manager import fm');
			this.addInclude('from Maix import GPIO');
			this.addSetupCode(`fm.register(${pin}, fm.fpioa.GPIOHS${rpin})`);
			this.addSetupCode(`pin${DPIN} = GPIO(GPIO.GPIOHS${rpin}, GPIO.OUT)`);
			return Arduino.tab() + `pin${DPIN}.value(${HIGH_LOW})` + END;
		}

		if(db.board == board_python_2in1){
			const key = 'pin_' + DPIN.split('_')[1];
			this.addInclude('from mpython import *');
			this.addInclude('from WePort import *');
			this.addSetupCode(`${key} = MPythonPin(${mPythonPinToIndex(DPIN)}, PinMode.OUT)`);
			return Arduino.tab() + `${key}.write_digital(${HIGH_LOW})` + END;
		}
		if(db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){
			if(db.board == board_elf_esp32_pro){
				this.addInclude('from WePort import *')
			}
			const key = 'pin_' + DPIN.split('_').pop();
			this.addInclude('from machine import Pin');
			this.addSetupCode(`${key} = Pin(${DPIN}, Pin.OUT)`, key);
			return Arduino.tab() + `${key}.value(${HIGH_LOW})` + END;
		}
		if(db.isMicrobitBoard()){
			this.addInclude('from microbit import *');
			return Arduino.tab() + `pin${DPIN}.write_digital(${HIGH_LOW})` + END;
		}
	}

	Arduino.weeemake_analogRead = function(block){
		const APIN = block.getFieldValue('APIN');
		if(db.board === board_elf_esp32 || db.board == board_elf_esp32_pro){
			if(db.board == board_elf_esp32_pro){
				this.addInclude('from WePort import *')
			}
			this.addInclude('from adc import analog_read');
			return [`analog_read(${APIN})`, ORDER_HIGH];
		}
		if(db.isMicrobitBoard()){
			this.addInclude('from microbit import *');
			return [`pin${APIN}.read_analog()`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_k210_analogRead = function(block){
		const APIN = block.getFieldValue('APIN');

		return [`nic.adc()[${APIN}]`, ORDER_HIGH];
	}

	Arduino.weeemake_analogWrite = function(block){
		const PWM_PIN = block.getFieldValue('PWM_PIN');
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);

		if(db.board == board_python_2in1){
			const key = 'pin_' + PWM_PIN.split('_')[1];
			Arduino.addInclude('from mpython import *');
			Arduino.addInclude('from WePort import *');
			Arduino.addSetupCode(`${key} = MPythonPin(${mPythonPinToIndex(PWM_PIN)}, PinMode.PWM)`);
			return Arduino.tab() + `${key}.write_analog(${VALUE})` + END;
		}
		if(db.isMicrobitBoard()){
			Arduino.addInclude('from microbit import *');
			return Arduino.tab() + `pin${PWM_PIN}.write_analog(${VALUE})` + END;
		}
	}

	Arduino.weeemake_k210_analogWrite = function(block){
		const PWM_PIN = block.getFieldValue('PWM_PIN');
		const TIMER = Arduino.valueToCode(block, 'TIMER', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const FREQ = this.valueToCode(block, 'FREQ', ORDER_NONE);

		Arduino.addInclude('from machine import Timer');
		Arduino.addInclude('from machine import PWM');
		return Arduino.tab() + `PWM(Timer(Timer.TIMER${TIMER >> 2},Timer.CHANNEL${TIMER % 4},mode=Timer.MODE_PWM),freq=${FREQ},duty=${VALUE},pin=${K210_PIN_MAP[PWM_PIN]})` + END;
	}

	Arduino.weeemake_k210_analogWrite_init = function(block){
		const PWM_PIN = block.getFieldValue('PWM_PIN');
		const TIMER = Arduino.valueToCode(block, 'TIMER', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const FREQ = this.valueToCode(block, 'FREQ', ORDER_NONE);

		Arduino.addInclude('from machine import Timer');
		Arduino.addInclude('from machine import PWM');
		
		const key = `pwm${PWM_PIN}`;

		return Arduino.tab() + `${key} = PWM(Timer(Timer.TIMER${TIMER >> 2},Timer.CHANNEL${TIMER % 4},mode=Timer.MODE_PWM),freq=${FREQ},duty=0,pin=${K210_PIN_MAP[PWM_PIN]})` + END;
	}

	Arduino.weeemake_esp32_analogWrite_init = function(block){
		const PWM_PIN = block.getFieldValue('PWM_PIN');
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const FREQ = this.valueToCode(block, 'FREQ', ORDER_NONE);

		if(db.board == board_elf_esp32_pro){
			this.addInclude('from WePort import *')
		}

		this.addInclude('from machine import Pin');
		this.addInclude('from machine import PWM');
		
		const key = `pwm${PWM_PIN.split('_').pop()}`;

		return this.tab() + `${key} = PWM(Pin(${PWM_PIN}),freq=${FREQ})` + END;
	}

	Arduino.weeemake_k210_analogWrite2 = function(block){
		const PWM_PIN = block.getFieldValue('PWM_PIN');
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const key = `pwm${PWM_PIN.split('_').pop()}`;
		return Arduino.tab() + `${key}.duty(${VALUE})` + END;
	}

	Arduino.weeemake_elf_shield_microbit_gesture = function(block){
		const MICROBIT_GESTURE = block.getFieldValue('MICROBIT_GESTURE');
		Arduino.addInclude('from microbit import *');
		return [`accelerometer.is_gesture("${MICROBIT_GESTURE}")`, ORDER_HIGH];
	}

	Arduino.weeemake_elf_shield_microbit_radio_set_power = function(block){
		const MICROBIT_RADIO_POWER = block.getFieldValue('MICROBIT_RADIO_POWER');
		Arduino.addInclude('import radio');
		Arduino.addSetupCode('radio.on()');
		return Arduino.tab() + `radio.config(power=${MICROBIT_RADIO_POWER})` + END;
	}

	Arduino.weeemake_elf_shield_microbit_radio_set_group = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		Arduino.addInclude('import radio');
		Arduino.addSetupCode('radio.on()');
		return Arduino.tab() + `radio.config(group=${VALUE})` + END;
	}

	Arduino.weeemake_elf_shield_microbit_radio_send_string = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		this.addInclude('import radio');
		this.addSetupCode('radio.on()');
		return this.tab() + `radio.send(str(${VALUE}))` + END;
	}

	Arduino.weeemake_elf_shield_microbit_radio_received_string = function(block){
		this.addInclude('import radio');
		this.addSetupCode('radio.on()');
		return [`radio.receive()`, ORDER_HIGH];
	}

	Arduino.weeemake_ascii2str = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return [`chr(${VALUE})`, ORDER_HIGH];
	}

	Arduino.weeemake_str2ascii = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return [`ord(${VALUE})`, ORDER_HIGH];
	}

	Arduino.weeemake_elf_shield_microbit_display_set_pixel = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		this.addInclude('from microbit import *');
		return Arduino.tab() + `display.set_pixel(${X}, ${Y}, ${VALUE})` + END;
	}

	Arduino.weeemake_elf_shield_microbit_display_get_pixel = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		this.addInclude('from microbit import *');
		return [`display.get_pixel(${X}, ${Y})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_audio_on_off = function(block){
		const ON_OFF = block.getFieldValue('ON_OFF');

		if(db.board == board_python_2in1 || db.board == board_elf_weee_core){
			this.addInclude(`import audio`);
			return this.tab() + `audio.player_${ON_OFF == 1 ? '' : 'de'}init()` + END;
		}
		if(db.board == board_k210){
		Arduino.addInclude(`from fpioa_manager import fm`);
		Arduino.addInclude(`from Maix import GPIO`);

		Arduino.addSetupCode('fm.register(32, fm.fpioa.GPIO1)');
		Arduino.addSetupCode('voice_en = GPIO(GPIO.GPIO1, GPIO.OUT)');
		
		return Arduino.tab() + `voice_en.value(${ON_OFF})` + END;
		}
	}

	Arduino.weeemake_k210_audio_play = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);

		if(db.board == board_python_2in1 || db.board == board_elf_weee_core){
			this.addInclude(`import audio`);
			return this.tab() + `audio.play(${VALUE})` + END;
		}
		if(db.board == board_k210){
		Arduino.addInclude(`from fpioa_manager import fm`);
		Arduino.addInclude(`from Maix import I2S`);
		Arduino.addInclude(`import audio`);
		Arduino.addSetupCode('fm.register(33, fm.fpioa.I2S0_WS)');
		Arduino.addSetupCode('fm.register(34, fm.fpioa.I2S0_OUT_D1)');
		Arduino.addSetupCode('fm.register(35, fm.fpioa.I2S0_SCLK)');
		Arduino.addSetupCode('i2s = I2S(I2S.DEVICE_0)');
		Arduino.addSetupCode('i2s.channel_config(I2S.CHANNEL_1, I2S.TRANSMITTER, resolution=I2S.RESOLUTION_16_BIT, cycles=I2S.SCLK_CYCLES_32, align_mode=I2S.RIGHT_JUSTIFYING_MODE)');
		return [
			`myAudio = audio.Audio(path=${VALUE})`,
			`i2s.set_sample_rate(myAudio.play_process(i2s)[1])`
		].map(v => Arduino.tab() + v + END).join('');
		}
	}

	Arduino.weeemake_k210_audio_volume = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(db.board == board_python_2in1 || db.board == board_elf_weee_core){
			this.addInclude(`import audio`);
			return this.tab() + `audio.set_volume(${VALUE})` + END;
		}
		if(db.board == board_k210){
		return Arduino.tab() + `myAudio.volume(${VALUE})` + END;
		}
	}

	Arduino.weeemake_k210_audio_stop = function(block){
		return Arduino.tab() + `myAudio.finish()` + END;
	}

	Arduino.weeemake_k210_audio_play_state = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_weee_core){
			this.addInclude(`import audio`);
			return ['audio.player_status()', ORDER_HIGH]
		}
		if(db.board == board_k210){
		return ['myAudio.play()', ORDER_HIGH]
		}
	}

	Arduino.weeemake_k210_video_play = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);

		Arduino.addInclude(`from fpioa_manager import fm`);
		Arduino.addInclude(`from Maix import I2S`);
		Arduino.addInclude(`from Maix import GPIO`);

		Arduino.addSetupCode('fm.register(2, fm.fpioa.GPIO1)');
		Arduino.addSetupCode('GPIO(GPIO.GPIO1, GPIO.OUT).value(1)');
		
		Arduino.addSetupCode('fm.register(33, fm.fpioa.I2S0_WS)');
		Arduino.addSetupCode('fm.register(34, fm.fpioa.I2S0_OUT_D1)');
		Arduino.addSetupCode('fm.register(35, fm.fpioa.I2S0_SCLK)');
		Arduino.addSetupCode('i2s = I2S(I2S.DEVICE_0)');
		Arduino.addSetupCode('i2s.channel_config(I2S.CHANNEL_1, I2S.TRANSMITTER, resolution=I2S.RESOLUTION_16_BIT, cycles=I2S.SCLK_CYCLES_32, align_mode=I2S.RIGHT_JUSTIFYING_MODE)');
		
		Arduino.addInclude(`import video`);
		return Arduino.tab() + `myVideo = video.open(${VALUE})` + END;
	}

	Arduino.weeemake_k210_video_volume = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		//Arduino.addInclude(`import audio`);
		return Arduino.tab() + `myVideo.volume(${VALUE})` + END;
	}

	Arduino.weeemake_k210_video_stop = function(block){
		//Arduino.addInclude(`import audio`);
		return Arduino.tab() + `myVideo.__del__()` + END;
	}

	Arduino.weeemake_k210_video_play_state = function(block){
		//Arduino.addInclude(`import audio`);
		return ['myVideo.play()', ORDER_HIGH]
	}

	Arduino.weeemake_k210_video_record_begin = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const FPS = this.valueToCode(block, 'FPS', Arduino.ORDER_MULTIPLICATIVE);
		const COMPRESS = this.valueToCode(block, 'COMPRESS', ORDER_NONE);
		const HZ = this.valueToCode(block, 'HZ', ORDER_NONE);
		const ON_OFF = block.getFieldValue('ON_OFF');
		
		Arduino.addInclude(`import video`);
		return Arduino.tab() + `myRecord = video.open(${VALUE}, record=True, interval=1000000 // ${FPS}, quality=${COMPRESS}, audio=${ON_OFF}, sample_rate=${HZ})` + END;
	}

	Arduino.weeemake_k210_video_record_image = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		return Arduino.tab() + `myRecord.record(${NAME || 'None'})` + END;
	}

	Arduino.weeemake_k210_video_record_end = function(block){
		return Arduino.tab() + `myRecord.record_finish()` + END;
	}

	Arduino.weeemake_k210_lcd_init = function(block){
		Arduino.addInclude(`import lcd`);
		const FEQ = this.valueToCode(block, 'FEQ', ORDER_NONE);
		const COLOR = this.valueToCode(block, 'COLOR', ORDER_NONE);
		//let color = COLOR.replace('#', '0x').replace(/"/g, '');
		return Arduino.tab() + `lcd.init(freq=${FEQ},color=${COLOR})` + END;
	}

	Arduino.weeemake_k210_lcd_system_color = function(block){
		Arduino.addInclude(`import lcd`);
		return [block.getFieldValue('K210_LCD_COLOR'), ORDER_HIGH]
	}

	function castAIHandleColor565(v){
		if(!v)return 'lcd.BLACK';
		if(typeof v == 'string' && v.startsWith('(') && v.endsWith(')')){
			return 'lcd.color565' + v;
		}
		return v;
	}

	Arduino.weeemake_ai_handle_lcd_color = function(block){
		return [block.getFieldValue('color'), ORDER_HIGH];
	}

	Arduino.weeemake_k210_lcd_clear_color = function(block){
		if(db.board == board_k210){
			this.addInclude(`import lcd`);
			const COLOR = this.valueToCode(block, 'COLOR', ORDER_NONE);
			return Arduino.tab() + `lcd.clear(${COLOR})` + END;
		}
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const COLOR = castAIHandleColor565(this.valueToCode(block, 'COLOR', ORDER_NONE));
			return Arduino.tab() + `display.fill(${COLOR})` + END;
		}
	}

	Arduino.weeemake_k210_lcd_size = (list => function(block){
		if(db.board == board_k210){
			this.addInclude(`import lcd`);
			const WH = block.getFieldValue('WH');
			return [`lcd.${list[WH]}()`, ORDER_HIGH]
		}
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const WH = block.getFieldValue('WH');
			return [`display.${list[WH]}()`, ORDER_HIGH]
		}
	})(['width','height']);

	Arduino.weeemake_k210_lcd_show_image = function(block){
		Arduino.addInclude(`import lcd`);
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		return Arduino.tab() + `lcd.display(${NAME || 'None'})` + END;
	}

	Arduino.weeemake_k210_lcd_rotate = function(block){
		if(db.board == board_k210){
			this.addInclude(`import lcd`);
			const K210_ANGLE = block.getFieldValue('K210_ANGLE');
			return Arduino.tab() + `lcd.rotation(${K210_ANGLE})` + END;
		}
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const K210_ANGLE = block.getFieldValue('K210_ANGLE');
			return Arduino.tab() + `display.rotation(${K210_ANGLE})` + END;
		}
	}

	Arduino.weeemake_k210_lcd_mirror = function(block){
		Arduino.addInclude(`import lcd`);
		const ON_OFF = block.getFieldValue('ON_OFF');
		return Arduino.tab() + `lcd.mirror(${ON_OFF})` + END;
	}

	Arduino.weeemake_k210_lcd_draw = function(block){
		Arduino.addInclude(`import lcd`);
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);

		const FG = this.valueToCode(block, 'FG', ORDER_NONE);
		const BG = this.valueToCode(block, 'BG', ORDER_NONE);
		//let fg = FG.replace('#', '0x').replace(/"/g, '');
		//let bg = BG.replace('#', '0x').replace(/"/g, '');
		return Arduino.tab() + `lcd.draw_string(${X},${Y},${VALUE},${FG},${BG})` + END;
	}

	Arduino.RGB565 = function(block){
		const COLOUR = block.getFieldValue('COLOUR');
		const colour = hexToRgb(COLOUR);
		const r = Math.floor(colour.R * 0x1F / 0xFF)
		const g = Math.floor(colour.G * 0x3F / 0xFF)
		const b = Math.floor(colour.B * 0x1F / 0xFF)
		let value;
		if(db.board == board_k210){
			value = r << 3 | g >> 3 | (g & 7) << 13 | b << 8
		}else{
			value = r << 11 | g << 5 | b;
		}
		return ['0x' + value.toString(16).padStart(4, '0'), ORDER_ATOMIC];
	}

	Arduino.weeemake_k210_camera_get_info = function(block){
		Arduino.addInclude(`import sensor`);
		const K210_CAMERA_INFO = block.getFieldValue('K210_CAMERA_INFO');
		return [`sensor.${K210_CAMERA_INFO}()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_camera_get_image = function(block){
		Arduino.addInclude(`import sensor`);
		return [`sensor.snapshot()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_camera_init = function(block){
		Arduino.addInclude(`import sensor`);
		const K210_CAMERA_COLOR_MODE = block.getFieldValue('K210_CAMERA_COLOR_MODE');
		const K210_CAMERA_SIZE = block.getFieldValue('K210_CAMERA_SIZE');
		const ON_OFF = block.getFieldValue('ON_OFF');
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const result = [
			'sensor.reset()',
			`sensor.set_pixformat(${K210_CAMERA_COLOR_MODE})`,
			`sensor.set_framesize(${K210_CAMERA_SIZE})`,
			`sensor.run(${ON_OFF})`,
			`sensor.skip_frames(${VALUE})`,
		];
		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.weeemake_k210_camera_on_off = function(block){
		const ON_OFF = block.getFieldValue('ON_OFF');
		Arduino.addInclude(`import sensor`);
		return Arduino.tab() + `sensor.shutdown(${ON_OFF})` + END;
	}

	Arduino.weeemake_k210_camera_Hmirror = function(block){
		const ON_OFF = block.getFieldValue('ON_OFF');
		Arduino.addInclude(`import sensor`);
		return Arduino.tab() + `sensor.set_hmirror(${ON_OFF})` + END;
	}

	Arduino.weeemake_k210_camera_Vmirror = function(block){
		const ON_OFF = block.getFieldValue('ON_OFF');
		Arduino.addInclude(`import sensor`);
		return Arduino.tab() + `sensor.set_vflip(${ON_OFF})` + END;
	}

	Arduino.weeemake_k210_camera_color_mode = function(block){
		const ON_OFF = block.getFieldValue('ON_OFF');
		Arduino.addInclude(`import sensor`);
		return Arduino.tab() + `sensor.set_colorbar(${ON_OFF})` + END;
	}

	Arduino.weeemake_k210_camera_set = function(block){
		Arduino.addInclude(`import sensor`);
		const K210_CAMERA_MODE = block.getFieldValue('K210_CAMERA_MODE');
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return Arduino.tab() + `sensor.${K210_CAMERA_MODE}(${VALUE})` + END;
	}

	Arduino.weeemake_k210_camera_set_window = function(block){
		Arduino.addInclude(`import sensor`);
		const W = this.valueToCode(block, 'W', ORDER_NONE);
		const H = this.valueToCode(block, 'H', ORDER_NONE);
		return Arduino.tab() + `sensor.set_windowing((${W},${H}))` + END;
	}

	Arduino.weeemake_k210_wifi_init = function(block){
		const K210_SPI_MODE = block.getFieldValue('K210_SPI_MODE');
		Arduino.addInclude('from fpioa_manager import fm');
		Arduino.addInclude('import network');

		let result;
		if(K210_SPI_MODE == '0'){
			result = [
				`fm.register(25,fm.fpioa.GPIOHS10)#cs`,
				`fm.register(8,fm.fpioa.GPIOHS11)#rst`,
				`fm.register(9,fm.fpioa.GPIOHS12)#rdy`,
				`nic = network.ESP32_SPI(cs=fm.fpioa.GPIOHS10, rst=fm.fpioa.GPIOHS11, rdy=fm.fpioa.GPIOHS12, spi=1)`
			];
		}else{
			result = [
				`fm.register(25,fm.fpioa.GPIOHS10, force=True)#cs`,
				`fm.register(8,fm.fpioa.GPIOHS11, force=True)#rst`,
				`fm.register(9,fm.fpioa.GPIOHS12, force=True)#rdy`,
				`fm.register(28,fm.fpioa.GPIOHS13, force=True)#mosi`,
				`fm.register(26,fm.fpioa.GPIOHS14, force=True)#miso`,
				`fm.register(27,fm.fpioa.GPIOHS15, force=True)#sclk`,
				`nic = network.ESP32_SPI(cs=fm.fpioa.GPIOHS10,rst=fm.fpioa.GPIOHS11,rdy=fm.fpioa.GPIOHS12, mosi=fm.fpioa.GPIOHS13,miso=fm.fpioa.GPIOHS14,sclk=fm.fpioa.GPIOHS15)`
			];
		}
		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.weeemake_k210_wifi_enable_AP = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const SECRET = this.valueToCode(block, 'SECRET', ORDER_NONE);
		if(db.board == board_k210){
			return this.tab() + `nic.enable_ap(${NAME}, ${SECRET})` + END;
		}
	}

	Arduino.weeemake_k210_wifi_scan = function(block){
		return [`nic.scan()`, ORDER_HIGH]
	}

	function castToStr(block, key, mapFn=identity){
		let valueBlock = block.getInputTargetBlock(key);
		return (valueBlock.type == 'text' || valueBlock.type == 'string') ? JSON.stringify(mapFn(valueBlock.getFieldValue('TEXT'))) : 'str(' + Arduino.valueToCode(block, key, ORDER_NONE) + ')';
	}
/*
	function castToStr(block, name, order){
		const value = Arduino.valueToCode(block, name, order);
		if(block.getInputTargetBlock(name).type != 'text'){
			return Arduino.valueToCode(block, name, order);
		}
		if(value.startsWith(`"`) && value.endsWith(`"`)){
			return value;
		}
		return `"` + value + `"`;
	}
*/
	function castToVarName(block, name, order, defaultValue){
		const value = Arduino.valueToCode(block, name, order);
		if(block.getInputTargetBlock(name).type != 'text'){
			return defaultValue || Arduino.valueToCode(block, name, order);
		}
		if(value.startsWith(`"`) && value.endsWith(`"`)){
			return value.slice(1, -1);
		}
		return value;
	}

	Arduino.weeemake_k210_wifi_connect = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const SECRET = this.valueToCode(block, 'SECRET', ORDER_NONE);

		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
			this.addSetupCode('my_wifi = wifi()');
			return Arduino.tab() + `my_wifi.connectWiFi(${NAME}, ${SECRET})` + END;
		}
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('from wifi import *');
			this.addSetupCode(`my_wifi = WiFi()`);
			return Arduino.tab() + `my_wifi.connectWiFi(${NAME}, ${SECRET})` + END;
		}
		return Arduino.tab() + `nic.connect(${NAME}, ${SECRET})` + END;
	}

	Arduino.weeemake_k210_wifi_info = (list => function(block){
		const K210_WIFI_CONNECT_INFO = block.getFieldValue('K210_WIFI_CONNECT_INFO');
		let key;
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
			this.addSetupCode('my_wifi = wifi()');
			key = 'my_wifi.sta';
		}else if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('from wifi import *');
			this.addSetupCode(`my_wifi = WiFi()`);
			key = 'my_wifi.sta';
		}else if(db.board == board_k210){
			key = 'nic'
		}else{
			return [`None`, ORDER_HIGH]
		}
		return [`${key}.${list[K210_WIFI_CONNECT_INFO]}()`, ORDER_HIGH]
	})(['ifconfig','isconnected']);

	Arduino.weeemake_k210_wifi_disconnect = function(block){
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
			this.addSetupCode('my_wifi = wifi()');
			return this.tab() + `my_wifi.disconnectWiFi()` + END;
		}
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('from wifi import *');
			this.addSetupCode(`my_wifi = WiFi()`);
			return this.tab() + `my_wifi.disconnectWiFi()` + END;
		}
		if(db.board == board_k210){
			return this.tab() + `nic.disconnect()` + END;
		}
	}

	Arduino.weeemake_k210_wifi_ping = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return [`nic.ping(${VALUE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_wifi_enable_server = function(block){
		const PORT = this.valueToCode(block, 'PORT', ORDER_NONE);
		return Arduino.tab() + `nic.enable_tcp_server(${PORT})` + END;
	}
/*
	Arduino.weeemake_k210_wifi_enable_client = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const PORT = this.valueToCode(block, 'PORT', ORDER_NONE);
		return Arduino.tab() + `nic.enable_tcp_client(${NAME}, ${PORT})` + END;
	}
*/
	Arduino.weeemake_k210_wifi_tcp_server_stop = function(block){
		return this.tab() + `nic.tcp_server_stop()` + END;
	}

	Arduino.weeemake_k210_wifi_tcp_server_status = function(block){
		return [`nic.tcp_server_status()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_wifi_tcp_server_listen = function(block){
		return [`nic.tcp_server_listen()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_wifi_tcp_connected = function(block){
		return [`nic.tcp_connected()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_wifi_tcp_read_available = function(block){
		return [`nic.tcp_read_available()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_wifi_tcp_read = function(block){
		const SIZE = this.valueToCode(block, 'SIZE', ORDER_NONE);
		return [`nic.tcp_read(${SIZE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_wifi_tcp_write = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return this.tab() + `nic.tcp_write(${VALUE || 'bytes()'})` + END;
	}
/*
	Arduino.weeemake_k210_sock_init = function(block){
		Arduino.addInclude('import socket')
		return Arduino.tab() + `sock = socket.socket()` + END;
	}
*/
	Arduino.weeemake_k210_sock_connect = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const PORT = this.valueToCode(block, 'PORT', ORDER_NONE);
		return this.tab() + `sock.connect((${NAME}, ${PORT}))` + END;
	}

	Arduino.weeemake_k210_sock_timeout = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return this.tab() + `sock.settimeout(${VALUE})` + END;
	}

	Arduino.weeemake_k210_sock_send = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return this.tab() + `sock.send(${VALUE})` + END;
	}

	Arduino.weeemake_k210_sock_sendTo = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const PORT = this.valueToCode(block, 'PORT', ORDER_NONE);
		return this.tab() + `sock.sendto(bytes(${VALUE}, 'utf-8'), (${NAME}, ${PORT}))` + END;
	}

	Arduino.weeemake_k210_sock_close = function(block){
		return this.tab() + `sock.close()` + END;
	}

	Arduino.weeemake_k210_sock_recv = function(block){
		const SIZE = this.valueToCode(block, 'SIZE', ORDER_NONE);
		return [`sock.recv(${SIZE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_sock_recvFrom = function(block){
		const SIZE = this.valueToCode(block, 'SIZE', ORDER_NONE);
		return [`sock.recvfrom(${SIZE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_sock_get_addr = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		return [`socket.getaddrinfo(${NAME},80)[0][-1]`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_sock_create = (list => function(block){
		const K210_SOCK_AF = block.getFieldValue('K210_SOCK_AF');
		const K210_SOCK_TYPE = block.getFieldValue('K210_SOCK_TYPE');
		this.addInclude('import socket')
		return this.tab() + `sock = socket.socket(socket.${list[K210_SOCK_AF]}, socket.${list[Number(K210_SOCK_TYPE)+2]})` + END;
	})(["AF_INET","AF_INET6","SOCK_STREAM","SOCK_DGRAM"])

	Arduino.weeemake_k210_sock_bind = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const PORT = this.valueToCode(block, 'PORT', ORDER_NONE);
		return this.tab() + `sock.bind((${NAME}, ${PORT}))` + END;
	}

	Arduino.weeemake_k210_image_open = function(block){
		this.addInclude('import image')
		return [`image.Image()`, ORDER_HIGH]
		//return Arduino.tab() + `img = image.Image()` + END;
	}

	Arduino.weeemake_k210_image_load = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		Arduino.addInclude('import image');
		return [`image.Image(${VALUE})`, ORDER_HIGH]
		//return Arduino.tab() + `img = image.Image(${VALUE})` + END;
	}

	Arduino.weeemake_k210_image_save = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const PATH = this.valueToCode(block, 'PATH', ORDER_NONE);
		return Arduino.tab() + `${VALUE || '#image'}.save(${PATH})` + END;
	}

	Arduino.weeemake_k210_image_clear = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return Arduino.tab() + `${VALUE || '#image'}.clear()` + END;
	}
	Arduino.weeemake_k210_image_get_pixel = function(block){
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = `image.Image()`;
		}
		return [`${VALUE}.get_pixel(${X}, ${Y})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_set_pixel = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const COLOR = this.valueToCode(block, 'COLOR', ORDER_NONE);
		//let color = COLOR.replace('#', '0x').replace(/"/g, '');
		return Arduino.tab() + `${VALUE || '#image'}.set_pixel(${X}, ${Y}, ${COLOR})` + END;
	}
	Arduino.weeemake_k210_image_copy = function(block){
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = `image.Image()`;
		}
		return [`${image}.copy(${xywh})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_image_compress = function(block){
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const RATE = this.valueToCode(block, 'RATE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		return [`${VALUE}.compress(quality=${RATE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_image_to_bytes = function(block){
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		return [`${VALUE}.to_bytes()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_image_get_info = function(block){
		const K210_IMAGE_INFO = block.getFieldValue('K210_IMAGE_INFO');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		return [`${VALUE}.${K210_IMAGE_INFO}()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_image_cast = function(block){
		const K210_IMAGE_TYPE = block.getFieldValue('K210_IMAGE_TYPE');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		return [`${VALUE}.${K210_IMAGE_TYPE}()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_image_draw_rect = function(block){
		const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const W = this.valueToCode(block, 'W', ORDER_NONE);
		const H = this.valueToCode(block, 'H', ORDER_NONE);
		const R = this.valueToCode(block, 'R', ORDER_NONE);
		const G = this.valueToCode(block, 'G', ORDER_NONE);
		const B = this.valueToCode(block, 'B', ORDER_NONE);
		const THICK = this.valueToCode(block, 'THICK', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.draw_rectangle((${X}, ${Y}, ${W}, ${H}), (${R}, ${G}, ${B}), ${THICK}, ${ON_OFF == '1' ? 'True' : 'False'})` + END;
	}
	Arduino.weeemake_k210_image_rgb = function(block){
		const r = this.valueToCode(block, 'r', ORDER_NONE);
		const g = this.valueToCode(block, 'g', ORDER_NONE);
		const b = this.valueToCode(block, 'b', ORDER_NONE);
		return [`(${r}, ${g}, ${b})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_draw_rectangle = function(block){
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		const rgb = this.valueToCode(block, 'rgb', ORDER_NONE);
		const thickness = this.valueToCode(block, 'thickness', ORDER_NONE);
		const fill = this.valueToCode(block, 'fill', ORDER_NONE);
		return Arduino.tab() + `${image}.draw_rectangle(${xywh}, ${rgb}, thickness=${thickness}, fill=${fill})` + END;
	}
	Arduino.weeemake_k210_image_draw_line = function(block){
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const X0 = this.valueToCode(block, 'X0', ORDER_NONE);
		const Y0 = this.valueToCode(block, 'Y0', ORDER_NONE);
		const X1 = this.valueToCode(block, 'X1', ORDER_NONE);
		const Y1 = this.valueToCode(block, 'Y1', ORDER_NONE);
		const rgb = this.valueToCode(block, 'rgb', ORDER_NONE);
		const THICK = this.valueToCode(block, 'THICK', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.draw_line((${X0}, ${Y0}, ${X1}, ${Y1}), ${rgb}, ${THICK})` + END;
	}

	Arduino.weeemake_k210_image_draw_image = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		let DATA = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		if(!DATA){
			Arduino.addInclude('import image');
			DATA = 'image.Image()'
		}
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const SX = this.valueToCode(block, 'SX', ORDER_NONE);
		const SY = this.valueToCode(block, 'SY', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.draw_image(${DATA}, ${X}, ${Y}, ${SX}, ${SY})` + END;
	}

	Arduino.weeemake_k210_image_draw_text = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const TEXT = this.valueToCode(block, 'TEXT', ORDER_NONE);
		const rgb = this.valueToCode(block, 'rgb', ORDER_NONE);
		const THICK = this.valueToCode(block, 'THICK', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.draw_string(${X}, ${Y}, ${TEXT}, ${rgb}, ${THICK})` + END;
	}

	Arduino.weeemake_k210_image_draw_text2 = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const TEXT = this.valueToCode(block, 'TEXT', ORDER_NONE);
		const rgb = this.valueToCode(block, 'rgb', ORDER_NONE);
		const THICK = this.valueToCode(block, 'THICK', ORDER_NONE);
		const x_spacing = this.valueToCode(block, 'x_spacing', ORDER_NONE);
		const y_spacing = this.valueToCode(block, 'y_spacing', ORDER_NONE);
		const mono_space = this.valueToCode(block, 'mono_space', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.draw_string(${X}, ${Y}, ${TEXT}, ${rgb}, ${THICK}, ${x_spacing}, ${y_spacing}, ${mono_space})` + END;
	}

	Arduino.weeemake_k210_image_font_load = function(block){
		Arduino.addInclude('import image');
		let size = block.getFieldValue('size');
		const path = this.valueToCode(block, 'path', ORDER_NONE);
		return Arduino.tab() + `image.font_load(image.UTF8, ${size}, ${size}, ${path})` + END;
	}

	Arduino.weeemake_k210_image_font_free = function(block){
		Arduino.addInclude('import image');
		return Arduino.tab() + `image.font_free()` + END;
	}

	Arduino.weeemake_k210_image_draw_arrow = function(block){
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const X0 = this.valueToCode(block, 'X0', ORDER_NONE);
		const Y0 = this.valueToCode(block, 'Y0', ORDER_NONE);
		const X1 = this.valueToCode(block, 'X1', ORDER_NONE);
		const Y1 = this.valueToCode(block, 'Y1', ORDER_NONE);
		const rgb = this.valueToCode(block, 'rgb', ORDER_NONE);
		const THICK = this.valueToCode(block, 'THICK', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.draw_arrow((${X0}, ${Y0}, ${X1}, ${Y1}), ${rgb}, ${THICK})` + END;
	}

	Arduino.weeemake_k210_image_draw_cross = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const SIZE = this.valueToCode(block, 'SIZE', ORDER_NONE);
		const rgb = this.valueToCode(block, 'rgb', ORDER_NONE);
		const THICK = this.valueToCode(block, 'THICK', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.draw_cross((${X}, ${Y}), ${rgb}, ${SIZE}, ${THICK})` + END;
	}

	Arduino.weeemake_k210_image_draw_circle = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const x = this.valueToCode(block, 'x', ORDER_NONE);
		const y = this.valueToCode(block, 'y', ORDER_NONE);
		const radius = this.valueToCode(block, 'radius', ORDER_NONE);
		const rgb = this.valueToCode(block, 'rgb', ORDER_NONE);
		const thickness = this.valueToCode(block, 'thickness', ORDER_NONE);
		const fill = this.valueToCode(block, 'fill', ORDER_NONE);
		return Arduino.tab() + `${image}.draw_circle(${x}, ${y}, ${radius}, ${rgb}, ${thickness}, ${fill})` + END;
	}
	Arduino.weeemake_k210_image_cartoon = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const SEED = this.valueToCode(block, 'SEED', ORDER_NONE);
		const FLOAT = this.valueToCode(block, 'FLOAT', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.cartoon(seed_threshold=${SEED}, floating_threshold=${FLOAT})` + END;
	}
	Arduino.weeemake_k210_image_invert = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		return Arduino.tab() + `${VALUE}.invert()` + END;
	}

	Arduino.weeemake_k210_image_linpolar = function(block){
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const reverse = this.valueToCode(block, 'reverse', ORDER_NONE);
		return Arduino.tab() + `${image}.linpolar(reverse=${reverse})` + END;
	}

	Arduino.weeemake_k210_image_lens_corr = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const STRENGTH = this.valueToCode(block, 'STRENGTH', ORDER_NONE);
		const ZOOM = this.valueToCode(block, 'ZOOM', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.lens_corr(${STRENGTH}, ${ZOOM})` + END;
	}
	Arduino.weeemake_k210_image_dilate = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const SIZE = this.valueToCode(block, 'SIZE', ORDER_NONE);
		const THRESHOLD = this.valueToCode(block, 'THRESHOLD', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.dilate(${SIZE}, ${THRESHOLD})` + END;
	}
	Arduino.weeemake_k210_image_erode = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const SIZE = this.valueToCode(block, 'SIZE', ORDER_NONE);
		const THRESHOLD = this.valueToCode(block, 'THRESHOLD', ORDER_NONE);
		return Arduino.tab() + `${VALUE}.erode(${SIZE}, ${THRESHOLD})` + END;
	}

	Arduino.weeemake_k210_image_histeq = function(block){
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const adaptive = this.valueToCode(block, 'adaptive', ORDER_NONE);
		const clip_limit = this.valueToCode(block, 'clip_limit', ORDER_NONE);
		return Arduino.tab() + `${image}.histeq(adaptive=${adaptive}, clip_limit=${clip_limit})` + END;
	}

	Arduino.weeemake_k210_image_mean = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const size = this.valueToCode(block, 'size', ORDER_NONE);
		const threshold = this.valueToCode(block, 'threshold', ORDER_NONE);
		const offset = this.valueToCode(block, 'offset', ORDER_NONE);
		return Arduino.tab() + `${image}.mean(${size}, threshold=${threshold}, offset=${offset})` + END;
	}
	Arduino.weeemake_k210_image_find_lines = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		const threshold = this.valueToCode(block, 'threshold', ORDER_NONE);
		const theta_margin = this.valueToCode(block, 'theta_margin', ORDER_NONE);
		const rho_margin = this.valueToCode(block, 'rho_margin', ORDER_NONE);
		return [`${image}.find_lines(${xywh}, threshold=${threshold}, theta_margin=${theta_margin}, rho_margin=${rho_margin})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_find_line_segments = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		const merge_distance = this.valueToCode(block, 'merge_distance', ORDER_NONE);
		const max_theta_difference = this.valueToCode(block, 'max_theta_difference', ORDER_NONE);
		return [`${image}.find_line_segments(${xywh}, merge_distance=${merge_distance}, max_theta_difference=${max_theta_difference})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_find_rects = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		const threshold = this.valueToCode(block, 'threshold', ORDER_NONE);
		return [`${image}.find_rects(${xywh}, ${threshold})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_find_circles = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const W = this.valueToCode(block, 'W', ORDER_NONE);
		const H = this.valueToCode(block, 'H', ORDER_NONE);
		const THRESHOLD = this.valueToCode(block, 'THRESHOLD', ORDER_NONE);
		const MIN_R = this.valueToCode(block, 'MIN_R', ORDER_NONE);
		const MAX_R = this.valueToCode(block, 'MAX_R', ORDER_NONE);
		const STEP_R = this.valueToCode(block, 'STEP_R', ORDER_NONE);
		const MERGE_X = this.valueToCode(block, 'MERGE_X', ORDER_NONE);
		const MERGE_Y = this.valueToCode(block, 'MERGE_Y', ORDER_NONE);
		const MERGE_R = this.valueToCode(block, 'MERGE_R', ORDER_NONE);
		return [`${VALUE}.find_circles((${X}, ${Y}, ${W}, ${H}), threshold=${THRESHOLD}, r_min=${MIN_R}, r_max=${MAX_R}, r_step=${STEP_R}, x_margin=${MERGE_X}, y_margin=${MERGE_Y}, r_margin=${MERGE_R})`, ORDER_HIGH];
	}
	Arduino.weeemake_func_on_off = function(block){
		return [block.getFieldValue('VALUE') == '1' ? 'True' : 'False', ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_xywh = function(block){
		const x = this.valueToCode(block, 'x', ORDER_NONE);
		const y = this.valueToCode(block, 'y', ORDER_NONE);
		const w = this.valueToCode(block, 'w', ORDER_NONE);
		const h = this.valueToCode(block, 'h', ORDER_NONE);
		return [`(${x}, ${y}, ${w}, ${h})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_lab = function(block){
		const ll = this.valueToCode(block, 'll', ORDER_NONE);
		const lh = this.valueToCode(block, 'lh', ORDER_NONE);
		const al = this.valueToCode(block, 'al', ORDER_NONE);
		const ah = this.valueToCode(block, 'ah', ORDER_NONE);
		const bl = this.valueToCode(block, 'bl', ORDER_NONE);
		const bh = this.valueToCode(block, 'bh', ORDER_NONE);
		return [`[(${ll}, ${lh}, ${al}, ${ah}, ${bl}, ${bh})]`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_find_blobs = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const lab = this.valueToCode(block, 'lab', ORDER_NONE);
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		const area = this.valueToCode(block, 'area', ORDER_NONE);
		const pixels = this.valueToCode(block, 'pixels', ORDER_NONE);
		const margin = this.valueToCode(block, 'margin', ORDER_NONE);
		const merge = this.valueToCode(block, 'merge', ORDER_NONE);
		return [`${VALUE}.find_blobs(${lab}, roi=${xywh}, area_threshold=${area}, pixels_threshold=${pixels}, merge=${merge}, margin=${margin})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_get_histogram = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		if(!VALUE){
			Arduino.addInclude('import image');
			VALUE = 'image.Image()'
		}
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		return [`${VALUE}.get_histogram(roi=${xywh})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_blob = function(block){
		const _var = this.valueToCode(block, 'var', ORDER_NONE);
		const key = block.getFieldValue('key');
		return [`${_var}.${key}()`, ORDER_HIGH]
	}
	Arduino.weeemake_k210_image_percentile = function(block){
		const _var = this.valueToCode(block, 'var', ORDER_NONE);
		const cdf = this.valueToCode(block, 'cdf', ORDER_NONE);
		const key = block.getFieldValue('key');
		return [`${_var}.get_percentile(${cdf}).${key}()`, ORDER_HIGH]
	}
	Arduino.weeemake_k210_image_find_barcodes = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		return [`${image}.find_barcodes(${xywh})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_find_qrcodes = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		return [`${image}.find_qrcodes(${xywh})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_find_apriltags = function(block){
		//const ON_OFF = block.getFieldValue('ON_OFF');
		let image = this.valueToCode(block, 'image', ORDER_NONE);
		if(!image){
			Arduino.addInclude('import image');
			image = 'image.Image()'
		}
		const xywh = this.valueToCode(block, 'xywh', ORDER_NONE);
		return [`${image}.find_apriltags(${xywh})`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_image_barcode_info = 
	Arduino.weeemake_k210_image_qrcode_info = 
	Arduino.weeemake_k210_image_apriltag_info = function(block){
		let VALUE = this.valueToCode(block, 'VALUE', ORDER_HIGH);
		if(!VALUE){
			return [`None`, ORDER_HIGH];
		}
		return [`${VALUE}.${block.getFieldValue('KEY')}()`, ORDER_HIGH];
	}
	Arduino.weeemake_k210_int_to_bytes = (list => function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const LEN = this.valueToCode(block, 'LEN', ORDER_NONE);
		const BYTE_ORDER = block.getFieldValue('BYTE_ORDER');
		return [`int(${VALUE}).to_bytes(${LEN}, '${list[BYTE_ORDER]}')`, ORDER_HIGH]
	})(['big', 'little']);

	Arduino.weeemake_k210_bytes_to_int = (list => function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const BYTE_ORDER = block.getFieldValue('BYTE_ORDER');
		return [`int.from_bytes(${VALUE||'None'}, '${list[BYTE_ORDER]}')`, ORDER_HIGH]
	})(['big', 'little']);

	Arduino.weeemake_k210_str_to_bytes = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return [`bytes(${VALUE}, 'utf-8')`, ORDER_HIGH]
	}
	Arduino.weeemake_k210_len = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return [`len(${VALUE||"''"})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_index = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const INDEX = this.valueToCode(block, 'INDEX', ORDER_NONE);
		return [`${VALUE||'[]'}[${INDEX}]`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_slice = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const FROM = this.valueToCode(block, 'FROM', ORDER_NONE);
		const TO = this.valueToCode(block, 'TO', ORDER_NONE);
		return [`${VALUE||'[]'}[${FROM}:${TO}]`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_list_clear = function(block){
		const LIST = this.valueToCode(block, 'LIST', ORDER_NONE);
		return Arduino.tab() + `${LIST || '#list'}.clear()` + END;
	}

	Arduino.weeemake_k210_list_reverse = function(block){
		const LIST = this.valueToCode(block, 'LIST', ORDER_NONE);
		return Arduino.tab() + `${LIST || '#list'}.reverse()` + END;
	}

	Arduino.weeemake_k210_list_get = function(block){
		const LIST = this.valueToCode(block, 'LIST', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const PYTHON_LIST_GET_TYPE = block.getFieldValue('PYTHON_LIST_GET_TYPE');
		return [`${LIST || 'list()'}.${PYTHON_LIST_GET_TYPE}(${VALUE})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_list_set = function(block){
		const LIST = this.valueToCode(block, 'LIST', ORDER_NONE);
		const INDEX = this.valueToCode(block, 'INDEX', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return Arduino.tab() + `${LIST || '#list'}[${INDEX}] = ${VALUE}` + END;
	}

	Arduino.weeemake_k210_list_insert = function(block){
		const LIST = this.valueToCode(block, 'LIST', ORDER_NONE);
		const INDEX = this.valueToCode(block, 'INDEX', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return Arduino.tab() + `${LIST || '#list'}.insert(${INDEX}, ${VALUE})` + END;
	}

	Arduino.weeemake_k210_list_removeAt = function(block){
		const LIST = this.valueToCode(block, 'LIST', ORDER_NONE);
		const INDEX = this.valueToCode(block, 'INDEX', ORDER_NONE);
		return Arduino.tab() + (LIST ? `del ${LIST}[${INDEX}]` : `#del list[${INDEX}]`) + END;
	}

	Arduino.weeemake_k210_list_remove = function(block){
		const LIST = this.valueToCode(block, 'LIST', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return Arduino.tab() + `${LIST || '#list'}.remove(${VALUE})` + END;
	}

	Arduino.weeemake_k210_dict_new = function(block){
		const DICT = this.valueToCode(block, 'DICT', ORDER_NONE);
		return [`dict()`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_dict_values = function(block){
		const DICT = this.valueToCode(block, 'DICT', ORDER_NONE);
		return [`${DICT || 'dict()'}.values()`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_dict_get = function(block){
		const DICT = this.valueToCode(block, 'DICT', ORDER_NONE);
		const KEY = this.valueToCode(block, 'KEY', ORDER_NONE);
		return [`${DICT || 'dict()'}[${KEY}]`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_dict_set = function(block){
		const DICT = this.valueToCode(block, 'DICT', ORDER_NONE);
		const KEY = this.valueToCode(block, 'KEY', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return Arduino.tab() + `${DICT || '#dict'}[${KEY}] = ${VALUE}` + END;
	}

	Arduino.weeemake_k210_dict_clear = function(block){
		const DICT = this.valueToCode(block, 'DICT', ORDER_NONE);
		return Arduino.tab() + `${DICT || '#dict'}.clear()` + END;
	}

	Arduino.weeemake_k210_dict_get_delete = function(block){
		const DICT = this.valueToCode(block, 'DICT', ORDER_NONE);
		const KEY = this.valueToCode(block, 'KEY', ORDER_NONE);
		return [`${DICT || 'dict()'}.pop(${KEY})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_dict_delete = function(block){
		const DICT = this.valueToCode(block, 'DICT', ORDER_NONE);
		const KEY = this.valueToCode(block, 'KEY', ORDER_NONE);
		return Arduino.tab() + (DICT ? `del ${DICT}[${KEY}]` : `#del dict[${KEY}]`) + END;
	}

	Arduino.weeemake_k210_create_anchor = function(block){
		const VALUE = castToVarName(block, 'VALUE', ORDER_NONE);
		return [`(${VALUE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_kpu_load_from_address = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		Arduino.addInclude('import KPU');
		return [`KPU.load(${VALUE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_kpu_load_from_path = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		Arduino.addInclude('import KPU');
		return [`KPU.load(${VALUE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_kpu_deinit = function(block){
		const MODEL = this.valueToCode(block, 'MODEL', ORDER_NONE);
		Arduino.addInclude('import KPU');
		return [`KPU.deinit(${MODEL})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_kpu_yolo2_init = function(block){
		const MODEL = this.valueToCode(block, 'MODEL', ORDER_NONE);
		const ANCHOR = this.valueToCode(block, 'ANCHOR', ORDER_NONE);
		const RATE = this.valueToCode(block, 'RATE', ORDER_NONE);
		const LIMIT = this.valueToCode(block, 'LIMIT', ORDER_NONE);
		const COUNT = this.valueToCode(block, 'COUNT', ORDER_NONE);
		Arduino.addInclude('import KPU');
		return [`KPU.init_yolo2(${MODEL}, ${RATE}, ${LIMIT}, ${COUNT}, ${ANCHOR})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_kpu_yolo2_run = function(block){
		const MODEL = this.valueToCode(block, 'MODEL', ORDER_NONE);
		const IMAGE = this.valueToCode(block, 'IMAGE', ORDER_NONE);
		Arduino.addInclude('import KPU');
		return [`KPU.run_yolo2(${MODEL}, ${IMAGE})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_kpu_yolo2_forward = function(block){
		const MODEL = this.valueToCode(block, 'MODEL', ORDER_NONE);
		const IMAGE = this.valueToCode(block, 'IMAGE', ORDER_NONE);
		Arduino.addInclude('import KPU');
		return [`KPU.forward(${MODEL}, ${IMAGE})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_kpu_yolo2_get_info = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const KPU_YOLO2_INFO = block.getFieldValue('KPU_YOLO2_INFO');
		
		return [`${VALUE}.${KPU_YOLO2_INFO}()`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_asr_init = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		Arduino.addInclude('from ASR import *');
		return [`asr_init(${VALUE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_asr_config = function(block){
		const asr = this.valueToCode(block, 'asr', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		//Arduino.addInclude('from ASR import *');
		return Arduino.tab() + `${asr}.config(${VALUE})` + END;
		//return [`asr_init(${VALUE})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_asr_recognize = function(block){
		const asr = this.valueToCode(block, 'asr', ORDER_NONE);
		return [`${asr}.recognize()`, ORDER_HIGH]
	}

	Arduino.weeemake_python_none = function(){
		return [`None`, ORDER_ATOMIC];
	}

	Arduino.weeemake_k210_type_cast = function(block){
		const type = block.getFieldValue('type');
		const value = this.valueToCode(block, 'value', ORDER_NONE);
		return [`${type}(${value})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_dict_method = function(block){
		const KEY = block.getFieldValue('KEY');
		const DICT = this.valueToCode(block, 'DICT', ORDER_NONE);
		return [`${DICT}.${KEY}()`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_file_open = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const FILE_MODE = block.getFieldValue('FILE_MODE');
		return [`open(${NAME}, '${FILE_MODE}')`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_file_read = function(block){
		const READ_MODE = block.getFieldValue('READ_MODE');
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		return [`${NAME || '#file'}.${READ_MODE}()`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_file_write = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		return Arduino.tab() + `${NAME || '#file'}.write(${VALUE})` + END;
	}

	Arduino.weeemake_k210_file_close = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		return Arduino.tab() + `${NAME || '#file'}.close()` + END;
	}

	Arduino.weeemake_k210_file_remove = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		this.addInclude('import os');
		return Arduino.tab() + `os.remove(${NAME})` + END;
	}
	Arduino.weeemake_k210_file_rename = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		this.addInclude('import os');
		return Arduino.tab() + `os.rename(${NAME}, ${VALUE})` + END;
	}

	Arduino.weeemake_k210_file_list_dir = function(block){
		this.addInclude('import os');
		return [`os.listdir()`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_file_get_curr_dir = function(block){
		this.addInclude('import os');
		return [`os.getcwd()`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_file_get_size = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		this.addInclude('import os');
		if(db.isMicrobitBoard()){
			return [`os.size(${NAME})`, ORDER_HIGH];
		}
		return [`os.stat(${NAME})[6]`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_file_set_curr_dir = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		this.addInclude('import os');
		return Arduino.tab() + `os.chdir(${VALUE})` + END;
	}
/*
	Arduino.weeemake_mpython_button = function(block){
		const MICROBIT_BUTTON_INDEX = block.getFieldValue('MICROBIT_BUTTON_INDEX');
		Arduino.addInclude('from mpython import *');
		return [`button_${MICROBIT_BUTTON_INDEX}.value() == 0`, ORDER_RELATIONAL]
	}
*/
	Arduino.weeemake_mpython_accelerometer_set_range = function(block){
		const ACCELEROMETER_RANGE = block.getFieldValue('ACCELEROMETER_RANGE');
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return this.tab() + `accelerometer.set_range(accelerometer.${ACCELEROMETER_RANGE})` + END;
	}


	Arduino.weeemake_mpython_accelerometer_set_resolustion = function(block){
		const ACCELEROMETER_RESOLUSTION = block.getFieldValue('ACCELEROMETER_RESOLUSTION');
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return this.tab() + `accelerometer.set_resolustion(accelerometer.${ACCELEROMETER_RESOLUSTION})` + END;
	}

	Arduino.weeemake_mpython_accelerometer_set_offset = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const Z = this.valueToCode(block, 'Z', ORDER_NONE);
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return this.tab() + `accelerometer.set_offset(${X}, ${Y}, ${Z})` + END;
	}

	Arduino.weeemake_mpython_magnetic = (dict => function(block){
		const AXIS3 = block.getFieldValue('AXIS3');

		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}

		return [`magnetic.get_${dict[AXIS3]}()`, ORDER_HIGH];
	})({'0':'x','1':'y','2':'z'})

	Arduino.weeemake_mpython_calibrate = function(block){
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return Arduino.tab() + `magnetic.calibrate()` + END;
	}

	Arduino.weeemake_mpython_peeling = function(block){
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return Arduino.tab() + `magnetic.peeling()` + END;
	}

	Arduino.weeemake_mpython_strength = function(block){
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return [`magnetic.get_field_strength()`, ORDER_HIGH];
	}

	Arduino.weeemake_mpython_heading = function(block){
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return [`magnetic.get_heading()`, ORDER_HIGH];
	}

	Arduino.weeemake_mpython_enable_AP = function(block){
		const NAME = castToStr(block, 'NAME');
		const SECRET = castToStr(block, 'SECRET');
		const WIFI_CHANNEL = block.getFieldValue('WIFI_CHANNEL');
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
			this.addSetupCode(`my_wifi = wifi()`);
		}else if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('from wifi import *');
			this.addSetupCode(`my_wifi = WiFi()`);
		}else{
			return;
		}
		return Arduino.tab() + `my_wifi.enable_APWiFi(${NAME}, ${SECRET}, channel=${WIFI_CHANNEL})` + END;
	}

	Arduino.weeemake_mpython_disable_AP = function(block){
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
			this.addSetupCode(`my_wifi = wifi()`);
		}else if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('from wifi import *');
			this.addSetupCode(`my_wifi = WiFi()`);
		}else{
			return;
		}
		return Arduino.tab() + `my_wifi.disable_APWiFi()` + END;
	}

	Arduino.weeemake_mpython_audio_do = function(block){
		const MPYTHON_AUDIO_FUNCTION = block.getFieldValue('MPYTHON_AUDIO_FUNCTION');
		this.addInclude('import audio');
		return this.tab() + `audio.${MPYTHON_AUDIO_FUNCTION}()` + END;
	}

	Arduino.weeemake_mpython_audio_record_on_off = function(block){
		const ON_OFF = block.getFieldValue('ON_OFF');
		this.addInclude('import audio');
		return this.tab() + `audio.recorder_${ON_OFF == 1 ? '' : 'de'}init()` + END;
	}

	Arduino.weeemake_mpython_audio_record = function(block){
		const NAME = this.valueToCode(block, 'NAME', ORDER_NONE);
		const TIME = this.valueToCode(block, 'TIME', ORDER_NONE);
		this.addInclude('import audio');
		return this.tab() + `audio.record(${NAME}, ${TIME})` + END;
	}

	Arduino.weeemake_mpython_oled_on_off = function(block){
		const ON_OFF = block.getFieldValue('ON_OFF');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.power${ON_OFF == 1 ? 'on' : 'off'}()` + END;
	}

	Arduino.weeemake_mpython_oled_contrast = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		this.addInclude('from mpython import *');
		return this.tab() + `oled.contrast(${VALUE})` + END;
	}

	Arduino.weeemake_mpython_oled_show = function(block){
		this.addInclude('from mpython import *');
		return this.tab() + `oled.show()` + END;
	}

	Arduino.weeemake_mpython_oled_display = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const TEXT = castToStr(block, 'TEXT');
		const MPYTHON_OLED_TEXT_MODE = block.getFieldValue('MPYTHON_OLED_TEXT_MODE');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.DispChar(${TEXT}, ${X}, ${Y}, ${MPYTHON_OLED_TEXT_MODE})` + END;
	}

	Arduino.weeemake_mpython_oled_draw_circle = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const RADIUS = this.valueToCode(block, 'RADIUS', ORDER_NONE);
		const DRAW_MODE = block.getFieldValue('MPYTHON_OLED_SHAPE_DRAW_MODE');
		const SHAPE_TYPE = block.getFieldValue('MPYTHON_OLED_SHAPE_TYPE');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.${SHAPE_TYPE == 1 ? 'fill_' : ''}circle(${X}, ${Y}, ${RADIUS}, ${DRAW_MODE})` + END;
	}

	Arduino.weeemake_mpython_oled_draw_rect = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const W = this.valueToCode(block, 'W', ORDER_NONE);
		const H = this.valueToCode(block, 'H', ORDER_NONE);
		const DRAW_MODE = block.getFieldValue('MPYTHON_OLED_SHAPE_DRAW_MODE');
		const SHAPE_TYPE = block.getFieldValue('MPYTHON_OLED_SHAPE_TYPE');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.${SHAPE_TYPE == 1 ? 'fill_' : ''}rect(${X}, ${Y}, ${W}, ${H}, ${DRAW_MODE})` + END;
	}

	Arduino.weeemake_mpython_oled_draw_round_rect = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const W = this.valueToCode(block, 'W', ORDER_NONE);
		const H = this.valueToCode(block, 'H', ORDER_NONE);
		const RADIUS = this.valueToCode(block, 'RADIUS', ORDER_NONE);
		const DRAW_MODE = block.getFieldValue('MPYTHON_OLED_SHAPE_DRAW_MODE');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.RoundRect(${X}, ${Y}, ${W}, ${H}, ${RADIUS}, ${DRAW_MODE})` + END;
	}

	Arduino.weeemake_mpython_oled_set = (list => function(block){
		const MPYTHON_OLED_SET = block.getFieldValue('MPYTHON_OLED_SET');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.${list[MPYTHON_OLED_SET]}` + END;
	})(['fill(0)', 'fill(1)', 'invert(0)', 'invert(1)'])

	Arduino.weeemake_mpython_oled_draw_triangle = function(block){
		const X0 = this.valueToCode(block, 'X0', ORDER_NONE);
		const Y0 = this.valueToCode(block, 'Y0', ORDER_NONE);
		const X1 = this.valueToCode(block, 'X1', ORDER_NONE);
		const Y1 = this.valueToCode(block, 'Y1', ORDER_NONE);
		const X2 = this.valueToCode(block, 'X2', ORDER_NONE);
		const Y2 = this.valueToCode(block, 'Y2', ORDER_NONE);
		const DRAW_MODE = block.getFieldValue('MPYTHON_OLED_SHAPE_DRAW_MODE');
		const SHAPE_TYPE = block.getFieldValue('MPYTHON_OLED_SHAPE_TYPE');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.${SHAPE_TYPE == 1 ? 'fill_' : ''}triangle(${X0}, ${Y0}, ${X1}, ${Y1}, ${X2}, ${Y2}, ${DRAW_MODE})` + END;
	}
	Arduino.weeemake_mpython_oled_draw_pixel = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const value = this.valueToCode(block, 'value', ORDER_NONE);
		this.addInclude('from mpython import *');
		return this.tab() + `oled.pixel(${X}, ${Y}, ${value})` + END;
	}
	Arduino.weeemake_mpython_oled_draw_line = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const LENGTH = this.valueToCode(block, 'LENGTH', ORDER_NONE);
		const DRAW_MODE = block.getFieldValue('MPYTHON_OLED_SHAPE_DRAW_MODE');
		const LINE_TYPE = block.getFieldValue('MPYTHON_OLED_LINE_TYPE');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.${LINE_TYPE}line(${X}, ${Y}, ${LENGTH}, ${DRAW_MODE})` + END;
	}
	Arduino.weeemake_mpython_oled_draw_line2 = function(block){
		const X0 = this.valueToCode(block, 'X0', ORDER_NONE);
		const Y0 = this.valueToCode(block, 'Y0', ORDER_NONE);
		const X1 = this.valueToCode(block, 'X1', ORDER_NONE);
		const Y1 = this.valueToCode(block, 'Y1', ORDER_NONE);
		const DRAW_MODE = block.getFieldValue('MPYTHON_OLED_SHAPE_DRAW_MODE');
		this.addInclude('from mpython import *');
		return this.tab() + `oled.line(${X0}, ${Y0}, ${X1}, ${Y1}, ${DRAW_MODE})` + END;
	}

	Arduino.weeemake_mpython_oled_draw_progressbar = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const W = this.valueToCode(block, 'W', ORDER_NONE);
		const H = this.valueToCode(block, 'H', ORDER_NONE);
		const PROGRESS = this.valueToCode(block, 'PROGRESS', ORDER_NONE);
		this.addInclude('from mpython import *');
		this.addSetupCode('myUI = UI(oled)');
		return this.tab() + `myUI.ProgressBar(${X}, ${Y}, ${W}, ${H}, ${PROGRESS})` + END;
	}

	Arduino.weeemake_mpython_oled_draw_stripbar = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const W = this.valueToCode(block, 'W', ORDER_NONE);
		const H = this.valueToCode(block, 'H', ORDER_NONE);
		const PROGRESS = this.valueToCode(block, 'PROGRESS', ORDER_NONE);
		const LINE_TYPE = block.getFieldValue('MPYTHON_OLED_LINE_TYPE');
		const SHOW = block.getFieldValue('MPYTHON_OLED_SHOW');
		this.addInclude('from mpython import *');
		this.addSetupCode('myUI = UI(oled)');
		return this.tab() + `myUI.stripBar(${X}, ${Y}, ${W}, ${H}, ${PROGRESS}, ${LINE_TYPE == 'h' ? 1 : 0}, ${SHOW})` + END;
	}

	Arduino.weeemake_mpython_oled_draw_qr_code = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const TEXT = this.valueToCode(block, 'TEXT', ORDER_NONE);
		const SIZE = block.getFieldValue('MPYTHON_OLED_QR_CODE_SIZE');
		this.addInclude('from mpython import *');
		this.addSetupCode('myUI = UI(oled)');
		return this.tab() + `myUI.qr_code(${TEXT}, ${X}, ${Y}, ${SIZE})` + END;
	}

	Arduino.weeemake_mpython_oled_create_clock = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		const RADIUS = this.valueToCode(block, 'RADIUS', ORDER_NONE);
		this.addInclude('from mpython import *');
		return [`Clock(oled, ${X}, ${Y}, ${RADIUS})`, ORDER_HIGH]
	}

	Arduino.weeemake_mpython_oled_update_clock = function(block){
		const CLOCK = this.valueToCode(block, 'CLOCK', ORDER_NONE);
		return this.tab() + `${CLOCK || '#Clock'}.settime()` + END;
	}

	Arduino.weeemake_mpython_oled_draw_clock = function(block){
		const CLOCK = this.valueToCode(block, 'CLOCK', ORDER_NONE);
		return this.tab() + `${CLOCK || '#Clock'}.drawClock()` + END;
	}

	Arduino.weeemake_microbitV2_logo_touched = function(block){
		this.addInclude('from microbit import *');
		return [`pin_logo.is_touched()`, ORDER_HIGH]
	}

	Arduino.weeemake_python_interrupt = function(block){
		const NAME = block.getFieldValue('NAME');
		this.addInclude('from fpioa_manager import fm');
		this.addInclude('from Maix import GPIO');
		//Arduino.addSetupCode('fm.register(16, fm.fpioa.GPIOHS0)');
		//Arduino.addSetupCode('boot_gpio = GPIO(GPIO.GPIOHS0, GPIO.IN)');
		this.addSetupCode(`fm.register(32, fm.fpioa.GPIOHS2)`);
		this.addSetupCode(`pin6 = GPIO(GPIO.GPIOHS2, GPIO.IN)`);

		return Arduino.tab() + `pin6.irq(${NAME||'None'}, GPIO.IRQ_RISING, GPIO.WAKEUP_NOT_SUPPORT)` + Arduino.END;
	}

	Arduino.weeemake_sensor_set_auto_gain = function(block){
		Arduino.addInclude('import sensor');
		const flag = this.valueToCode(block, 'flag', ORDER_NONE);
		return Arduino.tab() + `sensor.set_auto_gain(${flag})` + END;
	}
	Arduino.weeemake_sensor_set_auto_whitebal = function(block){
		Arduino.addInclude('import sensor');
		const flag = this.valueToCode(block, 'flag', ORDER_NONE);
		return Arduino.tab() + `sensor.set_auto_whitebal(${flag})` + END;
	}

	Arduino.weeemake_break_continue = function(block){
		const type = block.getFieldValue('type');
		return Arduino.tab() + type + END;
	}

	Arduino.weeemake_python_var = function(block){
		const name = block.getFieldValue('name');
		return [name, ORDER_ATOMIC];
	}

	Arduino.weeemake_python_var_declare = function(block){
		const type = block.getFieldValue('type');
		const nameBlock = block.getInputTargetBlock('name');
		let name;
		if(nameBlock.type == 'string'){
			name = nameBlock.getFieldValue('TEXT');
		}else if(nameBlock.type == 'data_variable'){
			let raw_name = nameBlock.getField('VARIABLE').text_;
			name = this.adjustVarName(raw_name);
		}else{
			name = 'Invalid';
		}
		return Arduino.tab() + `${type} ${name}` + END;
	}

	Arduino.weeemake_python_statement = function(block){
		const code = block.getFieldValue('code');
		return Arduino.tab() + code + END;
	}

	Arduino.math_hex_number = function(block){
		const NUM = block.getFieldValue('NUM');
		return [`0x${NUM}`, ORDER_ATOMIC];
	}

	Arduino.weeemake_python_tuple = function(block){
		const value = block.getFieldValue('value');
		return [`(${value})`, ORDER_ATOMIC];
	}

	Arduino.weeemake_python_iter = function(block){
		const VAR = block.getFieldValue('var');
		const LIST = Arduino.valueToCode(block, 'list', ORDER_NONE) || 'None';
		const subBlock = block.getInputTargetBlock('do');
		let tab = Arduino.tab();
		if(subBlock == null)return tab + `for ${VAR} in ${LIST}: pass` + END;
		let subCode = Arduino.statementToCodeIndent(block, 'do');
		return `${tab}for ${VAR} in ${LIST}:\n${subCode}`;
	}

	Arduino.weeemake_k210_camera_set_func = function(block) {
		let key = block.getFieldValue('key')
		let value = this.valueToCode(block, 'value', ORDER_NONE);
		Arduino.addInclude('import sensor')
		return Arduino.tab() + `sensor.${key}(${value})` + END;
	}

	Arduino.weeemake_k210_feature_learning_new = function(block){
		Arduino.addInclude(`from feature_learning import *`);
		const path = this.valueToCode(block, 'path', ORDER_NONE);
		return [`feature_learning(${path})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_feature_learning_load = function(block){
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		const names = this.valueToCode(block, 'names', ORDER_NONE);
		const path = this.valueToCode(block, 'path', ORDER_NONE);
		return Arduino.tab() + `${target}.loading(${names}, ${path})` + END;
	}

	Arduino.weeemake_k210_feature_learning_train = function(block){
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		const names = this.valueToCode(block, 'names', ORDER_NONE);
		const count = this.valueToCode(block, 'count', ORDER_NONE);
		const output = this.valueToCode(block, 'output', ORDER_NONE);
		return Arduino.tab() + `${target}.training(${names}, ${count}, ${output})` + END;
	}

	Arduino.weeemake_k210_feature_learning_predict = function(block){
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		const image = this.valueToCode(block, 'image', ORDER_NONE);
		return [`${target}.predict(${image})`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_isolated_word_new = function(block){
		Arduino.addInclude(`from ASR import *`);
		return [`maix_isolated_word()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_face_recognition_load = 
	Arduino.weeemake_k210_isolated_word_load = function(block){
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		const names = this.valueToCode(block, 'names', ORDER_NONE);
		const path = this.valueToCode(block, 'path', ORDER_NONE);
		return Arduino.tab() + `${target}.loading(${names}, ${path})` + END;
	}

	Arduino.weeemake_k210_face_recognition_train = 
	Arduino.weeemake_k210_isolated_word_train = function(block){
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		const names = this.valueToCode(block, 'names', ORDER_NONE);
		const output = this.valueToCode(block, 'output', ORDER_NONE);
		return Arduino.tab() + `${target}.training(${names}, ${output})` + END;
	}

	Arduino.weeemake_k210_face_recognition_get_result = function(block){
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		const accuracy = this.valueToCode(block, 'accuracy', ORDER_NONE);
		return [`${target}.get_result(${accuracy})`, ORDER_HIGH]
	}
	Arduino.weeemake_k210_isolated_word_get_result = function(block){
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		return [`${target}.get_result()`, ORDER_HIGH]
	}

	Arduino.weeemake_k210_face_recognition_new = function(block){
		Arduino.addInclude(`from face_recognition import *`);
		const fd = this.valueToCode(block, 'fd', ORDER_NONE);
		const ld = this.valueToCode(block, 'ld', ORDER_NONE);
		const fe = this.valueToCode(block, 'fe', ORDER_NONE);
		return [`face_recognition(${fd}, ${ld}, ${fe})`, ORDER_HIGH]
	}

	Arduino.weeemake_ir_avoid = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		if(db.board === board_microbitV2){
			Arduino.addInclude('from WePort import *');
		}else{//microbit V1
			Arduino.addInclude('from elfshield import *');
		}
		return [`${SENSOR_PORT}.read_digital()`, ORDER_HIGH];
	}

	Arduino.weeemake_microbit_temperature = function(){
		Arduino.addInclude('from microbit import *');
		return [`temperature()`, ORDER_HIGH]
	}

	Arduino.weeemake_barometer = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const BAROMETER_TYPE = block.getFieldValue('BAROMETER_TYPE');
		if(db.board === board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = `barometer_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeBarometerSensor import *');
			Arduino.addSetupCode(`${key} = WeBarometerSensor(${SENSOR_PORT})`);
			if(BAROMETER_TYPE != 1){//only support pressure
				return ['0', ORDER_ATOMIC];
			}
			return [`${key}.getValue()`, ORDER_HIGH];
		}else{//microbit V1
			//Arduino.addInclude('from elfshield import *');
		}
		return ['0', ORDER_ATOMIC];
	}

	Arduino.weeemake_PM25 = (list => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const PM25_TYPE = block.getFieldValue('PM25_TYPE');

		let key = `PM25_` + SENSOR_PORT.split('_').pop();
		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WePM25Sensor import *');

		Arduino.addSetupCode(`${key} = WePM25Sensor(${SENSOR_PORT})`);

		return [`${key}.${list[PM25_TYPE]}()`, ORDER_HIGH];
	})([
	'readPm1_0Concentration', 'readPm2_5Concentration', 'readPm10Concentration',
	'read0_3NumIn100ml', 'read0_5NumIn100ml', 'read1_0NumIn100ml', 'read2_5NumIn100ml',
	'read5_0NumIn100ml', 'read10NumIn100ml']);

	Arduino.weeemake_funny_touch = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const FUNNY_TOUCH_INDEX = block.getFieldValue('FUNNY_TOUCH_INDEX');

		let index = (1 << FUNNY_TOUCH_INDEX - 1).toString(16);
		let key = `funnyTouch_` + SENSOR_PORT.split('_')[1];

		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeFunnyTouch import *');

		Arduino.addSetupCode(`${key} = WeFunnyTouch(${SENSOR_PORT})`);

		return [`(${key}.getValue() & 0x${index}) > 0`, ORDER_RELATIONAL];
	}

	Arduino.weeemake_funny_touch_value = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		let key = `funnyTouch_` + SENSOR_PORT.split('_')[1];

		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeFunnyTouch import *');

		Arduino.addSetupCode(`${key} = WeFunnyTouch(${SENSOR_PORT})`);

		return [`${key}.getValue()`, ORDER_HIGH];
	}

	Arduino.weeemake_uv = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		let key = `uv_` + SENSOR_PORT.split('_').pop();

		this.addInclude('from WePort import *');
		this.addInclude('from WeUVSensor import *');

		this.addSetupCode(`${key} = WeUVSensor(${SENSOR_PORT})`);

		return [`${key}.getValue()`, ORDER_HIGH];
	}

	Arduino.weeemake_adapter_digitalWrite = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ADAPTER_INDEX = block.getFieldValue('ADAPTER_INDEX');
		const HIGH_LOW = block.getFieldValue('HIGH_LOW');

		let key = `adapter_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeAdapter import *');

		Arduino.addSetupCode(`${key} = WeAdapter(${SENSOR_PORT})`);

		return Arduino.tab() + `${key}.digital_write(${ADAPTER_INDEX}, ${HIGH_LOW})` + END;
	}

	Arduino.weeemake_adapter_servo = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ADAPTER_INDEX = block.getFieldValue('ADAPTER_INDEX');
		const ANGLE = Arduino.valueToCode(block, 'ANGLE', ORDER_NONE);

		let key = `adapter_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeAdapter import *');

		Arduino.addSetupCode(`${key} = WeAdapter(${SENSOR_PORT})`);

		return Arduino.tab() + `${key}.servo_write(${ADAPTER_INDEX}, ${ANGLE})` + END;
	}

	Arduino.weeemake_adapter_rgb = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ADAPTER_INDEX = block.getFieldValue('ADAPTER_INDEX');
		const PIXEL = Arduino.valueToCode(block, 'PIXEL', ORDER_NONE);
		const R = Arduino.valueToCode(block, 'R', ORDER_NONE);
		const G = Arduino.valueToCode(block, 'G', ORDER_NONE);
		const B = Arduino.valueToCode(block, 'B', ORDER_NONE);

		let key = `adapter_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeAdapter import *');

		Arduino.addSetupCode(`${key} = WeAdapter(${SENSOR_PORT})`);

		return Arduino.tab() + `${key}.rgbled_write(${ADAPTER_INDEX}, ${PIXEL}, ${R}, ${G}, ${B})` + END;
	}

	Arduino.weeemake_adapter_digitalRead = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ADAPTER_INDEX = block.getFieldValue('ADAPTER_INDEX');

		let key = `adapter_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeAdapter import *');

		Arduino.addSetupCode(`${key} = WeAdapter(${SENSOR_PORT})`);

		return [`${key}.digital_read(${ADAPTER_INDEX})`, ORDER_HIGH];
	}

	Arduino.weeemake_adapter_analogRead = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ADAPTER_INDEX = block.getFieldValue('ADAPTER_INDEX');

		let key = `adapter_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeAdapter import *');

		Arduino.addSetupCode(`${key} = WeAdapter(${SENSOR_PORT})`);

		return [`${key}.analog_read(${ADAPTER_INDEX})`, ORDER_HIGH];
	}

	Arduino.weeemake_adapter_temperature = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ADAPTER_INDEX = block.getFieldValue('ADAPTER_INDEX');

		let key = `adapter_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *');
		Arduino.addInclude('from WeAdapter import *');

		Arduino.addSetupCode(`${key} = WeAdapter(${SENSOR_PORT})`);

		return [`${key}.temperature_read(${ADAPTER_INDEX})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_uart = block => [block.getFieldValue('value'), ORDER_HIGH];
	Arduino.weeemake_k210_serial_init = function(block){
		const uart = this.valueToCode(block, 'uart', ORDER_NONE);
		const rx = block.getFieldValue('rx');
		const tx = block.getFieldValue('tx');
		const baudrate = block.getFieldValue('baudrate');

		Arduino.addInclude('from machine import UART')
		Arduino.addInclude('from fpioa_manager import fm')
		Arduino.addInclude('from Maix import GPIO')

		Arduino.addSetupCode(`fm.register(${tx == 6 ? 2 : K210_PIN_MAP[tx]}, fm.fpioa.UART${uart}_TX)`);
		Arduino.addSetupCode(`fm.register(${rx == 6 ? 2 : K210_PIN_MAP[rx]}, fm.fpioa.UART${uart}_RX)`);
		return Arduino.tab() + `uart${uart} = UART(UART.UART${uart}, ${baudrate}, 8, None, 1, timeout=1000, read_buf_len=4096)` + END;
	}
	Arduino.weeemake_k210_serial_print = function(block){
		const uart = this.valueToCode(block, 'uart', ORDER_NONE);
		const text = this.valueToCode(block, 'text', newline == '1' ? ORDER_ADDITIVE : ORDER_NONE);
		const newline = block.getFieldValue('newline');
		return Arduino.tab() + `uart${uart}.write(${text}${newline == '1' ? ` + '\\r\\n'` : ''})` + END;
	}
	Arduino.weeemake_k210_serial_any = function(block){
		const uart = this.valueToCode(block, 'uart', ORDER_NONE);
		return [`uart${uart}.any()`];
	}
	Arduino.weeemake_k210_serial_read = function(block){
		const uart = this.valueToCode(block, 'uart', ORDER_NONE);
		return [`uart${uart}.read()`];
	}
	Arduino.weeemake_k210_serial_readline = function(block){
		const uart = this.valueToCode(block, 'uart', ORDER_NONE);
		return [`uart${uart}.readline()`];
	}
	Arduino.weeemake_weeebotMini_board_ir = function(block){
		if(db.board !== board_k210){
			let IR_CODE = block.getFieldValue('IR_CODE');
			IR_CODE = IR_CODE_2_NAME[IR_CODE];

			Arduino.addInclude(`from WePort import *`);
			Arduino.addInclude(`from WeInfrareReceiver import *`);

			Arduino.addSetupCode('ir = WeInfrareReceiver(OnBoard_IR)');
			Arduino.addLoopCode('ir.loop()');

			return [`ir.isKeyPressed(ir.${IR_CODE})`, ORDER_HIGH];
		}
		//k210
		let IR_CODE = block.getFieldValue('IR_CODE');
		IR_CODE = IR_CODE_2_NAME[IR_CODE];

		Arduino.addInclude(`from fpioa_manager import fm`);
		Arduino.addInclude(`from Maix import GPIO`);
		Arduino.addInclude(`from WeInfrareReceiver import *`);

		const key = 'ir';

		Arduino.addSetupCode(`fm.register(2, fm.fpioa.GPIOHS2)`);
		Arduino.addSetupCode(`${key} = WeInfrareReceiver(GPIO(GPIO.GPIOHS2, GPIO.IN))`);
		Arduino.addLoopCode(`${key}.loop()`);

		return [`${key}.isKeyPressed(${key}.${IR_CODE})`, ORDER_HIGH];
	}

	Arduino.weeemake_weeebot_pin_ir = function(block){
		//k210
		const BOARD_PORT = block.getFieldValue('BOARD_PORT');
		let IR_CODE = block.getFieldValue('IR_CODE');
		IR_CODE = IR_CODE_2_NAME[IR_CODE];

		if(db.board == board_elf_esp32){
			let key = 'ir_' + BOARD_PORT.split('_').pop();
			Arduino.addInclude(`from irreceiver import InfrareReceiver`);
			Arduino.addSetupCode(`${key} = InfrareReceiver(${BOARD_PORT})`);
			Arduino.addLoopCode(`${key}.loop()`);

			return [`${key}.isKeyPressed(${key}.${IR_CODE})`, ORDER_HIGH];
		}

		if(db.board == board_elf_esp32_pro){
			let key = 'ir_' + BOARD_PORT.split('_').pop();
			Arduino.addInclude(`from WePort import *`);
			Arduino.addInclude(`from WeInfrareReceiver import *`);
			Arduino.addSetupCode(`${key} = WeInfrareReceiver(${BOARD_PORT})`);
			Arduino.addLoopCode(`${key}.loop()`);

			return [`${key}.isKeyPressed(${key}.${IR_CODE})`, ORDER_HIGH];
		}

		if(db.board == board_k210){
		Arduino.addInclude(`from fpioa_manager import fm`);
		Arduino.addInclude(`from Maix import GPIO`);
		Arduino.addInclude(`from WeInfrareReceiver import *`);

		const key = 'ir_' + BOARD_PORT;

		const pin = K210_PIN_MAP[BOARD_PORT];
		const rpin = pin == 32 ? 2 : pin;
		Arduino.addSetupCode(`fm.register(${pin}, fm.fpioa.GPIOHS${rpin})`);
		Arduino.addSetupCode(`${key} = WeInfrareReceiver(GPIO(GPIO.GPIOHS${rpin}, GPIO.IN))`);
		Arduino.addLoopCode(`${key}.loop()`);

		return [`${key}.isKeyPressed(${key}.${IR_CODE})`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_k210_visual_linefollower_new = function(block){
		//k210
		const color = this.valueToCode(block, 'color', ORDER_NONE);
		const rois = this.valueToCode(block, 'rois', ORDER_NONE);
		const area_threshold = this.valueToCode(block, 'area_threshold', ORDER_NONE);
		const pixels_threshold = this.valueToCode(block, 'pixels_threshold', ORDER_NONE);
		const merge = this.valueToCode(block, 'merge', ORDER_NONE);
		const margin = this.valueToCode(block, 'margin', ORDER_NONE);

		Arduino.addInclude(`from Visual_LineFollower import *`);

		return [`Visual_LineFollower(${color || 'None'}, ${rois || 'None'}, area_threshold=${area_threshold}, pixels_threshold=${pixels_threshold}, merge=${merge}, margin=${margin})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_visual_linefollower_get_angle = function(block){
		//k210
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		const img = this.valueToCode(block, 'img', ORDER_NONE);

		return [`${target || 'None'}.get_angle(${img || 'None'})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_object_detection_new = function(block){
		//k210
		const model_addr = this.valueToCode(block, 'model_addr', ORDER_NONE);
		const font_addr = this.valueToCode(block, 'font_addr', ORDER_NONE);

		Arduino.addInclude(`from ObjectDetection_20 import *`);

		return [`ObjectDetection_20(${model_addr}, ${font_addr})`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_object_detection_detect = function(block){
		//k210
		const target = this.valueToCode(block, 'target', ORDER_NONE);
		const img = this.valueToCode(block, 'img', ORDER_NONE);

		return [`${target || 'None'}.object_detection(${img || 'None'})`, ORDER_HIGH];
	}

	Arduino.print = function(block){
		let text = this.valueToCode(block, "value", ORDER_NONE);
		const newline = block.getFieldValue('newline');
		if(newline == 0){
			return Arduino.tab() + `print(${text}, end='')` + END;
		}
		return Arduino.tab() + `print(${text})` + END;
	}

	Arduino.weeemake_k210_image_colour = function(block){
		let colour = block.getFieldValue('colour');
		let r = parseInt(colour.slice(1, 3), 16);
		let g = parseInt(colour.slice(3, 5), 16);
		let b = parseInt(colour.slice(5, 7), 16);
		return [`(${r}, ${g}, ${b})`, this.ORDER_ATOMIC];
	}

	Arduino.weeemake_k210_board_rgb_strip = function rgb_strip(block){
		let key = 'rgb_led_board';
		let colour = this.valueToCode(block, "colour", ORDER_NONE);
		Arduino.addInclude('from modules import ws2812');
		Arduino.addSetupCode(`${key} = ws2812(1, 1, 1)`);
		
		let result = [
			`${key}.set_led(0, ${colour})`,
			`${key}.display()`
		];
		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.weeemake_ir_thermometer = (list => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const type = block.getFieldValue('type');
		let key = `ir_thermometer_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude(`from WePort import *`);
		Arduino.addInclude(`from WeIRThermometerSensor import *`);
		Arduino.addVarDef(`${key} = WeIRThermometerSensor(${SENSOR_PORT})`, key);

		return [`${key}.${list[type]}()`, ORDER_HIGH];
	})(['getBodyTemperature', 'getAmbientTemperature']);

	Arduino.weeemake_smart_ir_send = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ID = Arduino.valueToCode(block, 'ID', ORDER_NONE);

		let key = `smart_ir_` + SENSOR_PORT.split('_')[1];

		Arduino.addInclude(`from WePort import *`);
		Arduino.addInclude(`from WeSmartIRModule import *`);
		Arduino.addVarDef(`${key} = WeSmartIRModule(${SENSOR_PORT})`, key);

		return Arduino.tab() + `${key}.send(${ID})` + END;
	}

	Arduino.weeemake_smart_ir_recv = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ID = Arduino.valueToCode(block, 'ID', ORDER_NONE);

		let key = `smart_ir_` + SENSOR_PORT.split('_')[1];

		Arduino.addInclude(`from WePort import *`);
		Arduino.addInclude(`from WeSmartIRModule import *`);
		Arduino.addVarDef(`${key} = WeSmartIRModule(${SENSOR_PORT})`, key);

		return Arduino.tab() + `${key}.receiver(${ID})` + END;
	}

	Arduino.weeemake_python_start_thread = function(block){
		const name = block.getFieldValue('name');
		Arduino.addInclude(`import _thread`);
		Arduino.markNameUsed(name);
		return Arduino.tab() + `_thread.start_new_thread(${name}, ())` + END;
	}

	Arduino.constant = function(block){
		const name = block.getFieldValue('name');
		Arduino.addInclude(`import math`);
		if(name == '0'){
			return ['math.pi', ORDER_ATOMIC]
		}
		if(name == '1'){
			return ['math.e', ORDER_ATOMIC]
		}
		return ['0', ORDER_ATOMIC]
	}

	Arduino.weeemake_python_range = function(block){
		const from = Arduino.valueToCode(block, 'from', ORDER_NONE);
		const to = Arduino.valueToCode(block, 'to', ORDER_NONE);
		const step = Arduino.valueToCode(block, 'step', ORDER_NONE);
		return [`range(${from}, ${to}, ${step})`, ORDER_HIGH]
	}

	Arduino.math_decimal_number = function(block){
		let text = block.getFieldValue('NUM');
		return [Number(text), this.ORDER_ATOMIC];
	}

	Arduino.weeemake_uno_dc_motor = function(block){
		if(db.board === board_elf_esp32 || db.board == board_elf_esp32_pro){
			const DC_MOTOR_INDEX = block.getFieldValue('DC_MOTOR_INDEX');
			const SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);
			let key = 'dc_' + DC_MOTOR_INDEX;
			this.addInclude('from dcmotor import DCMotor');
			this.addSetupCode(`${key} = DCMotor(${DC_MOTOR_INDEX})`);
			return this.tab() + `${key}.run(${SPEED})` + this.END;
		}
	}

	Arduino.weeemake_uno_servo = function(block){
		if(db.board === board_elf_esp32 || db.board == board_elf_esp32_pro){
			const DPIN = block.getFieldValue('DPIN');
			const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
			const key = `servo_${DPIN}`;
			this.addInclude('from servo import Servo');
			this.addSetupCode(`${key} = Servo(${DPIN})`);
			return this.tab() + `${key}.write_angle(${VALUE})` + this.END;
		}
	}

	Arduino.weeemake_uno_digital_tube = function(block){
		if(db.board === board_elf_esp32 || db.board == board_elf_esp32_pro){
			const DIO_PIN = block.getFieldValue('DPIN');
			const CLK_PIN = block.getFieldValue('CLK_PIN');
			const VALUE = Arduino.valueToCode(block, 'VALUE', ORDER_NONE);

			const key = `digital_tube_${CLK_PIN}_${DIO_PIN}`;
			this.addInclude('from tm1650 import TM1650');
			this.addSetupCode(`${key} = TM1650(${CLK_PIN}, ${DIO_PIN})`);
			return this.tab() + `${key}.showNumber(${VALUE})` + this.END;
		}
	}

	Arduino.weeemake_uno_digital_tube_string = function(block){
		if(db.board === board_elf_esp32 || db.board == board_elf_esp32_pro){
			const DIO_PIN = block.getFieldValue('DPIN');
			const CLK_PIN = block.getFieldValue('CLK_PIN');
			const VALUE = Arduino.valueToCode(block, 'VALUE', ORDER_NONE);

			const key = `digital_tube_${CLK_PIN}_${DIO_PIN}`;
			this.addInclude('from tm1650 import TM1650');
			this.addSetupCode(`${key} = TM1650(${CLK_PIN}, ${DIO_PIN})`);
			return this.tab() + `${key}.showString(${VALUE})` + this.END;
		}
	}

	Arduino.weeemake_esp32_board_led = function(block){
		const value = this.valueToCode(block, 'value', ORDER_NONE);
		const DPIN = 2;
		const key = 'pin_' + DPIN;
		this.addInclude('from machine import Pin');
		this.addSetupCode(`${key} = Pin(${DPIN}, Pin.OUT)`, key);
		return this.tab() + `${key}.value(${value})` + END;
	}

	Arduino.weeemake_uno_buzzer = function(block){
		const DPIN = block.getFieldValue('DPIN');
		const NOTE = this.valueToCode(block, 'NOTE', ORDER_NONE);
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);

		if(db.board == board_elf_esp32_pro){
			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from WeBuzzer import *');
			let key = `buzzer_` + DPIN.split('_').pop();
			this.addVarDef(`${key} = WeBuzzer(${DPIN})`);
			return this.tab() + `${key}.tone(${NOTE}, ${VALUE})` + this.END;
		}

		const key = 'buzzer_' + DPIN;
		this.addInclude('from buzzer import BUZZER');
		this.addSetupCode(`${key} = BUZZER(${DPIN})`, key);

		return this.tab() + `${key}.tone(${NOTE}, ${VALUE})` + this.END;
	}

	Arduino.weeemake_uno_temperature_ds18b20 = function(block){
		const APIN = block.getFieldValue('APIN');
		this.addInclude('from ds18b20 import DS18B20');
		const key = `ds_${APIN}`;

		Arduino.addSetupCode(`${key} = DS18B20(${APIN})`);
		return [`${key}.get_temperature()`, this.ORDER_HIGH];
	}

	Arduino.weeemake_uno_dc_130_motor = function(block){
		const DPIN = block.getFieldValue('DPIN');
		const PWM_PIN = block.getFieldValue('PWM_PIN');
		const SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);

		this.addInclude('from dc130motor import DC130Motor');

		const key = `dc130_${DPIN}_${PWM_PIN}`;

		Arduino.addSetupCode(`${key} = DC130Motor(${DPIN}, ${PWM_PIN})`);
		return this.tab() + `${key}.run(${SPEED})` + this.END;
	}

	Arduino.weeemake_esp32_rgb_strip = function(block){
		const pin = block.getFieldValue('pin');
		const pixel = this.valueToCode(block, 'pixel', ORDER_NONE);
		const colour = this.valueToCode(block, 'colour', ORDER_NONE) || '(255, 255, 255)';
		const key = 'rgb_strip_' + pin;

		this.addInclude('from machine import Pin');
		this.addInclude('from neopixel import NeoPixel');
		this.addVarDef(`${key} = NeoPixel(Pin(${pin}, Pin.OUT), 32)`, key);
		let result = [];
		const index = Number(pixel);
		if(index > 0){
			result.push(`${key}[${index-1}] = ${colour}`);
		}else{
			add_helper_func_mpython();
			result.push(`set_rgb_pixel(${key}, ${pixel}, ${colour})`);
		}
		result.push(`${key}.write()`);
		
		return result.map(v => this.tab() + v + this.END).join('');
	}

	function not_support_yet(text){
		return Arduino.tab() + `#${text}` + END;
	}

	Arduino.weeemake_speech_recognition_set_mode = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SPEECH_RECOGNITION_MODE = block.getFieldValue('SPEECH_RECOGNITION_MODE');

		if(db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'speechRec_' + SENSOR_PORT.split('_').pop();
			this.addInclude('from WePort import *');
			this.addInclude('from WeSpeechRecognition import *');
			this.addSetupCode(`${key} = WeSpeechRecognition(${SENSOR_PORT})`);
			return this.tab() + `${key}.setTriggerMode(${SPEECH_RECOGNITION_MODE})` + END;
		}
		return not_support_yet(`setTriggerMode(${SPEECH_RECOGNITION_MODE})`);
	}

	Arduino.weeemake_speech_recognition_set_keyword = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const VALUE = castToStr(block, 'VALUE', v => pinyin(v).trim());

		if(db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'speechRec_' + SENSOR_PORT.split('_').pop();
			this.addInclude('from WePort import *');
			this.addInclude('from WeSpeechRecognition import *');
			this.addSetupCode(`${key} = WeSpeechRecognition(${SENSOR_PORT})`);
			return this.tab() + `${key}.setKeyword(${VALUE})` + END;
		}
		return not_support_yet(`setKeyword(${VALUE})`);
	}

	Arduino.weeemake_speech_recognition_set_password = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const INDEX = this.valueToCode(block, 'INDEX', ORDER_NONE);
		const VALUE = castToStr(block, 'VALUE', v => pinyin(v).trim());

		if(db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'speechRec_' + SENSOR_PORT.split('_').pop();
			this.addInclude('from WePort import *');
			this.addInclude('from WeSpeechRecognition import *');
			this.addSetupCode(`${key} = WeSpeechRecognition(${SENSOR_PORT})`);
			return this.tab() + `${key}.setPassword(${INDEX}, ${VALUE})` + END;
		}
		return not_support_yet(`setPassword(${INDEX}, ${VALUE})`);
	}

	Arduino.weeemake_speech_recognition_read = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		if(db.board == board_microbitV2 || db.board == board_elf_esp32_pro){
			const key = 'speechRec_' + SENSOR_PORT.split('_').pop();
			this.addInclude('from WePort import *');
			this.addInclude('from WeSpeechRecognition import *');
			this.addSetupCode(`${key} = WeSpeechRecognition(${SENSOR_PORT})`);
			return [`${key}.read()`, ORDER_HIGH];
		}

		if(db.board == board_elf_shield_microbit){
			this.addInclude('from elfshield import *');
			return [`speechRecognitionV2_read(${SENSOR_PORT})`, ORDER_HIGH];
		}

		return [`0`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_sock_listen = function(block){
		return [`sock.listen()`, ORDER_HIGH];
	}

	Arduino.weeemake_k210_sock_connected = function(block){
		return [`sock.connected()`, ORDER_HIGH];
	}

	Arduino.weeemake_servo_driver = function(block){

		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SERVO_DRIVER_INDEX = block.getFieldValue('SERVO_DRIVER_INDEX');
		const ANGLE = Arduino.valueToCode(block, 'ANGLE', ORDER_NONE);

		if(db.board == board_elf_esp32_pro){
			let key = `servoDriver_` + SENSOR_PORT.split('_').pop();
			this.addInclude(`from WePort import *`)
			Arduino.addInclude(`from WeServoMotorDrive import WeServoMotorDrive`);
			Arduino.addVarDef(`${key} = WeServoMotorDrive(${SENSOR_PORT})`, key);

			return Arduino.tab() + `${key}.servo_write(${SERVO_DRIVER_INDEX}, ${ANGLE})` + END;
		}
	}

	Arduino.weeemake_servo_driver_rgb = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SERVO_DRIVER_INDEX = block.getFieldValue('SERVO_DRIVER_INDEX');
		const pixel = Arduino.valueToCode(block, 'pixel', ORDER_NONE);
		const colour = Arduino.valueToCode(block, 'colour', ORDER_NONE);

		if(db.board == board_elf_esp32_pro){
			let key = `servoDriver_` + SENSOR_PORT.split('_').pop();
			this.addInclude(`from WePort import *`)
			Arduino.addInclude(`from WeServoMotorDrive import WeServoMotorDrive`);
			Arduino.addVarDef(`${key} = WeServoMotorDrive(${SENSOR_PORT})`, key);

			return Arduino.tab() + `${key}.rgbled_write(${SERVO_DRIVER_INDEX}, ${pixel}, ${colour.slice(1, -1)})` + END;
		}
	}

	Arduino.weeemake_36encoder_motor_set_origin = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const M12 = block.getFieldValue('M12');

		if(db.board == board_elf_esp32_pro){
			let key = `encoder36_${M12}_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from We36EncoderMotor import We36EncoderMotor`)
			Arduino.addVarDef(`${key} = We36EncoderMotor(${SENSOR_PORT}, ${M12})`, key);

			return Arduino.tab() + `${key}.setPositionOrigin()` + END;
		}

		
	}

	Arduino.weeemake_36encoder_motor_power = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);
		const M12 = block.getFieldValue('M12');

		if(db.board == board_elf_esp32_pro){
			let key = `encoder36_${M12}_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from We36EncoderMotor import We36EncoderMotor`)
			Arduino.addVarDef(`${key} = We36EncoderMotor(${SENSOR_PORT}, ${M12})`, key);

			return Arduino.tab() + `${key}.run(${SPEED})` + END;
		}
	}

	Arduino.weeemake_36encoder_motor_speed = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);

		const M12 = block.getFieldValue('M12');

		if(db.board == board_elf_esp32_pro){
			let key = `encoder36_${M12}_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from We36EncoderMotor import We36EncoderMotor`)
			Arduino.addVarDef(`${key} = We36EncoderMotor(${SENSOR_PORT}, ${M12})`, key);

			return Arduino.tab() + `${key}.runSpeed(${SPEED})` + END;
		}
	}
	//ready to remove
	Arduino.weeemake_36encoder_motor_move = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);

		const M12 = block.getFieldValue('M12');

		if(db.board == board_elf_esp32_pro){
			let key = `encoder36_${M12}_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from We36EncoderMotor import We36EncoderMotor`)
			Arduino.addVarDef(`${key} = We36EncoderMotor(${SENSOR_PORT}, ${M12})`, key);

			return Arduino.tab() + `${key}.move(150, ${SPEED})` + END;
		}
	}

	Arduino.weeemake_36encoder_motor_move_to = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SPEED = Arduino.valueToCode(block, 'SPEED', ORDER_NONE);

		const M12 = block.getFieldValue('M12');

		if(db.board == board_elf_esp32_pro){
			let key = `encoder36_${M12}_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from We36EncoderMotor import We36EncoderMotor`)
			Arduino.addVarDef(`${key} = We36EncoderMotor(${SENSOR_PORT}, ${M12})`, key);

			return Arduino.tab() + `${key}.moveTo(150, ${SPEED})` + END;
		}
	}
	//--------------------------------------

	Arduino.weeemake_36encoder_motor_move2 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const position = Arduino.valueToCode(block, 'position', ORDER_NONE);
		const speed = Arduino.valueToCode(block, 'speed', ORDER_NONE);

		const M12 = block.getFieldValue('M12');

		if(db.board == board_elf_esp32_pro){
			let key = `encoder36_${M12}_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from We36EncoderMotor import We36EncoderMotor`)
			Arduino.addVarDef(`${key} = We36EncoderMotor(${SENSOR_PORT}, ${M12})`, key);

			return Arduino.tab() + `${key}.move(${speed}, ${position})` + END;
		}
	}

	Arduino.weeemake_36encoder_motor_move_to2 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const position = Arduino.valueToCode(block, 'position', ORDER_NONE);
		const speed = Arduino.valueToCode(block, 'speed', ORDER_NONE);

		const M12 = block.getFieldValue('M12');

		if(db.board == board_elf_esp32_pro){
			let key = `encoder36_${M12}_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from We36EncoderMotor import We36EncoderMotor`)
			Arduino.addVarDef(`${key} = We36EncoderMotor(${SENSOR_PORT}, ${M12})`, key);

			return Arduino.tab() + `${key}.moveTo(${speed}, ${position})` + END;
		}
	}

	Arduino.weeemake_36encoder_motor_get_position = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const M12 = block.getFieldValue('M12');

		if(db.board == board_elf_esp32_pro){
			let key = `encoder36_${M12}_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from We36EncoderMotor import We36EncoderMotor`)
			Arduino.addVarDef(`${key} = We36EncoderMotor(${SENSOR_PORT}, ${M12})`, key);

			return [`${key}.getCurrentPosition()`, ORDER_HIGH];
		}
	}

	const bluetooth_controller_keys = [null,
		'WeJOYSTICK_LY',
		'WeJOYSTICK_LX',
		'WeJOYSTICK_RY',
		'WeJOYSTICK_RX',
		'WeBUTTON_ZR',
		'WeBUTTON_R',
		'WeBUTTON_ZL',
		'WeBUTTON_L',
		'WeBUTTON_HOME',
		'WeBUTTON_BL',
		'WeBUTTON_Y',
		'WeBUTTON_B',
		'WeBUTTON_A',
		'WeBUTTON_X',
		'WeBUTTON_PLUS',
		'WeBUTTON_MODE',
		'WeBUTTON_UP',
		'WeBUTTON_DOWN',
		'WeBUTTON_LEFT',
		'WeBUTTON_RIGHT',
		'WeBUTTON_MINUS',
		'WeBUTTON_BR'
	];

	function addBluetoothController(SENSOR_PORT){
		const key = `bluetooth_controller_` + SENSOR_PORT.split('_').pop();
		
		Arduino.addInclude(`from WePort import *`)
		Arduino.addInclude(`from WeBluetoothController import WeBluetoothController`)
		Arduino.addVarDef(`${key} = WeBluetoothController(${SENSOR_PORT})`, key);
		Arduino.addLoopCode(`${key}.loop()`, key);

		return key;
	}

	Arduino.weeemake_bluetooth_controller_button_ext = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const BLUETOOTH_CONTROLLER_KEY = block.getFieldValue('BLUETOOTH_CONTROLLER_KEY');

		let key = addBluetoothController(SENSOR_PORT);

		return [`${key}.buttonPressed(${key}.${bluetooth_controller_keys[BLUETOOTH_CONTROLLER_KEY]})`, ORDER_HIGH];
	}

	Arduino.weeemake_bluetooth_controller_joystick_ext = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const LEFT_RIGHT = block.getFieldValue('LEFT_RIGHT');
		const AXIS2 = block.getFieldValue('AXIS2');

		let key = addBluetoothController(SENSOR_PORT);

		let a = LEFT_RIGHT == '0' ? 0 : 2;
		let b = AXIS2 == '0' ? 2 : 1;

		return [`${key}.readAnalog(${key}.${bluetooth_controller_keys[a+b]})`, ORDER_HIGH];
	};

	Arduino.weeemake_image_recognition_set_mode = (nameList => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const IMAGE_RECOGNITION_MODE = block.getFieldValue('IMAGE_RECOGNITION_MODE');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return Arduino.tab() + `${IMAGE_RECOGNITION_MODE != 1 ? '#' : ''}${key}.${nameList[IMAGE_RECOGNITION_MODE]}()` + END;
		//}
	})(['setAutoTrackingMode', 'setLineFollowerMode', 'setCardSignsMode']);

	Arduino.weeemake_image_recognition_color_position = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const IMAGE_RECOGNITION_TYPE = block.getFieldValue('IMAGE_RECOGNITION_TYPE');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return [`${key}.getColorPosition(${IMAGE_RECOGNITION_TYPE})`, ORDER_HIGH];
		//}
	}

	Arduino.weeemake_image_recognition_app_color_position = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const IMAGE_RECOGNITION_COLOR_INDEX = block.getFieldValue('IMAGE_RECOGNITION_COLOR_INDEX');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return [`${key}.getAppColorPosition(${IMAGE_RECOGNITION_COLOR_INDEX})`, ORDER_HIGH];
		//}
	}

	Arduino.weeemake_image_recognition_update = (list => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const IMAGE_RECOGNITION_MODE = block.getFieldValue('IMAGE_RECOGNITION_MODE');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			if(IMAGE_RECOGNITION_MODE == 0){
				return [`0`, ORDER_HIGH];
			}

			return [`${key}.${list[IMAGE_RECOGNITION_MODE]}()`, ORDER_HIGH];
		//}
	})(['getAutoPosition', 'getLineFollowerAngle'])

	Arduino.weeemake_image_recognition_set_color = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const IMAGE_RECOGNITION_COLOR_INDEX = block.getFieldValue('IMAGE_RECOGNITION_COLOR_INDEX');
		const minL = this.valueToCode(block, 'minL', ORDER_NONE);
		const maxL = this.valueToCode(block, 'maxL', ORDER_NONE);
		const minA = this.valueToCode(block, 'minA', ORDER_NONE);
		const maxA = this.valueToCode(block, 'maxA', ORDER_NONE);
		const minB = this.valueToCode(block, 'minB', ORDER_NONE);
		const maxB = this.valueToCode(block, 'maxB', ORDER_NONE);

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return Arduino.tab() + `${key}.setLabColor(${IMAGE_RECOGNITION_COLOR_INDEX}, ${minL}, ${maxL}, ${minA}, ${maxA}, ${minB}, ${maxB})` + END;
		//}
	}

	Arduino.weeemake_image_recognition_set_threshold = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return Arduino.tab() + `${key}.setPixelsThreshold(${VALUE})` + END;
		//}
	}

	Arduino.weeemake_image_recognition_value = (nameList => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const IMAGE_RECOGNITION_VALUE = block.getFieldValue('IMAGE_RECOGNITION_VALUE');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return [`${key}.${nameList[IMAGE_RECOGNITION_VALUE]}`, ORDER_HIGH];
		//}
	})(['centerX', 'centerY', 'pixels']);

	Arduino.weeemake_image_recognition_line_follow_angle = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return [`${key}.angle`, ORDER_HIGH];
		//}
	}

	Arduino.weeemake_image_recognition_set_fast_mode = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ON_OFF = block.getFieldValue('ON_OFF');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return Arduino.tab() + `#${key}.fastMode(${ON_OFF})` + END;
		//}
	}

	Arduino.weeemake_image_recognition_face_position = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return ['False', ORDER_ATOMIC]
		//}
	}
	Arduino.weeemake_image_recognition_get_traffic_signs_value2 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return ['0', ORDER_ATOMIC]
		//}
	}
	Arduino.weeemake_image_recognition_traffic_signs_const = function(block){
		const TRAFFIC_SIGN = block.getFieldValue('TRAFFIC_SIGN');
		return [TRAFFIC_SIGN, ORDER_ATOMIC];
	}

	Arduino.weeemake_image_recognition_set_led2 = 
	Arduino.weeemake_image_recognition_set_led = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const value = this.valueToCode(block, 'value', ORDER_NONE);
		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return Arduino.tab() + `${key}.setLedBrightness(${value})` + END;
		//}
	}

	Arduino.weeemake_image_recognition_get_code = (list => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const type = block.getFieldValue('type');

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return [`${key}.${list[type]}()`, ORDER_HIGH];
		//}
	})(['getQrcods','getAprilTag','get20Classes','getTrafficClasses']);

	Arduino.weeemake_image_recognition_getAprilTag = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const index = this.valueToCode(block, 'index', ORDER_NONE);

		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return [`${key}.getAprilTagAt(${index})`, ORDER_HIGH];
		//}
	}

	Arduino.weeemake_image_recognition_get_code_result = (list => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const type = block.getFieldValue('type');
		//if(db.board == board_elf_esp32_pro){
			let key = `imageRec_` + SENSOR_PORT.split('_').pop();

			this.addInclude(`from WePort import *`)
			this.addInclude(`from WeImageRecognition import WeImageRecognition`)
			this.addVarDef(`${key} = WeImageRecognition(${SENSOR_PORT})`, key);

			return [`${key}.${list[type]}`, ORDER_HIGH];
		//}
	})(['num','qrcode','angle', 'x_degress', 'y_degress', 'z_degress'])

	Arduino.weeemake_multi_line_follower_update = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const READ_MODE = block.getFieldValue('READ_MODE');

		if(db.board == board_elf_esp32_pro){
			let key = `linefollower_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude(`from WePort import *`);
			Arduino.addInclude(`from WeMultipleLineFollower import WeMultipleLineFollower`);
			Arduino.addVarDef(`${key} = WeMultipleLineFollower(${SENSOR_PORT})`, key);

			return this.tab() + `${key}.updateData(${READ_MODE})` + END;
		}
	};

	Arduino.weeemake_multi_line_follower_led = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const ON_OFF = block.getFieldValue('ON_OFF');

		if(db.board == board_elf_esp32_pro){
			let key = `linefollower_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude(`from WePort import *`);
			Arduino.addInclude(`from WeMultipleLineFollower import WeMultipleLineFollower`);
			Arduino.addVarDef(`${key} = WeMultipleLineFollower(${SENSOR_PORT})`, key);

			return this.tab() + `${key}.setLED(${ON_OFF})` + END;
		}
	}

	Arduino.weeemake_multi_line_follower_read = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const LINE_FOLLOWER_INDEX = block.getFieldValue('LINE_FOLLOWER_INDEX');

		if(db.board == board_elf_esp32_pro){
			let key = `linefollower_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude(`from WePort import *`);
			Arduino.addInclude(`from WeMultipleLineFollower import WeMultipleLineFollower`);
			Arduino.addVarDef(`${key} = WeMultipleLineFollower(${SENSOR_PORT})`, key);

			return [`${key}.S${LINE_FOLLOWER_INDEX}`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_multi_line_follower_read2 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const READ_MODE = block.getFieldValue('READ_MODE');
		const LINE_FOLLOWER_INDEX = block.getFieldValue('LINE_FOLLOWER_INDEX');

		if(db.board == board_elf_esp32_pro){
			let key = `linefollower_` + SENSOR_PORT.split('_').pop();
			Arduino.addInclude(`from WePort import *`);
			Arduino.addInclude(`from WeMultipleLineFollower import WeMultipleLineFollower`);
			Arduino.addVarDef(`${key} = WeMultipleLineFollower(${SENSOR_PORT})`, key);

			return [`(${key}.updateData(${READ_MODE}), ${key}.S${LINE_FOLLOWER_INDEX})[1]`, ORDER_HIGH];
		}
	}

	const gesture_recognition_read = fieldKey => function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const GESTURE_RECOGNITION_TYPE = block.getFieldValue(fieldKey);

		if(db.board == board_elf_esp32_pro){
			Arduino.addInclude(`from WePort import *`);
			Arduino.addInclude(`from WeGestureSensor import *`);
			let key = `gestureSensor_` + SENSOR_PORT.split('_').pop();
			let valueKey = key + '_value';

			Arduino.addVarDef(`${key} = WeGestureSensor(${SENSOR_PORT})`, key);
			Arduino.addLoopCode(`${valueKey} = ${key}.getValue()`);

			return [`${valueKey} == ${GESTURE_RECOGNITION_TYPE}`, ORDER_RELATIONAL];
		}
	}

	Arduino.weeemake_gesture_recognition_read = gesture_recognition_read('GESTURE_RECOGNITION_TYPE');
	Arduino.weeemake_gesture_recognition_read_v2 = gesture_recognition_read('GESTURE_RECOGNITION_TYPE_V2');

	Arduino.weeemake_led_matrix_number = function(block){
		const LED_MATRIX_TYPE = block.getFieldValue('LED_MATRIX_TYPE').replace('x', '_');
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const NUM = Arduino.valueToCode(block, 'NUM', ORDER_NONE);

		let key = `led_matrix_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *')
		Arduino.addInclude('from WeLEDPanelMatrix import *')

		Arduino.addVarDef(`${key} = WeLEDPanelMatrix(${SENSOR_PORT})`, key);

		return Arduino.tab() + `${key}.showNumber(${NUM})` + END;
	}

	Arduino.weeemake_led_matrix_time = function(block){
		const LED_MATRIX_TYPE = block.getFieldValue('LED_MATRIX_TYPE').replace('x', '_');
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const HOUR = Arduino.valueToCode(block, 'HOUR', ORDER_NONE);
		const SHOW_COLON = block.getFieldValue('SHOW_COLON');
		const MINUTE = Arduino.valueToCode(block, 'MINUTE', ORDER_NONE);

		let key = `led_matrix_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *')
		Arduino.addInclude('from WeLEDPanelMatrix import *')

		Arduino.addVarDef(`${key} = WeLEDPanelMatrix(${SENSOR_PORT})`, key);

		return Arduino.tab() + `#${key}.showClock()` + END;
	}

	Arduino.weeemake_led_matrix_string = function(block){
		const LED_MATRIX_TYPE = block.getFieldValue('LED_MATRIX_TYPE').replace('x', '_');
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const X = Arduino.valueToCode(block, 'X', ORDER_NONE);
		const Y = Arduino.valueToCode(block, 'Y', ORDER_NONE);
		const STR = Arduino.valueToCode(block, 'STR', ORDER_NONE);

		let key = `led_matrix_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *')
		Arduino.addInclude('from WeLEDPanelMatrix import *')

		Arduino.addVarDef(`${key} = WeLEDPanelMatrix(${SENSOR_PORT})`, key);

		return Arduino.tab() + `${key}.showString(${X}, ${Y}, ${STR})` + END;
	}

	Arduino.weeemake_led_matrix_bitmap_21x7 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const X = Arduino.valueToCode(block, 'X', ORDER_NONE);
		const Y = Arduino.valueToCode(block, 'Y', ORDER_NONE);
		const MATRIX = Arduino.valueToCode(block, 'MATRIX', ORDER_NONE);

		let key = `led_matrix_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *')
		Arduino.addInclude('from WeLEDPanelMatrix import *')

		Arduino.addVarDef(`${key} = WeLEDPanelMatrix(${SENSOR_PORT})`, key);
		
		return Arduino.tab() + `${key}.showBitmap(${X}, ${Y}, (${castMatrixCPP(MATRIX, 21, 7)}))` + END;
	}

	Arduino.weeemake_led_matrix_bitmap_14x5 = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const X = Arduino.valueToCode(block, 'X', ORDER_NONE);
		const Y = Arduino.valueToCode(block, 'Y', ORDER_NONE);
		const MATRIX = Arduino.valueToCode(block, 'MATRIX', ORDER_NONE);

		let key = `led_matrix_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *')
		Arduino.addInclude('from WeLEDPanelMatrix import *')

		Arduino.addVarDef(`${key} = WeLEDPanelMatrix(${SENSOR_PORT})`, key);

		return Arduino.tab() + `#${key}.showBitmap()` + END;
	}

	Arduino.weeemake_led_matrix_pixel = (list => function(block){
		const LED_MATRIX_TYPE = block.getFieldValue('LED_MATRIX_TYPE').replace('x', '_');
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const SHOW_HIDE = block.getFieldValue('SHOW_HIDE');
		const X = Arduino.valueToCode(block, 'X', ORDER_NONE);
		const Y = Arduino.valueToCode(block, 'Y', ORDER_NONE);

		let key = `led_matrix_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *')
		Arduino.addInclude('from WeLEDPanelMatrix import *')

		Arduino.addVarDef(`${key} = WeLEDPanelMatrix(${SENSOR_PORT})`, key);

		return Arduino.tab() + `${key}.${list[SHOW_HIDE]}(${X}, ${Y})` + END;
	})(['turnOffDot', 'turnOnDot']);

	Arduino.weeemake_led_matrix_clear = function(block){
		const LED_MATRIX_TYPE = block.getFieldValue('LED_MATRIX_TYPE').replace('x', '_');
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');

		let key = `led_matrix_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude('from WePort import *')
		Arduino.addInclude('from WeLEDPanelMatrix import *')

		Arduino.addVarDef(`${key} = WeLEDPanelMatrix(${SENSOR_PORT})`, key);

		return Arduino.tab() + `${key}.clearScreen()` + END;
	}

	function weeebot_board_rgb(R,G,B){
		let result = [];
		if(db.board == board_elf_esp32 || db.board == board_elf_esp32_pro){

			Arduino.addInclude('from WePort import *');
			Arduino.addInclude('from machine import Pin');
			Arduino.addInclude('from neopixel import NeoPixel');

			let key = `rgb_led_board`;
			let rgb = `(${R}, ${G}, ${B})`;

			Arduino.addVarDef(`${key} = NeoPixel(Pin(OnBoard_RGB, Pin.OUT), 1)`, key);

			result.push(`${key}[0] = ${rgb}`);
			result.push(`${key}.write()`);
		}

		return result.map(v => Arduino.tab() + v + END).join('');
	}

	Arduino.weeemake_weeebot_board_rgb = function(block){
		const COLOR = Arduino.valueToCode(block, 'COLOR', ORDER_NONE);
		let {R,G,B} = hexToRgb(COLOR);
		return weeebot_board_rgb(R,G,B);
	}

	Arduino.weeemake_weeebot_board_rgb3 = function(block){
		const R = Arduino.valueToCode(block, 'R', ORDER_NONE);
		const G = Arduino.valueToCode(block, 'G', ORDER_NONE);
		const B = Arduino.valueToCode(block, 'B', ORDER_NONE);

		return weeebot_board_rgb(R,G,B);
	}

	Arduino.weeemake_magnet_driver = function(block){
		const SENSOR_PORT = block.getFieldValue('SENSOR_PORT');
		const index = Arduino.valueToCode(block, 'index', ORDER_NONE)
		const value = Arduino.valueToCode(block, 'value', ORDER_NONE)
		
		let key = `magnetDriver_` + SENSOR_PORT.split('_').pop();

		Arduino.addInclude(`from WePort import *`);
		Arduino.addInclude(`from WeElectromagnetDriver import *`);
		Arduino.addVarDef(`${key} = WeElectromagnetDriver(${SENSOR_PORT})`, key);

		return Arduino.tab() + `${key}.setStatus(${index}, ${value})` + END;
	}

	Arduino.weeemake_ai_handle_joystick = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const index = block.getFieldValue('index');
			this.addInclude(`from AIHandle import *`);
			return [`joyStick.is_pressed('${index}')`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_ai_handle_speech = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			return [`speech.read()`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_ai_handle_speech_cmd = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			return [block.getFieldValue('value'), ORDER_HIGH];
		}
	}

	Arduino.weeemake_ai_handle_rgb = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const index = block.getFieldValue('index');
			const colour = this.valueToCode(block, 'colour', ORDER_NONE)
			this.addInclude(`from AIHandle import *`);
			return Arduino.tab() + `rgb.write(${index}, ${colour || '(0, 0, 0)'})` + END;
		}
	}

	Arduino.weeemake_ai_handle_get_mac = function(block){
		/*
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from radio import *`);
			return [`getMAC()`, ORDER_HIGH];
		}*/
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core || db.board == board_python_2in1){
			this.addInclude('import machine')
			this.addInclude('import ubinascii')
			return [`ubinascii.hexlify(machine.unique_id()).decode().upper()`, ORDER_HIGH]
		}
		return [`""`, ORDER_HIGH];
	}
/*
	Arduino.weeemake_ai_handle_radio_recv = function(block){
		if(db.board == board_elf_ai_handle){
			this.addInclude(`import radio`);
			return [`radio.receive()`, ORDER_HIGH];
		}
	}

	Arduino.weeemake_ai_handle_radio_send = function(block){
		if(db.board == board_elf_ai_handle){
			this.addInclude(`import radio`);
			const data = this.valueToCode(block, 'data', ORDER_NONE)
			const peer = this.valueToCode(block, 'peer', ORDER_NONE)
			return Arduino.tab() + `radio.send(${peer}, ${data})` + END;
		}
	}
*/
	Arduino.weeemake_ai_handle_lcd_offset = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const x = this.valueToCode(block, 'x', ORDER_NONE);
			const y = this.valueToCode(block, 'y', ORDER_NONE);
			return Arduino.tab() + `display.offset(${x}, ${y})` + END;
		}
	}

	Arduino.weeemake_ai_handle_lcd_jpg = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const path = this.valueToCode(block, 'path', ORDER_NONE);
			const x = this.valueToCode(block, 'x', ORDER_NONE);
			const y = this.valueToCode(block, 'y', ORDER_NONE);
			const method = block.getFieldValue('method');
			return Arduino.tab() + `display.jpg(${path}, ${x}, ${y}, lcd.${method})` + END;
		}
	}

	Arduino.weeemake_ai_handle_lcd_png = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const path = this.valueToCode(block, 'path', ORDER_NONE);
			const x = this.valueToCode(block, 'x', ORDER_NONE);
			const y = this.valueToCode(block, 'y', ORDER_NONE);
			const mask = this.valueToCode(block, 'mask', ORDER_NONE);
			return Arduino.tab() + `display.png(${path}, ${x}, ${y}, ${mask})` + END;
		}
	}

	Arduino.weeemake_ai_handle_lcd_pixel = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const x = this.valueToCode(block, 'x', ORDER_NONE);
			const y = this.valueToCode(block, 'y', ORDER_NONE);
			const color = castAIHandleColor565(this.valueToCode(block, 'color', ORDER_NONE));
			return Arduino.tab() + `display.pixel(${x}, ${y}, ${color})` + END;
		}
	}
	Arduino.weeemake_ai_handle_lcd_line = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const x0 = this.valueToCode(block, 'x0', ORDER_NONE);
			const y0 = this.valueToCode(block, 'y0', ORDER_NONE);
			const x1 = this.valueToCode(block, 'x1', ORDER_NONE);
			const y1 = this.valueToCode(block, 'y1', ORDER_NONE);
			const color = castAIHandleColor565(this.valueToCode(block, 'color', ORDER_NONE));
			return Arduino.tab() + `display.line(${x0}, ${y0}, ${x1}, ${y1}, ${color})` + END;
		}
	}

	Arduino.weeemake_ai_handle_lcd_line2 = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const type = block.getFieldValue('type');
			const x = this.valueToCode(block, 'x', ORDER_NONE);
			const y = this.valueToCode(block, 'y', ORDER_NONE);
			const length = this.valueToCode(block, 'length', ORDER_NONE);
			const color = castAIHandleColor565(this.valueToCode(block, 'color', ORDER_NONE));
			return Arduino.tab() + `display.${type}line(${x}, ${y}, ${length}, ${color})` + END;
		}
	}

	Arduino.weeemake_ai_handle_lcd_rect = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const type = block.getFieldValue('type');
			const x = this.valueToCode(block, 'x', ORDER_NONE);
			const y = this.valueToCode(block, 'y', ORDER_NONE);
			const width = this.valueToCode(block, 'width', ORDER_NONE);
			const height = this.valueToCode(block, 'height', ORDER_NONE);
			const color = castAIHandleColor565(this.valueToCode(block, 'color', ORDER_NONE));
			return Arduino.tab() + `display.${type==1?'fill_':''}rect(${x}, ${y}, ${width}, ${height}, ${color})` + END;
		}
	}

	Arduino.weeemake_ai_handle_lcd_circle = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from AIHandle import *`);
			const type = block.getFieldValue('type');
			const x = this.valueToCode(block, 'x', ORDER_NONE);
			const y = this.valueToCode(block, 'y', ORDER_NONE);
			const r = this.valueToCode(block, 'r', ORDER_NONE);
			const color = castAIHandleColor565(this.valueToCode(block, 'color', ORDER_NONE));
			return Arduino.tab() + `display.${type==1?'fill_':''}circle(${x}, ${y}, ${r}, ${color})` + END;
		}
	}
	Arduino.weeemake_ai_handle_lcd_text = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const font = block.getFieldValue('font');
			this.addInclude(`from AIHandle import *`);
			this.addInclude(`import fonts.bitmap.vga1_bold_${font}`);
			const text = this.valueToCode(block, 'text', ORDER_NONE);
			const x = this.valueToCode(block, 'x', ORDER_NONE);
			const y = this.valueToCode(block, 'y', ORDER_NONE);
			const fg = castAIHandleColor565(this.valueToCode(block, 'fg', ORDER_NONE) || 'lcd.WHITE');
			const bg = castAIHandleColor565(this.valueToCode(block, 'bg', ORDER_NONE));
			return Arduino.tab() + `display.text(fonts.bitmap.vga1_bold_${font}, ${text}, ${x}, ${y}, ${fg}, ${bg})` + END;
		}
	}
	Arduino.weeemake_ai_handle_net_request = function(block){
		if(db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const method = block.getFieldValue('method');
			const url = this.valueToCode(block, 'url', ORDER_NONE);
			this.addInclude(`from urequests import request`);
			return [`request("${method}", ${url}).text`, ORDER_HIGH]
		}
	}

	Arduino.weeemake_wifi_set_time = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const zone = block.getFieldValue('zone');
			const server = block.getFieldValue('server');
			this.addInclude(`import ntptime`);
			return this.tab() + `ntptime.settime(${zone}, "${server}")` + END
		}
	}

	Arduino.weeemake_mpython_get_time = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude(`from machine import RTC`);
			return [`RTC().datetime()`, ORDER_HIGH]
		}
	}

	Arduino.weeemake_ai_handle_radio_set_channel = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const channel = this.valueToCode(block, 'channel', ORDER_NONE);
			this.addInclude('import radio');
			this.addSetupCode('radio.on()');
			return this.tab() + `radio.config(channel=${channel})` + END;
		}
	}

	Arduino.weeemake_ai_handle_radio_recv_msg = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			return [`_recv_msg`, ORDER_HIGH]
		}
	}

	Arduino.weeemake_ai_handle_radio_when_recv = function(block, subCode){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('from machine import Timer')
			this.addInclude('import radio')
			this.addSetupCode(`Timer(13).init(period=20, mode=Timer.PERIODIC, callback=on_radio_recv)`);
			this.markNameUsed('on_radio_recv');
			this.addFuncDef('on_radio_recv', ['_'], [
				`_recv_msg = radio.receive()`,
				`if not _recv_msg: return\n`+tabText(subCode)
			])
		}
	}

	Arduino.weeemake_blynk_config = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const server = this.valueToCode(block, 'server', ORDER_NONE);
			const port = this.valueToCode(block, 'port', ORDER_NONE);
			const token = this.valueToCode(block, 'token', ORDER_NONE);
			this.addInclude('import blynklib')
			return this.tab() + `blynk = blynklib.Blynk(${token}, server=${server}, port=${port})` + END;
		}
	}

	Arduino.weeemake_blynk_on_connect = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			let tab = this.tab();
			let subCode = this.statementToCodeIndent(block, 'do');
			return `${tab}@blynk.handle_event("connected")\n${tab}def connect_handler():\n${subCode || tab+'\tpass'}` + END;
		}
	}

	Arduino.weeemake_blynk_on_disconnect = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			let tab = this.tab();
			let subCode = this.statementToCodeIndent(block, 'do');
			return `${tab}@blynk.handle_event("disconnected")\n${tab}def disconnect_handler():\n${subCode || tab+'\tpass'}` + END;
		}
	}

	Arduino.weeemake_blynk_on_pin = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const pin = block.getFieldValue('pin');
			let tab = this.tab();
			let subCode = this.statementToCodeIndent(block, 'do');
			return `${tab}@blynk.handle_event("V${pin}")\n${tab}def write_virtual_pin_handler(_value):
${tab}\tfor i in range(0, len(_value)):
${tab}\t\ttry: _value[i] = eval(_value[i])
${tab}\t\texcept: pass
${tab}\tif len(_value) == 1: _value = _value[0]
${subCode}` + END;
		}
	}

	Arduino.weeemake_blynk_recv_data = function(block){
		return ['_value', ORDER_HIGH]
	}

	Arduino.weeemake_blynk_timer = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const index = block.getFieldValue('index');
			const run_once = block.getFieldValue('run_once');
			const interval = this.valueToCode(block, 'interval', ORDER_NONE);
			this.addInclude('import blynktimer');
			this.addSetupCode(`blynk_timer = blynktimer.Timer(no_timers_err=False)`)
			let tab = this.tab();
			let subCode = this.statementToCodeIndent(block, 'do');
			return `${tab}@blynk_timer.register(interval=${interval}, run_once=${run_once == '1' ? 'True' : 'False'})\n${tab}def blynk_timer${index}():\n${subCode || tab+'\tpass'}` + END;
		}
	}

	Arduino.weeemake_blynk_timer_left = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('import blynktimer');
			this.addSetupCode(`blynk_timer = blynktimer.Timer(no_timers_err=False)`)
			return [`blynk_timer.get_timers()`, ORDER_HIGH]
		}
	}

	Arduino.weeemake_blynk_timer_stop = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			this.addInclude('import blynktimer');
			this.addSetupCode(`blynk_timer = blynktimer.Timer(no_timers_err=False)`)
			const index = block.getFieldValue('index');
			return this.tab() + `blynk_timer.stop('${index}_blynk_timer${index}')` + END;
		}
	}
	Arduino.weeemake_blynk_run = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			return this.tab() + `blynk.run()` + END;
		}
	}
	Arduino.weeemake_blynk_timer_run = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			return this.tab() + `blynk_timer.run()` + END;
		}
	}
	Arduino.weeemake_blynk_send = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const pin = block.getFieldValue('pin');
			const value = this.valueToCode(block, 'value', ORDER_NONE);
			return this.tab() + `blynk.virtual_write(${pin}, ${value})` + END;
		}
	}
	Arduino.weeemake_blynk_sync_pin_state = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const pin = block.getFieldValue('pin');
			return this.tab() + `blynk.virtual_sync(${pin})` + END;
		}
	}
	/*
	Arduino.weeemake_blynk_send_mail = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle){
			const title = this.valueToCode(block, 'title', ORDER_NONE);
			const body = this.valueToCode(block, 'body', ORDER_NONE);
			return this.tab() + `blynk.email("", ${title}, ${body})` + END;
		}
	}
	Arduino.weeemake_blynk_show_notice = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle){
			const data = this.valueToCode(block, 'data', ORDER_NONE);
			return this.tab() + `blynk.notify(${data})` + END;
		}
	}
	*/
	Arduino.weeemake_blynk_add_pin_data = function(block){
		if(db.board == board_python_2in1 || db.board == board_elf_ai_handle || db.board == board_elf_weee_core){
			const key = this.valueToCode(block, 'key', ORDER_NONE);
			const value = this.valueToCode(block, 'value', ORDER_NONE);
			return this.tab() + `blynk.set_property(pin, ${key}, ${value})` + END;
		}
	}

	Arduino.weeemake_mpython_gyro = (list => function(block){
		const AXIS3 = block.getFieldValue('AXIS3');
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return [`gyroscope.get_${list[AXIS3]}()`, ORDER_HIGH];
	})(['x', 'y', 'z']);

	Arduino.weeemake_mpython_get_gyro_angle = function(block){
		const key = block.getFieldValue('key');
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		return [`accelerometer.roll_pitch_angle()[${key}]`, ORDER_HIGH];
	}

	Arduino.weeemake_mpython_get_gyro_tilt = function(block){
		const key = block.getFieldValue('key');
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		if(key == 0)return [`accelerometer.get_x() < -0.3`, ORDER_HIGH];
		if(key == 1)return [`accelerometer.get_x() > 0.3`, ORDER_HIGH];
		if(key == 2)return [`accelerometer.get_y() > 0.3`, ORDER_HIGH];
		if(key == 3)return [`accelerometer.get_y() < -0.3`, ORDER_HIGH];
	}

	Arduino.weeemake_mpython_gyro_tilt_angle = (list => function(block){
		const AXIS3 = block.getFieldValue('AXIS3');
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		this.addInclude('import math');
		this.markNameUsed('get_tilt_angle');
		this.addFuncDef('get_tilt_angle', ['_axis'], [`_Ax = accelerometer.get_x()
	_Ay = accelerometer.get_y()
	_Az = accelerometer.get_z()
	if 'x' == _axis:
		_T = math.sqrt(_Ay ** 2 + _Az ** 2)
		if _Az < 0: return math.degrees(math.atan2(_Ax , _T))
		else: return 180 - math.degrees(math.atan2(_Ax , _T))
	elif 'y' == _axis:
		_T = math.sqrt(_Ax ** 2 + _Az ** 2)
		if _Az < 0: return math.degrees(math.atan2(_Ay , _T))
		else: return 180 - math.degrees(math.atan2(_Ay , _T))
	elif 'z' == _axis:
		_T = math.sqrt(_Ax ** 2 + _Ay ** 2)
		if (_Ax + _Ay) < 0: return 180 - math.degrees(math.atan2(_T , _Az))
		else: return math.degrees(math.atan2(_T , _Az)) - 180
	return 0`]);
		return [`get_tilt_angle('${list[AXIS3]}')`, ORDER_HIGH];
	})(['x', 'y', 'z']);

	function init_gyro_state(){
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		this.addInclude('from machine import Timer')
		this.addVarDef(`_is_shaked = _is_thrown = False`);
		this.addVarDef(`_last_x = _last_y = _last_z = _count_shaked = _count_thrown = 0`);
		this.addVarDef(`def on_shaked():pass`);
		this.addVarDef(`def on_thrown():pass`);
		this.addVarDef(`def timer11_tick(_):
	global _is_shaked, _is_thrown, _last_x, _last_y, _last_z, _count_shaked, _count_thrown
	if _is_shaked:
		_count_shaked += 1
		if _count_shaked == 5: _count_shaked = 0
	if _is_thrown:
		_count_thrown += 1
		if _count_thrown == 10: _count_thrown = 0
	if _count_thrown > 0: return
	x=accelerometer.get_x(); y=accelerometer.get_y(); z=accelerometer.get_z()
	_is_thrown = (x * x + y * y + z * z < 0.25)
	if _is_thrown: on_thrown();return
	if _last_x == 0 and _last_y == 0 and _last_z == 0:
		_last_x = x; _last_y = y; _last_z = z; return
	diff_x = x - _last_x; diff_y = y - _last_y; diff_z = z - _last_z
	_last_x = x; _last_y = y; _last_z = z
	if _count_shaked > 0: return
	_is_shaked = (diff_x * diff_x + diff_y * diff_y + diff_z * diff_z > 1)
	if _is_shaked: on_shaked()`);
		this.addSetupCode(`Timer(11).init(period=100, mode=Timer.PERIODIC, callback=timer11_tick)`);
	}

	Arduino.weeemake_mpython_get_gyro_state = function(block){
		const key = block.getFieldValue('key');
		init_gyro_state.call(this);
		if(key == 0)return [`_is_shaked`, ORDER_HIGH];
		if(key == 1)return [`_is_thrown`, ORDER_HIGH];
	}

	Arduino.weeemake_mpython_when_state_change = (list => function(block, subCode){
		const key = block.getFieldValue('key');
		init_gyro_state.call(this);
		if(!subCode)return;
		this.addVarDef(`def ${list[key]}():\n${tabText(subCode)}`)
	})(['on_shaked','on_thrown'])

	Arduino.weeemake_mpython_when_tilt_change = (list => function(block, subCode){
		const key = block.getFieldValue('key');
		if(db.board == board_python_2in1){
			this.addInclude('from mpython import *');
		}else if(db.board == board_elf_weee_core){
			this.addInclude('from AIHandle import *');
		}
		this.addInclude('from machine import Timer')
		this.addVarDef(`_dir = ''`);
		this.addVarDef(`def on_tilt_forward():pass`);
		this.addVarDef(`def on_tilt_back():pass`);
		this.addVarDef(`def on_tilt_left():pass`);
		this.addVarDef(`def on_tilt_right():pass`);
		this.addVarDef(`def on_tilt_none():pass`);
		this.addVarDef(`def timer14_tick(_):
	global _dir
	if accelerometer.get_x() < -0.3:
		if 'F' != _dir:_dir = 'F';on_tilt_forward()
	elif accelerometer.get_x() > 0.3:
		if 'B' != _dir:_dir = 'B';on_tilt_back()
	elif accelerometer.get_y() < -0.3:
		if 'R' != _dir:_dir = 'R';on_tilt_right()
	elif accelerometer.get_y() > 0.3:
		if 'L' != _dir:_dir = 'L';on_tilt_left()
	else:
		if '' != _dir:_dir = '';on_tilt_none()`);
		this.addSetupCode(`Timer(14).init(period=200, mode=Timer.PERIODIC, callback=timer14_tick)`);
		if(!subCode)return;
		this.addVarDef(`def ${list[key]}():\n${tabText(subCode)}`)
	})(['on_tilt_forward','on_tilt_back','on_tilt_left','on_tilt_right','on_tilt_none'])
}