'use strict';


const repeatFnFactory = (keyCond, keyDo) => function(block, {[keyCond]:count, [keyDo]:subCode}){
	let name = 'i';
	return `for(int ${name}=${count}; ${name}>0; --${name})` + (subCode ? `{\n${subCode}}\n` : this.END);
}

const Arduino = {
	variables_get(block, {VAR}){
		let name = this.adjustVarName(VAR);
		this.markNameUsed(name);
		return [name, this.ORDER_ATOMIC];
	},
	variables_set(block, {VAR, VALUE=0}){
		let name = this.adjustVarName(VAR);
		this.markNameUsed(name);
		return this.commentStatement(`${name} = ${VALUE}`, VAR);
	},
	math_change(block, {VAR, DELTA}){
		let name = this.adjustVarName(VAR);
		this.markNameUsed(name);
		return this.commentStatement(`${name} += ${DELTA}`, VAR);
	},
	procedures_call(block){
		let raw_name = block.getFieldValue('NAME');
		let defBlock = block.workspace.getTopBlocks().find(block => block.type == 'procedures_definition' && block.getFieldValue('NAME') == raw_name);
		let name = this.adjustVarName(raw_name);
		let args = defBlock._getArgList().map(id => this.valueToCode(block, id, this.ORDER_NONE) || '0');
		return this.commentStatement(`${name}(${args.join(', ')})`, raw_name);
	},
	procedures_param(block){
		let raw_name = block.getFieldValue('NAME');
		let name = this.adjustVarName(raw_name);
		return [name, this.ORDER_ATOMIC];
	}

	/*,
	procedures_callnoreturn(block){
		return this.tab() + this.procedures_callreturn(block)[0] + this.END;
	},
	procedures_callreturn(block){
		const name = this.adjustVarName(block.getFieldValue('NAME'));
		const args = block.arguments_.map((_, i) => this.valueToCode(block, 'ARG'+i, this.ORDER_NONE));
		return [`${name}(${args.join(', ')})`, this.ORDER_ATOMIC];
	},
	procedures_return(block){
		const VALUE = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		return this.tab() + `return ${VALUE}` + this.END;
	}
	*/,
	procedures_ifreturn(block){
		const VALUE = this.valueToCode(block, 'VALUE', this.ORDER_NONE) || '0';
		const CONDITION = this.valueToCode(block, 'CONDITION', this.ORDER_NONE) || 'false';
		return `if(${CONDITION})return${block.hasReturnValue_ ? ' ' + VALUE : ''}` + this.END;
	},
	argument_reporter_boolean:'argument_reporter_string_number',
	argument_reporter_string_number(block){
		let name = this.adjustVarName(block.getFieldValue('VALUE'));
		this.markNameUsed(name);
		return [name, 0];
	},
	colour_picker(block, {COLOUR}){
		return [COLOUR.replace('#', '0x'), this.ORDER_ATOMIC];
	},
	text(block, {TEXT=''}){
		return [JSON.stringify(TEXT), this.ORDER_ATOMIC];
	},
	logic_null(){
		return ['NULL', this.ORDER_ATOMIC];
	},
	logic_ternary(block, {IF, THEN, ELSE}){
		return [`${IF} ? ${THEN} : ${ELSE}`, this.ORDER_HIGH]
	},
	math_lists_index:'math_number',
	math_angle:'math_number',
	math_integer:'math_number',
	math_positive_number:'math_number',
	math_whole_number:'math_number',
	math_number(block, {NUM:text}){
		return [isNaN(Number(text)) ? '0' : text, this.ORDER_ATOMIC];
	},
	calcListIndex(block, key='INDEX'){
		let index = this.valueToCode(block, key, this.ORDER_ADDITIVE);
		let number = Number(index);
		return isNaN(number) ? `${index} - 1` : number - 1;
	},
	
	log(block, {value=0}){
		this.addSetupCode('Serial.begin(115200)');
		return `Serial.println(${value})` + this.END;
	},
	sensing_timer(block){
		return ['millis() * 0.001', this.ORDER_MULTIPLICATIVE];
		//return ['millis()', this.ORDER_ATOMIC];
	},
	control_wait(block, _, {DURATION}){
		if(this.needGenLoopFunc)this.markNameUsed('sleep');
		let value = DURATION.fixBrackets(this.ORDER_MULTIPLICATIVE);
		let number = Number(value);
		let text = isNaN(number) ? `${value} * 1000` : number * 1000;
		let fn = this.needGenLoopFunc ? 'sleep' : 'delay';
		return `${fn}(${text})` + this.END;
	},
	control_stop(block){
		return `while(true)` + this.END;
	},
	control_wait_until(block){
		return `while(${this.notCondition(block)})` + (this.needGenLoopFunc ? 'update()' : '') + this.END;
	},
	control_repeat_until(block){
		if(!block.statement)
			return `while(${this.notCondition(block)})` + (this.needGenLoopFunc ? 'update()' : '') + this.END;
		let case1Code = this.insertUpdateCode() + this.statementToCodeIndent(block, 'SUBSTACK');
		return `while(${this.notCondition(block)}){\n${case1Code}}\n`;
	},
	control_if(block, {CONDITION, SUBSTACK}){
		if(!SUBSTACK)return `if(${CONDITION})` + this.END;
		return `if(${CONDITION}){\n${SUBSTACK}}\n`;
	},
	control_if_else(block){
		let condition = this.valueToCode(block, 'CONDITION', this.ORDER_NONE) || 'false';
		let case1 = block.getInputTargetBlock('SUBSTACK');
		let case2 = block.getInputTargetBlock('SUBSTACK2');
		let case1Code = this.statementToCodeIndent(block, 'SUBSTACK');
		let case2Code;
		let isCase1Null = case1 == null;
		let isCase2Null = case2 == null;
		if(isCase1Null && isCase2Null)return tab + `if(${condition})` + this.END;
		if(isCase2Null)return `if(${condition}){\n${case1Code}}\n`;
		if(!case2.getNextBlock() && (case2.type === 'control_if' || case2.type === 'control_if_else')){
			case2Code = this.statementToCode(block, 'SUBSTACK2');
			return `if(${condition}){\n${case1Code}}else ${case2Code.trimStart()}`;
		}
		case2Code = this.statementToCodeIndent(block, 'SUBSTACK2');
		if(isCase1Null)return `if(${this.notCondition(block)}){\n${case2Code}}\n`;
		return `if(${condition}){\n${case1Code}}else{\n${case2Code}}\n`;
	},

	
	controls_repeat_ext: repeatFnFactory('TIMES', 'DO'),
	control_repeat: repeatFnFactory('TIMES', 'SUBSTACK')
	/*,
	control_repeat(block){
		let tab = Arduino.tab();
		let count = Arduino.valueToCode(block, "TIMES", this.ORDER_NONE) || '0';
		let subCode = Arduino.statementToCodeIndent(block, 'SUBSTACK');
		let name = 'i';
		return `${tab}for(int ${name}=${count}; ${name}>0; --${name})` + (subCode ? `{\n${subCode}${tab}}\n` : this.END);
	}*/,
	control_forever(block, {SUBSTACK}){
		if(this.needHandleLoop && this.indent === 1)return null;
		if(!SUBSTACK)
			return 'while(true)' + this.END;
		let subCode = this.insertUpdateCode() + SUBSTACK;
		return `while(true){\n${subCode}}\n`;
	},
	logic_compare: (dict => function(block, {OP}, {A, B}){
		const order = this.ORDER_RELATIONAL;
		return [`${A?.fixBrackets(order) ?? 0} ${dict[OP]} ${B?.fixBrackets(order,true) ?? 0}`, order];
	})({
		EQ:'==',
		NEQ:'!=',
		LT:'<',
		LTE:'<=',
		GT:'>',
		GTE:'>=',
	}),
	math_arithmetic: (dict => function(block, {OP}, {A, B}){
		if(OP == 'POWER'){
			return [`pow(${A}, ${B})`, this.ORDER_ATOMIC]
		}
		let order = (OP == 'MULTIPLY' || OP == 'DIVIDE') ? this.ORDER_MULTIPLICATIVE : this.ORDER_ADDITIVE;
		return [`${A.fixBrackets(order)} ${dict[OP]} ${B.fixBrackets(order, true)}`, order];
	})({MULTIPLY: '*', DIVIDE: '/', ADD: '+', MINUS: '-'}),
	math_single(block, {OP}, {NUM}){
		const order = OP == 'NEG' ? this.ORDER_UNARY : this.ORDER_NONE;
		NUM = NUM.fixBrackets(order);
		if(OP == 'ROOT')return [`sqrt(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'ABS')return [`abs(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'NEG')return [`- ${NUM}`, order];
		if(OP == 'LN')return [`log(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'LOG10')return [`log10(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'EXP')return [`exp(${NUM})`, this.ORDER_ATOMIC];
		if(OP == 'POW10')return [`pow(10, ${NUM})`, this.ORDER_ATOMIC];
	},
	math_trig(block, {OP}, {NUM}){
		const order = OP.indexOf('A') == 0 ? this.ORDER_NONE : this.ORDER_MULTIPLICATIVE;
		NUM = NUM.fixBrackets(order);
		if(order == this.ORDER_NONE){
			return [OP.toLowerCase() + `(${NUM}) * M_1_PI * 180.0`, this.ORDER_MULTIPLICATIVE]
		}
		return [OP.toLowerCase() + `(${NUM} * M_PI / 180.0)`, this.ORDER_ATOMIC]
	},
	math_number_property(block){
		const PROPERTY = this.getFieldValue(block,'PROPERTY');
		const NUMBER_TO_CHECK = this.valueToCode(block, 'NUMBER_TO_CHECK', this.ORDER_MULTIPLICATIVE);
		//math_number_property({PROPERTY, NUMBER_TO_CHECK, DIVISOR}){
		if(PROPERTY == 'EVEN')return [
			`${this.valueToCode(block, 'NUMBER_TO_CHECK', this.ORDER_MULTIPLICATIVE)} % 2 == 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'ODD')return [
			`${this.valueToCode(block, 'NUMBER_TO_CHECK', this.ORDER_MULTIPLICATIVE)} % 2 == 1`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'WHOLE')return [
			`fmod(${this.valueToCode(block, 'NUMBER_TO_CHECK', this.ORDER_NONE)}, 1) == 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'POSITIVE')return [
			`${this.valueToCode(block, 'NUMBER_TO_CHECK', this.ORDER_RELATIONAL)} > 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'NEGATIVE')return [
			`${this.valueToCode(block, 'NUMBER_TO_CHECK', this.ORDER_RELATIONAL)} < 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'DIVISIBLE_BY')return [
			`lround(${
				this.valueToCode(block, 'NUMBER_TO_CHECK', this.ORDER_NONE)
			}) % lround(${
				this.valueToCode(block, 'DIVISOR', this.ORDER_NONE)
			}) == 0`,
			this.ORDER_RELATIONAL
		];
		if(PROPERTY == 'PRIME'){
			return ['0', this.ORDER_ATOMIC];
		}
	},
	math_constrain(block, {VALUE, LOW, HIGH}){
		return [`constrain(${VALUE}, ${LOW}, ${HIGH})`, this.ORDER_HIGH];
	},
	math_round: (dict => function(block, {OP, NUM}){
		return [`${dict[OP]}(${NUM})`, this.ORDER_ATOMIC];
	})({
		ROUND: 'round',
		ROUNDUP: 'ceil',
		ROUNDDOWN: 'floor'
	}),
	math_modulo(block, {DIVIDEND, DIVISOR}){
		return [`fmod(${DIVIDEND}, ${DIVISOR})`, this.ORDER_ATOMIC]
	},
	math_random_int(block, {FROM}, {TO}){
		return [`random(${FROM}, ${TO.fixBrackets(this.ORDER_ADDITIVE)} + 1)`, this.ORDER_ATOMIC];
	},
	math_random_float(block){
		return [`random(1000) * 0.001`, this.ORDER_MULTIPLICATIVE];
	},
	math_atan2(block, {X, Y}){
		return [`atan2(${Y}, ${X})`, this.ORDER_ATOMIC];
	},
	math_constant(block, {CONSTANT}){
		if(CONSTANT == 'PI')return ['M_PI', this.ORDER_ATOMIC];
		if(CONSTANT == 'E')return ['M_E', this.ORDER_ATOMIC];
		if(CONSTANT == 'GOLDEN_RATIO')return ['1.618', this.ORDER_ATOMIC];
		if(CONSTANT == 'SQRT2')return ['M_SQRT2', this.ORDER_ATOMIC];
		if(CONSTANT == 'SQRT1_2')return ['M_SQRT1_2', this.ORDER_ATOMIC];
		if(CONSTANT == 'INFINITY')return ['INFINITY', this.ORDER_ATOMIC];
	},
	text_length(block, {VALUE}){
		return [`String(${VALUE}).length()`, this.ORDER_HIGH];
	},
	colour_random(block){
		return [`random(0x1000000)`, this.ORDER_ATOMIC];
	},
	colour_rgb(block, _, {RED, GREEN, BLUE}){
		const order = this.ORDER_BIT_AND;
		RED = RED.fixBrackets(order);
		GREEN = GREEN.fixBrackets(order);
		BLUE = BLUE.fixBrackets(order);
		return [`(${RED} & 0xFF) * 0x10000 | (${GREEN} & 0xFF) << 8 | ${BLUE} & 0xFF`, this.ORDER_BIT_OR];
	},
	colour_blend(block, _, {COLOUR1, COLOUR2, RATIO}){
		const COLOUR1L = COLOUR1.fixBrackets(this.ORDER_ADDITIVE);
		const COLOUR1R = COLOUR1.fixBrackets(this.ORDER_ADDITIVE, true);
		COLOUR2 = COLOUR2.fixBrackets(this.ORDER_ADDITIVE);
		RATIO = RATIO.fixBrackets(this.ORDER_MULTIPLICATIVE, true);
		//bugfix COLOUR1 calc twice
		return [`${COLOUR1L} + (${COLOUR2} - ${COLOUR1R}) * ${RATIO}`, this.ORDER_ADDITIVE];
	},
	logic_operation(block, {OP}, {A, B}){
		const order = OP == 'AND' ? this.ORDER_AND : this.ORDER_OR;
		return [`${A?.fixBrackets(order) ?? false} ${OP == 'AND' ? '&&' : '||'} ${B?.fixBrackets(order,true) ?? false}`, order];
	},
	logic_negate(block, _, {BOOL}){
		const order = this.ORDER_UNARY;
		return [`!${BOOL?.fixBrackets(order,true) ?? false}`, order];
	},
	/*
	operator_add(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_ADDITIVE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_ADDITIVE) || "0";
		return [`${a} + ${b}`, this.ORDER_ADDITIVE];
	},
	operator_subtract(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_ADDITIVE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_ADDITIVE) || "0";
		return [`${a} - ${b}`, this.ORDER_ADDITIVE];
	},
	operator_multiply(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_MULTIPLICATIVE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_MULTIPLICATIVE) || "0";
		return [`${a} * ${b}`, this.ORDER_MULTIPLICATIVE];
	},
	operator_divide(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_MULTIPLICATIVE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_MULTIPLICATIVE) || "1";
		return [`${a} / ${b}`, this.ORDER_MULTIPLICATIVE];
	},
	*/
	operator_mathop(block){
		let op = this.getFieldValue(block,'OPERATOR');
		let order = /^(sin|cos|tan)$/.test(op) ? this.ORDER_MULTIPLICATIVE : this.ORDER_NONE;
		let v = this.valueToCode(block, "NUM", order) || '0';
		switch(op){
			case "ceiling":
				return [`ceil(${v})`, this.ORDER_ATOMIC];
			case "ln":
				return [`log(${v})`, this.ORDER_ATOMIC];
			case "log":
				return [`log10(${v})`, this.ORDER_ATOMIC];
			case "e ^":
				return [`exp(${v})`, this.ORDER_ATOMIC];
			case "10 ^":
				return [`pow(10, ${v})`, this.ORDER_ATOMIC];
			case "sin":
			case "cos":
			case "tan":
				return [`${op}(${v} * PI / 180.0)`, this.ORDER_ATOMIC];
			case "asin":
			case "acos":
			case "atan":
				return [`${op}(${v}) / PI * 180.0`, this.ORDER_MULTIPLICATIVE];
		}
		return [`${op}(${v})`, this.ORDER_ATOMIC];
	},
	/*
	operator_not(block, _, {OPERAND}){
		//let v = this.valueToCode(block, "OPERAND", this.ORDER_UNARY) || '0';
		return [`!${OPERAND.fixBrackets(this.ORDER_UNARY, true)}`, this.ORDER_UNARY];
	},
	*/
	operator_mod(block){
		let a = this.valueToCode(block, "NUM1", this.ORDER_NONE) || "0";
		let b = this.valueToCode(block, "NUM2", this.ORDER_NONE) || "1";
		return [`fmod(${a}, ${b})`, this.ORDER_HIGH];
	},
	operator_round(block){
		let v = this.valueToCode(block, "NUM", this.ORDER_NONE) || "0";
		return [`int(round(${v}))`, this.ORDER_HIGH];
	},
	operator_random(block){
		let a = this.valueToCode(block, "FROM", this.ORDER_NONE) || "0";
		let b = this.valueToCode(block, "TO", this.ORDER_ADDITIVE) || "1";
		return [`random(${a}, ${b} + 1)`, this.ORDER_HIGH];
	},
	operator_join(block, {STRING1, STRING2}){
		return [`String(${STRING1}) + String(${STRING2})`, this.ORDER_ADDITIVE];
	},
	operator_letter_of(block){
		let index = this.calcListIndex(block, 'LETTER');
		let text = this.valueToCode(block, "STRING", this.ORDER_NONE);
		return [`String(String(${text}).charAt(${index}))`, this.ORDER_HIGH];
	},
	operator_length(block){
		let text = this.valueToCode(block, "STRING", this.ORDER_NONE);
		return [`String(${text}).length()`, this.ORDER_HIGH];
	},
	operator_contains(block){
		let a = this.valueToCode(block, "STRING1", this.ORDER_NONE);
		let b = this.valueToCode(block, "STRING2", this.ORDER_NONE);
		return [`String(${a}).indexOf(String(${b})) >= 0`, this.ORDER_RELATIONAL];
	},
	lists_deleteoflist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.removeAt(${index})`, raw_name);
	},
	lists_addtolist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.push(${item})`, raw_name);
	},
	lists_deletealloflist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.clear()`, raw_name);
	},
	lists_insertatlist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.insertAt(${index}, ${item})`, raw_name);
	},
	lists_replaceitemoflist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.replaceAt(${index}, ${item})`, raw_name);
	},
	lists_itemoflist(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.getValueAt(${index})`, this.ORDER_HIGH];
	},
	lists_indexOf(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.indexOf(${item}) + 1`, this.ORDER_ADDITIVE];
	},
	lists_length(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.getLength()`, this.ORDER_HIGH];
	},
	lists_listcontainsitem(block){
		let raw_name = block.getField('LIST').getText();
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.include(${item})`, this.ORDER_HIGH];
	},
};


module.exports = Arduino;