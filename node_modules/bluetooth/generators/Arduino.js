'use strict';

const wrapFn = require( 'utils/function/overrideMethod');
const {message} = antd;

const ORDER_ATOMIC = 0;
const ORDER_HIGH = 1;
const ORDER_EXPONENTIATION = 2;
const ORDER_UNARY = 3;
const ORDER_MULTIPLICATIVE = 4;
const ORDER_ADDITIVE = 5;
const ORDER_CONCATENATION = 6;
const ORDER_RELATIONAL = 7;
const ORDER_AND = 8;
const ORDER_OR = 9;
const ORDER_NONE = 99;
const END = ';\n';

module.exports = function(){
	const Arduino = new Blockly.Generator('Arduino');
	Arduino.ORDER_ATOMIC = ORDER_ATOMIC;
	Arduino.ORDER_NONE = ORDER_NONE;
	Arduino.ORDER_HIGH = ORDER_HIGH;
	Arduino.ORDER_UNARY = ORDER_UNARY;
	Arduino.ORDER_ADDITIVE = ORDER_ADDITIVE;
	Arduino.ORDER_RELATIONAL = ORDER_RELATIONAL;
	Arduino.END = END;

	Arduino.commentStart = '//';

	Arduino.init = function(){
		this.needHandleLoop = false;
		this.indent = 1;
		this.funcDef = {};
		this.usedNames = new Set();
		this.varDef = {};
		this.varType = {};
		this.includeDict = {};
		this.setupDict = {};
		this.loopDict = {};
		this.needGenLoopFunc = false;
		this.irFlag = false;
	}

	Arduino.insertUpdateCode = function(){
		if(!this.needGenLoopFunc)return '';
		return this.tab() + this.INDENT + `update()` + END;
	}

	Arduino.onCodeMissed = function(text, v=0){
		text = text.replace(/\*\//g, '*\\/');
		return [`${v}/*${text}*/`, ORDER_ATOMIC];
	}
	Arduino.onStatementMissed = function(text){
		return this.tab() + this.commentStart + text + this.END;
	}
	Arduino.onGenVarDef = (new_name, name, type) => (type ? `LinkedList ${new_name}` : `${Arduino.varType[new_name] || 'double'} ${new_name} = 0`) + `;\t//${name}`;
	//Arduino.onGenFuncBody = (name, args, body) => `${body.indexOf('\treturn ') >= 0 ? 'double' : 'void'} ${name}(${args.map(v => v.join(' ')).join(', ')}){\n${body}}\n`;
	Arduino.onGenFuncBody = (type, name, args, body) => `${type} ${name}(${args.map(v => v.join(' ')).join(', ')}){\n${body}}\n`;
	
	Arduino.finish = function(workspace, setupBlock, loopBlock, funcBlockList){
		funcBlockList.map(v => v.getNextBlock()).concat(setupBlock).forEach(this.blockToCode, this);
		
		this.addFuncDef('void', 'sleep', [['unsigned long', 'duration']], [
			'unsigned long end = millis() + duration',
			'while(millis() < end)update()'
		]);

		this.collectFuncDefs(funcBlockList);
		this.needHandleLoop = true;
		let setupCode = this.blockToCode(setupBlock);
		this.needHandleLoop = false;
		let loopCode = this.blockToCode(loopBlock);
		this.collectVarDefs(workspace);
		if(setupCode){
			setupCode = this.generateSetupCodes() + setupCode;
		}else{
			setupCode = this.generateSetupCodes().replace(/\n\n$/, '\n');
		}
		void function(codeList){
			if(codeList.length <= 0)return;
			loopCode = Arduino.INDENT + 'update()' + END + loopCode;
			Arduino.addFuncDef('void', 'update', [], codeList);
			Arduino.markNameUsed('update');
		}(Object.values(this.loopDict));
		
		let result = this.generateIncludes();
		result += this.generateVarDefs();
		result += `void setup(){\n${setupCode}}\n\nvoid loop(){\n${loopCode}}\n\n`;
		result += this.generateFuncDefs();
		return result;
	}
	const calcBlockCount = (control_blocks => block => {
		let result = 0;
		for(; block; block = block.getNextBlock()){
			++result;
			if(!control_blocks.includes(block.type))continue;
			result += calcBlockCount(block.getInputTargetBlock('SUBSTACK'));
			if(block.type != 'control_if_else')continue;
			result += calcBlockCount(block.getInputTargetBlock('SUBSTACK2'));
		}
		return result;
	})(['control_if', 'control_if_else', 'control_forever', 'control_repeat', 'control_repeat_until']);
	const special_blocks = ['weeemake_generate_offline_code', 'procedures_definition', 'procedures_defnoreturn', 'procedures_defreturn'];
	const findBestBlock = blocks => blocks.map(b => [b, calcBlockCount(b)]).sort((a, b) => b[1] - a[1])[0][0];
	Arduino.workspaceToCode = function(workspace){
		const blockList = workspace.getTopBlocks();
		let setupBlock, loopBlock, funcBlockList = [];
		function bindBlock(block){
			setupBlock = block;
			while(block.getNextBlock()){
				block = block.getNextBlock();
			}
			if(block.type === 'control_forever'){
				loopBlock = block.getInputTargetBlock('SUBSTACK');
				return true;
			}
		}
		this.init(workspace);
		for(let block of blockList){
			if(block.type.indexOf('procedures_def') != 0)continue;
			funcBlockList.push(block);
		}
		let blocks = blockList.filter(block => block.type == 'when_start' && block.getNextBlock());
		if(blocks.length <= 0){
			blocks = blockList.filter(block => !special_blocks.includes(block.type));
		}
		if(blocks.length > 0){
			let subBlocks = blocks.filter(bindBlock);
			if(subBlocks.length > 0){
				blocks = subBlocks;
			}
			bindBlock(findBestBlock(blocks));
		}
		return this.finish(workspace, setupBlock, loopBlock, funcBlockList);
	}
	Arduino.looks_say = function(block){
		this.addSetupCode('Serial.begin(115200)');
		let text = this.valueToCode(block, "MESSAGE", ORDER_NONE);
		return Arduino.tab() + `Serial.println(${text})` + END;
	}
	Arduino.sensing_timer = function(block){
		return ['millis() * 0.001', ORDER_MULTIPLICATIVE];
		//return ['millis()', ORDER_ATOMIC];
	}
	Arduino.control_wait = function(block){
		if(Arduino.needGenLoopFunc)Arduino.markNameUsed('sleep');
		let value = Arduino.valueToCode(block, 'DURATION', ORDER_MULTIPLICATIVE);
		let number = Number(value);
		let text = isNaN(number) ? `${value} * 1000` : number * 1000;
		let fn = Arduino.needGenLoopFunc ? 'sleep' : 'delay';
		return Arduino.tab() + `${fn}(${text})` + END;
	}
	Arduino.controls_repeat_ext = function(block){
		const TIMES = Arduino.valueToCode(block, 'TIMES', ORDER_NONE);
	}
	Arduino.control_stop = function(block){
		return Arduino.tab() + `while(true)` + END;
	}
	const notCondition = block => {
		let condition = Arduino.valueToCode(block, 'CONDITION', ORDER_UNARY);
		return condition ? `!${condition}` : 'true';
	};
	Arduino.control_wait_until = function(block){
		return Arduino.tab() + `while(${notCondition(block)})` + (this.needGenLoopFunc ? 'update()' : '') + END;
	}
	Arduino.control_repeat_until = function(block){
		if(!block.getInputTargetBlock('SUBSTACK'))
			return Arduino.control_wait_until(block);
		let tab = Arduino.tab();
		let case1Code = this.insertUpdateCode() + this.statementToCodeIndent(block, 'SUBSTACK');
		return `${tab}while(${notCondition(block)}){\n${case1Code}${tab}}\n`;
	}
	Arduino.control_if = function(block){
		let condition = Arduino.valueToCode(block, 'CONDITION', ORDER_NONE) || 'false';
		let case1 = block.getInputTargetBlock('SUBSTACK');
		let tab = Arduino.tab();
		if(case1 == null)return tab + `if(${condition})` + END;
		let case1Code = Arduino.statementToCodeIndent(block, 'SUBSTACK');
		return `${tab}if(${condition}){\n${case1Code}${tab}}\n`;
	}
	Arduino.control_if_else = function(block){
		let condition = Arduino.valueToCode(block, 'CONDITION', ORDER_NONE) || 'false';
		let case1 = block.getInputTargetBlock('SUBSTACK');
		let case2 = block.getInputTargetBlock('SUBSTACK2');
		let case1Code = Arduino.statementToCodeIndent(block, 'SUBSTACK');
		let case2Code;
		let isCase1Null = case1 == null;
		let isCase2Null = case2 == null;
		let tab = Arduino.tab();
		if(isCase1Null && isCase2Null)return tab + `if(${condition})` + END;
		if(isCase2Null)return `${tab}if(${condition}){\n${case1Code}${tab}}\n`;
		if(!case2.getNextBlock() && (case2.type === 'control_if' || case2.type === 'control_if_else')){
			case2Code = Arduino.statementToCode(block, 'SUBSTACK2');
			return `${tab}if(${condition}){\n${case1Code}${tab}}else ${case2Code.trimStart()}`;
		}
		case2Code = Arduino.statementToCodeIndent(block, 'SUBSTACK2');
		if(isCase1Null)return `${tab}if(${notCondition(block)}){\n${case2Code}${tab}}\n`;
		return `${tab}if(${condition}){\n${case1Code}${tab}}else{\n${case2Code}${tab}}\n`;
	}

	const repeatFnFactory = (keyCond, keyDo) => function(block){
		let tab = Arduino.tab();
		let count = Arduino.valueToCode(block, keyCond, ORDER_NONE) || '0';
		let subCode = Arduino.statementToCodeIndent(block, keyDo);
		let name = 'i';
		return `${tab}for(int ${name}=${count}; ${name}>0; --${name})` + (subCode ? `{\n${subCode}${tab}}\n` : END);
	};
	Arduino.controls_repeat_ext = repeatFnFactory('TIMES', 'DO');
	Arduino.control_repeat = repeatFnFactory('TIMES', 'SUBSTACK');
	/*
	Arduino.control_repeat = function(block){
		let tab = Arduino.tab();
		let count = Arduino.valueToCode(block, "TIMES", ORDER_NONE) || '0';
		let subCode = Arduino.statementToCodeIndent(block, 'SUBSTACK');
		let name = 'i';
		return `${tab}for(int ${name}=${count}; ${name}>0; --${name})` + (subCode ? `{\n${subCode}${tab}}\n` : END);
	}*/
	Arduino.control_forever = function(block){
		if(this.needHandleLoop && this.indent === 1)return null;
		if(!block.getInputTargetBlock('SUBSTACK'))
			return Arduino.tab() + 'while(true)' + END;
		let tab = Arduino.tab();
		let subCode = this.insertUpdateCode() + this.statementToCodeIndent(block, 'SUBSTACK');
		return `${tab}while(true){\n${subCode}${tab}}\n`;
	}

	Arduino.logic_compare = (dict => function(block){
		const A = Arduino.valueToCode(block, 'A', ORDER_RELATIONAL);
		const B = Arduino.valueToCode(block, 'B', ORDER_RELATIONAL);
		const OP = block.getFieldValue('OP');
		return [`${A} ${dict[OP]} ${B}`, ORDER_RELATIONAL];
	})({
		EQ:'==',
		NEQ:'!=',
		LT:'<',
		LTE:'<=',
		GT:'>',
		GTE:'>=',
	});
	Arduino.math_arithmetic = (dict => function(block){
		const OP = block.getFieldValue('OP');
		let order;
		if(OP == 'POWER'){
			order = ORDER_NONE;
		}else if(OP == 'MULTIPLY' || OP == 'DIVIDE'){
			order = ORDER_MULTIPLICATIVE;
		}else{
			order = ORDER_ADDITIVE;
		}
		const A = Arduino.valueToCode(block, 'A', order);
		const B = Arduino.valueToCode(block, 'B', order);
		if(OP == 'POWER'){
			return [`pow(${A}, ${B})`, ORDER_ATOMIC]
		}
		return [`${A} ${dict[OP]} ${B}`, order]
	})({
		MULTIPLY: '*',
		DIVIDE: '/',
		ADD: '+',
		MINUS: '-',
	});
	Arduino.math_single = function(block){
		const OP = block.getFieldValue('OP');
		const order = OP == 'NEG' ? ORDER_UNARY : ORDER_NONE;
		const NUM = this.valueToCode(block, 'NUM', order);
		if(OP == 'ROOT')return [`sqrt(${NUM})`, ORDER_ATOMIC];
		if(OP == 'ABS')return [`abs(${NUM})`, ORDER_ATOMIC];
		if(OP == 'NEG')return [`- ${NUM}`, order];
		if(OP == 'LN')return [`log(${NUM})`, ORDER_ATOMIC];
		if(OP == 'LOG10')return [`log10(${NUM})`, ORDER_ATOMIC];
		if(OP == 'EXP')return [`exp(${NUM})`, ORDER_ATOMIC];
		if(OP == 'POW10')return [`pow(10, ${NUM})`, ORDER_ATOMIC];
	}
	Arduino.math_trig = function(block){
		const OP = block.getFieldValue('OP');
		const order = OP.indexOf('A') == 0 ? ORDER_NONE : ORDER_MULTIPLICATIVE;
		const NUM = this.valueToCode(block, 'NUM', order);
		if(order == ORDER_NONE){
			return [OP.toLowerCase() + `(${NUM}) * M_1_PI * 180.0`, ORDER_MULTIPLICATIVE]
		}
		return [OP.toLowerCase() + `(${NUM} * M_PI / 180.0)`, ORDER_ATOMIC]
	}
	Arduino.math_number_property = function(block){
		const PROPERTY = block.getFieldValue('PROPERTY');
		const NUMBER_TO_CHECK = this.valueToCode(block, 'NUMBER_TO_CHECK', ORDER_MULTIPLICATIVE);
		//math_number_property({PROPERTY, NUMBER_TO_CHECK, DIVISOR}){
		if(PROPERTY == 'EVEN')return [
			`${this.valueToCode(block, 'NUMBER_TO_CHECK', ORDER_MULTIPLICATIVE)} % 2 == 0`,
			ORDER_RELATIONAL
		];
		if(PROPERTY == 'ODD')return [
			`${this.valueToCode(block, 'NUMBER_TO_CHECK', ORDER_MULTIPLICATIVE)} % 2 == 1`,
			ORDER_RELATIONAL
		];
		if(PROPERTY == 'WHOLE')return [
			`fmod(${this.valueToCode(block, 'NUMBER_TO_CHECK', ORDER_NONE)}, 1) == 0`,
			ORDER_RELATIONAL
		];
		if(PROPERTY == 'POSITIVE')return [
			`${this.valueToCode(block, 'NUMBER_TO_CHECK', ORDER_RELATIONAL)} > 0`,
			ORDER_RELATIONAL
		];
		if(PROPERTY == 'NEGATIVE')return [
			`${this.valueToCode(block, 'NUMBER_TO_CHECK', ORDER_RELATIONAL)} < 0`,
			ORDER_RELATIONAL
		];
		if(PROPERTY == 'DIVISIBLE_BY')return [
			`lround(${
				this.valueToCode(block, 'NUMBER_TO_CHECK', ORDER_NONE)
			}) % lround(${
				this.valueToCode(block, 'DIVISOR', ORDER_NONE)
			}) == 0`,
			ORDER_RELATIONAL
		];
		if(PROPERTY == 'PRIME'){
			return ['0', ORDER_ATOMIC];
		}
	}
	Arduino.math_constrain = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		const LOW = this.valueToCode(block, 'LOW', ORDER_NONE);
		const HIGH = this.valueToCode(block, 'HIGH', ORDER_NONE);
		return [`constrain(${VALUE}, ${LOW}, ${HIGH})`, ORDER_HIGH];
	}
	Arduino.math_round = (dict => function(block){
		const OP = block.getFieldValue('OP');
		const NUM = this.valueToCode(block, 'NUM', ORDER_NONE);
		return [`${dict[OP]}(${NUM})`, ORDER_ATOMIC];
	})({
		ROUND: 'round',
		ROUNDUP: 'ceil',
		ROUNDDOWN: 'floor'
	})
	Arduino.math_modulo = function(block){
		const DIVIDEND = this.valueToCode(block, 'DIVIDEND', ORDER_NONE);
		const DIVISOR = this.valueToCode(block, 'DIVISOR', ORDER_NONE);
		return [`fmod(${DIVIDEND}, ${DIVISOR})`, ORDER_ATOMIC]
	}
	Arduino.math_random_int = function(block){
		const FROM = this.valueToCode(block, 'FROM', ORDER_NONE);
		const TO = this.valueToCode(block, 'TO', ORDER_ADDITIVE);
		return [`random(${FROM}, 1 + ${TO})`, ORDER_ATOMIC];
	}
	Arduino.math_random_float = function(block){
		return [`random(1000) * 0.001`, ORDER_MULTIPLICATIVE];
	}
	Arduino.math_atan2 = function(block){
		const X = this.valueToCode(block, 'X', ORDER_NONE);
		const Y = this.valueToCode(block, 'Y', ORDER_NONE);
		return [`atan2(${Y}, ${X})`, ORDER_ATOMIC];
	}
	Arduino.math_constant = function(block){
		const CONSTANT = block.getFieldValue('CONSTANT');
		if(CONSTANT == 'PI')return ['M_PI', ORDER_ATOMIC];
		if(CONSTANT == 'E')return ['M_E', ORDER_ATOMIC];
		if(CONSTANT == 'GOLDEN_RATIO')return ['1.618', ORDER_ATOMIC];
		if(CONSTANT == 'SQRT2')return ['M_SQRT2', ORDER_ATOMIC];
		if(CONSTANT == 'SQRT1_2')return ['M_SQRT1_2', ORDER_ATOMIC];
		if(CONSTANT == 'INFINITY')return ['INFINITY', ORDER_ATOMIC];
	}
	Arduino.text_length = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', ORDER_NONE);
		return [`String(${VALUE}).length()`, ORDER_HIGH];
	}
	Arduino.colour_random = function(block){
		return [`random(0x1000000)`, ORDER_ATOMIC];
	}
	Arduino.colour_rgb = function(block){
		const RED = this.valueToCode(block, 'RED', ORDER_ADDITIVE);
		const GREEN = this.valueToCode(block, 'GREEN', ORDER_ADDITIVE);
		const BLUE = this.valueToCode(block, 'BLUE', ORDER_ADDITIVE);
		return [`((${RED} & 0xFF) * 0x10000 | (${GREEN} & 0xFF) << 8 | ${BLUE} & 0xFF)`, ORDER_ATOMIC];
	}
	Arduino.logic_operation = function(block){
		const OP = block.getFieldValue('OP');
		const order = OP == 'AND' ? ORDER_AND : ORDER_OR;
		const A = Arduino.valueToCode(block, 'A', order);
		const B = Arduino.valueToCode(block, 'B', order);
		return [`${A} ${OP == 'AND' ? '&&' : '||'} ${B}`, order];
	}
	Arduino.logic_negate = function(block){
		const value = Arduino.valueToCode(block, 'BOOL', ORDER_UNARY);
		return ['!' + value, ORDER_UNARY]
	}
	Arduino.operator_add = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_ADDITIVE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_ADDITIVE) || "0";
		return [`${a} + ${b}`, ORDER_ADDITIVE];
	}
	Arduino.operator_subtract = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_ADDITIVE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_ADDITIVE) || "0";
		return [`${a} - ${b}`, ORDER_ADDITIVE];
	}
	Arduino.operator_multiply = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_MULTIPLICATIVE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_MULTIPLICATIVE) || "0";
		return [`${a} * ${b}`, ORDER_MULTIPLICATIVE];
	}
	Arduino.operator_divide = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_MULTIPLICATIVE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_MULTIPLICATIVE) || "1";
		return [`${a} / ${b}`, ORDER_MULTIPLICATIVE];
	}
	Arduino.operator_mathop = function(block){
		let op = block.getFieldValue('OPERATOR');
		let order = /^(sin|cos|tan)$/.test(op) ? ORDER_MULTIPLICATIVE : ORDER_NONE;
		let v = Arduino.valueToCode(block, "NUM", order) || '0';
		switch(op){
			case "ceiling":
				return [`ceil(${v})`, ORDER_ATOMIC];
			case "ln":
				return [`log(${v})`, ORDER_ATOMIC];
			case "log":
				return [`log10(${v})`, ORDER_ATOMIC];
			case "e ^":
				return [`exp(${v})`, ORDER_ATOMIC];
			case "10 ^":
				return [`pow(10, ${v})`, ORDER_ATOMIC];
			case "sin":
			case "cos":
			case "tan":
				return [`${op}(${v} * PI / 180.0)`, ORDER_ATOMIC];
			case "asin":
			case "acos":
			case "atan":
				return [`${op}(${v}) / PI * 180.0`, ORDER_MULTIPLICATIVE];
		}
		return [`${op}(${v})`, ORDER_ATOMIC];
	}
	const operator_compare = (operator, order) => function(block){
		let a = Arduino.valueToCode(block, "OPERAND1", order) || "0";
		let b = Arduino.valueToCode(block, "OPERAND2", order) || "0";
		return [`${a} ${operator} ${b}`, order];
	}
	Arduino.operator_gt = operator_compare('>', ORDER_RELATIONAL);
	Arduino.operator_lt = operator_compare('<', ORDER_RELATIONAL);
	Arduino.operator_equals = operator_compare('==', ORDER_RELATIONAL);
	Arduino.operator_and = operator_compare('&&', ORDER_AND);
	Arduino.operator_or = operator_compare('||', ORDER_OR);
	Arduino.operator_not = function(block){
		let v = Arduino.valueToCode(block, "OPERAND", ORDER_UNARY) || '0';
		return [`!${v}`, ORDER_UNARY];
	}
	Arduino.operator_mod = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_NONE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_NONE) || "1";
		return [`fmod(${a}, ${b})`, ORDER_HIGH];
	}
	Arduino.operator_round = function(block){
		let v = Arduino.valueToCode(block, "NUM", ORDER_NONE) || "0";
		return [`int(round(${v}))`, ORDER_HIGH];
	}
	Arduino.operator_random = function(block){
		let a = Arduino.valueToCode(block, "FROM", ORDER_NONE) || "0";
		let b = Arduino.valueToCode(block, "TO", ORDER_ADDITIVE) || "1";
		return [`random(${a}, ${b} + 1)`, ORDER_HIGH];
	}
	Arduino.operator_join = function(block){
		let a = Arduino.valueToCode(block, "STRING1", ORDER_NONE);
		let b = Arduino.valueToCode(block, "STRING2", ORDER_NONE);
		return [`String(${a}) + String(${b})`, ORDER_ADDITIVE];
	}
	Arduino.operator_letter_of = function(block){
		let index = this.calcListIndex(block, 'LETTER');
		let text = Arduino.valueToCode(block, "STRING", ORDER_NONE);
		return [`String(String(${text}).charAt(${index}))`, ORDER_HIGH];
	}
	Arduino.operator_length = function(block){
		let text = Arduino.valueToCode(block, "STRING", ORDER_NONE);
		return [`String(${text}).length()`, ORDER_HIGH];
	}
	Arduino.operator_contains = function(block){
		let a = Arduino.valueToCode(block, "STRING1", ORDER_NONE);
		let b = Arduino.valueToCode(block, "STRING2", ORDER_NONE);
		return [`String(${a}).indexOf(String(${b})) >= 0`, ORDER_RELATIONAL];
	}
	Arduino.data_addtolist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.push(${item})`, raw_name);
	}
	Arduino.data_deleteoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.removeAt(${index})`, raw_name);
	}
	Arduino.data_deletealloflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.clear()`, raw_name);
	}
	Arduino.data_insertatlist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.insertAt(${index}, ${item})`, raw_name);
	}
	Arduino.data_replaceitemoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.replaceAt(${index}, ${item})`, raw_name);
	}
	Arduino.data_itemoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.getValueAt(${index})`, this.ORDER_HIGH];
	}
	Arduino.data_itemnumoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.indexOf(${item}) + 1`, ORDER_ADDITIVE];
	}
	Arduino.data_lengthoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.getLength()`, ORDER_HIGH];
	}
	Arduino.data_listcontainsitem = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.include(${item})`, ORDER_HIGH];
	}
	Arduino.math_number = function(block){
		let text = block.getFieldValue('NUM');
		text = isNaN(Number(text)) ? '0' : text;
		return [text, ORDER_ATOMIC];
	}
	return Arduino;
}