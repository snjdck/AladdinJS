'use strict';

const needBrackets = require('js/needBrackets');
const {tab, untab} = require('utils/text');

const Arduino = {
	ORDER_ATOMIC: 0,
	ORDER_HIGH: 1,
	ORDER_EXPONENTIATION: 2,
	ORDER_UNARY: 3,
	ORDER_MULTIPLICATIVE: 4,
	ORDER_ADDITIVE: 5,
	ORDER_SHIFT: 6,
	ORDER_RELATIONAL: 7,
	ORDER_EQUAL: 8,
	ORDER_BIT_AND: 9,
	ORDER_BIT_XOR: 10,
	ORDER_BIT_OR: 11,
	ORDER_AND: 12,
	ORDER_OR: 13,
	ORDER_NONE: 99,
	END: ';\n',
	commentStart:'//',
	needBrackets: needBrackets(v => 100 - v, v => v == Arduino.ORDER_EXPONENTIATION || v == Arduino.ORDER_UNARY),
	init(){
		this.initStage();
		this.varType = {
			"Number": 'double',
			"String": 'String',
			"Boolean": 'bool',
			"Array": 'LinkedList',
			"": 'double',
		};
	},
	onCodeMissed(text, v=0){
		text = text.replace(/\*\//g, '*\\/');
		return [`${v}/*${text}*/`, this.ORDER_ATOMIC];
	},
	onGenVarDef(new_name, name, type){
		return `${this.varType[type]} ${new_name}` + `;\t//${name}\n`;
	},
	genSensorKey(type, name, pin='0'){
		const suffix = pin.split('_').pop();
		const key = name.startsWith(suffix.toLowerCase()) ? name : name + `_` + suffix;
		this.addInclude(`#include<${type}.h>`);
		this.addVarDef(`${type} ${key}(${pin});\n`);
		return key;
	},
	finish(workspace){
		this.collectVarDefs(workspace.variables?.variable);
		this.addStage(4, '%setup-b%');
		this.addStage(5, '%setup-e%');
		this.addStage(7, '%loop-b%');
		this.addStage(8, '%loop-e%');
		let code = this.genStageCode();
		const index = code.indexOf('\nwhile(true){\n');
		if(index > 0){
			const text = code.slice(index, code.indexOf('\n}', index) + 2);
			code = code.replace(text, '').replace('%loop-e%', untab(text.slice(14, -1)) + '$&');
		}
		return code.replace(/%(setup|loop)-b%\n(.*)%\1-e%/gs, (_, n, v) => `void ${n}(){\n${tab(v)}}\n`);
	},
	workspaceToCode(workspace){
		if(!workspace.block)return '';
		const blockList = Array.isArray(workspace.block) ? workspace.block : [workspace.block]
		this.init();
		blockList.filter(block => block.type === 'procedures_defreturn' || block.type === 'procedures_defnoreturn' || block.type === 'procedures_def').forEach(this.blockToCode, this);
		blockList.filter(block => block.data === 'isEventBlock').forEach(this.blockToCode, this);
		return this.finish(workspace);
	}
}

module.exports = Arduino;