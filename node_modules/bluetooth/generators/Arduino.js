'use strict';

const needBrackets = require('js/needBrackets');

const Arduino = {
	ORDER_ATOMIC: 0,
	ORDER_HIGH: 1,
	ORDER_EXPONENTIATION: 2,
	ORDER_UNARY: 3,
	ORDER_MULTIPLICATIVE: 4,
	ORDER_ADDITIVE: 5,
	ORDER_SHIFT: 6,
	ORDER_RELATIONAL: 7,
	ORDER_EQUAL: 8,
	ORDER_BIT_AND: 9,
	ORDER_BIT_XOR: 10,
	ORDER_BIT_OR: 11,
	ORDER_AND: 12,
	ORDER_OR: 13,
	ORDER_NONE: 99,
	END: ';\n',
	commentStart:'//',
	needBrackets: needBrackets(v => 100 - v, v => v == Arduino.ORDER_EXPONENTIATION || v == Arduino.ORDER_UNARY),
	init(){
		this.needHandleLoop = false;
		this.indent = 1;
		this.funcDef = {};
		this.usedNames = new Set();
		this.varDef = {};
		this.varType = {
			"Number": 'double',
			"String": 'String',
			"Boolean": 'bool',
			"Array": 'LinkedList',
			"": 'double',
		};
		this.includeDict = {};
		this.setupDict = {};
		this.loopDict = {};
		this.needGenLoopFunc = false;
		this.irFlag = false;
	},
	insertUpdateCode(){
		if(!this.needGenLoopFunc)return '';
		return this.INDENT + `update()` + this.END;
	},
	onCodeMissed(text, v=0){
		text = text.replace(/\*\//g, '*\\/');
		return [`${v}/*${text}*/`, this.ORDER_ATOMIC];
	},
	onStatementMissed(text){
		return this.commentStart + text + this.END;
	},
	onGenVarDef(new_name, name, type){
		return `${this.varType[type]} ${new_name}` + `;\t//${name}`;
	},
	onGenFuncBody(type, name, args, body){
		return `${type} ${name}(${args.map(v => v.join(' ')).join(', ')}){\n${body}}\n`;
	},
	genSensorKey(type, name, pin='0'){
		const key = name + `_` + pin.split('_').pop();
		this.addInclude(`#include<${type}.h>`);
		this.addVarDef(`${type} ${key}(${pin})`);
		return key;
	},
	finish(workspace, setupBlock, loopBlock, funcBlockList){
		funcBlockList.map(v => v.next?.block).concat(setupBlock).forEach(this.blockToCode, this);
		
		this.addFuncDef('void', 'sleep', [['unsigned long', 'duration']], [
			'unsigned long end = millis() + duration',
			'while(millis() < end)update()'
		]);

		this.collectFuncDefs(funcBlockList);
		this.needHandleLoop = true;
		let setupCode = this.blockToCode(setupBlock);
		this.needHandleLoop = false;
		let loopCode = this.blockToCode(loopBlock);
		this.collectVarDefs(workspace.variables?.variable);
		if(setupCode){
			setupCode = this.generateSetupCodes() + setupCode;
		}else{
			setupCode = this.generateSetupCodes().replace(/\n\n$/, '\n');
		}
		void function(codeList){
			if(codeList.length <= 0)return;
			loopCode = 'update();\n' + loopCode;
			this.addFuncDef('void', 'update', [], codeList);
			this.markNameUsed('update');
		}(Object.values(this.loopDict));
		
		let result = this.generateIncludes();
		result += this.generateFuncProto();
		result += this.generateVarDefs();
		result += `void setup(){\n${this.tab(setupCode)}}\n\nvoid loop(){\n${this.tab(loopCode)}}\n\n`;
		result += this.generateFuncDefs();
		return result;
	},
	workspaceToCode(workspace){
		if(!workspace.block)return '';
		const blockList = Array.isArray(workspace.block) ? workspace.block : [workspace.block]
		let setupBlock, loopBlock, funcBlockList = [];
		function bindBlock(block){
			setupBlock = block;
			while(block.next){
				block = block.next.block;
			}
			if(block.type === 'control_forever'){
				loopBlock = block.statement?.block;
				return true;
			}
		}
		this.init(workspace);
		for(let block of blockList){
			if(!['procedures_defreturn', 'procedures_def'].includes(block.type))continue;
			//if(block.type.indexOf('procedures_def') != 0)continue;
			funcBlockList.push(block);
		}
		let blocks = blockList.filter(block => block.type == 'when_start' && block.next?.block);
		if(blocks.length > 0){
			blocks.forEach(bindBlock);
		}
		return this.finish(workspace, setupBlock, loopBlock, funcBlockList);
	}
}

module.exports = Arduino;