'use strict';

const needBrackets = require('js/needBrackets');
const {tab, untab} = require('utils/text');
const Generator = require('./Generator');

class Arduino extends Generator {
	addFuncDef(name, body){
		this.addStage(this.STAGE_FUNC_PROTO, name + ';\n');
		this.addStage(this.STAGE_FUNC_DEF, `${name}{\n${tab(body)}}\n\n`);
	}
	onCodeMissed(text, v=0){
		text = text.replace(/\*\//g, '*\\/');
		return [`${v}/*${text}*/`, this.ORDER_ATOMIC];
	}
	genSensorKey(type, name, pin='0'){
		const suffix = pin.split('_').pop();
		const key = name.startsWith(suffix.toLowerCase()) ? name : name + `_` + suffix;
		this.addInclude(`#include<${type}.h>`);
		this.addVarDef(`${type} ${key}(${pin});\n`);
		return key;
	}
	finish(workspace, setupCode){
		this.collectVarDefs(workspace.variables?.variable);
		this.addStage(this.STAGE_FUNC_DEF, '%setup-b%');
		this.addStage(this.STAGE_SETUP, setupCode + '%setup-e%\n%loop-b%');
		this.addStage(this.STAGE_LOOP, '%loop-e%');
		let code = this.genStageCode();
		const index = code.indexOf('\nwhile(true){\n');
		if(index > 0){
			const text = code.slice(index, code.indexOf('\n}', index) + 2);
			code = code.replace(text, '').replace('%loop-e%', untab(text.slice(14, -1)) + '$&');
		}
		return code.replace(/%(setup|loop)-b%\n(.*)%\1-e%/gs, (_, n, v) => `void ${n}(){\n${tab(v)}}\n`);
	}
}

Arduino.prototype.onGenVarDef = function(){
	const varType = {
		"Number": 'double',
		"String": 'String',
		"Boolean": 'bool',
		"Array": 'LinkedList',
		"": 'double',
	};
	return (name, type) => `${varType[type]} ${name}`;
}();

Object.assign(Arduino.prototype, {
	ORDER_ATOMIC: 0,
	ORDER_HIGH: 1,
	ORDER_EXPONENTIATION: 2,
	ORDER_UNARY: 3,
	ORDER_MULTIPLICATIVE: 4,
	ORDER_ADDITIVE: 5,
	ORDER_SHIFT: 6,
	ORDER_RELATIONAL: 7,//<,<=,>,>=
	ORDER_EQUAL: 8,//==, !=
	ORDER_BIT_AND: 9,
	ORDER_BIT_XOR: 10,
	ORDER_BIT_OR: 11,
	ORDER_AND: 12,
	ORDER_OR: 13,
	ORDER_NONE: 99,
	END: ';\n',
	COMMENT:'//',
	needBrackets: needBrackets([2, 3]),//ORDER_EXPONENTIATION, ORDER_UNARY
});

module.exports = Arduino;
