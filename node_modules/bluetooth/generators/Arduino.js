
const wrapFn = require( 'utils/function/overrideMethod');
const {message} = antd;

const ORDER_ATOMIC = 0;
const ORDER_HIGH = 1;
const ORDER_EXPONENTIATION = 2;
const ORDER_UNARY = 3;
const ORDER_MULTIPLICATIVE = 4;
const ORDER_ADDITIVE = 5;
const ORDER_CONCATENATION = 6;
const ORDER_RELATIONAL = 7;
const ORDER_AND = 8;
const ORDER_OR = 9;
const ORDER_NONE = 99;
const END = ';\n';

module.exports = function(){
	const Arduino = new Blockly.Generator('Arduino');
	Arduino.ORDER_ATOMIC = ORDER_ATOMIC;
	Arduino.ORDER_NONE = ORDER_NONE;
	Arduino.ORDER_HIGH = ORDER_HIGH;
	Arduino.ORDER_UNARY = ORDER_UNARY;
	Arduino.ORDER_ADDITIVE = ORDER_ADDITIVE;
	Arduino.ORDER_RELATIONAL = ORDER_RELATIONAL;
	Arduino.END = END;

	Arduino.commentStart = '//';

	Arduino.init = function(){
		this.needHandleLoop = false;
		this.indent = 1;
		this.funcDef = {};
		this.usedNames = new Set();
		this.varDef = {};
		this.varType = {};
		this.includeDict = {};
		this.setupDict = {};
		this.loopDict = {};
		this.needGenLoopFunc = false;
		this.irFlag = false;
	}

	Arduino.insertUpdateCode = function(){
		if(!this.needGenLoopFunc)return '';
		return this.tab() + this.INDENT + `update()` + END;
	}

	Arduino.onCodeMissed = function(text, v=0){
		text = text.replace(/\*\//g, '*\\/');
		return [`${v}/*${text}*/`, ORDER_ATOMIC];
	}
	Arduino.onStatementMissed = function(text){
		return this.tab() + this.commentStart + text + this.END;
	}
	Arduino.onGenVarDef = (new_name, name, type) => (type ? `LinkedList ${new_name}` : `${Arduino.varType[new_name] || 'double'} ${new_name} = 0`) + `;\t//${name}`;
	Arduino.onGenFuncBody = (name, args, body) => `void ${name}(${args.map(v => v.join(' ')).join(', ')}){\n${body}}\n`;
	
	Arduino.finish = function(workspace, setupBlock, loopBlock, funcBlockList){
		funcBlockList.map(v => v.getNextBlock()).concat(setupBlock).forEach(this.blockToCode, this);
		
		this.addFuncDef('sleep', [['unsigned long', 'duration']], [
			'unsigned long end = millis() + duration',
			'while(millis() < end)update()'
		]);

		this.collectFuncDefs(funcBlockList);
		this.needHandleLoop = true;
		let setupCode = this.blockToCode(setupBlock);
		this.needHandleLoop = false;
		let loopCode = this.blockToCode(loopBlock);
		this.collectVarDefs(workspace);
		if(setupCode){
			setupCode = this.generateSetupCodes() + setupCode;
		}else{
			setupCode = this.generateSetupCodes().replace(/\n\n$/, '\n');
		}
		void function(codeList){
			if(codeList.length <= 0)return;
			loopCode = Arduino.INDENT + 'update()' + END + loopCode;
			Arduino.addFuncDef('update', [], codeList);
			Arduino.markNameUsed('update');
		}(Object.values(this.loopDict));
		
		let result = this.generateIncludes();
		result += this.generateVarDefs();
		result += `void setup(){\n${setupCode}}\n\nvoid loop(){\n${loopCode}}\n\n`;
		result += this.generateFuncDefs();
		return result;
	}
	const calcBlockCount = (control_blocks => block => {
		let result = 0;
		for(; block; block = block.getNextBlock()){
			++result;
			if(!control_blocks.includes(block.type))continue;
			result += calcBlockCount(block.getInputTargetBlock('SUBSTACK'));
			if(block.type != 'control_if_else')continue;
			result += calcBlockCount(block.getInputTargetBlock('SUBSTACK2'));
		}
		return result;
	})(['control_if', 'control_if_else', 'control_forever', 'control_repeat', 'control_repeat_until']);
	const special_blocks = ['weeemake_generate_offline_code', 'procedures_definition'];
	const findBestBlock = blocks => blocks.map(b => [b, calcBlockCount(b)]).sort((a, b) => b[1] - a[1])[0][0];
	Arduino.workspaceToCode = function(workspace){
		const blockList = workspace.getTopBlocks();
		let setupBlock, loopBlock, funcBlockList = [];
		function bindBlock(block){
			setupBlock = block;
			while(block.getNextBlock()){
				block = block.getNextBlock();
			}
			if(block.type === 'control_forever'){
				loopBlock = block.getInputTargetBlock('SUBSTACK');
				return true;
			}
		}
		this.init(workspace);
		for(let block of blockList){
			if(block.type !== 'procedures_definition')continue;
			funcBlockList.push(block);
		}
		let blocks = blockList.filter(block => block.type == 'when_start' && block.getNextBlock());
		if(blocks.length <= 0){
			blocks = blockList.filter(block => !special_blocks.includes(block.type));
		}
		if(blocks.length > 0){
			let subBlocks = blocks.filter(bindBlock);
			if(subBlocks.length > 0){
				blocks = subBlocks;
			}
			bindBlock(findBestBlock(blocks));
		}
		return this.finish(workspace, setupBlock, loopBlock, funcBlockList);
	}
	Arduino.looks_say = function(block){
		this.addSetupCode('Serial.begin(115200)');
		let text = this.valueToCode(block, "MESSAGE", ORDER_NONE);
		return Arduino.tab() + `Serial.println(${text})` + END;
	}
	Arduino.sensing_timer = function(block){
		return ['millis() * 0.001', ORDER_MULTIPLICATIVE];
	}
	Arduino.control_wait = function(block){
		if(Arduino.needGenLoopFunc)Arduino.markNameUsed('sleep');
		let value = Arduino.valueToCode(block, 'DURATION', ORDER_MULTIPLICATIVE);
		let number = Number(value);
		let text = isNaN(number) ? `${value} * 1000` : number * 1000;
		let fn = Arduino.needGenLoopFunc ? 'sleep' : 'delay';
		return Arduino.tab() + `${fn}(${text})` + END;
	}
	Arduino.control_stop = function(block){
		return Arduino.tab() + `while(true)` + END;
	}
	const notCondition = block => {
		let condition = Arduino.valueToCode(block, 'CONDITION', ORDER_UNARY);
		return condition ? `!${condition}` : 'true';
	};
	Arduino.control_wait_until = function(block){
		return Arduino.tab() + `while(${notCondition(block)})` + (this.needGenLoopFunc ? 'update()' : '') + END;
	}
	Arduino.control_repeat_until = function(block){
		if(!block.getInputTargetBlock('SUBSTACK'))
			return Arduino.control_wait_until(block);
		let tab = Arduino.tab();
		let case1Code = this.insertUpdateCode() + this.statementToCodeIndent(block, 'SUBSTACK');
		return `${tab}while(${notCondition(block)}){\n${case1Code}${tab}}\n`;
	}

	Arduino.control_if = function(block){
		let condition = Arduino.valueToCode(block, 'CONDITION', ORDER_NONE) || 'false';
		let case1 = block.getInputTargetBlock('SUBSTACK');
		let tab = Arduino.tab();
		if(case1 == null)return tab + `if(${condition})` + END;
		let case1Code = Arduino.statementToCodeIndent(block, 'SUBSTACK');
		return `${tab}if(${condition}){\n${case1Code}${tab}}\n`;
	}
	Arduino.control_if_else = function(block){
		let condition = Arduino.valueToCode(block, 'CONDITION', ORDER_NONE) || 'false';
		let case1 = block.getInputTargetBlock('SUBSTACK');
		let case2 = block.getInputTargetBlock('SUBSTACK2');
		let case1Code = Arduino.statementToCodeIndent(block, 'SUBSTACK');
		let case2Code;
		let isCase1Null = case1 == null;
		let isCase2Null = case2 == null;
		let tab = Arduino.tab();
		if(isCase1Null && isCase2Null)return tab + `if(${condition})` + END;
		if(isCase2Null)return `${tab}if(${condition}){\n${case1Code}${tab}}\n`;
		if(!case2.getNextBlock() && (case2.type === 'control_if' || case2.type === 'control_if_else')){
			case2Code = Arduino.statementToCode(block, 'SUBSTACK2');
			return `${tab}if(${condition}){\n${case1Code}${tab}}else ${case2Code.trimStart()}`;
		}
		case2Code = Arduino.statementToCodeIndent(block, 'SUBSTACK2');
		if(isCase1Null)return `${tab}if(${notCondition(block)}){\n${case2Code}${tab}}\n`;
		return `${tab}if(${condition}){\n${case1Code}${tab}}else{\n${case2Code}${tab}}\n`;
	}
	Arduino.control_repeat = function(block){
		let tab = Arduino.tab();
		let count = Arduino.valueToCode(block, "TIMES", ORDER_NONE) || '0';
		let subCode = Arduino.statementToCodeIndent(block, 'SUBSTACK');
		let name = 'i';
		return `${tab}for(int ${name}=${count}; ${name}>0; --${name})` + (subCode ? `{\n${subCode}${tab}}\n` : END);
	}
	Arduino.control_forever = function(block){
		if(this.needHandleLoop && this.indent === 1)return null;
		if(!block.getInputTargetBlock('SUBSTACK'))
			return Arduino.tab() + 'while(true)' + END;
		let tab = Arduino.tab();
		let subCode = this.insertUpdateCode() + this.statementToCodeIndent(block, 'SUBSTACK');
		return `${tab}while(true){\n${subCode}${tab}}\n`;
	}
	Arduino.operator_add = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_ADDITIVE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_ADDITIVE) || "0";
		return [`${a} + ${b}`, ORDER_ADDITIVE];
	}
	Arduino.operator_subtract = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_ADDITIVE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_ADDITIVE) || "0";
		return [`${a} - ${b}`, ORDER_ADDITIVE];
	}
	Arduino.operator_multiply = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_MULTIPLICATIVE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_MULTIPLICATIVE) || "0";
		return [`${a} * ${b}`, ORDER_MULTIPLICATIVE];
	}
	Arduino.operator_divide = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_MULTIPLICATIVE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_MULTIPLICATIVE) || "1";
		return [`${a} / ${b}`, ORDER_MULTIPLICATIVE];
	}
	Arduino.operator_mathop = function(block){
		let op = block.getFieldValue('OPERATOR');
		let order = /^(sin|cos|tan)$/.test(op) ? ORDER_MULTIPLICATIVE : ORDER_NONE;
		let v = Arduino.valueToCode(block, "NUM", order) || '0';
		switch(op){
			case "ceiling":
				return [`ceil(${v})`, ORDER_ATOMIC];
			case "ln":
				return [`log(${v})`, ORDER_ATOMIC];
			case "log":
				return [`log10(${v})`, ORDER_ATOMIC];
			case "e ^":
				return [`exp(${v})`, ORDER_ATOMIC];
			case "10 ^":
				return [`pow(10, ${v})`, ORDER_ATOMIC];
			case "sin":
			case "cos":
			case "tan":
				return [`${op}(${v} * PI / 180.0)`, ORDER_ATOMIC];
			case "asin":
			case "acos":
			case "atan":
				return [`${op}(${v}) / PI * 180.0`, ORDER_MULTIPLICATIVE];
		}
		return [`${op}(${v})`, ORDER_ATOMIC];
	}
	const operator_compare = (operator, order) => function(block){
		let a = Arduino.valueToCode(block, "OPERAND1", order) || "0";
		let b = Arduino.valueToCode(block, "OPERAND2", order) || "0";
		return [`${a} ${operator} ${b}`, order];
	}
	Arduino.operator_gt = operator_compare('>', ORDER_RELATIONAL);
	Arduino.operator_lt = operator_compare('<', ORDER_RELATIONAL);
	Arduino.operator_equals = operator_compare('==', ORDER_RELATIONAL);
	Arduino.operator_and = operator_compare('&&', ORDER_AND);
	Arduino.operator_or = operator_compare('||', ORDER_OR);
	Arduino.operator_not = function(block){
		let v = Arduino.valueToCode(block, "OPERAND", ORDER_UNARY) || '0';
		return [`!${v}`, ORDER_UNARY];
	}
	Arduino.operator_mod = function(block){
		let a = Arduino.valueToCode(block, "NUM1", ORDER_NONE) || "0";
		let b = Arduino.valueToCode(block, "NUM2", ORDER_NONE) || "1";
		return [`fmod(${a}, ${b})`, ORDER_HIGH];
	}
	Arduino.operator_round = function(block){
		let v = Arduino.valueToCode(block, "NUM", ORDER_NONE) || "0";
		return [`int(round(${v}))`, ORDER_HIGH];
	}
	Arduino.operator_random = function(block){
		let a = Arduino.valueToCode(block, "FROM", ORDER_NONE) || "0";
		let b = Arduino.valueToCode(block, "TO", ORDER_ADDITIVE) || "1";
		return [`random(${a}, ${b} + 1)`, ORDER_HIGH];
	}
	Arduino.operator_join = function(block){
		let a = Arduino.valueToCode(block, "STRING1", ORDER_NONE);
		let b = Arduino.valueToCode(block, "STRING2", ORDER_NONE);
		return [`String(${a}) + String(${b})`, ORDER_ADDITIVE];
	}
	Arduino.operator_letter_of = function(block){
		let index = this.calcListIndex(block, 'LETTER');
		let text = Arduino.valueToCode(block, "STRING", ORDER_NONE);
		return [`String(${text}).charAt(${index})`, ORDER_HIGH];
	}
	Arduino.operator_length = function(block){
		let text = Arduino.valueToCode(block, "STRING", ORDER_NONE);
		return [`String(${text}).length()`, ORDER_HIGH];
	}
	Arduino.operator_contains = function(block){
		let a = Arduino.valueToCode(block, "STRING1", ORDER_NONE);
		let b = Arduino.valueToCode(block, "STRING2", ORDER_NONE);
		return [`String(${a}).indexOf(String(${b})) >= 0`, ORDER_RELATIONAL];
	}
	Arduino.data_addtolist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.push(${item})`, raw_name);
	}
	Arduino.data_deleteoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.removeAt(${index})`, raw_name);
	}
	Arduino.data_deletealloflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.clear()`, raw_name);
	}
	Arduino.data_insertatlist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.insertAt(${index}, ${item})`, raw_name);
	}
	Arduino.data_replaceitemoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		return this.commentStatement(`${name}.replaceAt(${index}, ${item})`, raw_name);
	}
	Arduino.data_itemoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let index = this.calcListIndex(block);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.getValueAt(${index})`, this.ORDER_HIGH];
	}
	Arduino.data_itemnumoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.indexOf(${item}) + 1`, ORDER_ADDITIVE];
	}
	Arduino.data_lengthoflist = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.getLength()`, ORDER_HIGH];
	}
	Arduino.data_listcontainsitem = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		let item = this.valueToCode(block, 'ITEM', ORDER_NONE);
		this.markNameUsed(name);
		if(!this.isNormalName(raw_name)){
			name = this.onCodeMissed(raw_name, name)[0];
		}
		return [`${name}.include(${item})`, ORDER_HIGH];
	}
	Arduino.math_number = function(block){
		let text = block.getFieldValue('NUM');
		text = isNaN(Number(text)) ? '0' : text;
		return [text, ORDER_ATOMIC];
	}
	return Arduino;
}