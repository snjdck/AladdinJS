
const Arduino = require('./Arduino');
const ScratchOfflineCode = require('./ScratchOfflineCode');
const ArduinoOfflineCode = require('./ArduinoOfflineCode');
const {tab} = require('utils/text');

const generateCodes = dict => Object.values(dict).join('');

const castType = type => {
	if(type === 'argument_reporter_string_number')
		return 'double';
	if(type === 'argument_reporter_boolean')
		return 'bool';
	return 'int';
}

const castRetType = (type, defaultType) => {
	switch(type){
		case "CHARACTER": return 'char';
		case "TEXT": return 'String';
		case "BOOLEAN": return 'bool';
		case "SHORT_NUMBER": return 'short';
		case "NUMBER": return 'int';
		case "LARGE_NUMBER": return 'long';
		case "DECIMAL": return 'double';
	}
	return defaultType;
}


const prototype = {
	tab,
	INDENT: '\t',
	quote: JSON.stringify,
	//addBrackets: v => `(${v})`,
	isNormalName(name){
		return /^\w+$/.test(name);
	},
	commentStatement(code, text){
		let result = code + this.END;
		if(this.isNormalName(text))return result;
		return result.replace('\n', n => '\t' + this.commentStart + text + n);
	},
	numberOrText(block){
		let text = this.getFieldValue(block, 'TEXT') ?? '';
		return /^\s*$/.test(text) || isNaN(Number(text)) ? this.quote(text) : text;
	},
	addInclude(text, key=text){
		this.includeDict[key] = text;
	},
	addVarDef(text, key=text){
		this.varDef[key] = text;
	},
	addFuncDef(name, body){
		this.funcDef[name] = body;
	},
	addSetupCode(text, key=text){
		this.setupDict[key] = text;
	},
	addLoopCode(text, key=text){
		this.loopDict[key] = text;
	},
	generateIncludes(){
		return Object.values(this.includeDict).map(v => v + '\n').join('') + '\n';
	},
	generateFuncProto(){
		let funcList = Object.keys(this.funcDef);
		if(funcList.length <= 0)return '';
		return funcList.join(';\n') + ';\n\n';
	},
	generateFuncDefs(){
		let funcList = Object.entries(this.funcDef);
		if(funcList.length <= 0)return '';
		return funcList.map(v => `${v[0]}{\n${tab(v[1])}}`).join('\n\n');
	},
	collectVarDefs(vars){
		if(!vars)return;
		if(!Array.isArray(vars)){
			vars = [vars];
		}
		for(let {'#text':name, type} of vars){
			if(!type)continue;
			let new_name = this.adjustVarName(name);
			this.addVarDef(this.onGenVarDef(new_name, name, type), new_name);
		}
	},
	generateVarDefs(){
		return generateCodes.call(this, this.varDef);
	},
	generateSetupCodes(){
		return generateCodes.call(this, this.setupDict);
	},
	adjustVarName: ((p1, p2, p3, fn) => name => {
		name = name.trim();
		if(!p1.test(name))
			name = name.replace(p2, '_').replace(p3, fn);
		return '_' + name;
	})(/^[_A-Za-z0-9]+$/, /[\x20\t]+/g, /[^_A-Za-z0-9]/g, char => char.charCodeAt().toString(36)),

	blockToCode(block){
		if(!block)return '';
		let func = block.type;
		do{
			func = this.context[func];
		}while(typeof func === 'string');
		if(!func){
			if(!block.value && block.field && !Array.isArray(block.field)){
				return [block.field['#text'], this.ORDER_ATOMIC];
			}
		}
		let code;
		if(!block.disabled && func){
			const fields = Object.create(null);
			if(block.field){
				for(let field of Array.isArray(block.field) ? block.field : [block.field]){
					fields[field.name] = field['#text'];
				}
			}
			const inputs = Object.create(null);
			if(block.value){
				for(let value of Array.isArray(block.value) ? block.value : [block.value]){
					let input = value.block ?? value.shadow;
					let [code, order] = this.blockToCode(input);
					inputs[value.name] = {
						type: input.type,
						fixBrackets: (...args) => this.needBrackets(order, ...args) ? `(${code})` : code,
					};
					fields[value.name] = code;
				}
			}
			if(block.statement){
				for(let statement of Array.isArray(block.statement) ? block.statement : [block.statement]){
					fields[statement.name] = this.blockToCode(statement.block);
				}
			}
			Object.assign(fields, block.mutation);
			const isEventBlock = block.data === 'isEventBlock';
			if(isEventBlock)fields.next = this.blockToCode(block.next?.block);
			code = func.call(this, null, fields, inputs);//remove block arg
			if(isEventBlock)return code;
		}
		if(Array.isArray(code))return code;
		return (code ?? '') + this.blockToCode(block.next?.block);
	}
}

const Blockly = {Arduino:Object.assign({
	context: Object.assign({}, ScratchOfflineCode, ArduinoOfflineCode)
}, prototype, Arduino)}

module.exports = Blockly;