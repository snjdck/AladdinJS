
const Arduino = require('./Arduino');
const ScratchOfflineCode = require('./ScratchOfflineCode');
const ArduinoOfflineCode = require('./ArduinoOfflineCode');
const {tab} = require('utils/text');

const generateCodes = function(dict){
	let codeList = Object.values(dict);
	if(codeList.length <= 0)return '';
	return codeList.map(v => v + this.END).join('') + '\n';
}

const castType = type => {
	if(type === 'argument_reporter_string_number')
		return 'double';
	if(type === 'argument_reporter_boolean')
		return 'bool';
	return 'int';
}

const castRetType = (type, defaultType) => {
	switch(type){
		case "CHARACTER": return 'char';
		case "TEXT": return 'String';
		case "BOOLEAN": return 'bool';
		case "SHORT_NUMBER": return 'short';
		case "NUMBER": return 'int';
		case "LARGE_NUMBER": return 'long';
		case "DECIMAL": return 'double';
	}
	return defaultType;
}


const prototype = {
	tab,
	INDENT: '\t',
	quote: JSON.stringify,
	//addBrackets: v => `(${v})`,
	isNormalName(name){
		return /^\w+$/.test(name);
	},
	commentStatement(code, text){
		let result = code + this.END;
		if(this.isNormalName(text))return result;
		return result.replace('\n', n => '\t' + this.commentStart + text + n);
	},
	numberOrText(block){
		let text = this.getFieldValue(block, 'TEXT') ?? '';
		return /^\s*$/.test(text) || isNaN(Number(text)) ? this.quote(text) : text;
	},
	addInclude(text, key=text){
		this.includeDict[key] = text;
	},
	addVarDef(text, key=text){
		this.varDef[key] = text;
	},
	addFuncDef(type, name, args, body, comment=''){
		if(Array.isArray(body))
			body = body.map(code => this.INDENT + code + this.END).join('');
		this.funcDef[name] = [type, args, body, comment];
	},
	addSetupCode(text, key=text){
		this.setupDict[key] = text;
	},
	addLoopCode(text, key=text){
		this.loopDict[key] = text;
		this.needGenLoopFunc = true;
	},
	markNameUsed(name){
		this.usedNames.add(name);
	},
	generateIncludes(){
		return Object.values(this.includeDict).map(v => v + '\n').join('') + '\n';
	},
	generateFuncProto(){
		let funcList = Object.entries(this.funcDef).filter(([name]) => this.usedNames.has(name));
		if(funcList.length <= 0)return '';
		return funcList.map(
			([name, [retType, args, body, comment]]) => comment + `${retType} ${name}(${args.map(v => v.join(' ')).join(', ')});\n`
		).join('') + '\n';
	},
	collectFuncDefs(funcBlockList){
		const prev_indent = this.indent;
		this.indent = 1;
		//console.log(funcBlockList, funcBlockList.forEach(this.blockToCode, this))
		return
		for(let block of funcBlockList){
			/*
			let target = block.childBlocks_[0];
			let name = target.getFieldValue();
			let args = target.childBlocks_.map(v => [castType(v.type), v.getFieldValue('VALUE')]);
			let comment = `${this.commentStart}\t${name}(${args.map(v => quote(v[1])).join(', ')})\n`;
			name = this.adjustVarName(name);
			args = args.map(v => [v[0], this.adjustVarName(v[1])]);
			this.addFuncDef(name, args, this.blockToCode(block.getNextBlock()), comment);
			this.markNameUsed(name);
			//*/
			//const retType = castRetType(block.getFieldValue('RETURN_TYPE'), 'void');
			const retType = block.type == 'procedures_defreturn' ? 'double' : 'void';
			let name = block.field['#text'];
			let branch = Blockly.Arduino.statementToCode(block, 'SUBSTACK');
			let args = block._getArgList().map((v, i) => [castRetType(block.getFieldValue('ARG_TYPE_'+i), 'int'), v]);
			let comment = `${this.commentStart}\t${name}(${args.map(v => this.quote(v[1])).join(', ')})\n`;
			if(block.type == 'procedures_defreturn'){
				branch += '\treturn ' + this.valueToCode(block, 'RETURN', this.ORDER_NONE) + this.END;
			}
			//console.log(name, branch);
			//let target = block.childBlocks_[0];
			//let name = target.getFieldValue();
			//let args = target.childBlocks_.map(v => [castType(v.type), v.getFieldValue('VALUE')]);
			//let comment = `${this.commentStart}\t${name}(${args.map(v => quote(v[1])).join(', ')})\n`;
			name = this.adjustVarName(name);
			args = args.map(v => [v[0], this.adjustVarName(v[1])]);
			this.addFuncDef(retType, name, args, branch, comment);
			this.markNameUsed(name);
		}
		this.indent = prev_indent;
	},
	generateFuncDefs(){
		let funcList = Object.entries(this.funcDef).filter(([name]) => this.usedNames.has(name));
		if(funcList.length <= 0)return '';
		return funcList.map(
			([name, [type, args, body, comment]]) => comment + this.onGenFuncBody(type, name, args, body)
		).join('\n') + '\n';
	},
	collectVarDefs(vars){
		if(!vars)return;
		if(!Array.isArray(vars)){
			vars = [vars];
		}
		for(let {'#text':name, type} of vars){
			let new_name = this.adjustVarName(name);
			if(!this.usedNames.has(new_name))continue;
			this.addVarDef(this.onGenVarDef(new_name, name, type), new_name);
		}
	},
	generateVarDefs(){
		return generateCodes.call(this, this.varDef);
	},
	generateSetupCodes(){
		return generateCodes.call(this, this.setupDict);
	},
	adjustVarName: ((p1, p2, p3, fn) => name => {
		name = name.trim();
		if(!p1.test(name))
			name = name.replace(p2, '_').replace(p3, fn);
		return '_' + name;
	})(/^[_A-Za-z0-9]+$/, /[\x20\t]+/g, /[^_A-Za-z0-9]/g, char => char.charCodeAt().toString(36)),

	notCondition(block){
		let condition = this.valueToCode(block, 'CONDITION', this.ORDER_UNARY);
		return condition ? `!${condition}` : 'true';
	},
	blockToCode(block){
		if(!block)return '';
		let func = block.type;
		do{
			func = this.context[func];
		}while(typeof func === 'string');
		if(!func){
			if(!block.value && block.field && !Array.isArray(block.field)){
				return [block.field['#text'], this.ORDER_ATOMIC];
			}
		}
		let code;
		if(!block.disabled && func){
			const fields = Object.create(null);
			if(block.field){
				for(let field of Array.isArray(block.field) ? block.field : [block.field]){
					fields[field.name] = field['#text'];
				}
			}
			const inputs = Object.create(null);
			if(block.value){
				for(let value of Array.isArray(block.value) ? block.value : [block.value]){
					let input = value.block ?? value.shadow;
					let [code, order] = this.blockToCode(input);
					inputs[value.name] = {
						type: input.type,
						fixBrackets: (...args) => this.needBrackets(order, ...args) ? `(${code})` : code,
					};
					fields[value.name] = code;
				}
			}
			if(block.statement){
				for(let statement of Array.isArray(block.statement) ? block.statement : [block.statement]){
					fields[statement.name] = tab(this.blockToCode(statement.block));
				}
			}
			code = func.call(this, block, fields, inputs);//remove block arg
		}else if(block.outputShape_ === null || block.outputShape_ === 3){
			code = this.onStatementMissed(block.type + '()');
		}else{
			code = this.onCodeMissed(block.type + '()');
		}
		if(Array.isArray(code)){
			return code;
			//return [this.scrub_(block, code[0]), code[1]];
		}
		if(typeof code === 'string'){
			return code + this.blockToCode(block.next?.block);
		}
		if(code === null)return '';
		console.error('Invalid code generated: ' + code);
	},
}

const Blockly = {Arduino:Object.assign({
	context: Object.assign({}, ScratchOfflineCode, ArduinoOfflineCode)
}, prototype, Arduino)}

module.exports = Blockly;