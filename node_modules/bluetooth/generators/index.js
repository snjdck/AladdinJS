
const Arduino = require('./Arduino');
const ArduinoOfflineCode = require('./ArduinoOfflineCode');

const numberOrText = block => {
	let text = block.getFieldValue('TEXT');
	return /^\s*$/.test(text) || isNaN(Number(text)) ? quote(text) : text;
}

const quote = v => '"' + v.replace(/"/g, '\\"') + '"';

const generateCodes = function(dict, tab){
	let codeList = Object.values(dict);
	if(codeList.length <= 0)return '';
	return codeList.map(v => tab + v + this.END).join('') + '\n';
}

const castType = type => {
	if(type === 'argument_reporter_string_number')
		return 'double';
	if(type === 'argument_reporter_boolean')
		return 'bool';
	return 'int';
}

const castRetType = (type, defaultType) => {
	switch(type){
		case "CHARACTER": return 'char';
		case "TEXT": return 'String';
		case "BOOLEAN": return 'bool';
		case "SHORT_NUMBER": return 'short';
		case "NUMBER": return 'int';
		case "LARGE_NUMBER": return 'long';
		case "DECIMAL": return 'double';
	}
	return defaultType;
}

void function(prototype){
	prototype.INDENT = '\t';
	prototype.quote = quote;
	prototype.isNormalName = name => /^\w+$/.test(name);
	prototype.tab = function(){
		return this.INDENT.repeat(this.indent);
	}
	prototype.commentStatement = function(code, text){
		let result = this.tab() + code + this.END;
		if(this.isNormalName(text))return result;
		return result.replace('\n', n => '\t' + this.commentStart + text + n);
	}
	prototype.addInclude = function(text, key=text){
		this.includeDict[key] = text;
	}
	prototype.addVarDef = function(text, key=text){
		this.varDef[key] = text;
	}
	prototype.addFuncDef = function(type, name, args, body, comment=''){
		if(Array.isArray(body))
			body = body.map(code => this.INDENT + code + this.END).join('');
		this.funcDef[name] = [type, args, body, comment];
	}
	prototype.addSetupCode = function(text, key=text){
		this.setupDict[key] = text;
	}
	prototype.addLoopCode = function(text, key=text){
		this.loopDict[key] = text;
		this.needGenLoopFunc = true;
	}
	prototype.markNameUsed = function(name){
		this.usedNames.add(name);
	}
	prototype.generateIncludes = function(){
		return Object.values(this.includeDict).map(v => v + '\n').join('') + '\n';
	}
	prototype.collectFuncDefs = function(funcBlockList){
		const prev_indent = this.indent;
		this.indent = 1;
		for(let block of funcBlockList){
			/*
			let target = block.childBlocks_[0];
			let name = target.getFieldValue();
			let args = target.childBlocks_.map(v => [castType(v.type), v.getFieldValue('VALUE')]);
			let comment = `${this.commentStart}\t${name}(${args.map(v => quote(v[1])).join(', ')})\n`;
			name = this.adjustVarName(name);
			args = args.map(v => [v[0], this.adjustVarName(v[1])]);
			this.addFuncDef(name, args, this.blockToCode(block.getNextBlock()), comment);
			this.markNameUsed(name);
			//*/
			//const retType = castRetType(block.getFieldValue('RETURN_TYPE'), 'void');
			const retType = block.type == 'procedures_defreturn' ? 'double' : 'void';
			let name = block.getFieldValue('NAME');
			let branch = Blockly.Arduino.statementToCode(block, 'STACK');
			let args = block.arguments_.map((v, i) => [castRetType(block.getFieldValue('ARG_TYPE_'+i), 'int'), v]);
			let comment = `${this.commentStart}\t${name}(${args.map(v => quote(v[1])).join(', ')})\n`;
			if(block.type == 'procedures_defreturn'){
				branch += '\treturn ' + this.valueToCode(block, 'RETURN', this.ORDER_NONE) + this.END;
			}
			//console.log(name, branch);
			//let target = block.childBlocks_[0];
			//let name = target.getFieldValue();
			//let args = target.childBlocks_.map(v => [castType(v.type), v.getFieldValue('VALUE')]);
			//let comment = `${this.commentStart}\t${name}(${args.map(v => quote(v[1])).join(', ')})\n`;
			name = this.adjustVarName(name);
			args = args.map(v => [v[0], this.adjustVarName(v[1])]);
			this.addFuncDef(retType, name, args, branch, comment);
			this.markNameUsed(name);
		}
		this.indent = prev_indent;
	}
	prototype.generateFuncDefs = function(){
		let funcList = Object.entries(this.funcDef).filter(([name]) => this.usedNames.has(name));
		if(funcList.length <= 0)return '';
		return funcList.map(
			([name, [type, args, body, comment]]) => comment + this.onGenFuncBody(type, name, args, body)
		).join('\n') + '\n';
	}
	prototype.collectVarDefs = function(workspace){
		for(let {name, type} of workspace.variableMap_.getAllVariables()){
			let new_name = this.adjustVarName(name);
			if(!this.usedNames.has(new_name))continue;
			this.addVarDef(this.onGenVarDef(new_name, name, type), new_name);
		}
	}
	prototype.generateVarDefs = function(){
		return generateCodes.call(this, this.varDef, '');
	}
	prototype.generateSetupCodes = function(){
		return generateCodes.call(this, this.setupDict, this.tab());
	}
	prototype.adjustVarName = ((p1, p2, p3, fn) => name => {
		name = name.trim();
		if(!p1.test(name))
			name = name.replace(p2, '_').replace(p3, fn);
		return '_' + name;
	})(/^[_A-Za-z0-9]+$/, /[\x20\t]+/g, /[^_A-Za-z0-9]/g, char => char.charCodeAt().toString(36));
	prototype.prefixLines = code => code;
	prototype.scrub_ = function(block, code){
		return code + this.blockToCode(block.getNextBlock());
	}
	prototype.statementToCodeIndent = function(block, name){
		this.indent++;
		let result = this.statementToCode(block, name);
		this.indent--;
		return result;
	}
	prototype.blockToCode = function(block){
		if(!block)return '';
		let func = this[block.type];
		let code;
		if(!block.disabled && func){
			code = func.call(this, block);
		}else if(block.outputShape_ === null || block.outputShape_ === 3){
			code = this.onStatementMissed(block.type + '()');
		}else{
			code = this.onCodeMissed(block.type + '()');
		}
		if(Array.isArray(code)){
			return [this.scrub_(block, code[0]), code[1]];
		}
		if(typeof code === 'string'){
			return this.scrub_(block, code);
		}
		if(code === null){
			return '';
		}
		console.error('Invalid code generated: ' + code);
	}
	prototype.variables_get = function(block){
		let raw_name = block.getField('VAR').variable_.name;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		if(this.isNormalName(raw_name))
			return [name, this.ORDER_ATOMIC];
		return this.onCodeMissed(raw_name, name);
	}
	prototype.variables_set = function(block){
		let raw_name = block.getField('VAR').variable_.name;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		let valueBlock = block.getInputTargetBlock('VALUE');
		if(!valueBlock){
			return this.commentStatement(`${name} = 0`, raw_name);
		}
		let value;
		if(valueBlock.type === 'text'){
			value = numberOrText(valueBlock);
		}else{
			value = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		}
		return this.commentStatement(`${name} = ${value}`, raw_name);
	}
	prototype.math_change = function(block){
		let raw_name = block.getField('VAR').variable_.name;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		let value = this.valueToCode(block, 'DELTA', this.ORDER_NONE);
		return this.commentStatement(`${name} += ${value}`, raw_name);
	}
	/*
	prototype.data_setvariableto = function(block){
		let raw_name = block.getField('VARIABLE').text_;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		let valueBlock = block.getInputTargetBlock('VALUE');
		let value;
		if(valueBlock.type === 'text'){
			value = numberOrText(valueBlock);
		}else{
			value = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		}
		return this.commentStatement(`${name} = ${value}`, raw_name);
	}
	prototype.data_changevariableby = function(block){
		let raw_name = block.getField('VARIABLE').text_;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		let value = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		return this.commentStatement(`${name} += ${value}`, raw_name);
	}
	prototype.data_variable = function(block){
		let raw_name = block.getField('VARIABLE').text_;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		if(this.isNormalName(raw_name))
			return [name, this.ORDER_ATOMIC];
		return this.onCodeMissed(raw_name, name);
	}
	prototype.data_listcontents = function(block){
		let raw_name = block.getField('LIST').text_;
		let name = this.adjustVarName(raw_name);
		this.markNameUsed(name);
		if(this.isNormalName(raw_name))
			return [name, this.ORDER_ATOMIC];
		return this.onCodeMissed(raw_name, name);
	}
	*/
	prototype.procedures_call = function(block){
		let raw_name = block.getFieldValue();
		let name = this.adjustVarName(raw_name);
		let args = block.argumentIds_.map(id => this.valueToCode(block, id, this.ORDER_NONE) || '0');
		return this.commentStatement(`${name}(${args.join(', ')})`, raw_name);
	}
	prototype.procedures_callnoreturn = function(block){
		return this.tab() + this.procedures_callreturn(block)[0] + this.END;
	}
	prototype.procedures_callreturn = function(block){
		const name = this.adjustVarName(block.getFieldValue('NAME'));
		const args = block.arguments_.map((_, i) => this.valueToCode(block, 'ARG'+i, this.ORDER_NONE));
		return [`${name}(${args.join(', ')})`, this.ORDER_ATOMIC];
	}
	prototype.procedures_return = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', this.ORDER_NONE);
		return this.tab() + `return ${VALUE}` + this.END;
	}
	prototype.procedures_ifreturn = function(block){
		const VALUE = this.valueToCode(block, 'VALUE', this.ORDER_NONE) || '0';
		const CONDITION = this.valueToCode(block, 'CONDITION', this.ORDER_NONE) || 'false';
		return this.tab() + `if(${CONDITION})return${block.hasReturnValue_ ? ' ' + VALUE : ''}` + this.END;
	}
	prototype.argument_reporter_boolean = 
	prototype.argument_reporter_string_number = function(block){
		let name = this.adjustVarName(block.getFieldValue('VALUE'));
		this.markNameUsed(name);
		return [name, 0];
	}
	prototype.colour_picker = function(block){
		return [block.getFieldValue('COLOUR').replace('#', '0x'), this.ORDER_ATOMIC];
	}
	prototype.text = function(block){
		return [numberOrText(block), this.ORDER_ATOMIC];
	}
	prototype.math_lists_index =
	prototype.math_angle =
	prototype.math_integer =
	prototype.math_positive_number =
	prototype.math_whole_number =
	prototype.math_number = function(block){
		let text = block.getFieldValue('NUM');
		text = isNaN(Number(text)) ? '0' : text;
		return [text, this.ORDER_ATOMIC];
	}

	prototype.calcListIndex = function(block, key='INDEX'){
		let index = this.valueToCode(block, key, this.ORDER_ADDITIVE);
		let number = Number(index);
		return isNaN(number) ? `${index} - 1` : number - 1;
	}
}(Blockly.Arduino = Arduino());

ArduinoOfflineCode(Blockly.Arduino);