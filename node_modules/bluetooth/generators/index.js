
const Arduino = require('./Arduino');
const ArduinoScratchCode = require('./ScratchOfflineCode');
const ArduinoExternalCode = require('./ArduinoOfflineCode');
const {tab} = require('utils/text');
const {createListGetter} = require('utils/cache');

const castType = type => {
	if(type === 'argument_reporter_string_number')
		return 'double';
	if(type === 'argument_reporter_boolean')
		return 'bool';
	return 'int';
}

const castRetType = (type, defaultType) => {
	switch(type){
		case "CHARACTER": return 'char';
		case "TEXT": return 'String';
		case "BOOLEAN": return 'bool';
		case "SHORT_NUMBER": return 'short';
		case "NUMBER": return 'int';
		case "LARGE_NUMBER": return 'long';
		case "DECIMAL": return 'double';
	}
	return defaultType;
}

const prototype = {
	tab,
	quote: JSON.stringify,
	STAGE_INCLUDE:0,
	STAGE_VAR:1,
	STAGE_FUNC_PROTO:2,
	STAGE_FUNC_DEF:3,
	STAGE_SETUP:4,
	STAGE_LOOP:5,
	initStage(){
		this._stage = [];
		this.stage = createListGetter(() => Object.create(null), this._stage);
	},
	addStage(index, code, key=code){
		this.stage(index)[key] = code;
	},
	genStageCode(){
		return Object.values(this._stage).map(v => Object.values(v).join('')).join('\n');
	},
	isNormalName(name){
		return /^\w+$/.test(name);
	},
	commentStatement(code, text){
		let result = code + this.END;
		if(this.isNormalName(text))return result;
		return result.replace('\n', n => '\t' + this.commentStart + text + n);
	},
	addInclude(text, key=text){
		this.addStage(this.STAGE_INCLUDE, text+'\n', key);
	},
	addVarDef(text, key=text){
		this.addStage(this.STAGE_VAR, text, key);
	},
	addSetupCode(text, key=text){
		this.addStage(this.STAGE_SETUP, text, key);
	},
	addLoopCode(text, key=text){
		this.addStage(this.STAGE_LOOP, text, key);
	},
	collectVarDefs(vars){
		if(!vars)return;
		if(!Array.isArray(vars)){
			vars = [vars];
		}
		for(let {'#text':name, type} of vars){
			if(!type)continue;
			let new_name = this.adjustVarName(name);
			this.addVarDef(this.onGenVarDef(new_name, name, type), new_name);
		}
	},
	adjustVarName: ((p1, p2, p3, fn) => name => {
		name = name.trim();
		if(!p1.test(name))
			name = name.replace(p2, '_').replace(p3, fn);
		return '_' + name;
	})(/^[_A-Za-z0-9]+$/, /[\x20\t]+/g, /[^_A-Za-z0-9]/g, char => char.charCodeAt().toString(36)),

	blockToCode(block){
		if(!block)return '';
		let func = block.type;
		do{
			func = this.context[func];
		}while(typeof func === 'string');
		if(!func){
			if(!block.value && block.field && !Array.isArray(block.field)){
				return [block.field['#text'], this.ORDER_ATOMIC];
			}
		}
		let code;
		if(!block.disabled && func){
			const fields = Object.create(null);
			if(block.field){
				for(let field of Array.isArray(block.field) ? block.field : [block.field]){
					fields[field.name] = field['#text'];
				}
			}
			const inputs = Object.create(null);
			if(block.value){
				for(let value of Array.isArray(block.value) ? block.value : [block.value]){
					let input = value.block ?? value.shadow;
					let [code, order] = this.blockToCode(input);
					inputs[value.name] = {
						type: input.type,
						fixBrackets: (...args) => this.needBrackets(order, ...args) ? `(${code})` : code,
					};
					fields[value.name] = code;
				}
			}
			if(block.statement){
				for(let statement of Array.isArray(block.statement) ? block.statement : [block.statement]){
					fields[statement.name] = this.blockToCode(statement.block);
				}
			}
			Object.assign(fields, block.mutation);
			if(this.isEventBlock(block))fields.next = this.blockToCode(block.next?.block);
			code = func.call(this, null, fields, inputs);//remove block arg
			if(this.isEventBlock(block))return code;
		}
		if(Array.isArray(code))return code;
		return (code ?? '') + this.blockToCode(block.next?.block);
	},
	init(){
		this.initStage();
	},
	workspaceToCode(workspace){
		if(!workspace.block)return '';
		const blockList = Array.isArray(workspace.block) ? workspace.block : [workspace.block]
		this.init();
		blockList.filter(this.isFunctionBlock).forEach(this.blockToCode, this);
		const code = blockList.filter(this.isEventBlock).map(this.blockToCode, this).join('');
		return this.finish(workspace, code);
	},
	isFunctionBlock(block){
		return block.type === 'procedures_defreturn' || block.type === 'procedures_defnoreturn' || block.type === 'procedures_def';
	},
	isEventBlock(block){
		return block.data === 'isEventBlock';
	}
}

const Blockly = {Arduino:Object.assign({
	context: Object.assign({}, ArduinoScratchCode, ArduinoExternalCode)
}, prototype, Arduino)}

module.exports = Blockly;