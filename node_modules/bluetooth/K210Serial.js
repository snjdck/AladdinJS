
const ChromeSerial = require('webonly/chrome/ChromeSerial');
const {TaskQueue} = require('utils/task');
const crypto = require('crypto');
const crc32 = require('fileformats/crc32');
const esp32 = require('./ESP32Serial');

const ISP_PROG = require('./K210_bin');

class Serial extends ChromeSerial
{
	constructor(){
		super();
		this.sendQueue = TaskQueue();
		this.on('closed', () => this.emit('packet'));
	}

	async reset(rts=false){
		await this.setControlSignals({dtr:false, rts:false});
		await this.delay(50);
		await this.setControlSignals({dtr:true, rts:false});
		await this.delay(50);
		await this.setControlSignals({dtr:false, rts});
		await this.delay(50);
	}

	async upload(data, offset=0, progressFn=null){
		await this.reset(true);
		await this.write_bootloader(progressFn);
		await this.change_bitrate(1500000);
		await this.write_flash(data, offset, progressFn);
		await this.update(115200);
		await this.reset();
	}
}

Serial.prototype.change_bitrate = function(){
	function buildPacket(bitrate){
		let b = Buffer.alloc(12);
		b.writeUInt32LE(4, 4);
		b.writeUInt32LE(bitrate, 8);
		return b;
	}
	return async function(bitrate){
		await this.send_cmd(0xd6, buildPacket(bitrate), -1);
		await this.delay(50);
		await this.update(bitrate);
	}
}();

Serial.prototype.write_bootloader = function(){
	const address = 0x80000000;
	return async function(progressFn=null){
		await this.write_dataframe(0xc3, 1024, ISP_PROG, address, progressFn);
		let b = Buffer.alloc(8);
		b.writeUInt32LE(address, 0);
		await this.send_cmd(0xc5, b, -1);//reboot
		await this.delay(50);
	}
}();

Serial.prototype.write_dataframe = function(){
	function memBlock(data, offset){
		let b = Buffer.alloc(8);
		b.writeUInt32LE(offset, 0);
		b.writeUInt32LE(data.length, 4);
		return Buffer.concat([b, data]);
	}
	return async function(cmd, frameSize, data, offset, progressFn=null){
		for(let i=0, n=data.length; i<n; i+=frameSize){
			const packet = data.slice(i, i+frameSize);
			await this.send_cmd(cmd, memBlock(packet, offset+i));
			progressFn?.((i + packet.length) / data.length);
		}
	}
}();

Serial.prototype.write_flash = function(){
	function memBegin(chipType){
		let b = Buffer.alloc(8);
		b.writeUInt32LE(chipType, 0);
		return b;
	}
	const sha256 = v => crypto.createHash('sha256').update(v).digest();
	return async function(data, offset=0, progressFn=null){
		if(offset == 0){
			const dataNew = Buffer.concat([Buffer.alloc(5), data]);
			dataNew.writeUInt32LE(data.length, 1);
			data = Buffer.concat([dataNew, sha256(dataNew)]);
		}
		data = this.align_data(data, 4096);
		await this.send_cmd(0xd7, memBegin(1));
		await this.write_dataframe(0xd4, 0x10000, data, offset, progressFn);
	}
}();

Serial.prototype.send_cmd = function(){
	const head = Buffer.alloc(8);
	return function(op, data, timeout=1000){
		head.writeUInt16LE(op, 0);
		head.writeInt32LE(crc32(data) & 0xFFFFFFFF, 4);
		return this.send([...head, ...data], timeout).then(result => {
			if(timeout < 0)return;
			if(result.length === 2 && result[0] === op && result[1] === 0xE0)return;
			return Promise.reject();
		});
	}
}();

for(let key of ['align_data', 'delay', 'send', 'recv']){
	Serial.prototype[key] = esp32.prototype[key];
}

module.exports = Serial;