
const ChromeSerial = require('webonly/chrome/ChromeSerial');
const {TaskQueue} = require('utils/task');
const crypto = require('crypto');
const crc32 = require('fileformats/crc32');
const esp32 = require('./ESP32Serial');

const ISP_PROG = require('./K210_bin');

class Serial extends ChromeSerial
{
	constructor(){
		super();
		this.sendQueue = TaskQueue();
		this.on('closed', () => this.emit('packet'));
	}

	async reset(rts=false){
		await this.setControlSignals({dtr:false, rts:false});
		await this.delay(50);
		await this.setControlSignals({dtr:true, rts:false});
		await this.delay(50);
		await this.setControlSignals({dtr:false, rts});
		await this.delay(50);
	}

	async upload(data, offset=0, progressFn=null){
		await this.reset(true);
		await this.write_bootloader(progressFn);
		await this.change_bitrate(1500000);
		await this.write_flash(data, offset, progressFn);
		await this.update(115200);
		await this.reset();
	}

	async change_bitrate(bitrate){
		await this.send_cmd(0xd6, this.ints_to_buffer(0, 4, bitrate), -1);
		await this.delay(50);
		await this.update(bitrate);
	}

	async write_dataframe(cmd, frameSize, data, offset, progressFn=null){
		for(let i=0, n=data.length; i<n; i+=frameSize){
			const packet = data.slice(i, i+frameSize);
			const payload = Buffer.concat([this.ints_to_buffer(offset+i, packet.length), packet]);
			await this.send_cmd(cmd, payload);
			progressFn?.((i + packet.length) / data.length);
		}
	}

	async write_bootloader(progressFn=null){
		const address = 0x80000000;
		await this.write_dataframe(0xc3, 1024, ISP_PROG, address, progressFn);
		await this.send_cmd(0xc5, this.ints_to_buffer(address, 0), -1);//reboot
		await this.delay(50);
	}

	async write_flash(data, offset=0, progressFn=null){
		if(offset == 0){
			const dataNew = Buffer.concat([Buffer.alloc(5), data]);
			dataNew.writeUInt32LE(data.length, 1);
			const sha256 = crypto.createHash('sha256').update(dataNew).digest();
			data = Buffer.concat([dataNew, sha256]);
		}
		data = this.align_data(data, 4096);
		await this.send_cmd(0xd7, this.ints_to_buffer(1, 0));//chipType=1(on-board), 0(in-chip)
		await this.write_dataframe(0xd4, 65536, data, offset, progressFn);
	}

	send_cmd(op, data, timeout=1000){
		const head = this.ints_to_buffer(op, crc32(data));
		return this.send(Buffer.concat([head, data]), timeout).then(result => {
			if(timeout < 0)return;
			if(result.length === 2 && result[0] === op && result[1] === 0xE0)return;
			return Promise.reject();
		});
	}
}

for(let key of ['ints_to_buffer', 'align_data', 'delay', 'send', 'recv']){
	Serial.prototype[key] = esp32.prototype[key];
}

module.exports = Serial;