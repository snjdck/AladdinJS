'use strict';

const DROPDOWN_ARROW_PADDING = 0;

const calcSize = (size, pad, count) =>  (size + pad) * count - pad;

Blockly.FieldMatrix = function(matrix){
  Blockly.FieldMatrix.superClass_.constructor.call(this, matrix);
  //this.addArgType('matrix');
  /**
   * Array of SVGElement<rect> for matrix thumbnail image on block field.
   * @type {!Array<SVGElement>}
   * @private
   */
  this.ledThumbNodes_ = [];
  /**
   * Array of SVGElement<rect> for matrix editor in dropdown menu.
   * @type {!Array<SVGElement>}
   * @private
   */
  this.ledButtons_ = [];
  /**
   * String for storing current matrix value.
   * @type {!String]
   * @private
   */
  this.matrix_ = '';
  /**
   * SVGElement for LED matrix in editor.
   * @type {?SVGElement}
   * @private
   */
  this.matrixStage_ = null;
  /**
   * SVG image for dropdown arrow.
   * @type {?SVGElement}
   * @private
   */
  this.arrow_ = null;
  /**
   * String indicating matrix paint style.
   * value can be [null, 'fill', 'clear'].
   * @type {?String}
   * @private
   */
  this.paintStyle_ = null;
  /**
   * Touch event wrapper.
   * Runs when the field is selected.
   * @type {!Array}
   * @private
   */
  this.mouseDownWrapper_ = null;
  /**
   * Touch event wrapper.
   * Runs when the clear button editor button is selected.
   * @type {!Array}
   * @private
   */
  this.clearButtonWrapper_ = null;
  /**
   * Touch event wrapper.
   * Runs when the fill button editor button is selected.
   * @type {!Array}
   * @private
   */
  this.fillButtonWrapper_ = null;
  /**
   * Touch event wrapper.
   * Runs when the matrix editor is touched.
   * @type {!Array}
   * @private
   */
  this.matrixTouchWrapper_ = null;
  /**
   * Touch event wrapper.
   * Runs when the matrix editor touch event moves.
   * @type {!Array}
   * @private
   */
  this.matrixMoveWrapper_ = null;
  /**
   * Touch event wrapper.
   * Runs when the matrix editor is released.
   * @type {!Array}
   * @private
   */
  this.matrixReleaseWrapper_ = null;
};
Blockly.utils.object.inherits(Blockly.FieldMatrix, Blockly.Field);
Blockly.FieldMatrix.prototype.SERIALIZABLE = true;
//Blockly.FieldMatrix.prototype.EDITABLE = true;

/**
 * Construct a FieldMatrix from a JSON arg object.
 * @param {!Object} options A JSON object with options (matrix).
 * @returns {!Blockly.FieldMatrix} The new field instance.
 * @package
 * @nocollapse
 */
Blockly.FieldMatrix.fromJson = function(options) {
  let result = new Blockly.FieldMatrix(options['matrix']);
  result._w = options.width;
  result._h = options.height;
  return result;
};

/**
 * Fixed size of the matrix thumbnail in the input field, in px.
 * @type {number}
 * @const
 */
//Blockly.FieldMatrix.THUMBNAIL_SIZE = 26;

/**
 * Fixed size of each matrix thumbnail node, in px.
 * @type {number}
 * @const
 */
Blockly.FieldMatrix.THUMBNAIL_NODE_SIZE = 4;

/**
 * Fixed size of each matrix thumbnail node, in px.
 * @type {number}
 * @const
 */
Blockly.FieldMatrix.THUMBNAIL_NODE_PAD = 1;

/**
 * Fixed size of arrow icon in drop down menu, in px.
 * @type {number}
 * @const
 */
//Blockly.FieldMatrix.ARROW_SIZE = 12;

/**
 * Fixed size of each button inside the 5x5 matrix, in px.
 * @type {number}
 * @const
 */
Blockly.FieldMatrix.MATRIX_NODE_SIZE = 18;

/**
 * Fixed corner radius for 5x5 matrix buttons, in px.
 * @type {number}
 * @const
 */
Blockly.FieldMatrix.MATRIX_NODE_RADIUS = 4;

/**
 * Fixed padding for 5x5 matrix buttons, in px.
 * @type {number}
 * @const
 */
Blockly.FieldMatrix.MATRIX_NODE_PAD = 5;

Blockly.FieldMatrix.prototype.updateSize_ = function(){
	const nodeSize = Blockly.FieldMatrix.THUMBNAIL_NODE_SIZE;
	const nodePad  = Blockly.FieldMatrix.THUMBNAIL_NODE_PAD;
	const THUMBNAIL_W = calcSize(nodeSize, nodePad, this._w);
	const THUMBNAIL_H = calcSize(nodeSize, nodePad, this._h);

	this.size_.width = THUMBNAIL_W;
	this.size_.height = THUMBNAIL_H;
}

Blockly.FieldMatrix.prototype.initView = function(){
	const nodeSize = Blockly.FieldMatrix.THUMBNAIL_NODE_SIZE;
	const nodePad  = Blockly.FieldMatrix.THUMBNAIL_NODE_PAD;

	let thumbnail = Blockly.utils.dom.createSvgElement('g', {
		//'transform': 'translate(' + thumbX + ', ' + thumbY + ')',
		'pointer-events': 'bounding-box',
		'cursor': 'pointer'
		}, this.fieldGroup_
	);
	this.ledThumbNodes_ = [];
	let attr = {
		'width': nodeSize, 'height': nodeSize,
		'rx': nodePad, 'ry': nodePad
	};
	for (let y = 0; y < this._h; y++) {
		for (let x = 0; x < this._w; x++) {
			attr.x = (nodeSize + nodePad) * x;
			attr.y = (nodeSize + nodePad) * y;
			this.ledThumbNodes_.push(
				Blockly.utils.dom.createSvgElement('rect', attr, thumbnail)
			);
		}
	}
	thumbnail.style.cursor = 'default';
	this.matrix_ = '0'.repeat(this._w * this._h);
	this.updateMatrix_();
	this.mouseDownWrapper_ = Blockly.bindEventWithChecks_(this.getClickTarget_(), 'mousedown', this, this.onMouseDown_);
}

/**
 * Get the value from this matrix menu.
 * @return {string} Current matrix value.
 */
Blockly.FieldMatrix.prototype.getValue = function() {
  return String(this.matrix_);
};

/**
 * Show the drop-down menu for editing this field.
 * @private
 */
Blockly.FieldMatrix.prototype.showEditor_ = function() {
	const nodeSize = Blockly.FieldMatrix.MATRIX_NODE_SIZE;
	const nodePad  = Blockly.FieldMatrix.MATRIX_NODE_PAD;
	const matrixW = calcSize(nodeSize, nodePad, this._w);
	const matrixH = calcSize(nodeSize, nodePad, this._h);


	// If there is an existing drop-down someone else owns, hide it immediately and clear it.
	Blockly.DropDownDiv.hideWithoutAnimation();
	Blockly.DropDownDiv.clearContent();
	var div = Blockly.DropDownDiv.getContentDiv();
	// Build the SVG DOM.
	//var matrixSize = (Blockly.FieldMatrix.MATRIX_NODE_SIZE * 5) + (Blockly.FieldMatrix.MATRIX_NODE_PAD * 6);
	this.matrixStage_ = Blockly.utils.dom.createSvgElement('svg', {
		'xmlns': 'http://www.w3.org/2000/svg',
		'xmlns:html': 'http://www.w3.org/1999/xhtml',
		'xmlns:xlink': 'http://www.w3.org/1999/xlink',
		'version': '1.1',
		'height': matrixH + 'px',
		'width':  matrixW + 'px'
	}, div);
	// Create the 5x5 matrix
	this.ledButtons_ = [];
	const attr = {
		'width': nodeSize,
		'height': nodeSize,
		'rx': Blockly.FieldMatrix.MATRIX_NODE_RADIUS,
		'ry': Blockly.FieldMatrix.MATRIX_NODE_RADIUS
	};
	for (let y = 0; y < this._h; y++) {
		for (let x = 0; x < this._w; x++) {
			attr.x = (nodeSize + nodePad) * x;
			attr.y = (nodeSize + nodePad) * y;
			this.ledButtons_.push(
				Blockly.utils.dom.createSvgElement('rect', attr, this.matrixStage_)
			);
		}
	}
	// Div for lower button menu
	let buttonDiv = document.createElement('div');
	buttonDiv.style = 'display: flex; justify-content: space-around; align-items: center;';
	// Button to clear matrix
	let clearButtonDiv = document.createElement('div');
	clearButtonDiv.className = 'scratchMatrixButtonDiv';
	let clearButton = this.createButton_(this.getSourceBlock().getColourSecondary());
	clearButtonDiv.appendChild(clearButton);
	// Button to fill matrix
	let fillButtonDiv = document.createElement('div');
	fillButtonDiv.className = 'scratchMatrixButtonDiv';
	let fillButton = this.createButton_('#FFFFFF');
	fillButtonDiv.appendChild(fillButton);

	buttonDiv.appendChild(clearButtonDiv);
	buttonDiv.appendChild(fillButtonDiv);
	div.appendChild(buttonDiv);

	Blockly.DropDownDiv.setColour(this.sourceBlock_.getColour(),
	this.sourceBlock_.getColourTertiary());
	//Blockly.DropDownDiv.setCategory("Robots");
	Blockly.DropDownDiv.showPositionedByBlock(this, this.sourceBlock_);

	this.matrixTouchWrapper_ = Blockly.bindEvent_(this.matrixStage_, 'mousedown', this, this.onMouseDown);
	this.clearButtonWrapper_ = Blockly.bindEvent_(clearButton, 'mousedown', this, this.clearMatrix_);
	this.fillButtonWrapper_ = Blockly.bindEvent_(fillButton, 'mousedown', this, this.fillMatrix_);

	// Update the matrix for the current value
	this.updateMatrix_();


	//let buttonDiv = Blockly.DropDownDiv.getContentDiv().children[1];
	

	let iconList = FaceData[this._h + 'x' + this._w];
	if(!iconList)return;

	if(this.wrapperList){
		this.unbindWrapperList();
	}else{
		this.wrapperList = [];
	}

	for(let i=0, n=Math.ceil(iconList.length * 0.5); i<n; ++i){
		let iconDiv = document.createElement('div');
		buttonDiv.insertBefore(iconDiv, buttonDiv.lastChild);
		for(let j=0; j<2; ++j){
			let icon = iconList[i+j*n];
			if(!icon)continue;
			let testBtn = this.createButton2(icon);
			let testBtnDiv = document.createElement('div');
			testBtnDiv.appendChild(testBtn);
			iconDiv.appendChild(testBtnDiv);
			this.wrapperList.push(
				Blockly.bindEvent_(testBtn, 'mousedown', this, () => this.setValue(icon))
			);
		}
	}
};

/**
 * Make an svg object that resembles a 3x3 matrix to be used as a button.
 * @param {string} fill The color to fill the matrix nodes.
 * @return {SvgElement} The button svg element.
 */
Blockly.FieldMatrix.prototype.createButton_ = function(fill) {
  var button = Blockly.utils.dom.createSvgElement('svg', {
	'xmlns': 'http://www.w3.org/2000/svg',
	'xmlns:html': 'http://www.w3.org/1999/xhtml',
	'xmlns:xlink': 'http://www.w3.org/1999/xlink',
	'version': '1.1',
	'height': Blockly.FieldMatrix.MATRIX_NODE_SIZE + 'px',
	'width': Blockly.FieldMatrix.MATRIX_NODE_SIZE + 'px'
  });
  var nodeSize = Blockly.FieldMatrix.MATRIX_NODE_SIZE / 4;
  var nodePad = Blockly.FieldMatrix.MATRIX_NODE_SIZE / 16;
  for (var i = 0; i < 3; i++) {
	for (var n = 0; n < 3; n++) {
	  Blockly.utils.dom.createSvgElement('rect', {
		'x': ((nodeSize + nodePad) * n) + nodePad,
		'y': ((nodeSize + nodePad) * i) + nodePad,
		'width': nodeSize, 'height': nodeSize,
		'rx': nodePad, 'ry': nodePad,
		'fill': fill
	  }, button);
	}
  }
  return button;
};

/**
 * Redraw the matrix with the current value.
 * @private
 */
Blockly.FieldMatrix.prototype.updateMatrix_ = function() {
	for(var i = 0; i < this.matrix_.length; i++){
		if (this.matrix_[i] === '0') {
			this.fillMatrixNode_(this.ledButtons_, i, this.sourceBlock_.getColourSecondary());
			this.fillMatrixNode_(this.ledThumbNodes_, i, this.sourceBlock_.colour_);
		} else {
			this.fillMatrixNode_(this.ledButtons_, i, '#FFFFFF');
			this.fillMatrixNode_(this.ledThumbNodes_, i, '#FFFFFF');
		}
	}
};


/**
 * Fill matrix node with specified colour.
 * @param {!Array<SVGElement>} node The array of matrix nodes.
 * @param {!number} index The index of the matrix node.
 * @param {!string} fill The fill colour in '#rrggbb' format.
 */
Blockly.FieldMatrix.prototype.fillMatrixNode_ = function(node, index, fill) {
  if (!node || !node[index] || !fill) return;
  node[index].setAttribute('fill', fill);
};

/**
 * Toggle matrix nodes on and off.
 * @param {!Event} e Mouse event.
 */
Blockly.FieldMatrix.prototype.onMouseDown = function(e) {
  this.matrixMoveWrapper_ =
	Blockly.bindEvent_(document.body, 'mousemove', this, this.onMouseMove);
  this.matrixReleaseWrapper_ =
	Blockly.bindEvent_(document.body, 'mouseup', this, this.onMouseUp);
  var ledHit = this.checkForLED_(e);
  if (ledHit > -1) {
	if (this.matrix_.charAt(ledHit) === '0') {
	  this.paintStyle_ = 'fill';
	} else {
	  this.paintStyle_ = 'clear';
	}
	this.toggleLEDNode_(ledHit);
	this.updateMatrix_();
  } else {
	this.paintStyle_ = null;
  }
};

/**
 * Unbind mouse move event and clear the paint style.
 * @param {!Event} e Mouse move event.
 */
Blockly.FieldMatrix.prototype.onMouseUp = function() {
  Blockly.unbindEvent_(this.matrixMoveWrapper_);
  Blockly.unbindEvent_(this.matrixReleaseWrapper_);
  this.paintStyle_ = null;
};

/**
 * Toggle matrix nodes on and off by dragging mouse.
 * @param {!Event} e Mouse move event.
 */
Blockly.FieldMatrix.prototype.onMouseMove = function(e) {
  e.preventDefault();
  if (this.paintStyle_) {
	var led = this.checkForLED_(e);
	if (led < 0) return;
	if (this.paintStyle_ === 'clear') {
	  this.setLEDNode_(led, '0');
	} else if (this.paintStyle_ === 'fill') {
	  this.setLEDNode_(led, '1');
	}
  }
};

/**
 * Clean up this FieldMatrix, as well as the inherited Field.
 * @return {!Function} Closure to call on destruction of the WidgetDiv.
 * @private
 */
Blockly.FieldMatrix.prototype.dispose_ = function() {
  var thisField = this;
  return function() {
	Blockly.FieldMatrix.superClass_.dispose_.call(thisField)();
	thisField.matrixStage_ = null;
	if (thisField.mouseDownWrapper_) {
	  Blockly.unbindEvent_(thisField.mouseDownWrapper_);
	}
	if (thisField.matrixTouchWrapper_) {
	  Blockly.unbindEvent_(thisField.matrixTouchWrapper_);
	}
	if (thisField.matrixReleaseWrapper_) {
	  Blockly.unbindEvent_(thisField.matrixReleaseWrapper_);
	}
	if (thisField.matrixMoveWrapper_) {
	  Blockly.unbindEvent_(thisField.matrixMoveWrapper_);
	}
	if (thisField.clearButtonWrapper_) {
	  Blockly.unbindEvent_(thisField.clearButtonWrapper_);
	}
	if (thisField.fillButtonWrapper_) {
	  Blockly.unbindEvent_(thisField.fillButtonWrapper_);
	}
	thisField.unbindWrapperList();
  };
};

Blockly.fieldRegistry.register('field_matrix', Blockly.FieldMatrix);

const FaceData = function(){
	const IconList = [
	[
		' OO      OO ',
		'O  O    O  O',
		'            ',
		'    OOOO    ',
		'     OO     ',
	],
	[
		'OOO      OOO',
		'O O      O O',
		'OOO O  O OOO',
		'     OO     ',
	],
	[
		'O            O',
		' O          O ',
		'  O        O  ',
		'   O      O   ',
		'O   O    O   O',
	],
	[
		'OOO      OOO',
		' O   OO   O ',
		' O  O  O  O ',
	],
	[
		'O  O    O  O ',
		'O O O O O O O',
		'O  O    O  O ',
		'O O   O O O  ',
		'O OOO   O OOO',
	],
	[
		'O  O O',
		'O  O  ',
		'OOOO O',
		'O  O O',
		'O  O O',
	],
	[
		'OOOOOO ',
		'  O O  ',
		' O  O  ',
		'O   O  ',
		'    OOO',
	],
	[
		'OOO  O  O',
		'O O  O O ',
		'O O  OO  ',
		'O O  O O ',
		'OOO  O  O',
	],
	];

	function _replaceIcon(value){
		return value === 'O' ? 1 : 0;
	}

	function createIcon(data, w, h){
		let iconW = data[0].length;
		let iconH = data.length;
		let x = Math.ceil((w - iconW) * 0.5);
		let y = Math.ceil((h - iconH) * 0.5);
		let result = '';
		for(let i=0; i<h; ++i){
			if(i < y || i >= y+iconH){
				result += '0'.repeat(w);
				continue;
			}
			result += '0'.repeat(x) + data[i-y].replace(/[O\x20]/g, _replaceIcon) + '0'.repeat(w - x - iconW);
		}
		return result;
	}

	return {
		'7x21':IconList.map(v => createIcon(v, 21, 7)),
		'5x14':IconList.map(v => createIcon(v, 14, 5)),
	};
}();

Blockly.FieldMatrix.prototype.createButton2 = function(icon) {
	var nodeSize = 2;
	var nodePad = 1;
	var button = Blockly.utils.dom.createSvgElement('svg', {
		'xmlns': 'http://www.w3.org/2000/svg',
		'xmlns:html': 'http://www.w3.org/1999/xhtml',
		'xmlns:xlink': 'http://www.w3.org/1999/xlink',
		'version': '1.1',
		'height': calcSize(nodeSize, nodePad, this._h) + 'px',
		'width': calcSize(nodeSize, nodePad, this._w) + 'px'
	});
	
	for (var i = 0; i < this._h; i++) {
		for (var n = 0; n < this._w; n++) {
			let index = i * this._w + n;
			let isOn = index < icon.length && icon.charAt(index) === '1';
			Blockly.utils.dom.createSvgElement('rect', {
				'x': (nodeSize + nodePad) * n,
				'y': (nodeSize + nodePad) * i,
				'width': nodeSize, 'height': nodeSize,
				'rx': nodePad, 'ry': nodePad,
				'fill': (isOn ? '#FFFFFF' : this.sourceBlock_.getColourSecondary())
			}, button);
		}
	}
	return button;
};

Blockly.FieldMatrix.prototype.unbindWrapperList = function(){
	for(let wrapper of this.wrapperList){
		Blockly.unbindEvent_(wrapper);
	}
	this.wrapperList.length = 0;
};

Blockly.FieldMatrix.prototype.setValue = function(matrix){
	if(!matrix || matrix === this.matrix_){
		return;
	}
	if(this.sourceBlock_ && Blockly.Events.isEnabled()){
		Blockly.Events.fire(new Blockly.Events.Change(
			this.sourceBlock_, 'field', this.name, this.matrix_, matrix
		));
	}
	this.matrix_ = matrix.padEnd(this._w * this._h, '0');
	this.updateMatrix_();
};

Blockly.FieldMatrix.prototype.clearMatrix_ = function(e){
	if (e.button != 0) return;
	this.setValue('0'.repeat(this._w * this._h));
};

Blockly.FieldMatrix.prototype.fillMatrix_ = function(e) {
	if (e.button != 0) return;
	this.setValue('1'.repeat(this._w * this._h));
};

Blockly.FieldMatrix.prototype.setLEDNode_ = function(led, state){
	if(led < 0 || led >= this._w * this._h)return;
	var matrix = this.matrix_.substr(0, led) + state + this.matrix_.substr(led + 1);
	this.setValue(matrix);
};

Blockly.FieldMatrix.prototype.toggleLEDNode_ = function(led){
	let isOn = this.matrix_.charAt(led) !== '0';
	this.setLEDNode_(led, isOn ? '0' : '1');
};

Blockly.FieldMatrix.prototype.checkForLED_ = function(e){
	var bBox = this.matrixStage_.getBoundingClientRect();
	var nodeSize = Blockly.FieldMatrix.MATRIX_NODE_SIZE;
	var nodePad = Blockly.FieldMatrix.MATRIX_NODE_PAD;
	var dx = e.clientX - bBox.left;
	var dy = e.clientY - bBox.top;
	var min = nodePad / 2;
	var max = bBox.width - (nodePad / 2);
	if (dx < min || dx > max || dy < min || dy > max) {
		return -1;
	}
	var xDiv = Math.trunc((dx - nodePad / 2) / (nodeSize + nodePad));
	var yDiv = Math.trunc((dy - nodePad / 2) / (nodeSize + nodePad));
	return xDiv + (yDiv * this._w);
};
