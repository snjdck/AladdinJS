
const ChromeSerial = require('webonly/chrome/ChromeSerial');
const {TaskQueue} = require('utils/task');
const {waitWhen} = require('utils/events');
const {composeFactory} = require('net/packet');
const zlib = require('zlib');
const crypto = require('crypto');

const codeText = require('./ESP32_bin');

class Serial extends ChromeSerial
{
	constructor(){
		super();
		this.sendQueue = TaskQueue();
		this.on('closed', () => this.emit('packet'));
	}

	delay(milliseconds){
		return new Promise(resolve => setTimeout(resolve, milliseconds));
	}

	async reset(){
		await this.setControlSignals({rts:true});
		await this.setControlSignals({rts:false});
	}

	async upload(data, offset=0x1000, progressFn=null){
		await this.sync();
		await this.write_stub();
		await this.write_flash(data, offset, progressFn);
		await this.check_flash_md5(data, offset);
		await this.reset();
	}

	async sync(){
		await this.setControlSignals({dtr:false, rts:true});
		await this.delay(50);
		await this.setControlSignals({dtr:true, rts:false});
		await this.delay(50);
		await this.setControlSignals({dtr:false});
		const data = Buffer.alloc(36, 0x55);
		for(let i=0; i<10; ++i){
			try{
				await this.send_cmd(8, data, 100);
				await this.delay(100);
				return;
			}catch{
				continue;
			}
		}
		throw new Error('timeout');
	}

	read_reg(address){
		return this.send_cmd(0xA, this.ints_to_buffer(address)).then(v => v[0]);
	}

	write_reg(address, value){
		return this.send_cmd(0x9, this.ints_to_buffer(address, value, 0xFFFFFFFF, 0));
	}

	async check_flash_md5(data, offset){
		const timeout = Math.max(3000, 8000 * data.length / 0x100000);//speed=8s/M
		const result = await this.send_cmd(0x13, this.ints_to_buffer(offset, data.length, 0, 0), timeout);
		const md5_old = crypto.createHash('md5').update(data).digest('hex');
		const md5_new = result[1].slice(0, 16).map(v => v.toString(16).padStart(2, '0')).join('');
		console.assert(md5_old === md5_new);
	}

	async change_bitrate(bitrate){
		await this.send_cmd(0xF, this.ints_to_buffer(bitrate, this.bitrate));
		await this.delay(1000)
		//await this.update(bitrate);
		//return
		await this.disconnect();
		await this.delay(50);
		await this.connect(this.port, bitrate);
	}
}

Serial.prototype.write_stub = function(){
	const codeData = Buffer.from('CMD8Pw==', 'base64');
	const ESP_RAM_BLOCK = 0x1800;
	async function send_code(code, offset){
		const blockCount = Math.ceil(code.length / ESP_RAM_BLOCK);
		await this.send_cmd(5, this.ints_to_buffer(code.length, blockCount, ESP_RAM_BLOCK, offset));
		for(let i=0; i<blockCount; ++i){
			const packet = code.slice(ESP_RAM_BLOCK * i, ESP_RAM_BLOCK * (i + 1));
			const payload = Buffer.concat([this.ints_to_buffer(packet.length, i, 0, 0), packet]);
			await this.send_cmd(7, payload);
		}
	}
	return async function(){
		await send_code.call(this, codeText, 0x400be000);
		await send_code.call(this, codeData, 0x3ffdeba8);
		await this.send_cmd(6, this.ints_to_buffer(0, 0x400be598));
		console.assert(Buffer.from(await this.recv()).toString() == 'OHAI');
	}
}();

Serial.prototype.write_flash = function(){
	const FLASH_WRITE_SIZE = 0x4000;
	return async function(data, offset, progressFn=null){
		data = this.align_data(data, 4, 0xFF);
		const oldBlockCount = Math.ceil(data.length / FLASH_WRITE_SIZE);
		data = zlib.deflateSync(data, {level:9});
		const blockCount = Math.ceil(data.length / FLASH_WRITE_SIZE);
		await this.send_cmd(0x10, this.ints_to_buffer(oldBlockCount * FLASH_WRITE_SIZE, blockCount, FLASH_WRITE_SIZE, offset));
		for(let i=0; i<blockCount; ++i){
			const packet = data.slice(FLASH_WRITE_SIZE * i, FLASH_WRITE_SIZE * (i + 1));
			const payload = Buffer.concat([this.ints_to_buffer(packet.length, i, 0, 0), packet]);
			await this.send_cmd(0x11, payload);
			progressFn?.((FLASH_WRITE_SIZE * i + packet.length) / data.length);
		}
		//await this.send_cmd(2, memBegin(0, 0, 0));
		await this.send_cmd(0x12, this.ints_to_buffer(1));//0==reboot
	}
}();

Serial.prototype.ints_to_buffer = function(...ints){
	const count = ints.length;
	const buffer = Buffer.allocUnsafe(count << 2);
	for(let i=0; i<count; ++i){
		buffer.writeUInt32LE(ints[i], i << 2);
	}
	return buffer;
}

Serial.prototype.align_data = function(){
	const calcPad = (length, align) => (align - length % align) % align;
	return function(data, align, fill=0){
		const pad = calcPad(data.length, align);
		return pad > 0 ? Buffer.concat([data, Buffer.alloc(pad, fill)]) : data;
	}
}();

Serial.prototype.send_cmd = function(){
	function checksum(data, offset){
		let result = 0xEF;
		for(let i=offset, n=data.length; i<n; ++i){
			result ^= data[i];
		}
		return result;
	}
	return function(op, data, timeout=1000){
		const head = Buffer.allocUnsafe(8);
		head.writeUInt16BE(op, 0);
		head.writeUInt16LE(data.length, 2);
		head.writeUInt32LE(checksum(data, 16), 4);
		return this.send(Buffer.concat([head, data]), timeout).then(result => {
			console.assert(result.length === 8 + (result[2] | result[3] << 8));
			if(result[0] == 1 && result[1] == op){
				return [Buffer.from(result).readUInt32LE(4), result.slice(8)];
			}
			return Promise.reject();
		});
	}
}();

Serial.prototype.send = function(){
	const encode = function(){
		function mapFn(v){
			if(v == 0xc0)return [0xdb, 0xdc];
			if(v == 0xdb)return [0xdb, 0xdd];
			return v;
		}
		return buffer => Buffer.from([0xc0, ...Array.from(buffer, mapFn).flat(), 0xc0]);
	}();
	return function(buffer, timeout=1000){
		return this.sendQueue(() => {
			if(!this.isConnected())return;
			return this.send_buffer(encode(buffer)).then(() => timeout < 0 ? undefined : this.recv(timeout));
		});
	}
}();

Serial.prototype.recv = function(){
	function concatFn(value, buffer){
		buffer.push(...new Uint8Array(value));
		while(buffer[0] != 0xc0)buffer.shift();
	}
	const replyFn = composeFactory(
		concatFn,
		buffer => buffer.indexOf(0xc0, 1) > 0,
		buffer => {
			const index = buffer.indexOf(0xc0, 1);
			return decode(buffer.slice(1, index));
		}
	);
	const decode = function(){
		function reduceFn(result, v){
			const lastIndex = result.length - 1;
			if(result[lastIndex] != 0xdb){
				result.push(v);
			}else if(v == 0xdc){
				result[lastIndex] = 0xc0;
			}else if(v != 0xdd){
				result.push(v);
			}
			return result;
		}
		return list => list.reduce(reduceFn, []);
	}();
	return function(timeout=1000){
		if(!this.isConnected())return;
		return waitWhen(this, 'data', timeout, replyFn([]));
	}
}();

module.exports = Serial;