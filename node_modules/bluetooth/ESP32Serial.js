
const ChromeSerial = require('webonly/chrome/ChromeSerial');
const {TaskQueue} = require('utils/task');
const {waitWhen} = require('utils/events');
const {composeFactory} = require('net/packet');
const zlib = require('zlib');
const crypto = require('crypto');

class Serial extends ChromeSerial
{
	constructor(){
		super();
		this.sendQueue = TaskQueue();
		this.on('closed', () => this.emit('packet'));
	}

	async reset(){
		await this.setControlSignals({rts:true});
		await this.setControlSignals({rts:false});
	}

	delay(milliseconds){
		return new Promise(resolve => setTimeout(resolve, milliseconds));
	}
}

Serial.prototype.sync = function(){
	const cmd = Array.from({length:36}).fill(0x55);
	cmd.splice(0, 4, 7, 7, 0x12, 0x20);
	return async function(){
		await this.setControlSignals({dtr:false, rts:true});
		await this.delay(50);
		await this.setControlSignals({dtr:true, rts:false});
		await this.delay(50);
		await this.setControlSignals({dtr:false});
		for(let i=0; i<10; ++i){
			try{
				await this.send_cmd(8, cmd, false, 100);
				await this.delay(100);
				return;
			}catch{
				continue;
			}
		}
		throw new Error('timeout');
	}
}();
/*
Serial.prototype.change_bitrate = function(){
	function buildPacket(newBitrate, oldBitrate){
		let b = Buffer.alloc(8);
		b.writeUInt32LE(newBitrate, 0);
		b.writeUInt32LE(oldBitrate, 4);
		return b;
	}
	return async function(bitrate){
		await this.send_cmd(0xF, buildPacket(bitrate, this.bitrate));
		await this.delay(1000)
		//await this.update(bitrate);
		//return
		await this.disconnect();
		await this.delay(50);
		await this.connect(this.port, bitrate);
	}
}();
*/
Serial.prototype.write_stub = function(){
	const codeData = Buffer.from('CMD8Pw==', 'base64');
	const codeText = zlib.gunzipSync(Buffer.from("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", 'base64'));
	const ESP_RAM_BLOCK = 0x1800;
	function memBegin(size, blockCount, offset){
		let b = Buffer.alloc(16);
		b.writeUInt32LE(size, 0);
		b.writeUInt32LE(blockCount, 4);
		b.writeUInt32LE(ESP_RAM_BLOCK, 8);
		b.writeUInt32LE(offset, 12);
		return b;
	}
	function memEnd(entrypoint){
		let b = Buffer.alloc(8);
		b.writeUInt32LE(entrypoint, 4);
		return b;
	}
	function memBlock(data, index){
		let b = Buffer.alloc(16);
		b.writeUInt32LE(data.length, 0);
		b.writeUInt32LE(index, 4);
		return Buffer.concat([b, data]);
	}
	async function send_code(code, offset){
		const blockCount = Math.ceil(code.length / ESP_RAM_BLOCK);
		await this.send_cmd(5, memBegin(code.length, blockCount, offset));
		for(let i=0; i<blockCount; ++i){
			const packet = code.slice(ESP_RAM_BLOCK * i, ESP_RAM_BLOCK * (i + 1));
			await this.send_cmd(7, memBlock(packet, i), true);
		}
	}
	return async function(){
		await send_code.call(this, codeText, 0x400be000);
		await send_code.call(this, codeData, 0x3ffdeba8);
		await this.send_cmd(6, memEnd(0x400be598));
		console.assert(Buffer.from(await this.recv()).toString() == 'OHAI');
	}
}();

Serial.prototype.write_flash = function(){
	const FLASH_WRITE_SIZE = 0x4000;
	function memBegin(size, blockCount, offset){
		let b = Buffer.alloc(16);
		b.writeUInt32LE(size, 0);
		b.writeUInt32LE(blockCount, 4);
		b.writeUInt32LE(FLASH_WRITE_SIZE, 8);
		b.writeUInt32LE(offset, 12);
		return b;
	}
	function memEnd(rebootFlag=false){
		let b = Buffer.alloc(4);
		b.writeUInt32LE(!rebootFlag, 0);
		return b;
	}
	function memBlock(data, index){
		let b = Buffer.alloc(16);
		b.writeUInt32LE(data.length, 0);
		b.writeUInt32LE(index, 4);
		return Buffer.concat([b, data]);
	}
	return async function(data, offset, progressFn=null){
		if(data.length % 4){
			data = Buffer.concat([data, Buffer.alloc(4 - data.length % 4, 0xFF)]);
		}
		const oldBlockCount = Math.ceil(data.length / FLASH_WRITE_SIZE);
		data = zlib.deflateSync(data, {level:9});
		const blockCount = Math.ceil(data.length / FLASH_WRITE_SIZE);
		await this.send_cmd(0x10, memBegin(oldBlockCount * FLASH_WRITE_SIZE, blockCount, offset));
		for(let i=0; i<blockCount; ++i){
			const packet = data.slice(FLASH_WRITE_SIZE * i, FLASH_WRITE_SIZE * (i + 1));
			await this.send_cmd(0x11, memBlock(packet, i), true);
			progressFn?.((FLASH_WRITE_SIZE * i + packet.length) / data.length);
		}
		//await this.send_cmd(2, memBegin(0, 0, 0));
		await this.send_cmd(0x12, memEnd());
	}
}();
/*
Serial.prototype.check_flash_md5 = function(){
	function buildPacket(size, offset){
		let b = Buffer.alloc(16);
		b.writeUInt32LE(offset, 0);
		b.writeUInt32LE(size, 4);
		return b;
	}
	return async function(data, offset){
		const timeout = Math.max(3000, 8000 * data.length / 0x100000);//speed=8s/M
		const result = await this.send_cmd(0x13, buildPacket(data.length, offset), false, timeout);
		const md5_old = crypto.createHash('md5').update(data).digest('hex');
		const md5_new = result[1].slice(0, 16).map(v => v.toString(16).padStart(2, '0')).join('');
		console.assert(md5_old === md5_new);
	}
}();

Serial.prototype.write_reg = function(){
	function buildPacket(address, value){
		let b = Buffer.alloc(16);
		b.writeUInt32LE(address, 0);
		b.writeUInt32LE(value, 4);
		b.writeUInt32LE(0xFFFFFFFF, 8);
		return b;
	}
	return function(address, value){
		return this.send_cmd(0x9, buildPacket(address, value));
	}
}();

Serial.prototype.read_reg = function(){
	function buildPacket(address){
		let b = Buffer.alloc(4);
		b.writeUInt32LE(address, 0);
		return b;
	}
	return function(address){
		return this.send_cmd(0xA, buildPacket(address)).then(v => v[0]);
	}
}();
*/
Serial.prototype.send_cmd = function(){
	function checksum(data, offset){
		let result = 0xef;
		for(let i=offset, n=data.length; i<n; ++i){
			result ^= data[i];
		}
		return result;
	}
	return function(op, data, checksumFlag=false, timeout=1000){
		const head = Buffer.alloc(8);
		head[1] = op;
		head.writeUInt16LE(data.length, 2);
		if(checksumFlag){
			head.writeUInt32LE(checksum(data, 16), 4);
		}
		return this.send([...head, ...data], timeout).then(result => {
			console.assert(result.length === 8 + (result[2] | result[3] << 8));
			if(result[0] == 1 && result[1] == op){
				return [Buffer.from(result).readUInt32LE(4), result.slice(8)];
			}
			return Promise.reject();
		});
	}
}();

Serial.prototype.send = function(){
	const encode = function(){
		function mapFn(v){
			if(v == 0xc0)return [0xdb, 0xdc];
			if(v == 0xdb)return [0xdb, 0xdd];
			return v;
		}
		return buffer => Buffer.from([0xc0, ...Array.from(buffer, mapFn).flat(), 0xc0]);
	}();
	return function(buffer, timeout=1000){
		return this.sendQueue(() => {
			if(!this.isConnected())return;
			return this.send_buffer(encode(buffer)).then(() => timeout < 0 ? undefined : this.recv(timeout));
		});
	}
}();

Serial.prototype.recv = function(){
	function concatFn(value, buffer){
		buffer.push(...new Uint8Array(value));
		while(buffer[0] != 0xc0)buffer.shift();
	}
	const replyFn = composeFactory(
		concatFn,
		buffer => buffer.indexOf(0xc0, 1) > 0,
		buffer => {
			const index = buffer.indexOf(0xc0, 1);
			return decode(buffer.slice(1, index));
		}
	);
	const decode = function(){
		function reduceFn(result, v){
			const lastIndex = result.length - 1;
			if(result[lastIndex] != 0xdb){
				result.push(v);
			}else if(v == 0xdc){
				result[lastIndex] = 0xc0;
			}else if(v != 0xdd){
				result.push(v);
			}
			return result;
		}
		return list => list.reduce(reduceFn, []);
	}();
	return function(timeout=1000){
		if(!this.isConnected())return;
		return waitWhen(this, 'data', timeout, replyFn([]));
	}
}();

module.exports = Serial;