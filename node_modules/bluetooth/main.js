'use strict';

require('./fix_blockly');
const {getSearchInfo} = require('../webonly/index.js');
const searchInfo = Object.assign({board:'elf'}, getSearchInfo());
/*
const toolbox = document.getElementById('toolbox');

function updateToolBoxByTag(board){
	for(let category of toolbox.childNodes){
		if(category.nodeType != Node.ELEMENT_NODE)continue;
		if(category.localName != 'category')continue;
		for(let block of category.childNodes){
			if(block.nodeType != Node.ELEMENT_NODE)continue;
			if(block.localName != 'block')continue;
			let type = block.getAttribute('type');
			if(type.startsWith('weeemake_weeebot_')){
				if(board == 'mini'){
					block.remove();
				}
				//block.setAttribute('disabled', board == 'mini');
			}else if(type.startsWith('weeemake_weeebotMini_')){
				if(board == 'elf'){
					block.remove();
				}
				//block.setAttribute('disabled', board == 'elf');
			}
		}
	}
}


updateToolBoxByTag(searchInfo.board);
*/
const startBlockName = 'when_start';
const startBlockLabel = '当点击开始';

Blockly.Extensions.register('markAsyncFunc', function(){this.data = 'isAsyncFunc';});
Blockly.Extensions.register('markConstText', function(){this.data = 'isConstText';});
Blockly.Extensions.register('markConstNumber', function(){this.data = 'isConstNumber';});
Blockly.Extensions.register('markStatement', function(){
	this.setPreviousStatement(true, null);
	this.setNextStatement(true, null);
});
Blockly.Extensions.register('set_colours_image_recognition', function(){
	let field = this.getField("IMAGE_RECOGNITION_TYPE");
	field.setColours(['#e17373','#e08649','#5450e8','#37b80c','#24716b']);
});

void function(){
	const colours = {
		"motion": {
			"primary": "#4C97FF",
			"secondary": "#4280D7",
			"tertiary": "#3373CC"
		},
		"looks": {
			"primary": "#9966FF",
			"secondary": "#855CD6",
			"tertiary": "#774DCB"
		},
		"sounds": {
			"primary": "#CF63CF",
			"secondary": "#C94FC9",
			"tertiary": "#BD42BD"
		},
		"control": {
			"primary": "#FFAB19",
			"secondary": "#EC9C13",
			"tertiary": "#CF8B17"
		},
		"event": {
			"primary": "#FFBF00",
			"secondary": "#E6AC00",
			"tertiary": "#CC9900"
		},
		"sensing": {
			"primary": "#5CB1D6",
			"secondary": "#47A8D1",
			"tertiary": "#2E8EB8"
		},
		"pen": {
			"primary": "#0fBD8C",
			"secondary": "#0DA57A",
			"tertiary": "#0B8E69"
		},
		"operators": {
			"primary": "#59C059",
			"secondary": "#46B946",
			"tertiary": "#389438"
		},
		"data": {
			"primary": "#FF8C1A",
			"secondary": "#FF8000",
			"tertiary": "#DB6E00"
		},
		// This is not a new category, but rather for differentiation
		// between lists and scalar variables.
		"data_lists": {
			"primary": "#FF661A",
			"secondary": "#FF5500",
			"tertiary": "#E64D00"
		},
		"more": {
			"primary": "#FF6680",
			"secondary": "#FF4D6A",
			"tertiary": "#FF3355"
		},
		"text": "#575E75",
		"workspace": "#F9F9F9",
		"toolboxHover": "#4C97FF",
		"toolboxSelected": "#e9eef2",
		"toolboxText": "#575E75",
		"toolbox": "#FFFFFF",
		"flyout": "#F9F9F9",
		"scrollbar": "#CECDCE",
		"scrollbarHover": '#CECDCE',
		"textField": "#FFFFFF",
		"insertionMarker": "#000000",
		"insertionMarkerOpacity": 0.2,
		"dragShadowOpacity": 0.3,
		"stackGlow": "#FFF200",
		"stackGlowSize": 4,
		"stackGlowOpacity": 1,
		"replacementGlow": "#FFFFFF",
		"replacementGlowSize": 2,
		"replacementGlowOpacity": 1,
		"colourPickerStroke": "#FFFFFF",
		// CSS colours: support RGBA
		"fieldShadow": "rgba(0,0,0,0.1)",
		"dropDownShadow": "rgba(0, 0, 0, .3)",
		"numPadBackground": "#547AB2",
		"numPadBorder": "#435F91",
		"numPadActiveBackground": "#435F91",
		"numPadText": "white", // Do not use hex here, it cannot be inlined with data-uri SVG
		"valueReportBackground": "#FFFFFF",
		"valueReportBorder": "#AAAAAA"
	};

	function register_colour(name){
		Blockly.Extensions.register('colours_' + name, function(){
			const colour = colours[name];
			this.setColour(colour.primary, colour.secondary, colour.tertiary);
		});
	}
}();

Blockly.Extensions.register('colour_robots', function(){
	let colours = {
   "primary": "#0fBD8C",
			"secondary": "#0DA57A",
			"tertiary": "#0B8E69"
  };
	this.setColour(colours.primary, colours.secondary, colours.tertiary);
});

//Blockly.HSV_SATURATION = 0.6; // 0 (inclusive) to 1 (exclusive), defaulting to 0.45
//Blockly.HSV_VALUE = 0.8;// 0 (inclusive) to 1 (exclusive), defaulting to 0.65

Blockly.defineBlocksWithJsonArray(require('./blocks_for_scratch')('elf'));

const defaultXml = `<xml xmlns="https://developers.google.com/blockly/xml"><block type="${startBlockName}" editable="false" deletable="false" movable="false"></block></xml>`;

//Blockly.VerticalFlyout.prototype.autoClose = true;
Blockly.BlockSvg.START_HAT = true;

const workspace = Blockly.inject('blocklyDiv', {
	media: 'media/',
	toolbox: require('./toolbox_for_scratch'),
	grid: {
		spacing: 20,
		length: 3,
		colour: '#ccc',
		snap: true
	},
	zoom: {
		startScale: 1.0,
		maxScale: 3,
		minScale: 0.3,
	},
	theme: require('./scratch_theme')
});

Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(defaultXml), workspace);

workspace.addChangeListener(Blockly.Events.disableOrphans);
//workspace.addChangeListener(evt => console.log('changed'));

const toJSON = require('../fileformats/xml/toJSON.js');
const js_engine = require('../blockly/js_engine.js');

const runBtn = document.getElementById('runBtn');
const mask = document.getElementById('mask');

const context = function(){
	const primitives = require('./op/Primitives2.js');
	const varDict = Object.create(null);
	const context = {
	text({TEXT}){
		return TEXT || '';
	},
	math_number({NUM}){
		let v = Number(NUM);
		return isNaN(v) ? NUM : v;
	},
	math_arithmetic({OP, A, B}){
		if(OP == 'ADD')return A + B;
		if(OP == 'MINUS')return A - B;
		if(OP == 'MULTIPLY')return A * B;
		if(OP == 'DIVIDE')return A / B;
		if(OP == 'POWER')return A ** B;
	},
	math_single({OP, NUM}){
		if(OP == 'ROOT')return Math.sqrt(NUM);
		if(OP == 'ABS')return Math.abs(NUM);
		if(OP == 'NEG')return -NUM;
		if(OP == 'LN')return Math.log(NUM);
		if(OP == 'LOG10')return Math.log10(NUM);
		if(OP == 'EXP')return Math.exp(NUM);
		if(OP == 'POW10')return 10 ** NUM;
	},
	math_trig({OP, NUM}){
		if(OP == 'SIN')return Math.sin(NUM);
		if(OP == 'COS')return Math.cos(NUM);
		if(OP == 'TAN')return Math.tan(NUM);
		if(OP == 'ASIN')return Math.asin(NUM);
		if(OP == 'ACOS')return Math.acos(NUM);
		if(OP == 'ATAN')return Math.atan(NUM);
	},
	math_constant({CONSTANT}){
		if(CONSTANT == 'PI')return Math.PI;
		if(CONSTANT == 'E')return Math.E;
		if(CONSTANT == 'GOLDEN_RATIO')return 2 / (Math.sqrt(5) - 1);
		if(CONSTANT == 'SQRT2')return Math.SQRT2;
		if(CONSTANT == 'SQRT1_2')return Math.SQRT1_2;
		if(CONSTANT == 'INFINITY')return Infinity;
	},
	math_number_property({PROPERTY, NUMBER_TO_CHECK, DIVISOR}){
		if(PROPERTY == 'EVEN')return NUMBER_TO_CHECK % 2 == 0;
		if(PROPERTY == 'ODD')return NUMBER_TO_CHECK % 2 == 1;
		if(PROPERTY == 'WHOLE')return Number.isInteger(NUMBER_TO_CHECK);
		if(PROPERTY == 'POSITIVE')return NUMBER_TO_CHECK > 0;
		if(PROPERTY == 'NEGATIVE')return NUMBER_TO_CHECK < 0;
		if(PROPERTY == 'DIVISIBLE_BY')return NUMBER_TO_CHECK % DIVISOR == 0;
		if(PROPERTY == 'PRIME'){
			for(let i=2, n=NUMBER_TO_CHECK>>1; i<n; ++i){
				if(NUMBER_TO_CHECK % i == 0)return false;
			}
			return true;
		}
	},
	math_round({OP, NUM}){
		if(OP == 'ROUND')return Math.round(NUM);
		if(OP == 'ROUNDUP')return Math.ceil(NUM);
		if(OP == 'ROUNDDOWN')return Math.floor(NUM);
	},
	math_on_list({OP, LIST}){
		if(OP == 'MIN')return Math.min.apply(null, LIST);
		//not finish
	},
	math_modulo({DIVIDEND, DIVISOR}){
		return DIVIDEND % DIVISOR;
	},
	math_constrain({VALUE, LOW, HIGH}){
		return Math.min(Math.max(VALUE, LOW), HIGH);
	},
	math_random_int({FROM, TO}){
		if(FROM > TO){
			let t = FROM;
			FROM = TO;
			TO = t;
		}
		return Math.floor(Math.random() * (TO - FROM + 1) + FROM);
	},
	math_random_float(){
		return Math.random();
	},
	math_atan2({X, Y}){
		return Math.atan2(Y, X);
	},
	text_length({VALUE}){
		return VALUE ? VALUE.length : 0;
	},
	text_print({TEXT}){
		console.log(TEXT);
	},
	text_join(args){
		let keys = Object.keys(args).sort();
		return keys.map(k => args[k]).join('');
	},
	text_append({VAR, TEXT}){
		console.log('text_append', VAR, TEXT)
	},
	text_isEmpty({VALUE}){
		return VALUE.length == 0;
	},
	lists_create_empty(){
		return [];
	},
	lists_create_with(args){
		let keys = Object.keys(args).sort();
		return keys.map(k => args[k]);
	},
	colour_picker({COLOUR}){
		return parseInt(COLOUR.slice(1), 16);
	},
	colour_random(){
		return Math.floor(Math.random() * 0x1000000);
	},
	colour_rgb({RED, GREEN, BLUE}){
		let r = 2.55 * Math.max(0, Math.min(100, RED));
		let g = 2.55 * Math.max(0, Math.min(100, GREEN));
		let b = 2.55 * Math.max(0, Math.min(100, BLUE));
		return r << 16 | g << 8 | b;
	},
	colour_blend({COLOUR1, COLOUR2, RATIO}){
		let ratio = Math.max(Math.min(RATIO, 1), 0);
		let r = Math.round((COLOUR1 >> 16 & 0xFF) * (1 - ratio) + (COLOUR2 >> 16 & 0xFF) * ratio);
		let g = Math.round((COLOUR1 >>  8 & 0xFF) * (1 - ratio) + (COLOUR2 >>  8 & 0xFF) * ratio);
		let b = Math.round((COLOUR1 & 0xFF) * (1 - ratio) + (COLOUR2 & 0xFF) * ratio);
		return r << 16 | g << 8 | b;
	},
	variables_get({VAR}){
		if(VAR in varDict){
			return varDict[VAR];
		}
	},
	variables_set({VAR, VALUE}){
		varDict[VAR] = VALUE;
	},
	math_change({VAR, DELTA}){
		if(VAR in varDict){
			varDict[VAR] = Number(varDict[VAR]) + DELTA;
		}else{
			varDict[VAR] = DELTA;
		}
	},
	logic_boolean({BOOL}){
		return BOOL === 'TRUE';
	},
	logic_negate({BOOL}){
		return !BOOL;
	},
	logic_null(){
		return null;
	},
	logic_compare({OP, A, B}){
		if(OP == 'EQ')return A == B;
		if(OP == 'LT')return A < B;
		if(OP == 'GT')return A > B;
		if(OP == 'NEQ')return A != B;
		if(OP == 'LTE')return A <= B;
		if(OP == 'GTE')return A >= B;
	},
	logic_operation({OP, A, B}){
		if(OP == 'AND')return A && B;
		if(OP == 'OR')return A || B;
	},
	str2ascii({VALUE}){
		return VALUE.charCodeAt();
	},
	ascii2str({VALUE}){
		return String.fromCharCode(VALUE);
	},
	sensing_timer(){
		if(!this._timer){
			this._timer = Date.now();
		}
		return (Date.now() - this._timer) * 0.001;
	},
	sensing_resettimer(){
		this._timer = Date.now();
	},
	sensing_current({CURRENTMENU}){
		const date = new Date();
		switch (CURRENTMENU.toLowerCase()) {
		case 'year': return date.getFullYear();
		case 'month': return date.getMonth() + 1; // getMonth is zero-based
		case 'date': return date.getDate();
		case 'dayofweek': return date.getDay() + 1; // getDay is zero-based, Sun=0
		case 'hour': return date.getHours();
		case 'minute': return date.getMinutes();
		case 'second': return date.getSeconds();
		}
		return 0;
	},
	sensing_dayssince2000(){
		const msPerDay = 24 * 60 * 60 * 1000;
		const start = new Date(2000, 0, 1); // Months are 0-indexed.
		const today = new Date();
		const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
		let mSecsSinceStart = today.valueOf() - start.valueOf();
		mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);
		return mSecsSinceStart / msPerDay;
	}
}
return Object.assign({net:{sendData(buffer){
	return window.sendBLERawData(buffer.buffer);
}}}, context, primitives);
}();

function onExecFinish(){
	js_engine.stop();
	mask.style.display = 'none';
}

mask.onclick = onExecFinish;
runBtn.onclick = async function(){
	await connectBLE();
	//let workspace = Blockly.getMainWorkspace();
	let json = toJSON(Blockly.Xml.workspaceToDom(workspace));
	js_engine.exec(json.block, startBlockName, context);
	js_engine.onfinish = onExecFinish;
	mask.style.display = 'block';
}


