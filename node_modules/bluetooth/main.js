'use strict';

require('./Buffer');
require('./field_matrix');
require('./field_note');
require('./zh-hans');

function listenDragDrop(handler){
	window.addEventListener('dragover', evt => {
		evt.preventDefault();
		return false;
	});
	window.addEventListener('drop', evt => {
		evt.preventDefault();
		handler(Array.from(evt.dataTransfer.files, v => v.path));
		return false;
	});
}

listenDragDrop(v => console.log(v))

const overrideMethod = require('../utils/function/overrideMethod.js');
const {getSearchInfo} = require('../webonly/index.js');
const searchInfo = Object.assign({board:'elf'}, getSearchInfo());

function getHeadFile(){
	if(searchInfo.board == 'elf'){
		return '#include<WeELF2560.h>\n';
		return '#include<WeELF328P.h>\n';
	}
	if(searchInfo.board == 'mini'){
		return '#include<WeELFMini.h>\n';
	}
	return '';
}

function updateToolBoxByTag(toolbox, board){
	for(let category of toolbox.childNodes){
		if(category.nodeType != Node.ELEMENT_NODE)continue;
		if(category.localName != 'category')continue;
		for(let block of category.childNodes){
			if(block.nodeType != Node.ELEMENT_NODE)continue;
			if(block.localName != 'block')continue;
			let type = block.getAttribute('type');
			if(type.startsWith('weeemake_weeebot_')){
				if(board == 'mini'){
					block.remove();
				}
				//block.setAttribute('disabled', board == 'mini');
			}else if(type.startsWith('weeemake_weeebotMini_')){
				if(board == 'elf'){
					block.remove();
				}
				//block.setAttribute('disabled', board == 'elf');
			}
		}
	}
	return toolbox;
}

const startBlockName = 'when_start';

Blockly.Extensions.registerMutator('wifi_mode_mutator', {
	mutationToDom(){
		const container = Blockly.utils.xml.createElement('mutation');
		container.setAttribute('mode', this.getFieldValue('MODE'));
		return container;
	},
	domToMutation(xmlElement){
		this.updateShape_(xmlElement.getAttribute('mode'));
	},
	updateShape_(mode){
		if(mode == 'tcp' || mode == 'slave'){
			if(this.getInput('CHANNEL')){
				this.removeInput('CHANNEL');
			}
			if(!this.getInput('IP')){
				this.appendDummyInput('IP').appendField('ip地址').appendField(new Blockly.FieldTextInput("192.168.0.1"), 'IP');
			}
			if(!this.getInput('PORT')){
				this.appendDummyInput('PORT').appendField('端口').appendField(new Blockly.FieldNumber(6602, 0, 65535, 1), 'PORT');
			}
		}else if(mode == 'ap'){
			if(this.getInput('IP')){
				this.removeInput('IP');
			}
			if(this.getInput('PORT')){
				this.removeInput('PORT');
			}
			if(!this.getInput('CHANNEL')){
				this.appendDummyInput('CHANNEL').appendField('信道').appendField(new Blockly.FieldNumber(11, 0, 255, 1), 'CHANNEL');
			}
		}else if(mode == 'sta'){
			if(this.getInput('IP')){
				this.removeInput('IP');
			}
			if(this.getInput('PORT')){
				this.removeInput('PORT');
			}
			if(this.getInput('CHANNEL')){
				this.removeInput('CHANNEL');
			}
		}
	}
}, function(){
	this.getField('MODE').setValidator(function(option){
		this.getSourceBlock().updateShape_(option);
	});
});
Blockly.Extensions.register('wifi_update_output', function(){
	this.getField('WIFI_VALUE_NAME').setValidator(function(option){
		this.getSourceBlock().setOutput(true, option == '1' ? "Number" : "String");
	});
});
Blockly.Extensions.register('testAlex', function(){
	setTimeout(() => {
		const input = this.getInputTargetBlock('SENSOR_PORT');
		if(!input)return;
		input.setEditable(false);
		input.setEnabled(false);
	});
});
Blockly.Extensions.register('markAsyncFunc', function(){this.data = 'isAsyncFunc';});
Blockly.Extensions.register('markConstText', function(){this.data = 'isConstText';});
Blockly.Extensions.register('markConstNumber', function(){this.data = 'isConstNumber';});
Blockly.Extensions.register('markStatement', function(){
	this.setPreviousStatement(true, null);
	this.setNextStatement(true, null);
});
Blockly.Extensions.register('set_colours_image_recognition', function(){
	let field = this.getField("IMAGE_RECOGNITION_TYPE");
	field.setColours(['#e17373','#e08649','#5450e8','#37b80c','#24716b']);
});
Blockly.Extensions.register('sync_parent_style', function(){
	setTimeout(() => {
		this.setStyle(this.outputConnection.targetConnection.getSourceBlock().getStyleName());
	}, 0);
});
const blockTypeColorDict = {
	'Number': 'math_blocks',
	'String': 'text_blocks',
	'Array': 'list_blocks',
	'Boolean': 'logic_blocks',
};
const blockTypeBlockDict = {
	'Number': 'math_number',
	'String': 'text',
	'Array': 'lists_create_empty',
	'Boolean': 'logic_boolean',
};
const variables_sync_type_helper = callback => function(){
	function handler(id){
		const type = Blockly.getMainWorkspace().getVariableById(id).type;
		//this.setTypes_([type], type);
		callback.call(this.getSourceBlock(), type);
	}
	const fieldVar = this.getField("VAR");
	fieldVar.setValidator(handler);
	setTimeout(() => handler.call(fieldVar, fieldVar.getValue()), 0);
};
Blockly.Extensions.register('variables_set_sync_value_type', variables_sync_type_helper(function(type){
	const input = this.getInput('VALUE');
	if(input.connection.check_ && input.connection.check_.indexOf(type) >= 0){
		return;
	}
	input.setCheck(type);
	if(this.getInputTargetBlock('VALUE'))return;

	const blockType = blockTypeBlockDict[type] || 'math_number';
	const topBlocks = this.workspace.getTopBlocks();
	let block = topBlocks.find(block => block.type == blockType);
	if(!block){
		let blockDef = `<block type="${blockType}"></block>`;
		block = Blockly.Xml.domToBlock(Blockly.Xml.textToDom(blockDef), this.workspace);
	}
	block.outputConnection.connect(input.connection);
	
	//this.setStyle(blockTypeColorDict[type]);
}));
Blockly.Extensions.register('variables_get_sync_output_type', variables_sync_type_helper(function(type){
	this.setOutput(true, type);
	//this.setStyle(blockTypeColorDict[type]);
}));
Blockly.Extensions.register('fix_list_block', function(){
	const fieldVar = this.getField("LIST");
	setTimeout(() => {
		fieldVar.setTypes_(['Array'], 'Array');
		fieldVar.setValue(fieldVar.getOptions()[0][1]);
	}, 0);
});

function procedures_mutator(fn, hasOutputFn){
	const getAttributeName = v => v.getAttribute('name');
	return {
		mutationToDom(){
			const inputList = fn(this.inputList);
			const container = Blockly.utils.xml.createElement('mutation');
			//container.setAttribute('name', this.getFieldValue('NAME'));
			container.setAttribute('hasOutput', hasOutputFn(this));
			for (let i=0; i < inputList.length; ++i) {
				const input = inputList[i];
				const parameter = Blockly.utils.xml.createElement('arg');
				parameter.setAttribute('name', input.name);
				container.appendChild(parameter);
			}
			return container;
		},
		domToMutation(xmlElement){
			//xmlElement.childNodes, xmlElement.children
			this._updateShape(
				Array.from(xmlElement.children, getAttributeName),
				xmlElement.getAttribute('hasOutput') == 'true'
			);
		},
		_hasOutput(){
			return hasOutputFn(this);
		},
		_getArgList(){
			return fn(this.inputList).map(v => v.name);
		}
	};
}
Blockly.Extensions.registerMutator('procedures_definition', {
	...procedures_mutator(inputList => {
		const index = inputList.findIndex(v => v.type == Blockly.DUMMY_INPUT && v.name == 'PARAMS');
		return inputList.slice(1, index);
	}, block => block.getInput('OUTPUT') != null),
	_updateShape(argList, hasOutput){
		//this._forEachCallDo(block => block._updateShape(argList, hasOutput));
		for(let name of argList){
			this._addArgInput(name);
		}
		if(hasOutput){
			this.appendValueInput('OUTPUT').setCheck('Number').appendField('返回').setAlign(Blockly.ALIGN_RIGHT);
		}
	},
	_isNameUsed(name){
		const blockList = this.workspace.getAllBlocks(false);
		for(let i=0; i < blockList.length; ++i){
			const block = blockList[i];
			if(block == this)continue;
			if(block.type != 'procedures_definition')continue;
			if(Blockly.Names.equals(block.getFieldValue('NAME'), name))return true;
		}
		return false;
	},
	_findLegalName(name){
		if(this.isInFlyout)return name;
		if(!name){
			name = Blockly.Msg['UNNAMED_KEY'] || 'unnamed';
		}
		while(this._isNameUsed(name)){
			let pattern = name.match(/^(.*?)(\d+)$/);
			if(pattern){
				name = pattern[1] + (parseInt(pattern[2], 10) + 1);
			}else{
				name += '2';
			}
		}
		return name;
	},
	_addArgInput(name){
		const input = this.appendValueInput(name).setCheck('Number');
		this.moveInputBefore(name, 'PARAMS');
		return input;
	},
	_addArg(name){
		const input = this._addArgInput(name);
		Blockly.Xml.domToBlock(
			Blockly.Xml.textToDom(`<block type="procedures_param"><field name="NAME">${name}</field></block>`),
			this.workspace
		).outputConnection.connect(input.connection);
		this._forEachCallDo(block => block._addArg(name));
	},
	_subArg(name){
		this.getInputTargetBlock(name).dispose();
		this.removeInput(name);
		this._forEachCallDo(block => block._subArg(name));
	},
	_forEachCallDo(fn){
		const blockName = this.getFieldValue('NAME');
		const blockList = this.workspace.getAllBlocks(false);
		for(let i=0; i < blockList.length; ++i){
			const block = blockList[i];
			if(block.type != 'procedures_call')continue;
			if(!Blockly.Names.equals(block.getFieldValue('NAME'), blockName))continue;
			fn(block);
		}
	}
}, function(){
	this.getField("NAME").setValidator(function(newName){
		newName = newName.trim();
		const legalName = this.getSourceBlock()._findLegalName(newName);
		const oldName = this.getValue();
		if(oldName != newName && oldName != legalName){
			this.getSourceBlock()._forEachCallDo(block => block.setFieldValue(legalName, 'NAME'));
		}
		return legalName;
	});
	this.getField("sub_btn").setOnClickHandler(function(){
		const block = this.getSourceBlock();
		const argList = block._getArgList();
		if(argList.length <= 0)return;
		block._subArg(argList.pop());
	});
	const specArgNames = ['PARAMS', 'OUTPUT', 'SUBSTACK'];
	this.getField("add_btn").setOnClickHandler(function(){
		const block = this.getSourceBlock();
		const argList = block._getArgList();

		function callback(name){
			if(!name)return;
			name = name.trim();
			if(argList.includes(name) || specArgNames.includes(name)){
				promptVarName("变量名重复,请重新命名!");
				return;
			}
			block._addArg(name);
		}

		const promptVarName = title => Blockly.prompt(title, String.fromCharCode(97 + argList.length), callback);
		promptVarName('变量名');
	});
});
Blockly.Extensions.registerMutator('procedures_call', {
	...procedures_mutator(inputList => inputList.slice(1), block => block.outputConnection != null),
	_updateShape(argList, hasOutput){
		for(let name of argList){
			this._addArgInput(name);
		}
		if(hasOutput){
			this.setPreviousStatement(false);
			this.setNextStatement(false);
			this.setOutput(true, 'Number');
		}
	},
	_addArgInput(name){
		return this.appendValueInput(name).appendField(name).setCheck('Number');
	},
	_addArg(name){
		this._addArgInput(name);
	},
	_subArg(name){
		this.removeInput(name);
	},
	onchange(evt){
		//Blockly.Workspace.getById(evt.workspaceId)
		if(!this.workspace || this.workspace.isFlyout)return;
		if(!evt.recordUndo)return;
		if(evt.type == Blockly.Events.BLOCK_DELETE){
			const name = this.getFieldValue('NAME');
			const topBlockList = this.workspace.getTopBlocks(false);
			const defineBlock = topBlockList.find(v => v.type == 'procedures_definition' && Blockly.Names.equals(v.getFieldValue('NAME'), name));
			if(!defineBlock){
				Blockly.Events.setGroup(evt.group);
				this.dispose(true);
				Blockly.Events.setGroup(false);
			}
		}
	}
});
Blockly.Extensions.registerMutator('procedures_ifreturn', {
	mutationToDom(){
		const container = Blockly.utils.xml.createElement('mutation');
		container.setAttribute('hasReturnValue', this._hasReturnValue());
		return container;
	},
	domToMutation(xmlElement){
		this._updateShape(xmlElement.getAttribute('hasReturnValue') == 'true');
	},
	_hasReturnValue(){
		return this.getInput('VALUE').type == Blockly.INPUT_VALUE;
	},
	_updateShape(hasReturnValue){
		if(hasReturnValue == this._hasReturnValue())return;
		this.removeInput('VALUE');
		const input = hasReturnValue ? this.appendValueInput('VALUE') : this.appendDummyInput('VALUE');
		input.appendField(Blockly.Msg['PROCEDURES_DEFRETURN_RETURN']);
	},
	onchange(){
		if(this.workspace.isDragging())return;
		let legal = false;
		let block = this;
		do{
			if(block.type == 'procedures_definition'){
				legal = true;
				break;
			}
			block = block.getSurroundParent();
		}while(block);
		if(legal){
			this._updateShape(block._hasOutput());
			this.setWarningText(null);
			if(!this.isInFlyout){
				this.setEnabled(true);
			}
		}else{
			this.setWarningText(Blockly.Msg['PROCEDURES_IFRETURN_WARNING']);
			if (!this.isInFlyout && !this.getInheritedDisabled()) {
				this.setEnabled(false);
			}
		}
	}
});
Blockly.Extensions.register('procedures_param', function(){
	this.setOnChange(function(evt){
		if(this.workspace.isDragging())return;
		const name = this.getFieldValue('NAME');
		let legal = false;
		let block = this;
		do{
			if(block.type == 'procedures_definition' && block._getArgList().includes(name)){
				legal = true;
				break;
			}
			block = block.getSurroundParent();
		}while(block);
		if(legal){
			this.setWarningText(null);
			this.setEnabled(true);
		}else{
			this.setWarningText(Blockly.Msg['PROCEDURES_IFRETURN_WARNING']);
			if(!this.getInheritedDisabled()) {
				this.setEnabled(false);
			}
			if(this.getParent()){
				this.unplug();
			}
		}
	});
});
function isParamDefineBlock(block){
	if(!block)return false;
	const parent = block.getParent();
	if(!parent)return false;
	return block.type == 'procedures_param' && parent.type == 'procedures_definition' && parent.getInputTargetBlock('OUTPUT') != block
}
overrideMethod(Blockly.Connection.prototype, 'isConnectionAllowed', oldFn => function(candidate){
	return oldFn.call(this, candidate) && !(
		candidate.type == Blockly.INPUT_VALUE
		&& candidate.targetConnection
		&& isParamDefineBlock(candidate.targetConnection.getSourceBlock())
	);
});
overrideMethod(Blockly.Gesture.prototype, 'startDraggingBlock_', oldFn => function(){
	let block = this.targetBlock_;
	if(isParamDefineBlock(block)){
		const root = Blockly.utils.xml.createElement('xml');
		root.appendChild(Blockly.Xml.blockToDomWithXY(block, true));
		const blockIds = Blockly.Xml.domToWorkspace(root, block.workspace);
		block.unselect();
		block = block.workspace.getBlockById(blockIds[0]);
		block.select();
		this.targetBlock_ = block;
	}
	oldFn.call(this);
});

void function(){
	const colours = {
		"motion": {
			"primary": "#4C97FF",
			"secondary": "#4280D7",
			"tertiary": "#3373CC"
		},
		"looks": {
			"primary": "#9966FF",
			"secondary": "#855CD6",
			"tertiary": "#774DCB"
		},
		"sounds": {
			"primary": "#CF63CF",
			"secondary": "#C94FC9",
			"tertiary": "#BD42BD"
		},
		"control": {
			"primary": "#FFAB19",
			"secondary": "#EC9C13",
			"tertiary": "#CF8B17"
		},
		"event": {
			"primary": "#FFBF00",
			"secondary": "#E6AC00",
			"tertiary": "#CC9900"
		},
		"sensing": {
			"primary": "#5CB1D6",
			"secondary": "#47A8D1",
			"tertiary": "#2E8EB8"
		},
		"pen": {
			"primary": "#0fBD8C",
			"secondary": "#0DA57A",
			"tertiary": "#0B8E69"
		},
		"operators": {
			"primary": "#59C059",
			"secondary": "#46B946",
			"tertiary": "#389438"
		},
		"data": {
			"primary": "#FF8C1A",
			"secondary": "#FF8000",
			"tertiary": "#DB6E00"
		},
		// This is not a new category, but rather for differentiation
		// between lists and scalar variables.
		"data_lists": {
			"primary": "#FF661A",
			"secondary": "#FF5500",
			"tertiary": "#E64D00"
		},
		"more": {
			"primary": "#FF6680",
			"secondary": "#FF4D6A",
			"tertiary": "#FF3355"
		},
		"text": "#575E75",
		"workspace": "#F9F9F9",
		"toolboxHover": "#4C97FF",
		"toolboxSelected": "#e9eef2",
		"toolboxText": "#575E75",
		"toolbox": "#FFFFFF",
		"flyout": "#F9F9F9",
		"scrollbar": "#CECDCE",
		"scrollbarHover": '#CECDCE',
		"textField": "#FFFFFF",
		"insertionMarker": "#000000",
		"insertionMarkerOpacity": 0.2,
		"dragShadowOpacity": 0.3,
		"stackGlow": "#FFF200",
		"stackGlowSize": 4,
		"stackGlowOpacity": 1,
		"replacementGlow": "#FFFFFF",
		"replacementGlowSize": 2,
		"replacementGlowOpacity": 1,
		"colourPickerStroke": "#FFFFFF",
		// CSS colours: support RGBA
		"fieldShadow": "rgba(0,0,0,0.1)",
		"dropDownShadow": "rgba(0, 0, 0, .3)",
		"numPadBackground": "#547AB2",
		"numPadBorder": "#435F91",
		"numPadActiveBackground": "#435F91",
		"numPadText": "white", // Do not use hex here, it cannot be inlined with data-uri SVG
		"valueReportBackground": "#FFFFFF",
		"valueReportBorder": "#AAAAAA"
	};

	function register_colour(name){
		Blockly.Extensions.register('colours_' + name, function(){
			const colour = colours[name];
			this.setColour(colour.primary, colour.secondary, colour.tertiary);
		});
	}
}

//Blockly.HSV_SATURATION = 0.6; // 0 (inclusive) to 1 (exclusive), defaulting to 0.45
//Blockly.HSV_VALUE = 0.8;// 0 (inclusive) to 1 (exclusive), defaulting to 0.65

Blockly.defineBlocksWithJsonArray(require('./blocks_for_scratch')(searchInfo.board));
//const defaultToolbox = require('./toolbox_for_scratch');
const defaultToolbox = require('./toolbox.json');

//const defaultXml = `<xml xmlns="https://developers.google.com/blockly/xml"><block type="${startBlockName}" editable="false" deletable="false" movable="false"></block></xml>`;
const defaultXml = `<xml xmlns="https://developers.google.com/blockly/xml"><block type="${startBlockName}" editable="false" deletable="false" movable="false"></block></xml>`;

Blockly.VerticalFlyout.prototype.autoClose = true;
//Blockly.BlockSvg.START_HAT = true;
//Blockly.ZoomControls.prototype.MARGIN_BOTTOM_ = 200;

overrideMethod(Blockly.Toolbox.prototype, 'addColour_', oldFn => function(opt_tree){
	var tree = opt_tree || this.tree_;
	var children = tree.getChildren(false);
	for (var i = 0, child; (child = children[i]); i++) {
		var element = child.getRowElement();
		if (element) {
			if(!element.firstChild.className.startsWith('blocklyTreeIcon')){
				continue;
			}
			element.firstChild.style.backgroundColor = child.hexColour;
			var border = '4px';
			if (this.workspace_.RTL) {
				element.style.paddingRight = border;
			} else {
				element.style.paddingLeft = border;
			}
		}
		this.addColour_(child);
	}
});

overrideMethod(Blockly.Toolbox.prototype, 'handleBeforeTreeSelected_', oldFn => function(node){
	if (node == this.tree_) {
		return false;
	}
	if (this.lastCategory_) {
		this.lastCategory_.getRowElement().style.backgroundColor = '';
	}
	if (node) {
		var hexColour = node.hexColour || '#57e';
		node.getRowElement().style.backgroundColor = hexColour;
		this.addColour_(node);
	}
	return true;
});

Blockly.Procedures.flyoutCategory = function(){
	const argFn = v => `<arg name="${v}"></arg>`;
	const mapFn = type => block =>
`<block type="${type}">
	<field name="NAME">${block.getFieldValue('NAME')}</field>
	<mutation hasOutput="${block._hasOutput()}">
		${block._getArgList().map(argFn).join('')}
	</mutation>
</block>`;
	const mapFn1 = mapFn('procedures_call');
	//const mapFn1 = mapFn('procedures_callnoreturn');
	//const mapFn2 = mapFn('procedures_callreturn');
	return function(workspace){
		const result = [
`<block type="procedures_definition"></block>`,
`<block type="procedures_definition">
	<mutation hasOutput="true">
	</mutation>
</block>`,
`<block type="procedures_ifreturn">
	<value name="CONDITION">
		<shadow type="logic_boolean"></shadow>
	</value>
	<value name="VALUE">
		<block type="math_number"></block>
	</value>
</block>`,
/*`<block type="procedures_defnoreturn">
	<field name="NAME">${Blockly.Msg['PROCEDURES_DEFNORETURN_PROCEDURE']}</field>
</block>`,
`<block type="procedures_defreturn">
	<field name="NAME">${Blockly.Msg['PROCEDURES_DEFRETURN_PROCEDURE']}</field>
</block>`,
`<block type="procedures_ifreturn"></block>`,
		...workspace.getBlocksByType('procedures_defnoreturn').map(mapFn1),
		...workspace.getBlocksByType('procedures_defreturn').map(mapFn2)*/
		...workspace.getBlocksByType('procedures_definition').map(mapFn1)
		];
		return result.map(Blockly.Xml.textToDom);
	}
}();

Blockly.Variables.flyoutCategory = function(){
	
	const variables_get = variable =>
		 `<block type="variables_get"><field name="VAR" id="${variable.getId()}" variabletype="${variable.type}">${variable.name}</field></block>`;
	return function(workspace){
		function registerButtonCallback(key, type){
			workspace.registerButtonCallback(key, function(button){
				Blockly.Variables.createVariableButtonHandler(button.getTargetWorkspace(), undefined, type);
			});
		}
	registerButtonCallback('CREATE_VARIABLE', '');
	registerButtonCallback('CREATE_VARIABLE_NUMBER', 'Number');
	registerButtonCallback('CREATE_VARIABLE_STRING', 'String');
	registerButtonCallback('CREATE_VARIABLE_BOOLEAN', 'Boolean');
	registerButtonCallback('CREATE_VARIABLE_ARRAY', 'Array');
	const result = [
		`<button text="创建数字变量" callbackKey="CREATE_VARIABLE_NUMBER"></button>`,
		`<button text="创建文本变量" callbackKey="CREATE_VARIABLE_STRING"></button>`,
		`<button text="创建布尔变量" callbackKey="CREATE_VARIABLE_BOOLEAN"></button>`,
		`<button text="创建列表变量" callbackKey="CREATE_VARIABLE_ARRAY"></button>`,
	];

	const varList = workspace.getAllVariables().filter(variable => variable.type !== 'Array');
	const numberVarList = varList.filter(variable => variable.type === '' || variable.type === 'Number');
	const arrayVarList = workspace.getVariablesOfType('Array');

	if(varList.length > 0){
		const mostRecentVariable = varList[varList.length - 1];
		result.push(
`<label text="变量"></label>`,
`<block type="variables_set">
	<field name="VAR" id="${mostRecentVariable.getId()}" variabletype="${mostRecentVariable.type}">${mostRecentVariable.name}</field>
</block>`,
	);
	}
	
	if(numberVarList.length > 0){
		const mostRecentVariable = numberVarList[numberVarList.length - 1];
		result.push(
`<block type="math_change">
	<field name="VAR" id="${mostRecentVariable.getId()}" variabletype="${mostRecentVariable.type}">${mostRecentVariable.name}</field>
	<value name="DELTA">
		<shadow type="math_number">
			<field name="NUM">1</field>
		</shadow>
	</value>
</block>`);
	}

	varList.sort(Blockly.VariableModel.compareByName);
	result.push(...varList.map(variables_get));

	if(arrayVarList.length > 0){
		result.push(
`<label text="列表"></label>`,
`<block type="lists_deletealloflist"></block>`,
`<block type="lists_addtolist">
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_deleteoflist">
	<value name="INDEX">
		<shadow type="math_lists_index">
			<field name="NUM">1</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_replaceitemoflist">
	<value name="INDEX">
		<shadow type="math_lists_index">
			<field name="NUM">1</field>
		</shadow>
	</value>
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_insertatlist">
	<value name="INDEX">
		<shadow type="math_lists_index">
			<field name="NUM">1</field>
		</shadow>
	</value>
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_itemoflist">
	<value name="INDEX">
		<shadow type="math_lists_index">
			<field name="NUM">1</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_indexOf">
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
`<block type="lists_length"></block>`,
`<block type="lists_listcontainsitem">
	<value name="VALUE">
		<shadow type="math_number">
			<field name="NUM">100</field>
		</shadow>
	</value>
</block>`,
		);
	}
	return result.map(Blockly.Xml.textToDom);
}
}();

/*
overrideMethod(Blockly.Toolbox.prototype, 'updateSelectedItemColour_', oldFn => function(tree){
	var selectedItem = tree.getSelectedItem();
	if(!selectedItem)return;
	var hexColour = selectedItem.hexColour || '#57e';
	//selectedItem.getRowElement().style.backgroundColor = hexColour;
	selectedItem.getRowElement().style.color = hexColour;
	console.log('=')
	this.addColour_(selectedItem);
});
*/
Blockly.Block.prototype.getInputsInline = function(){
	return true;
};
overrideMethod(Blockly.zelos.Renderer.prototype, 'makeConstants_', oldFn => function(){
	let result = oldFn.call(this);
	result.FIELD_COLOUR_FULL_BLOCK = false;
	result.FIELD_COLOUR_DEFAULT_WIDTH = 20;
	result.FIELD_COLOUR_DEFAULT_HEIGHT = 20;
	result.NOTCH_WIDTH = 6 * result.GRID_UNIT;
	result.NOTCH_HEIGHT = 1.5 * result.GRID_UNIT;
	result.STATEMENT_BOTTOM_SPACER = -result.NOTCH_HEIGHT;
	result.DUMMY_INPUT_MIN_HEIGHT = 24;
	result.DUMMY_INPUT_SHADOW_MIN_HEIGHT = 18;
	return result;
})

overrideMethod(Blockly.Toolbox.prototype, 'init', oldFn => function(){
	oldFn.call(this);
	let div = document.createElement('div');
	div.setAttribute('id', 'toolbox_mask');
	div.setAttribute('style', 'position:absolute;left:0;top:0;width:100%;height:100%;display:none;background-color:rgba(255,0,0,0.5);');
	this.HtmlDiv.appendChild(div);
});

overrideMethod(Blockly.BlockDragger.prototype, 'updateCursorDuringBlockDrag_', oldFn => function(){
	oldFn.call(this);
	let div = document.getElementById('toolbox_mask');
	div.style.display = this.wouldDeleteBlock_ ? 'block': 'none';
});



const toJSON = require('../fileformats/xml/toJSON.js');
const js_engine = require('../blockly/js_engine.js');

const context = function(){
	const primitives = require('./op/Primitives2.js');
	const varDict = Object.create(null);
	const context = {
	log({value}){
		console.log(value);
		message.info(value);
	},
	text({TEXT}){
		return TEXT || '';
	},
	math_number({NUM}){
		let v = Number(NUM);
		return isNaN(v) ? NUM : v;
	},
	math_arithmetic({OP, A, B}){
		if(OP == 'ADD')return A + B;
		if(OP == 'MINUS')return A - B;
		if(OP == 'MULTIPLY')return A * B;
		if(OP == 'DIVIDE')return A / B;
		if(OP == 'POWER')return A ** B;
	},
	math_single({OP, NUM}){
		if(OP == 'ROOT')return Math.sqrt(NUM);
		if(OP == 'ABS')return Math.abs(NUM);
		if(OP == 'NEG')return -NUM;
		if(OP == 'LN')return Math.log(NUM);
		if(OP == 'LOG10')return Math.log10(NUM);
		if(OP == 'EXP')return Math.exp(NUM);
		if(OP == 'POW10')return 10 ** NUM;
	},
	math_trig({OP, NUM}){
		if(OP == 'SIN')return Math.sin(NUM);
		if(OP == 'COS')return Math.cos(NUM);
		if(OP == 'TAN')return Math.tan(NUM);
		if(OP == 'ASIN')return Math.asin(NUM);
		if(OP == 'ACOS')return Math.acos(NUM);
		if(OP == 'ATAN')return Math.atan(NUM);
	},
	math_constant({CONSTANT}){
		if(CONSTANT == 'PI')return Math.PI;
		if(CONSTANT == 'E')return Math.E;
		if(CONSTANT == 'GOLDEN_RATIO')return 2 / (Math.sqrt(5) - 1);
		if(CONSTANT == 'SQRT2')return Math.SQRT2;
		if(CONSTANT == 'SQRT1_2')return Math.SQRT1_2;
		if(CONSTANT == 'INFINITY')return Infinity;
	},
	math_number_property({PROPERTY, NUMBER_TO_CHECK, DIVISOR}){
		if(PROPERTY == 'EVEN')return NUMBER_TO_CHECK % 2 == 0;
		if(PROPERTY == 'ODD')return NUMBER_TO_CHECK % 2 == 1;
		if(PROPERTY == 'WHOLE')return Number.isInteger(NUMBER_TO_CHECK);
		if(PROPERTY == 'POSITIVE')return NUMBER_TO_CHECK > 0;
		if(PROPERTY == 'NEGATIVE')return NUMBER_TO_CHECK < 0;
		if(PROPERTY == 'DIVISIBLE_BY')return NUMBER_TO_CHECK % DIVISOR == 0;
		if(PROPERTY == 'PRIME'){
			for(let i=2, n=NUMBER_TO_CHECK>>1; i<n; ++i){
				if(NUMBER_TO_CHECK % i == 0)return false;
			}
			return true;
		}
	},
	math_round({OP, NUM}){
		if(OP == 'ROUND')return Math.round(NUM);
		if(OP == 'ROUNDUP')return Math.ceil(NUM);
		if(OP == 'ROUNDDOWN')return Math.floor(NUM);
	},
	math_on_list({OP, LIST}){
		if(OP == 'MIN')return Math.min.apply(null, LIST);
		//not finish
	},
	math_modulo({DIVIDEND, DIVISOR}){
		return DIVIDEND % DIVISOR;
	},
	math_constrain({VALUE, LOW, HIGH}){
		return Math.min(Math.max(VALUE, LOW), HIGH);
	},
	math_random_int({FROM, TO}){
		if(FROM > TO){
			let t = FROM;
			FROM = TO;
			TO = t;
		}
		return Math.floor(Math.random() * (TO - FROM + 1) + FROM);
	},
	math_random_float(){
		return Math.random();
	},
	math_atan2({X, Y}){
		return Math.atan2(Y, X);
	},
	text_length({VALUE}){
		return VALUE ? VALUE.length : 0;
	},
	text_print({TEXT}){
		console.log(TEXT);
	},
	text_join(args){
		let keys = Object.keys(args).sort();
		return keys.map(k => args[k]).join('');
	},
	text_append({VAR, TEXT}){
		console.log('text_append', VAR, TEXT)
	},
	text_isEmpty({VALUE}){
		return VALUE.length == 0;
	},
	lists_create_empty(){
		return [];
	},
	lists_create_with(args){
		let keys = Object.keys(args).sort();
		return keys.map(k => args[k]);
	},
	lists_setIndex({LIST, MODE, WHERE, AT, TO}){
		if(!Array.isArray(LIST))return;
		if(MODE == 'SET'){
			if(WHERE == 'FROM_START'){
				LIST[AT - 1] = TO;
			}else if(WHERE == 'FROM_END'){
				LIST[LIST.length - AT] = TO;
			}else if(WHERE == 'FIRST'){
				LIST[0] = TO;
			}else if(WHERE == 'LAST'){
				LIST[LIST.length - 1] = TO;
			}else if(WHERE == 'RANDOM'){
				LIST[Math.floor(Math.random() * LIST.length)] = TO;
			}
		}else if(MODE == 'INSERT'){
			if(WHERE == 'FROM_START'){
				LIST.splice(AT - 1, 0, TO);
			}else if(WHERE == 'FROM_END'){
				LIST.splice(LIST.length - AT, 0, TO);
			}else if(WHERE == 'FIRST'){
				LIST.unshift(TO);
			}else if(WHERE == 'LAST'){
				LIST.push(TO);
			}else if(WHERE == 'RANDOM'){
				LIST.splice(Math.floor(Math.random() * (LIST.length + 1)), 0, TO);
			}
		}
	},
	lists_getIndex({VALUE, MODE, WHERE, AT}){
		if(!Array.isArray(VALUE))return;
		if(MODE == 'GET'){
			if(WHERE == 'FROM_START'){
				return VALUE[AT - 1];
			}else if(WHERE == 'FROM_END'){
				return VALUE[VALUE.length - AT];
			}else if(WHERE == 'FIRST'){
				return VALUE[0];
			}else if(WHERE == 'LAST'){
				return VALUE[VALUE.length - 1];
			}else if(WHERE == 'RANDOM'){
				return VALUE[Math.floor(Math.random() * VALUE.length)];
			}
		}else{
			if(WHERE == 'FROM_START'){
				return VALUE.splice(AT - 1, 1)[0];
			}else if(WHERE == 'FROM_END'){
				return VALUE.splice(VALUE.length - AT, 1)[0];
			}else if(WHERE == 'FIRST'){
				return VALUE.shift();
			}else if(WHERE == 'LAST'){
				return VALUE.pop();
			}else if(WHERE == 'RANDOM'){
				return VALUE.splice(Math.floor(Math.random() * VALUE.length), 1)[0];
			}
		}
	},
	colour_picker({COLOUR}){
		return parseInt(COLOUR.slice(1), 16);
	},
	colour_random(){
		return Math.floor(Math.random() * 0x1000000);
	},
	colour_rgb({RED, GREEN, BLUE}){
		let r = 2.55 * Math.max(0, Math.min(100, RED));
		let g = 2.55 * Math.max(0, Math.min(100, GREEN));
		let b = 2.55 * Math.max(0, Math.min(100, BLUE));
		return r << 16 | g << 8 | b;
	},
	colour_blend({COLOUR1, COLOUR2, RATIO}){
		let ratio = Math.max(Math.min(RATIO, 1), 0);
		let r = Math.round((COLOUR1 >> 16 & 0xFF) * (1 - ratio) + (COLOUR2 >> 16 & 0xFF) * ratio);
		let g = Math.round((COLOUR1 >>  8 & 0xFF) * (1 - ratio) + (COLOUR2 >>  8 & 0xFF) * ratio);
		let b = Math.round((COLOUR1 & 0xFF) * (1 - ratio) + (COLOUR2 & 0xFF) * ratio);
		return r << 16 | g << 8 | b;
	},
	variables_get({VAR}){
		if(VAR in varDict){
			return varDict[VAR];
		}
	},
	variables_set({VAR, VALUE}){
		varDict[VAR] = VALUE;
	},
	math_change({VAR, DELTA}){
		if(VAR in varDict){
			varDict[VAR] = Number(varDict[VAR]) + DELTA;
		}else{
			varDict[VAR] = DELTA;
		}
	},
	logic_boolean({BOOL}){
		return BOOL === 'TRUE';
	},
	logic_negate({BOOL}){
		return !BOOL;
	},
	logic_null(){
		return null;
	},
	logic_compare({OP, A, B}){
		if(OP == 'EQ')return A == B;
		if(OP == 'LT')return A < B;
		if(OP == 'GT')return A > B;
		if(OP == 'NEQ')return A != B;
		if(OP == 'LTE')return A <= B;
		if(OP == 'GTE')return A >= B;
	},
	logic_operation({OP, A, B}){
		if(OP == 'AND')return A && B;
		if(OP == 'OR')return A || B;
	},
	str2ascii({VALUE}){
		return VALUE.charCodeAt();
	},
	ascii2str({VALUE}){
		return String.fromCharCode(VALUE);
	},
	sensing_timer(){
		if(!this._timer){
			this._timer = Date.now();
		}
		return (Date.now() - this._timer) * 0.001;
	},
	sensing_resettimer(){
		this._timer = Date.now();
	},
	sensing_current({CURRENTMENU}){
		const date = new Date();
		switch (CURRENTMENU.toLowerCase()) {
		case 'year': return date.getFullYear();
		case 'month': return date.getMonth() + 1; // getMonth is zero-based
		case 'date': return date.getDate();
		case 'dayofweek': return date.getDay() + 1; // getDay is zero-based, Sun=0
		case 'hour': return date.getHours();
		case 'minute': return date.getMinutes();
		case 'second': return date.getSeconds();
		}
		return 0;
	},
	sensing_dayssince2000(){
		const msPerDay = 24 * 60 * 60 * 1000;
		const start = new Date(2000, 0, 1); // Months are 0-indexed.
		const today = new Date();
		const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
		let mSecsSinceStart = today.valueOf() - start.valueOf();
		mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);
		return mSecsSinceStart / msPerDay;
	},
	operator_join({STRING1, STRING2}){
		return String(STRING1) + String(STRING2);
	},
	operator_letter_of({LETTER, STRING}){
		let index = LETTER - 1;
		return String(STRING).charAt(index);
	},
	operator_contains({STRING1, STRING2}){
		return String(STRING1).toLowerCase().includes(String(STRING2).toLowerCase());
	},
	lists_deletealloflist({LIST}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return;
		list.length = 0;
	},
	lists_listcontainsitem({LIST, VALUE}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return false;
		return list.includes(VALUE);
	},
	lists_indexOf({LIST, VALUE}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return 0;
		return list.indexOf(VALUE) + 1;
	},
	lists_addtolist({LIST, VALUE}){
		const list = varDict[LIST];
		if(Array.isArray(list)){
			list.push(VALUE);
		}else{
			varDict[LIST] = [VALUE];
		}
	},
	lists_deleteoflist({LIST, INDEX}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return;
		list.splice(Math.max(0, INDEX-1), 1);
	},
	lists_length({LIST}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return 0;
		return list.length;
	},
	lists_itemoflist({LIST, INDEX}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return null;
		return list[Math.max(0, INDEX-1)];
	},
	lists_replaceitemoflist({LIST, INDEX, VALUE}){
		let list = varDict[LIST];
		if(!Array.isArray(list)){
			list = varDict[LIST] = [];
		}
		list[Math.max(0, INDEX-1)] = VALUE;
	},
	lists_insertatlist({LIST, INDEX, VALUE}){
		let list = varDict[LIST];
		if(!Array.isArray(list)){
			list = varDict[LIST] = [];
		}
		list.splice(Math.max(0, INDEX-1), 0, VALUE);
	},
	print({VAR}){
		console.log(varDict[VAR]);
	}
}
context.math_integer = context.math_number;
context.math_lists_index = context.math_number;
const result = Object.assign({net:{sendData(buffer){
	return window.sendBLERawData(buffer.buffer);
}}}, context, primitives);
return result;
}();

function regExt({blocks, toolbox, context:ctx, buttons}){
	const workspace = Blockly.getMainWorkspace();
	Blockly.defineBlocksWithJsonArray(blocks);
	defaultToolbox.contents.push(toolbox);
	for(let key in ctx){
		context[key] = ctx[key].bind(ctx);
	}
	for(let key in buttons){
		workspace.registerButtonCallback(key, buttons[key]);
	}
}

const {connectBLE} = require('./serial');
require('./generators');
const {loadData} = require('../utils/loader');
const {message} = antd;

//linkBtn.onclick = connectBLE;
/*
async function onRunCode(){
	let isFinished = false;
	function onExecFinish(){
		if(isFinished)return;
		js_engine.stop();
		antd.message.warning('程序运行终止');
	}
	const modal = antd.Modal.info({
		icon: 'loading',
		maskClosable: true,
		okType: 'danger',
		okText: '终止执行',
		title: '正在执行程序',
		onOk: onExecFinish,
		onCancel: onExecFinish,
	});
	//let workspace = Blockly.getMainWorkspace();
	//console.log(Blockly.getMainWorkspace().getTopBlocks())
	const json = toJSON(Blockly.Xml.workspaceToDom(workspace));
	js_engine.exec(json.block, startBlockName, context);
	js_engine.onfinish = function(){
		isFinished = true;
		modal.update({
			icon: React.createElement(antd.Icon, {
				type: 'check-circle',
				style: {color:'#52c41a'}
			}),
			title: '程序运行完成',
			okType: 'primary',
			okText: '关闭',
		});
	}
}

async function onUploadFirmware(){
	let data = await loadData('./online_firmware_328p.hex');
	window.resetBLE(data);
}
*/

/*
class MyDrawer extends React.Component
{
	constructor(){
		super();
		this.state = {
			visible: false,
			spinning: false,
			uploadModalVisible: false,
			step: 0,
			uploadProgress:0,
		};
		this.showDrawer = this.showDrawer.bind(this);
		this.onDrawerClose = this.onDrawerClose.bind(this);
		this.onDrawerClick = this.onDrawerClick.bind(this);
		this.onRunCode = this.onRunCode.bind(this);
		this.onUploadFirmware = this.onUploadFirmware.bind(this);
		this.onUploadCode = this.onUploadCode.bind(this);
		this.onUploadModalClose = this.onUploadModalClose.bind(this);
	}

	showDrawer(){
		this.setState({visible: true});
	}

	onDrawerClick(){
		if(this.state.spinning){
			js_engine.stop();
			this.setState({spinning: false});
			antd.message.warning('程序运行终止');
		}
	}

	onDrawerClose(){
		if(!this.state.spinning){
			this.setState({visible: false});
		}
	}

	onRunCode(){
		this.setState({spinning: true});
		const json = toJSON(Blockly.Xml.workspaceToDom(workspace));
		js_engine.exec(json.block, startBlockName, context);
		js_engine.onfinish = () => {
			this.setState({spinning: false});
			antd.message.success('程序运行结束');
		}
	}

	async onUploadFirmware(){
		this.setState({uploadModalVisible: true, step: 0});
		let data = await loadData('./online_firmware_328p.hex.raw', 'arraybuffer');
		this.setState({step: 1});
		await window.resetBLE(data,
			() => this.setState({step: 2}),
			progress => this.setState({uploadProgress: progress})
		);
		this.setState({step: 3});
		setTimeout(this.onUploadModalClose, 2000);
	}

	async onUploadCode(){
		let code = getHeadFile();
		code += Blockly.Arduino.workspaceToCode(Blockly.getMainWorkspace());
		console.log(code);
		return
		this.setState({uploadModalVisible: true, step: 0});
		let data = await loadData('compile', 'arraybuffer', 'POST', code);
		this.setState({step: 1});
		await window.resetBLE(data,
			() => this.setState({step: 2}),
			progress => this.setState({uploadProgress: progress})
		);
		this.setState({step: 3});
		setTimeout(this.onUploadModalClose, 2000);
	}

	onUploadModalClose(){
		this.setState({uploadModalVisible: false});
	}

	render(){
		const {step, uploadProgress} = this.state;
		const loadingIcon = React.createElement(antd.Progress, {type:'circle', width:30, percent: Math.round(100 * uploadProgress)});
		return React.createElement('div', null,
			React.createElement(antd.Button, {
				icon: 'menu',
				size: 'large',
				onClick: this.showDrawer
			}),
			React.createElement(antd.Drawer, {
				maskStyle: {
					backgroundColor: 'rgba(0,0,0,0)',
				},
				closable: false,
				visible: this.state.visible,
				onClose: this.onDrawerClose,
				onClick: this.onDrawerClick,
				width: 160,
				bodyStyle:{
					height: '100%',
					padding: '10px',
				}
			},
				React.createElement(antd.Spin, {
					spinning:this.state.spinning,
				},
				React.createElement('div', {
					style:{
						display:'flex',
						flexDirection: 'column',
						height: '100%',
						justifyContent: 'space-between'
					},
					},
					React.createElement(antd.Button, {
						icon: 'link',
						size: 'large',
						onClick: connectBLE
					}, '连接蓝牙'),
					React.createElement(antd.Button, {
						icon: 'upload',
						size: 'large',
						onClick: this.onUploadFirmware,
					}, '上传固件'),
					React.createElement(antd.Button, {
						icon: 'cloud-upload',
						size: 'large',
						onClick: this.onUploadCode
					}, '上传代码'),
					React.createElement('div', {
						style:{flex: 'auto',height: '100%'},
					}),
					React.createElement(antd.Button, {
						icon: 'play-circle',
						size: 'large',
						onClick: this.onRunCode
					}, '开始执行'),
				))
			),
			React.createElement(antd.Modal, {
				maskClosable: step == 3,
				closable: false,
				footer: null,
				visible: this.state.uploadModalVisible,
				onCancel: this.onUploadModalClose,
				width: '200',
				centered: true,
			},
			React.createElement(
				antd.Steps, {
					direction:'vertical',
					current:step
				},
				React.createElement(antd.Steps.Step, {title:'编译固件', subTitle:step == 0 && React.createElement(antd.Icon, {type:'loading'})}),
				React.createElement(antd.Steps.Step, {title:'上传固件', subTitle:step == 1 && loadingIcon}),
				React.createElement(antd.Steps.Step, {title:'验证固件', subTitle:step == 2 && loadingIcon}),
				React.createElement(antd.Steps.Step, {title:'上传成功', status:step == 3 ? 'finish' : 'wait'}),
			)
			)
		);
	}
}
//*/

const confirmWrap = (self, method, title) => overrideMethod(self, method, oldFn => () => 
	antd.Modal.confirm({
		title,
		okText: '确定',
		cancelText: '取消',
		centered: true,
		maskClosable: true,
		onOk(){
			oldFn.call(self);
		},
	})
);

const factoryFirmwareDict = {
	'WeeeBot': 'weeebot_factory_firmware',
	'WeeeBotMini': 'weeebotmini_factory_firmware',
	'WeeeSmart': 'Smart_home',
	'WeeeTwelveInOne': 'twelve_in_one',
	'WeeeSixInOne': 'six_in_one_evolution',
	'WeeeFourFeet': 'six_in_one_evolution',
	'WeeePenguin': 'six_in_one_evolution',
	'WeeeThreeWheels': 'six_in_one_evolution',
	'WeeeWalle': 'six_in_one_evolution',
	'WeeeWalk': 'six_in_one_evolution',
	'WeeeTank': 'six_in_one_evolution',
};

const {createElement} = require('../vdom/createElement');
const {ReactInit} = require('../vdom/ReactHelper');

const {Menu} = antd;
const {SubMenu} = Menu;

const TabPanel = require('../vdom/components/TabPanel');
const Dialog = require('../vdom/components/Dialog');
const Fieldset = require('../vdom/components/Fieldset');
const Collapse = require('../vdom/components/Collapse');
const Select = require('../vdom/components/Select');
const MenuGroup = require('../vdom/components/MenuGroup');
const MenuBar = require('../vdom/components/MenuBar');
const CodeView = require('../vdom/components/CodeView');
const Serial = require('../webonly/chrome/ChromeSerial');

const AppMenu2 = createElement(function(tag, end){
	const dialog = React.useRef();
	tag('div', {style:{flex:'auto'}})
	tag(MenuGroup, {menuWidth:'100px', style:{'--direction':'row-reverse'}})
		tag('div')
			tag`文件`
			tag('button'), tag`新建`, end('button')
			tag('button'), tag`打开`, end('button')
			tag('button'), tag`保存`, end('button')
			tag('button'), tag`另存为`, end('button')
		end('div')
		tag('div')
			tag`编辑`
			tag(MenuBar, true)
		end('div')
		tag('div')
			tag`固件`
			tag('button', {onClick(){dialog.current.showModal()}}), tag`上传在线固件`, end('button')
		end('div')
		tag('div')
			tag`帮助`
			tag('button'), tag`检查更新`, end('button')
			tag('button'), tag`公司主页`, end('button')
		end('div')
	end(MenuGroup)
	tag(Dialog, {maskClosable:true, title:'标题', ref:dialog, style:{width:300,height:400}, buttonList:[
		{title:'关闭', className:'ant-btn ant-btn-default'},
	]})
		tag(Collapse, {style:{padding:'8px'}})
			tag('div', {title:'出厂固件',open:true})
				tag('div', {style:{display:'flex',flexDirection:'column',gap:'10px'}})
					tag('button', {type:'button'}), tag`六合一探索者`, end('button')
					tag('button', {type:'button'}), tag`WeeeBot mini酷跑侠`, end('button')
				end('div')
			end('div')
			tag('div', {title:'移动端固件', open:true})
				tag('div', {style:{display:'flex',flexDirection:'column',gap:'10px'}})
					tag('button', {type:'button'}), tag`elf 328p`, end('button')
					tag('button', {type:'button'}), tag`elf 2560`, end('button')
				end('div')
			end('div')
		end(Collapse)
	end(Dialog)
	end('div')
});

const AppMenu = createElement(function(tag, end){
	const lineHeight = '2em';
	tag('nav', {style:{display:'flex',userSelect:'none',backgroundColor:'hsl(215, 100%, 65%)'}})
		tag(Menu, {mode:'horizontal',selectable:false,style:{lineHeight,flex:'auto'}})
			tag(SubMenu, {title:'文件'})
				tag(Menu.Item, {onClick:()=>console.log('new')}), tag`新建`, end(Menu.Item)
				tag(Menu.Item), tag`打开`, end(Menu.Item)
				tag(Menu.Item), tag`保存`, end(Menu.Item)
				tag(Menu.Item), tag`另存为`, end(Menu.Item)
			end(SubMenu)
			tag(SubMenu, {title:'编辑'})
				tag(Menu.Item), tag`撤销`, end(Menu.Item)
			end(SubMenu)
			tag(SubMenu, {title:'帮助'})
				tag(Menu.Item), tag`检查更新`, end(Menu.Item)
				tag(Menu.Item), tag`公司主页`, end(Menu.Item)
			end(SubMenu)
		end(Menu)
		tag(Menu, {mode:'horizontal',selectable:false,style:{lineHeight}})
			tag(Menu.Item)
				tag`代码模式 `, tag(antd.Switch, {checkedChildren:'打开', unCheckedChildren:'关闭'}, true)
			end(Menu.Item)
		end(Menu)
	end('nav')
})

class BlocklyPanel extends React.Component
{
	constructor(props){
		super(props);
		this.onInit = this.onInit.bind(this);
		this.onResize = this.onResize.bind(this);
	}

	onResize(){
		Blockly.svgResize(this.workspace);
	}

	onInit(blocklyDiv){
		this.workspace = Blockly.inject(blocklyDiv, {
			horizontalLayout: false,
			toolboxPosition: 'start',
			media: 'media/',
			//toolbox: updateToolBoxByTag(Blockly.Xml.textToDom(defaultToolbox), searchInfo.board),
			toolbox: defaultToolbox,
			grid: {
				spacing: 20,
				length: 3,
				colour: '#ccc',
				snap: true
			},
			zoom: {
				controls: false,
				wheel: true,
				startScale: 1.0,
				maxScale: 1.2,
				minScale: 0.8,
			},
			trashcan: false,
			renderer: 'zelos',
			theme: require('./scratch_theme'),
		});

		Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(defaultXml), this.workspace);

		//workspace.addChangeListener(Blockly.Events.disableOrphans);
		this.workspace.addChangeListener(evt => {
			//console.log(this.setFlag)
			if(this.setFlag)return;
			let code = getHeadFile();
			code += Blockly.Arduino.workspaceToCode(Blockly.getMainWorkspace());
			this.props.updateCode(code);

			this.props.updateXML(Blockly.Xml.domToPrettyText((Blockly.Xml.workspaceToDom(this.workspace, true))))

			if(evt.type != Blockly.Events.BLOCK_DELETE)return;
			let div = document.getElementById('toolbox_mask');
			div.style.display = 'none';
		});

		regExt(require('./extensions/tlink'))
		regExt(require('./extensions/tinywebdb'))
		this.workspace.updateToolbox(defaultToolbox);
	}

	setXML(text){
		this.setFlag = true
		//Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(text), this.workspace);
		this.setFlag = false
	}

	getXML(){
		return Blockly.Xml.domToPrettyText((Blockly.Xml.workspaceToDom(this.workspace, true)));
	}

	render(){
		const {className} = this.props;
		return React.createElement('div', {className, ref:this.onInit});
	}
}

class MonacoEditor extends React.Component
{
	constructor(props){
		super(props);
		this.onInit = this.onInit.bind(this);
		this.onResize = this.onResize.bind(this);
	}

	onInit(element){
		this.containerElement = element;
	}

	onResize(){
		//let width = window.innerWidth - 400;
		//let height = window.innerHeight - 86;
		this.editor.layout();
		//this.editor.layout({width, height});
	}

	componentDidMount(){
		if(!this.containerElement)return;
		const {value, language, onChange} = this.props;
		this.editor = monaco.editor.create(this.containerElement, {value:'', language});
		this.editor.onDidChangeModelContent(evt => onChange(this.editor.getValue()));
		/*this.editor.layout();*/
		window.addEventListener('resize', this.onResize);
	}

	componentWillUnmount(){
		if(!this.editor)return;
		window.removeEventListener('resize', this.onResize);
		this.editor.getModel().dispose();
		this.editor.dispose();
		this.editor = null;
	}

	shouldComponentUpdate(nextProps, nextState){
		const {value, language, className} = this.props;
		if(className != nextProps.className)return true;
		if(value != nextProps.value)return true;
		if(language != nextProps.language)return true;
		return false;
	}

	componentDidUpdate(prevProps, prevState){
		const {editor} = this;
		const {value, language} = this.props;
		if(value != prevProps.value){
			editor.setValue(value);
		}
		if(language != prevProps.language){
			monaco.editor.setModelLanguage(editor.getModel(), language);
		}
	}

	setValue(value){
		this.editor.setValue(value);
	}

	getValue(){
		return this.editor.getValue();
	}

	render(){
		const {className} = this.props;
		return React.createElement('div', {className, ref: this.onInit});
	}
}

function initCodeMirror(parentDiv){
	let code = `#include<WeELFMini.h>\nvoid setup(){\n\tint a = 10;\n}\n\nvoid loop(){\n}`;
	let editor = monaco.editor.create(parentDiv, {
		value:code,
		language:'cpp',
		//automaticLayout:true,
	});
}
/*
function initCodeMirror(parentDiv){
	let code = `#include<WeELFMini.h>\nvoid setup(){\n\tint a = 10;\n}\n\nvoid loop(){\n}`;
	let editor = monaco.editor.create(parentDiv, {
		model: monaco.editor.createModel(code, 'cpp')
	});
	function onResize(){
		let width = window.innerWidth - 400;
		let height = window.innerHeight - 80;
		editor.layout({width, height});
	}
	parentDiv.addEventListener('active', onResize);
	window.addEventListener('resize', onResize);
}
*/
const ExitDialog = createElement(function(tag, end, props){
	tag(Dialog, {maskClosable:true, title:'退出提示', style:{width:300,height:200}, buttonList:[
		{title:'直接退出', value:'quit', className:'ant-btn ant-btn-danger'},
		{title:'保存并退出', value:'save', className:'ant-btn ant-btn-primary'},
		{title:'取消', value:'',className:'ant-btn ant-btn-default'},
	], ...props})
		tag('div', {style:{display:'flex',justifyContent:'center',alignItems:'center',height:'100%'}})
			tag`文件有更改,退出前是否需要保存?`
		end('div')
	end(Dialog)
})


const BoardDialog = createElement(function(tag, end, {boardList, board, ...props}){
	tag(Dialog, {maskClosable:true,resetOnClose:true, title:'选择主板', style:{width:300,height:360}, buttonList:[
		{title:'选择', value:'ok', className:'ant-btn ant-btn-primary'},
		{title:'取消', value:'',className:'ant-btn ant-btn-default'},
	], ...props})
		const prefix = React.useId();
		tag('div', {className:'table', style:{padding:4,columnGap:4}})
		for(let {name} of boardList){
			const id = prefix + name;
			const isActive = board == name;
			tag('input', {type:'radio', id, name:'board', value:name, defaultChecked: isActive, disabled: isActive}, true)
			tag('label', {htmlFor:id}), tag`${name}`, end('label')
		}
		end('div')
	end(Dialog)
})

const PortDialog = createElement(function(tag, end, {availablePortList, port, tempPort, setTempPort, ...props}){
	tag(Dialog, {maskClosable:true,resetOnClose:false, title:'选择串口', style:{width:300,height:360}, buttonList:[
		availablePortList.length <= 0 ?
		{title:'安装', value:'install', className:'ant-btn ant-btn-primary'}:
		port && tempPort == port ?
		{title:'断开', value:'disconnect', className:'ant-btn ant-btn-danger'}:
		{title:'连接', value:'connect', className:'ant-btn ant-btn-primary'},
		{title:'取消', value:'cancel',className:'ant-btn ant-btn-default'},
	], ...props})
		if(availablePortList.length > 0){
			const prefix = React.useId();
			tag('div', {className:'table', style:{padding:4,columnGap:4}})
			for(let {path} of availablePortList){
				const id = prefix + path;
				tag('input', {type:'radio', id, name:'port', value:path, onChange(evt){
					setTempPort(evt.target.value)
				}, checked:tempPort == path}, true)
				tag('label', {htmlFor:id}), tag`${path}`, end('label')
			}
			end('div')
		}else{
			tag('div', {style:{display:'flex',justifyContent:'center',alignItems:'center',height:'100%'}})
				tag`未发现串口,安装驱动程序?`
			end('div')
		}
	end(Dialog)
})

const support_serial_ports = [
	{vid:0x1A86,pid:0x7523},
	{vid:0x1A86,pid:0x8040},
	{vid:0x2341,pid:0x0043},
];

const MainFrame = createElement(function(tag, end){
	//const [tabPanelKey, setTabPanelKey] = React.useState('blockly');
	const [code, setCode] = React.useState('');
	const [blockXML, setBlockXML] = React.useState('');
	//const dialog = React.useRef();
	const blocklyPanel = React.useRef();
	const editorPanel = React.useRef();
	const [editorCode, setEditorCode] = React.useState('#include<WeELFMini.h>\nvoid setup(){\n\tint a = 10;\n}\n\nvoid loop(){\n}');
	const [editorLang, setEditorLang] = React.useState('cpp');

	const [port, setPort] = React.useState('');
	const [tempPort, setTempPort] = React.useState(port);
	const [isPortDialogOpen, setPortDialogOpen] = React.useState(false);
	const [isBoardDialogOpen, setBoardDialogOpen] = React.useState(false);
	const [isExitDialogOpen, setExitDialogOpen] = React.useState(false);
	const [board, setBoard] = React.useState('ELF mini');
	//const [availablePortList, setAvailablePortList] = React.useState([{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},{path:'COM3'},{path:'COM4'},]);
	const [availablePortList, setAvailablePortList] = React.useState([]);

	function onPortDialogClose(btn, form){
		setPortDialogOpen(false);
		if(btn == 'disconnect'){
			setPort('');
		}else if(btn == 'connect'){
			setPort(form.get('port'));
		}else if(btn == 'install'){
			console.log('install driver')
		}
	}

	function onBoardDialogClose(btn, form){
		setBoardDialogOpen(false);
		if(btn == 'ok'){
			const board = form.get('board');
			if(board)setBoard(board);
		}
	}

	async function scanPortList(){
		//const portList = Serial.filter(await Serial.enum(), support_serial_ports);
		const portList = await Serial.enum();
		setAvailablePortList(portList);
		if(portList.length > 0){
			setTempPort(port || portList[0].path);
		}
	}

	React.useEffect(() => {
		console.log('reg once');
		nw.Window.get().on('close', () => setExitDialogOpen(true));
		//nw.Window.get().close(true);
	}, [])

	React.useEffect(() => {
		if(!isPortDialogOpen)return;
		const timer = setInterval(scanPortList, 1000);
		return () => clearInterval(timer);
	}, [isPortDialogOpen])

	const boardList = [{name:'ELF mini'},{name:'ELF 328p'}]

	tag('div', {className:'frame', style:{width:'100%',height:'100%',backgroundColor:'aliceblue'}})
		tag('div', {id:'menu', style:{gridColumnEnd:'span 2'}})
			tag(MenuBar, {port:port || '未连接', board, onClick(key){
				if(key == 'choosePort'){
					setPortDialogOpen(true);
					scanPortList();
				}else if(key == 'chooseBoard'){
					setBoardDialogOpen(true);
				}
			}}, true)
			tag(PortDialog, {availablePortList, port, tempPort, setTempPort, isOpen:isPortDialogOpen,onClose:onPortDialogClose}, true)
			tag(BoardDialog, {board, boardList, isOpen:isBoardDialogOpen, onClose:onBoardDialogClose}, true)
			tag(ExitDialog, {isOpen:isExitDialogOpen, onClose(btn){
				setExitDialogOpen(false);
				if(btn == 'quit'){
					nw.Window.get().close(true);
				}else if(btn == 'save'){

				}
			}}, true)
		end('div')
		tag(TabPanel)
			tag(BlocklyPanel, {key:'blockly',title:'积木', ref:blocklyPanel, updateCode:setCode, updateXML:setBlockXML, buttonList:[
				{title:'运行', onClick(){
					let workspace = Blockly.getMainWorkspace()
					const json = toJSON(Blockly.Xml.workspaceToDom(workspace));
					js_engine.exec(json.block, startBlockName, context);
					js_engine.onfinish = () => {
						console.log('finish')
					}
				}},
				{title:'上传'},
			]}, true)
			tag(MonacoEditor, {ref:editorPanel,key:'code_editor', title:'代码', value:blockXML, language:'xml', onChange(code){
				//console.log(code);
				blocklyPanel.current.setXML(code)
			}, buttonList:[
				{title:'复制'},
				{title:'上传', onClick(){console.log('upload')}},
			]}, true)
			tag('div', {key:'dialogPanel',title:'声音'})
				tag('div')
					tag('button'), tag`click`, end('button')
				end('div')
			end('div')
		end(TabPanel)
		tag(Collapse, {style:{width:400}})
			tag(CodeView, {title:'代码预览',open:true, children: code, buttonList:[
				{title:'上传', onClick(){console.log('upload')}},
				{title:'复制'},
			]}, true)
			tag('div', {title:'输出日志', style:{height:'200px'}}, true)
		end(Collapse)
	end('div')
})

function setFontSize(target){
	const {style} = target.parentNode.parentNode.nextSibling;
	let fontSize = parseFloat(style.fontSize);
	if(isNaN(fontSize)){
		style.fontSize = '1.1em';
	}else{
		fontSize += 0.5;
		if(fontSize > 4){
			fontSize = 1;
		}
		style.fontSize = `${fontSize.toFixed(1)}em`;
	}
}

class MyDrawer extends React.Component
{
	constructor(){
		super();
		this.state = {
			visible: false,
			spinning: false,
			uploadModalVisible: false,
			step: 0,
			uploadProgress:0,
		};
		this.showDrawer = this.showDrawer.bind(this);
		this.onDrawerClose = this.onDrawerClose.bind(this);
		this.onDrawerClick = this.onDrawerClick.bind(this);
		this.onRunCode = this.onRunCode.bind(this);
		confirmWrap(this, 'onUploadFactoryFirmware', '恢复出厂玩法固件?');
		confirmWrap(this, 'onUploadFirmware', '恢复在线固件?');
		confirmWrap(this, 'onUploadCode', '上传离线固件?');
		this.onUploadModalClose = this.onUploadModalClose.bind(this);
	}

	showDrawer(){
		this.setState({visible: true});
	}

	onDrawerClick(){
		if(this.state.spinning){
			js_engine.stop();
			this.setState({spinning: false});
			antd.message.warning('程序运行终止');
		}
	}

	onDrawerClose(){
		if(!this.state.spinning){
			this.setState({visible: false});
		}
	}

	onRunCode(){
		this.setState({spinning: true});
		const json = toJSON(Blockly.Xml.workspaceToDom(workspace));
		js_engine.exec(json.block, startBlockName, context);
		js_engine.onfinish = () => {
			this.setState({spinning: false});
		}
	}

	doUpload(data){
		return window.resetBLE(data,
			() => this.setState({step: 2}),
			progress => this.setState({uploadProgress: progress})
		).then(success => {
			if(success){
				message.success('固件上传成功');
			}else{
				message.error('固件上传失败');
			}
		});
	}

	async uploadFirmware(path){
		this.setState({uploadModalVisible: true, step: 0});
		let data = await loadData(path, 'arraybuffer');
		this.setState({step: 1});
		await this.doUpload(data);
		this.setState({step: 3});
		setTimeout(this.onUploadModalClose, 2000);
	}

	onUploadFactoryFirmware(){
		let robot = factoryFirmwareDict[searchInfo.robot];
		if(robot){
			this.uploadFirmware(`./hex/${robot}.hex.raw`);
		}else{
			message.error(`不支持:${robot}`);
		}
	}

	onUploadFirmware(){
		this.uploadFirmware('./hex/online_firmware_328p.hex.raw');
	}

	async onUploadCode(){
		this.setState({uploadModalVisible: true, step: 0});
		let data;
		try{
			data = await loadData('compile', 'arraybuffer', 'POST', code);
		}catch(error){
			antd.message.error('编译代码出错!');
			this.onUploadModalClose();
			return;
		}
		this.setState({step: 1});
		await this.doUpload(data);
		this.setState({step: 3});
		setTimeout(this.onUploadModalClose, 2000);
	}

	onUploadModalClose(){
		this.setState({uploadModalVisible: false});
	}
}


MyDrawer.prototype.render = createElement(function(tag, end){
	const {step, uploadProgress} = this.state;
	const loadingIcon = React.createElement(antd.Progress, {type:'circle', width:30, percent: Math.round(100 * uploadProgress)});

	tag('div')
		tag('div', {style:{
			display:'flex',
			flexDirection: 'column',
			gap:'20px',
			height: '100%',
			alignItems: 'flex-end',
			justifyContent: 'space-between'
		}})
			tag(antd.Button, {icon: 'link', size: 'large', onClick: connectBLE}, true)
			tag('img', {onClick: this.onUploadFactoryFirmware,width:'36',height:'36',src:'./icons/firmware.png'}, true)
			tag('img', {onClick: this.onUploadFirmware,width:'36',height:'36',src:'./icons/restore.png'}, true)
			tag('img', {onClick: this.onUploadCode,width:'36',height:'36',src:'./icons/upload.png'}, true)
			tag('img', {onClick: this.onRunCode,width:'64',height:'64',src:'./icons/play.png'}, true)
		end('div')
		tag(antd.Modal, {
			maskClosable: step == 3,
			closable: false,
			footer: null,
			visible: this.state.uploadModalVisible,
			onCancel: this.onUploadModalClose,
			width: '200',
			centered: true,
		})
			tag(antd.Steps, {direction:'vertical',current:step})
				tag(antd.Steps.Step, {title:'编译固件', subTitle:step == 0 && React.createElement(antd.Icon, {type:'loading'})}, true)
				tag(antd.Steps.Step, {title:'上传固件', subTitle:step == 1 && loadingIcon}, true)
				tag(antd.Steps.Step, {title:'验证固件', subTitle:step == 2 && loadingIcon}, true)
				tag(antd.Steps.Step, {title:'上传成功', status:step == 3 ? 'finish' : 'wait'}, true)
			end(antd.Steps)
		end(antd.Modal)
		tag(antd.Modal, {
			maskClosable: true,
			closable: false,
			footer: null,
			visible: this.state.spinning,
			onCancel: this.onDrawerClick,
			width: '200',
			centered: true
		})
			tag(antd.Spin, {
				spinning:true,
				size:'large',
				tip:'正在运行,点击停止.'
			}, true)
		end(antd.Modal)
	end('div')
})

ReactInit(mainFrame, MainFrame)