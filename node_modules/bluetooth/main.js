'use strict';

require('./Buffer');
require('./field_matrix');
require('./field_note');
require('./zh-hans');
const {getSearchInfo} = require('../webonly/index.js');
const searchInfo = Object.assign({board:'elf'}, getSearchInfo());

/*
Blockly.FieldNumber.prototype.showPromptEditor_ = function(){
	var fieldText = this;
	antd.message.info('hello');
	const style = {
		width: '30px',
		height: '30px',
		backgroundColor: 'yellow'
	};
	antd.Modal.confirm({
		title: 'sure?',
		content: React.createElement('div', null, 
			React.createElement('div', {style}, '1'),
			React.createElement('div', {style}, '2'),
			React.createElement('div', {style}, '3'),
			React.createElement('div', {style}, '4'),
			React.createElement('div', {style}, '5'),
			React.createElement('div', {style}, '6'),
			React.createElement('div', {style}, '7'),
			React.createElement('div', {style}, '8'),
			React.createElement('div', {style}, '9'),
			React.createElement('div', {style}, '-'),
		)
	});
	return
	Blockly.prompt(Blockly.Msg['CHANGE_VALUE_TITLE'], this.getText(), function(newValue){
		fieldText.setValue(newValue);
	});
};
/*
const toolbox = document.getElementById('toolbox');

function updateToolBoxByTag(board){
	for(let category of toolbox.childNodes){
		if(category.nodeType != Node.ELEMENT_NODE)continue;
		if(category.localName != 'category')continue;
		for(let block of category.childNodes){
			if(block.nodeType != Node.ELEMENT_NODE)continue;
			if(block.localName != 'block')continue;
			let type = block.getAttribute('type');
			if(type.startsWith('weeemake_weeebot_')){
				if(board == 'mini'){
					block.remove();
				}
				//block.setAttribute('disabled', board == 'mini');
			}else if(type.startsWith('weeemake_weeebotMini_')){
				if(board == 'elf'){
					block.remove();
				}
				//block.setAttribute('disabled', board == 'elf');
			}
		}
	}
}


updateToolBoxByTag(searchInfo.board);
*/
const startBlockName = 'when_start';
const startBlockLabel = '当点击开始';

Blockly.Extensions.registerMutator('wifi_mode_mutator', {
	mutationToDom(){
		const container = Blockly.utils.xml.createElement('mutation');
		container.setAttribute('mode', this.getFieldValue('MODE'));
		return container;
	},
	domToMutation(xmlElement){
		this.updateShape_(xmlElement.getAttribute('mode'));
	},
	updateShape_(mode){
		if(mode == 'tcp' || mode == 'slave'){
			if(this.getInput('CHANNEL')){
				this.removeInput('CHANNEL');
			}
			if(!this.getInput('IP')){
				this.appendDummyInput('IP').appendField('ip地址').appendField(new Blockly.FieldTextInput("192.168.0.1"), 'IP');
			}
			if(!this.getInput('PORT')){
				this.appendDummyInput('PORT').appendField('端口').appendField(new Blockly.FieldNumber(6602, 0, 65535, 1), 'PORT');
			}
		}else if(mode == 'ap'){
			if(this.getInput('IP')){
				this.removeInput('IP');
			}
			if(this.getInput('PORT')){
				this.removeInput('PORT');
			}
			if(!this.getInput('CHANNEL')){
				this.appendDummyInput('CHANNEL').appendField('信道').appendField(new Blockly.FieldNumber(11, 0, 255, 1), 'CHANNEL');
			}
		}else if(mode == 'sta'){
			if(this.getInput('IP')){
				this.removeInput('IP');
			}
			if(this.getInput('PORT')){
				this.removeInput('PORT');
			}
			if(this.getInput('CHANNEL')){
				this.removeInput('CHANNEL');
			}
		}
	}
}, function(){
	this.getField('MODE').setValidator(function(option){
		this.getSourceBlock().updateShape_(option);
	});
});

Blockly.Extensions.register('markAsyncFunc', function(){this.data = 'isAsyncFunc';});
Blockly.Extensions.register('markConstText', function(){this.data = 'isConstText';});
Blockly.Extensions.register('markConstNumber', function(){this.data = 'isConstNumber';});
Blockly.Extensions.register('markStatement', function(){
	this.setPreviousStatement(true, null);
	this.setNextStatement(true, null);
});
Blockly.Extensions.register('set_colours_image_recognition', function(){
	let field = this.getField("IMAGE_RECOGNITION_TYPE");
	field.setColours(['#e17373','#e08649','#5450e8','#37b80c','#24716b']);
});

void function(){
	const colours = {
		"motion": {
			"primary": "#4C97FF",
			"secondary": "#4280D7",
			"tertiary": "#3373CC"
		},
		"looks": {
			"primary": "#9966FF",
			"secondary": "#855CD6",
			"tertiary": "#774DCB"
		},
		"sounds": {
			"primary": "#CF63CF",
			"secondary": "#C94FC9",
			"tertiary": "#BD42BD"
		},
		"control": {
			"primary": "#FFAB19",
			"secondary": "#EC9C13",
			"tertiary": "#CF8B17"
		},
		"event": {
			"primary": "#FFBF00",
			"secondary": "#E6AC00",
			"tertiary": "#CC9900"
		},
		"sensing": {
			"primary": "#5CB1D6",
			"secondary": "#47A8D1",
			"tertiary": "#2E8EB8"
		},
		"pen": {
			"primary": "#0fBD8C",
			"secondary": "#0DA57A",
			"tertiary": "#0B8E69"
		},
		"operators": {
			"primary": "#59C059",
			"secondary": "#46B946",
			"tertiary": "#389438"
		},
		"data": {
			"primary": "#FF8C1A",
			"secondary": "#FF8000",
			"tertiary": "#DB6E00"
		},
		// This is not a new category, but rather for differentiation
		// between lists and scalar variables.
		"data_lists": {
			"primary": "#FF661A",
			"secondary": "#FF5500",
			"tertiary": "#E64D00"
		},
		"more": {
			"primary": "#FF6680",
			"secondary": "#FF4D6A",
			"tertiary": "#FF3355"
		},
		"text": "#575E75",
		"workspace": "#F9F9F9",
		"toolboxHover": "#4C97FF",
		"toolboxSelected": "#e9eef2",
		"toolboxText": "#575E75",
		"toolbox": "#FFFFFF",
		"flyout": "#F9F9F9",
		"scrollbar": "#CECDCE",
		"scrollbarHover": '#CECDCE',
		"textField": "#FFFFFF",
		"insertionMarker": "#000000",
		"insertionMarkerOpacity": 0.2,
		"dragShadowOpacity": 0.3,
		"stackGlow": "#FFF200",
		"stackGlowSize": 4,
		"stackGlowOpacity": 1,
		"replacementGlow": "#FFFFFF",
		"replacementGlowSize": 2,
		"replacementGlowOpacity": 1,
		"colourPickerStroke": "#FFFFFF",
		// CSS colours: support RGBA
		"fieldShadow": "rgba(0,0,0,0.1)",
		"dropDownShadow": "rgba(0, 0, 0, .3)",
		"numPadBackground": "#547AB2",
		"numPadBorder": "#435F91",
		"numPadActiveBackground": "#435F91",
		"numPadText": "white", // Do not use hex here, it cannot be inlined with data-uri SVG
		"valueReportBackground": "#FFFFFF",
		"valueReportBorder": "#AAAAAA"
	};

	function register_colour(name){
		Blockly.Extensions.register('colours_' + name, function(){
			const colour = colours[name];
			this.setColour(colour.primary, colour.secondary, colour.tertiary);
		});
	}
}();

//Blockly.HSV_SATURATION = 0.6; // 0 (inclusive) to 1 (exclusive), defaulting to 0.45
//Blockly.HSV_VALUE = 0.8;// 0 (inclusive) to 1 (exclusive), defaulting to 0.65

Blockly.defineBlocksWithJsonArray(require('./blocks_for_scratch')('elf'));

const defaultXml = `<xml xmlns="https://developers.google.com/blockly/xml"><block type="${startBlockName}" editable="false" deletable="false" movable="false"></block></xml>`;

//Blockly.VerticalFlyout.prototype.autoClose = true;
Blockly.BlockSvg.START_HAT = true;

const workspace = Blockly.inject('blocklyDiv', {
	media: 'media/',
	toolbox: require('./toolbox_for_scratch'),
	grid: {
		spacing: 20,
		length: 3,
		colour: '#ccc',
		snap: true
	},
	zoom: {
		startScale: 1.0,
		maxScale: 3,
		minScale: 0.3,
	},
	theme: require('./scratch_theme')
});

Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(defaultXml), workspace);

workspace.addChangeListener(Blockly.Events.disableOrphans);
//workspace.addChangeListener(evt => console.log('changed'));

const toJSON = require('../fileformats/xml/toJSON.js');
const js_engine = require('../blockly/js_engine.js');

const runBtn = document.getElementById('runBtn');
const mask = document.getElementById('mask');

const context = function(){
	const primitives = require('./op/Primitives2.js');
	const varDict = Object.create(null);
	const context = {
	text({TEXT}){
		return TEXT || '';
	},
	math_number({NUM}){
		let v = Number(NUM);
		return isNaN(v) ? NUM : v;
	},
	math_arithmetic({OP, A, B}){
		if(OP == 'ADD')return A + B;
		if(OP == 'MINUS')return A - B;
		if(OP == 'MULTIPLY')return A * B;
		if(OP == 'DIVIDE')return A / B;
		if(OP == 'POWER')return A ** B;
	},
	math_single({OP, NUM}){
		if(OP == 'ROOT')return Math.sqrt(NUM);
		if(OP == 'ABS')return Math.abs(NUM);
		if(OP == 'NEG')return -NUM;
		if(OP == 'LN')return Math.log(NUM);
		if(OP == 'LOG10')return Math.log10(NUM);
		if(OP == 'EXP')return Math.exp(NUM);
		if(OP == 'POW10')return 10 ** NUM;
	},
	math_trig({OP, NUM}){
		if(OP == 'SIN')return Math.sin(NUM);
		if(OP == 'COS')return Math.cos(NUM);
		if(OP == 'TAN')return Math.tan(NUM);
		if(OP == 'ASIN')return Math.asin(NUM);
		if(OP == 'ACOS')return Math.acos(NUM);
		if(OP == 'ATAN')return Math.atan(NUM);
	},
	math_constant({CONSTANT}){
		if(CONSTANT == 'PI')return Math.PI;
		if(CONSTANT == 'E')return Math.E;
		if(CONSTANT == 'GOLDEN_RATIO')return 2 / (Math.sqrt(5) - 1);
		if(CONSTANT == 'SQRT2')return Math.SQRT2;
		if(CONSTANT == 'SQRT1_2')return Math.SQRT1_2;
		if(CONSTANT == 'INFINITY')return Infinity;
	},
	math_number_property({PROPERTY, NUMBER_TO_CHECK, DIVISOR}){
		if(PROPERTY == 'EVEN')return NUMBER_TO_CHECK % 2 == 0;
		if(PROPERTY == 'ODD')return NUMBER_TO_CHECK % 2 == 1;
		if(PROPERTY == 'WHOLE')return Number.isInteger(NUMBER_TO_CHECK);
		if(PROPERTY == 'POSITIVE')return NUMBER_TO_CHECK > 0;
		if(PROPERTY == 'NEGATIVE')return NUMBER_TO_CHECK < 0;
		if(PROPERTY == 'DIVISIBLE_BY')return NUMBER_TO_CHECK % DIVISOR == 0;
		if(PROPERTY == 'PRIME'){
			for(let i=2, n=NUMBER_TO_CHECK>>1; i<n; ++i){
				if(NUMBER_TO_CHECK % i == 0)return false;
			}
			return true;
		}
	},
	math_round({OP, NUM}){
		if(OP == 'ROUND')return Math.round(NUM);
		if(OP == 'ROUNDUP')return Math.ceil(NUM);
		if(OP == 'ROUNDDOWN')return Math.floor(NUM);
	},
	math_on_list({OP, LIST}){
		if(OP == 'MIN')return Math.min.apply(null, LIST);
		//not finish
	},
	math_modulo({DIVIDEND, DIVISOR}){
		return DIVIDEND % DIVISOR;
	},
	math_constrain({VALUE, LOW, HIGH}){
		return Math.min(Math.max(VALUE, LOW), HIGH);
	},
	math_random_int({FROM, TO}){
		if(FROM > TO){
			let t = FROM;
			FROM = TO;
			TO = t;
		}
		return Math.floor(Math.random() * (TO - FROM + 1) + FROM);
	},
	math_random_float(){
		return Math.random();
	},
	math_atan2({X, Y}){
		return Math.atan2(Y, X);
	},
	text_length({VALUE}){
		return VALUE ? VALUE.length : 0;
	},
	text_print({TEXT}){
		console.log(TEXT);
	},
	text_join(args){
		let keys = Object.keys(args).sort();
		return keys.map(k => args[k]).join('');
	},
	text_append({VAR, TEXT}){
		console.log('text_append', VAR, TEXT)
	},
	text_isEmpty({VALUE}){
		return VALUE.length == 0;
	},
	lists_create_empty(){
		return [];
	},
	lists_create_with(args){
		let keys = Object.keys(args).sort();
		return keys.map(k => args[k]);
	},
	colour_picker({COLOUR}){
		return parseInt(COLOUR.slice(1), 16);
	},
	colour_random(){
		return Math.floor(Math.random() * 0x1000000);
	},
	colour_rgb({RED, GREEN, BLUE}){
		let r = 2.55 * Math.max(0, Math.min(100, RED));
		let g = 2.55 * Math.max(0, Math.min(100, GREEN));
		let b = 2.55 * Math.max(0, Math.min(100, BLUE));
		return r << 16 | g << 8 | b;
	},
	colour_blend({COLOUR1, COLOUR2, RATIO}){
		let ratio = Math.max(Math.min(RATIO, 1), 0);
		let r = Math.round((COLOUR1 >> 16 & 0xFF) * (1 - ratio) + (COLOUR2 >> 16 & 0xFF) * ratio);
		let g = Math.round((COLOUR1 >>  8 & 0xFF) * (1 - ratio) + (COLOUR2 >>  8 & 0xFF) * ratio);
		let b = Math.round((COLOUR1 & 0xFF) * (1 - ratio) + (COLOUR2 & 0xFF) * ratio);
		return r << 16 | g << 8 | b;
	},
	variables_get({VAR}){
		if(VAR in varDict){
			return varDict[VAR];
		}
	},
	variables_set({VAR, VALUE}){
		varDict[VAR] = VALUE;
	},
	math_change({VAR, DELTA}){
		if(VAR in varDict){
			varDict[VAR] = Number(varDict[VAR]) + DELTA;
		}else{
			varDict[VAR] = DELTA;
		}
	},
	logic_boolean({BOOL}){
		return BOOL === 'TRUE';
	},
	logic_negate({BOOL}){
		return !BOOL;
	},
	logic_null(){
		return null;
	},
	logic_compare({OP, A, B}){
		if(OP == 'EQ')return A == B;
		if(OP == 'LT')return A < B;
		if(OP == 'GT')return A > B;
		if(OP == 'NEQ')return A != B;
		if(OP == 'LTE')return A <= B;
		if(OP == 'GTE')return A >= B;
	},
	logic_operation({OP, A, B}){
		if(OP == 'AND')return A && B;
		if(OP == 'OR')return A || B;
	},
	str2ascii({VALUE}){
		return VALUE.charCodeAt();
	},
	ascii2str({VALUE}){
		return String.fromCharCode(VALUE);
	},
	sensing_timer(){
		if(!this._timer){
			this._timer = Date.now();
		}
		return (Date.now() - this._timer) * 0.001;
	},
	sensing_resettimer(){
		this._timer = Date.now();
	},
	sensing_current({CURRENTMENU}){
		const date = new Date();
		switch (CURRENTMENU.toLowerCase()) {
		case 'year': return date.getFullYear();
		case 'month': return date.getMonth() + 1; // getMonth is zero-based
		case 'date': return date.getDate();
		case 'dayofweek': return date.getDay() + 1; // getDay is zero-based, Sun=0
		case 'hour': return date.getHours();
		case 'minute': return date.getMinutes();
		case 'second': return date.getSeconds();
		}
		return 0;
	},
	sensing_dayssince2000(){
		const msPerDay = 24 * 60 * 60 * 1000;
		const start = new Date(2000, 0, 1); // Months are 0-indexed.
		const today = new Date();
		const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
		let mSecsSinceStart = today.valueOf() - start.valueOf();
		mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);
		return mSecsSinceStart / msPerDay;
	}
}
return Object.assign({net:{sendData(buffer){
	return window.sendBLERawData(buffer.buffer);
}}}, context, primitives);
}();

const {connectBLE} = require('./ble');
require('./generators');
const {loadData} = require('../utils/loader');
const {message} = antd;

//linkBtn.onclick = connectBLE;
/*
async function onRunCode(){
	let isFinished = false;
	function onExecFinish(){
		if(isFinished)return;
		js_engine.stop();
		antd.message.warning('程序运行终止');
	}
	const modal = antd.Modal.info({
		icon: 'loading',
		maskClosable: true,
		okType: 'danger',
		okText: '终止执行',
		title: '正在执行程序',
		onOk: onExecFinish,
		onCancel: onExecFinish,
	});
	//let workspace = Blockly.getMainWorkspace();
	//console.log(Blockly.getMainWorkspace().getTopBlocks())
	const json = toJSON(Blockly.Xml.workspaceToDom(workspace));
	js_engine.exec(json.block, startBlockName, context);
	js_engine.onfinish = function(){
		isFinished = true;
		modal.update({
			icon: React.createElement(antd.Icon, {
				type: 'check-circle',
				style: {color:'#52c41a'}
			}),
			title: '程序运行完成',
			okType: 'primary',
			okText: '关闭',
		});
	}
}

async function onUploadFirmware(){
	let data = await loadData('./online_firmware_328p.hex');
	window.resetBLE(data);
}
*/


class MyDrawer extends React.Component
{
	constructor(){
		super();
		this.state = {
			visible: false,
			spinning: false,
			uploadModalVisible: false,
			step: 0,
			uploadProgress:0,
		};
		this.showDrawer = this.showDrawer.bind(this);
		this.onDrawerClose = this.onDrawerClose.bind(this);
		this.onDrawerClick = this.onDrawerClick.bind(this);
		this.onRunCode = this.onRunCode.bind(this);
		this.onUploadFirmware = this.onUploadFirmware.bind(this);
		this.onUploadCode = this.onUploadCode.bind(this);
		this.onUploadModalClose = this.onUploadModalClose.bind(this);
	}

	showDrawer(){
		this.setState({visible: true});
	}

	onDrawerClick(){
		if(this.state.spinning){
			js_engine.stop();
			this.setState({spinning: false});
			antd.message.warning('程序运行终止');
		}
	}

	onDrawerClose(){
		if(!this.state.spinning){
			this.setState({visible: false});
		}
	}

	onRunCode(){
		this.setState({spinning: true});
		const json = toJSON(Blockly.Xml.workspaceToDom(workspace));
		js_engine.exec(json.block, startBlockName, context);
		js_engine.onfinish = () => {
			this.setState({spinning: false});
			antd.message.success('程序运行结束');
		}
	}

	async onUploadFirmware(){
		this.setState({uploadModalVisible: true, step: 0});
		let data = await loadData('./online_firmware_328p.hex');
		this.setState({step: 1});
		await window.resetBLE(data,
			() => this.setState({step: 2}),
			progress => this.setState({uploadProgress: progress})
		);
		this.setState({step: 3});
		setTimeout(this.onUploadModalClose, 2000);
	}

	async onUploadCode(){
		let code = '#include<WeELF328P.h>\n';
		code += Blockly.Arduino.workspaceToCode(Blockly.getMainWorkspace());
		console.log(code);
		this.setState({uploadModalVisible: true, step: 0});
		let data = await loadData('compile', 'text', 'POST', code);
		this.setState({step: 1});
		await window.resetBLE(data,
			() => this.setState({step: 2}),
			progress => this.setState({uploadProgress: progress})
		);
		this.setState({step: 3});
		setTimeout(this.onUploadModalClose, 2000);
	}

	onUploadModalClose(){
		this.setState({uploadModalVisible: false});
	}

	render(){
		const {step, uploadProgress} = this.state;
		const loadingIcon = React.createElement(antd.Progress, {type:'circle', width:30, percent: Math.round(100 * uploadProgress)});
		return React.createElement('div', null,
			React.createElement(antd.Button, {
				icon: 'menu',
				size: 'large',
				onClick: this.showDrawer
			}),
			React.createElement(antd.Drawer, {
				maskStyle: {
					backgroundColor: 'rgba(0,0,0,0)',
				},
				closable: false,
				visible: this.state.visible,
				onClose: this.onDrawerClose,
				onClick: this.onDrawerClick,
				width: 160,
				bodyStyle:{
					height: '100%',
					padding: '10px',
				}
			},
				React.createElement(antd.Spin, {
					spinning:this.state.spinning,
				},
				React.createElement('div', {
					style:{
						display:'flex',
						flexDirection: 'column',
						height: '100%',
						justifyContent: 'space-between'
					},
					},
					React.createElement(antd.Button, {
						icon: 'link',
						size: 'large',
						onClick: connectBLE
					}, '连接蓝牙'),
					React.createElement(antd.Button, {
						icon: 'upload',
						size: 'large',
						onClick: this.onUploadFirmware,
					}, '上传固件'),
					React.createElement(antd.Button, {
						icon: 'cloud-upload',
						size: 'large',
						onClick: this.onUploadCode
					}, '上传代码'),
					React.createElement('div', {
						style:{flex: 'auto',height: '100%'},
					}),
					React.createElement(antd.Button, {
						icon: 'play-circle',
						size: 'large',
						onClick: this.onRunCode
					}, '开始执行'),
				))
			),
			React.createElement(antd.Modal, {
				maskClosable: step == 3,
				closable: false,
				footer: null,
				visible: this.state.uploadModalVisible,
				onCancel: this.onUploadModalClose,
				width: '200',
				centered: true,
			},
			React.createElement(
				antd.Steps, {
					direction:'vertical',
					current:step
				},
				React.createElement(antd.Steps.Step, {title:'编译固件', subTitle:step == 0 && React.createElement(antd.Icon, {type:'loading'})}),
				React.createElement(antd.Steps.Step, {title:'上传固件', subTitle:step == 1 && loadingIcon}),
				React.createElement(antd.Steps.Step, {title:'验证固件', subTitle:step == 2 && loadingIcon}),
				React.createElement(antd.Steps.Step, {title:'上传成功', status:step == 3 ? 'finish' : 'wait'}),
			)
			)
		);
	}
}

ReactDOM.render(React.createElement(MyDrawer), document.getElementById('overlay'));

