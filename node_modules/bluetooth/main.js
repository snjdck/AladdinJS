'use strict';

function listenDragDrop(handler){
	window.addEventListener('dragover', evt => {
		evt.preventDefault();
		return false;
	});
	window.addEventListener('drop', evt => {
		evt.preventDefault();
		handler(Array.from(evt.dataTransfer.files, v => v.path));
		return false;
	});
}

const compileCode = function(worker){
	return code => new Promise(resolve => {
		worker.addEventListener('message', evt => resolve(evt.data), {once:true});
		worker.postMessage(code);
	});
}(new Worker('compile_worker.js'));

listenDragDrop(v => console.log(v))

const overrideMethod = require('../utils/function/overrideMethod.js');
const {getSearchInfo} = require('../webonly/index.js');
const {sendMsg, waitEvent, handleMsg} = require('../webonly/iframe.js');
const searchInfo = Object.assign({board:'mini'}, getSearchInfo());

function getHeadFile(){
	if(searchInfo.board == 'elf'){
		return '#include<WeELF2560.h>\n';
		return '#include<WeELF328P.h>\n';
	}
	if(searchInfo.board == 'mini'){
		return '#include<WeELFMini.h>\n';
	}
	return '';
}

function updateToolBoxByTag(toolbox, board){
	for(let category of toolbox.childNodes){
		if(category.nodeType != Node.ELEMENT_NODE)continue;
		if(category.localName != 'category')continue;
		for(let block of category.childNodes){
			if(block.nodeType != Node.ELEMENT_NODE)continue;
			if(block.localName != 'block')continue;
			let type = block.getAttribute('type');
			if(type.startsWith('weeemake_weeebot_')){
				if(board == 'mini'){
					block.remove();
				}
				//block.setAttribute('disabled', board == 'mini');
			}else if(type.startsWith('weeemake_weeebotMini_')){
				if(board == 'elf'){
					block.remove();
				}
				//block.setAttribute('disabled', board == 'elf');
			}
		}
	}
	return toolbox;
}

const startBlockName = 'when_start';


//const defaultXml = `<xml xmlns="https://developers.google.com/blockly/xml"><block type="${startBlockName}" editable="false" deletable="false" movable="false"></block></xml>`;
const defaultXml = `<xml xmlns="https://developers.google.com/blockly/xml"><block type="${startBlockName}" editable="false" deletable="false" movable="false"></block></xml>`;

//Blockly.VerticalFlyout.prototype.autoClose = true;



const toJSON = require('../fileformats/xml/toJSON.js');
const js_engine = require('../blockly/js_engine.js');

const context = function(){
	const primitives = require('./op/Primitives2.js');
	const varDict = Object.create(null);
	const context = {
	log({value}){
		console.log(value);
		message.info(value);
	},
	text({TEXT}){
		return TEXT || '';
	},
	math_number({NUM}){
		let v = Number(NUM);
		return isNaN(v) ? NUM : v;
	},
	math_arithmetic({OP, A, B}){
		if(OP == 'ADD')return A + B;
		if(OP == 'MINUS')return A - B;
		if(OP == 'MULTIPLY')return A * B;
		if(OP == 'DIVIDE')return A / B;
		if(OP == 'POWER')return A ** B;
	},
	math_single({OP, NUM}){
		if(OP == 'ROOT')return Math.sqrt(NUM);
		if(OP == 'ABS')return Math.abs(NUM);
		if(OP == 'NEG')return -NUM;
		if(OP == 'LN')return Math.log(NUM);
		if(OP == 'LOG10')return Math.log10(NUM);
		if(OP == 'EXP')return Math.exp(NUM);
		if(OP == 'POW10')return 10 ** NUM;
	},
	math_trig({OP, NUM}){
		if(OP == 'SIN')return Math.sin(NUM);
		if(OP == 'COS')return Math.cos(NUM);
		if(OP == 'TAN')return Math.tan(NUM);
		if(OP == 'ASIN')return Math.asin(NUM);
		if(OP == 'ACOS')return Math.acos(NUM);
		if(OP == 'ATAN')return Math.atan(NUM);
	},
	math_constant({CONSTANT}){
		if(CONSTANT == 'PI')return Math.PI;
		if(CONSTANT == 'E')return Math.E;
		if(CONSTANT == 'GOLDEN_RATIO')return 2 / (Math.sqrt(5) - 1);
		if(CONSTANT == 'SQRT2')return Math.SQRT2;
		if(CONSTANT == 'SQRT1_2')return Math.SQRT1_2;
		if(CONSTANT == 'INFINITY')return Infinity;
	},
	math_number_property({PROPERTY, NUMBER_TO_CHECK, DIVISOR}){
		if(PROPERTY == 'EVEN')return NUMBER_TO_CHECK % 2 == 0;
		if(PROPERTY == 'ODD')return NUMBER_TO_CHECK % 2 == 1;
		if(PROPERTY == 'WHOLE')return Number.isInteger(NUMBER_TO_CHECK);
		if(PROPERTY == 'POSITIVE')return NUMBER_TO_CHECK > 0;
		if(PROPERTY == 'NEGATIVE')return NUMBER_TO_CHECK < 0;
		if(PROPERTY == 'DIVISIBLE_BY')return NUMBER_TO_CHECK % DIVISOR == 0;
		if(PROPERTY == 'PRIME'){
			for(let i=2, n=NUMBER_TO_CHECK>>1; i<n; ++i){
				if(NUMBER_TO_CHECK % i == 0)return false;
			}
			return true;
		}
	},
	math_round({OP, NUM}){
		if(OP == 'ROUND')return Math.round(NUM);
		if(OP == 'ROUNDUP')return Math.ceil(NUM);
		if(OP == 'ROUNDDOWN')return Math.floor(NUM);
	},
	math_on_list({OP, LIST}){
		if(OP == 'MIN')return Math.min.apply(null, LIST);
		//not finish
	},
	math_modulo({DIVIDEND, DIVISOR}){
		return DIVIDEND % DIVISOR;
	},
	math_constrain({VALUE, LOW, HIGH}){
		return Math.min(Math.max(VALUE, LOW), HIGH);
	},
	math_random_int({FROM, TO}){
		if(FROM > TO){
			let t = FROM;
			FROM = TO;
			TO = t;
		}
		return Math.floor(Math.random() * (TO - FROM + 1) + FROM);
	},
	math_random_float(){
		return Math.random();
	},
	math_atan2({X, Y}){
		return Math.atan2(Y, X);
	},
	text_length({VALUE}){
		return VALUE ? VALUE.length : 0;
	},
	text_print({TEXT}){
		console.log(TEXT);
	},
	text_join(args){
		let keys = Object.keys(args).sort();
		return keys.map(k => args[k]).join('');
	},
	text_append({VAR, TEXT}){
		console.log('text_append', VAR, TEXT)
	},
	text_isEmpty({VALUE}){
		return VALUE.length == 0;
	},
	lists_create_empty(){
		return [];
	},
	lists_create_with(args){
		let keys = Object.keys(args).sort();
		return keys.map(k => args[k]);
	},
	lists_setIndex({LIST, MODE, WHERE, AT, TO}){
		if(!Array.isArray(LIST))return;
		if(MODE == 'SET'){
			if(WHERE == 'FROM_START'){
				LIST[AT - 1] = TO;
			}else if(WHERE == 'FROM_END'){
				LIST[LIST.length - AT] = TO;
			}else if(WHERE == 'FIRST'){
				LIST[0] = TO;
			}else if(WHERE == 'LAST'){
				LIST[LIST.length - 1] = TO;
			}else if(WHERE == 'RANDOM'){
				LIST[Math.floor(Math.random() * LIST.length)] = TO;
			}
		}else if(MODE == 'INSERT'){
			if(WHERE == 'FROM_START'){
				LIST.splice(AT - 1, 0, TO);
			}else if(WHERE == 'FROM_END'){
				LIST.splice(LIST.length - AT, 0, TO);
			}else if(WHERE == 'FIRST'){
				LIST.unshift(TO);
			}else if(WHERE == 'LAST'){
				LIST.push(TO);
			}else if(WHERE == 'RANDOM'){
				LIST.splice(Math.floor(Math.random() * (LIST.length + 1)), 0, TO);
			}
		}
	},
	lists_getIndex({VALUE, MODE, WHERE, AT}){
		if(!Array.isArray(VALUE))return;
		if(MODE == 'GET'){
			if(WHERE == 'FROM_START'){
				return VALUE[AT - 1];
			}else if(WHERE == 'FROM_END'){
				return VALUE[VALUE.length - AT];
			}else if(WHERE == 'FIRST'){
				return VALUE[0];
			}else if(WHERE == 'LAST'){
				return VALUE[VALUE.length - 1];
			}else if(WHERE == 'RANDOM'){
				return VALUE[Math.floor(Math.random() * VALUE.length)];
			}
		}else{
			if(WHERE == 'FROM_START'){
				return VALUE.splice(AT - 1, 1)[0];
			}else if(WHERE == 'FROM_END'){
				return VALUE.splice(VALUE.length - AT, 1)[0];
			}else if(WHERE == 'FIRST'){
				return VALUE.shift();
			}else if(WHERE == 'LAST'){
				return VALUE.pop();
			}else if(WHERE == 'RANDOM'){
				return VALUE.splice(Math.floor(Math.random() * VALUE.length), 1)[0];
			}
		}
	},
	colour_picker({COLOUR}){
		return parseInt(COLOUR.slice(1), 16);
	},
	colour_random(){
		return Math.floor(Math.random() * 0x1000000);
	},
	colour_rgb({RED, GREEN, BLUE}){
		let r = 2.55 * Math.max(0, Math.min(100, RED));
		let g = 2.55 * Math.max(0, Math.min(100, GREEN));
		let b = 2.55 * Math.max(0, Math.min(100, BLUE));
		return r << 16 | g << 8 | b;
	},
	colour_blend({COLOUR1, COLOUR2, RATIO}){
		let ratio = Math.max(Math.min(RATIO, 1), 0);
		let r = Math.round((COLOUR1 >> 16 & 0xFF) * (1 - ratio) + (COLOUR2 >> 16 & 0xFF) * ratio);
		let g = Math.round((COLOUR1 >>  8 & 0xFF) * (1 - ratio) + (COLOUR2 >>  8 & 0xFF) * ratio);
		let b = Math.round((COLOUR1 & 0xFF) * (1 - ratio) + (COLOUR2 & 0xFF) * ratio);
		return r << 16 | g << 8 | b;
	},
	variables_get({VAR}){
		if(VAR in varDict){
			return varDict[VAR];
		}
	},
	variables_set({VAR, VALUE}){
		varDict[VAR] = VALUE;
	},
	math_change({VAR, DELTA}){
		if(VAR in varDict){
			varDict[VAR] = Number(varDict[VAR]) + DELTA;
		}else{
			varDict[VAR] = DELTA;
		}
	},
	logic_boolean({BOOL}){
		return BOOL === 'TRUE';
	},
	logic_negate({BOOL}){
		return !BOOL;
	},
	logic_null(){
		return null;
	},
	logic_compare({OP, A, B}){
		if(OP == 'EQ')return A == B;
		if(OP == 'LT')return A < B;
		if(OP == 'GT')return A > B;
		if(OP == 'NEQ')return A != B;
		if(OP == 'LTE')return A <= B;
		if(OP == 'GTE')return A >= B;
	},
	logic_operation({OP, A, B}){
		if(OP == 'AND')return A && B;
		if(OP == 'OR')return A || B;
	},
	str2ascii({VALUE}){
		return VALUE.charCodeAt();
	},
	ascii2str({VALUE}){
		return String.fromCharCode(VALUE);
	},
	sensing_timer(){
		if(!this._timer){
			this._timer = Date.now();
		}
		return (Date.now() - this._timer) * 0.001;
	},
	sensing_resettimer(){
		this._timer = Date.now();
	},
	sensing_current({CURRENTMENU}){
		const date = new Date();
		switch (CURRENTMENU.toLowerCase()) {
		case 'year': return date.getFullYear();
		case 'month': return date.getMonth() + 1; // getMonth is zero-based
		case 'date': return date.getDate();
		case 'dayofweek': return date.getDay() + 1; // getDay is zero-based, Sun=0
		case 'hour': return date.getHours();
		case 'minute': return date.getMinutes();
		case 'second': return date.getSeconds();
		}
		return 0;
	},
	sensing_dayssince2000(){
		const msPerDay = 24 * 60 * 60 * 1000;
		const start = new Date(2000, 0, 1); // Months are 0-indexed.
		const today = new Date();
		const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
		let mSecsSinceStart = today.valueOf() - start.valueOf();
		mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);
		return mSecsSinceStart / msPerDay;
	},
	operator_join({STRING1, STRING2}){
		return String(STRING1) + String(STRING2);
	},
	operator_letter_of({LETTER, STRING}){
		let index = LETTER - 1;
		return String(STRING).charAt(index);
	},
	operator_contains({STRING1, STRING2}){
		return String(STRING1).toLowerCase().includes(String(STRING2).toLowerCase());
	},
	lists_deletealloflist({LIST}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return;
		list.length = 0;
	},
	lists_listcontainsitem({LIST, VALUE}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return false;
		return list.includes(VALUE);
	},
	lists_indexOf({LIST, VALUE}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return 0;
		return list.indexOf(VALUE) + 1;
	},
	lists_addtolist({LIST, VALUE}){
		const list = varDict[LIST];
		if(Array.isArray(list)){
			list.push(VALUE);
		}else{
			varDict[LIST] = [VALUE];
		}
	},
	lists_deleteoflist({LIST, INDEX}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return;
		list.splice(Math.max(0, INDEX-1), 1);
	},
	lists_length({LIST}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return 0;
		return list.length;
	},
	lists_itemoflist({LIST, INDEX}){
		const list = varDict[LIST];
		if(!Array.isArray(list))return null;
		return list[Math.max(0, INDEX-1)];
	},
	lists_replaceitemoflist({LIST, INDEX, VALUE}){
		let list = varDict[LIST];
		if(!Array.isArray(list)){
			list = varDict[LIST] = [];
		}
		list[Math.max(0, INDEX-1)] = VALUE;
	},
	lists_insertatlist({LIST, INDEX, VALUE}){
		let list = varDict[LIST];
		if(!Array.isArray(list)){
			list = varDict[LIST] = [];
		}
		list.splice(Math.max(0, INDEX-1), 0, VALUE);
	},
	print({VAR}){
		console.log(varDict[VAR]);
	}
}
context.math_integer = context.math_number;
context.math_lists_index = context.math_number;
const result = Object.assign({net:{sendData(buffer){
	return window.mainSerial.send(buffer);
}}}, context, primitives);
return result;
}();

function regExt({blocks, toolbox, context:ctx, arduino}, resultBlocks, resultToolbox, hidden){
	if(typeof hidden == 'boolean'){
		toolbox.hidden = String(hidden);
	}
	resultBlocks?.push(...blocks)
	if(toolbox)resultToolbox.contents.push(toolbox);
	for(let key in ctx){
		context[key] = ctx[key].bind(ctx);
	}
	if(arduino){
		Blockly.Arduino.context = Object.assign(Object.create(Blockly.Arduino.context), arduino);
	}
	/*
	for(let key in buttons){
		workspace.registerButtonCallback(key, buttons[key]);
	}
	*/
}

const Serial = require('./UnoSerial');
const Blockly = require('./generators');
const {message} = antd;

window.mainSerial = new Serial();

//linkBtn.onclick = connectBLE;
/*
async function onRunCode(){
	let isFinished = false;
	function onExecFinish(){
		if(isFinished)return;
		js_engine.stop();
		antd.message.warning('程序运行终止');
	}
	const modal = antd.Modal.info({
		icon: 'loading',
		maskClosable: true,
		okType: 'danger',
		okText: '终止执行',
		title: '正在执行程序',
		onOk: onExecFinish,
		onCancel: onExecFinish,
	});
	//let workspace = Blockly.getMainWorkspace();
	//console.log(Blockly.getMainWorkspace().getTopBlocks())
	const json = toJSON(Blockly.Xml.workspaceToDom(workspace));
	js_engine.exec(json.block, startBlockName, context);
	js_engine.onfinish = function(){
		isFinished = true;
		modal.update({
			icon: React.createElement(antd.Icon, {
				type: 'check-circle',
				style: {color:'#52c41a'}
			}),
			title: '程序运行完成',
			okType: 'primary',
			okText: '关闭',
		});
	}
}

async function onUploadFirmware(){
	let data = await loadData('./online_firmware_328p.hex');
	window.resetBLE(data);
}
*/

/*
class MyDrawer extends React.Component
{
	constructor(){
		super();
		this.state = {
			visible: false,
			spinning: false,
			uploadModalVisible: false,
			step: 0,
			uploadProgress:0,
		};
		this.showDrawer = this.showDrawer.bind(this);
		this.onDrawerClose = this.onDrawerClose.bind(this);
		this.onDrawerClick = this.onDrawerClick.bind(this);
		this.onRunCode = this.onRunCode.bind(this);
		this.onUploadFirmware = this.onUploadFirmware.bind(this);
		this.onUploadCode = this.onUploadCode.bind(this);
		this.onUploadModalClose = this.onUploadModalClose.bind(this);
	}

	showDrawer(){
		this.setState({visible: true});
	}

	onDrawerClick(){
		if(this.state.spinning){
			js_engine.stop();
			this.setState({spinning: false});
			antd.message.warning('程序运行终止');
		}
	}

	onDrawerClose(){
		if(!this.state.spinning){
			this.setState({visible: false});
		}
	}

	onRunCode(){
		this.setState({spinning: true});
		const json = toJSON(Blockly.Xml.workspaceToDom(workspace));
		js_engine.exec(json.block, startBlockName, context);
		js_engine.onfinish = () => {
			this.setState({spinning: false});
			antd.message.success('程序运行结束');
		}
	}

	async onUploadFirmware(){
		this.setState({uploadModalVisible: true, step: 0});
		let data = await loadData('./online_firmware_328p.hex.raw', 'arraybuffer');
		this.setState({step: 1});
		await window.resetBLE(data,
			() => this.setState({step: 2}),
			progress => this.setState({uploadProgress: progress})
		);
		this.setState({step: 3});
		setTimeout(this.onUploadModalClose, 2000);
	}

	async onUploadCode(){
		let code = getHeadFile();
		code += Blockly.Arduino.workspaceToCode(Blockly.getMainWorkspace());
		console.log(code);
		return
		this.setState({uploadModalVisible: true, step: 0});
		let data = await loadData('compile', 'arraybuffer', 'POST', code);
		this.setState({step: 1});
		await window.resetBLE(data,
			() => this.setState({step: 2}),
			progress => this.setState({uploadProgress: progress})
		);
		this.setState({step: 3});
		setTimeout(this.onUploadModalClose, 2000);
	}

	onUploadModalClose(){
		this.setState({uploadModalVisible: false});
	}

	render(){
		const {step, uploadProgress} = this.state;
		const loadingIcon = React.createElement(antd.Progress, {type:'circle', width:30, percent: Math.round(100 * uploadProgress)});
		return React.createElement('div', null,
			React.createElement(antd.Button, {
				icon: 'menu',
				size: 'large',
				onClick: this.showDrawer
			}),
			React.createElement(antd.Drawer, {
				maskStyle: {
					backgroundColor: 'rgba(0,0,0,0)',
				},
				closable: false,
				visible: this.state.visible,
				onClose: this.onDrawerClose,
				onClick: this.onDrawerClick,
				width: 160,
				bodyStyle:{
					height: '100%',
					padding: '10px',
				}
			},
				React.createElement(antd.Spin, {
					spinning:this.state.spinning,
				},
				React.createElement('div', {
					style:{
						display:'flex',
						flexDirection: 'column',
						height: '100%',
						justifyContent: 'space-between'
					},
					},
					React.createElement(antd.Button, {
						icon: 'link',
						size: 'large',
						onClick: connectBLE
					}, '连接蓝牙'),
					React.createElement(antd.Button, {
						icon: 'upload',
						size: 'large',
						onClick: this.onUploadFirmware,
					}, '上传固件'),
					React.createElement(antd.Button, {
						icon: 'cloud-upload',
						size: 'large',
						onClick: this.onUploadCode
					}, '上传代码'),
					React.createElement('div', {
						style:{flex: 'auto',height: '100%'},
					}),
					React.createElement(antd.Button, {
						icon: 'play-circle',
						size: 'large',
						onClick: this.onRunCode
					}, '开始执行'),
				))
			),
			React.createElement(antd.Modal, {
				maskClosable: step == 3,
				closable: false,
				footer: null,
				visible: this.state.uploadModalVisible,
				onCancel: this.onUploadModalClose,
				width: '200',
				centered: true,
			},
			React.createElement(
				antd.Steps, {
					direction:'vertical',
					current:step
				},
				React.createElement(antd.Steps.Step, {title:'编译固件', subTitle:step == 0 && React.createElement(antd.Icon, {type:'loading'})}),
				React.createElement(antd.Steps.Step, {title:'上传固件', subTitle:step == 1 && loadingIcon}),
				React.createElement(antd.Steps.Step, {title:'验证固件', subTitle:step == 2 && loadingIcon}),
				React.createElement(antd.Steps.Step, {title:'上传成功', status:step == 3 ? 'finish' : 'wait'}),
			)
			)
		);
	}
}
//*/

const confirmWrap = (self, method, title) => overrideMethod(self, method, oldFn => () => 
	antd.Modal.confirm({
		title,
		okText: '确定',
		cancelText: '取消',
		centered: true,
		maskClosable: true,
		onOk(){
			oldFn.call(self);
		},
	})
);

const factoryFirmwareDict = {
	'WeeeBot': 'weeebot_factory_firmware',
	'WeeeBotMini': 'weeebotmini_factory_firmware',
	'WeeeSmart': 'Smart_home',
	'WeeeTwelveInOne': 'twelve_in_one',
	'WeeeSixInOne': 'six_in_one_evolution',
	'WeeeFourFeet': 'six_in_one_evolution',
	'WeeePenguin': 'six_in_one_evolution',
	'WeeeThreeWheels': 'six_in_one_evolution',
	'WeeeWalle': 'six_in_one_evolution',
	'WeeeWalk': 'six_in_one_evolution',
	'WeeeTank': 'six_in_one_evolution',
};

const {createElement} = require('../vdom/createElement');
const {ReactInit} = require('../vdom/ReactHelper');

const {Menu} = antd;
const {SubMenu} = Menu;

const TabPanel = require('../vdom/components/TabPanel');
const Dialog = require('../vdom/components/Dialog');
const Fieldset = require('../vdom/components/Fieldset');
const Collapse = require('../vdom/components/Collapse');
const Select = require('../vdom/components/Select');
const MenuGroup = require('../vdom/components/MenuGroup');
const MenuBar = require('../vdom/components/MenuBar');
const CodeView = require('../vdom/components/CodeView');
const Video = require('../vdom/components/Video');


const AppMenu2 = createElement(function(tag, end){
	const dialog = React.useRef();
	tag('div', {style:{flex:'auto'}})
	tag(MenuGroup, {menuWidth:'100px', style:{'--direction':'row-reverse'}})
		tag('div')
			tag`文件`
			tag('button'), tag`新建`, end('button')
			tag('button'), tag`打开`, end('button')
			tag('button'), tag`保存`, end('button')
			tag('button'), tag`另存为`, end('button')
		end('div')
		tag('div')
			tag`编辑`
			tag(MenuBar, true)
		end('div')
		tag('div')
			tag`固件`
			tag('button', {onClick(){dialog.current.showModal()}}), tag`上传在线固件`, end('button')
		end('div')
		tag('div')
			tag`帮助`
			tag('button'), tag`检查更新`, end('button')
			tag('button'), tag`公司主页`, end('button')
		end('div')
	end(MenuGroup)
	tag(Dialog, {maskClosable:true, title:'标题', ref:dialog, style:{width:300,height:400}, buttonList:[
		{title:'关闭', className:'ant-btn ant-btn-default'},
	]})
		tag(Collapse, {style:{padding:'8px'}})
			tag('div', {title:'出厂固件',open:true})
				tag('div', {style:{display:'flex',flexDirection:'column',gap:'10px'}})
					tag('button', {type:'button'}), tag`六合一探索者`, end('button')
					tag('button', {type:'button'}), tag`WeeeBot mini酷跑侠`, end('button')
				end('div')
			end('div')
			tag('div', {title:'移动端固件', open:true})
				tag('div', {style:{display:'flex',flexDirection:'column',gap:'10px'}})
					tag('button', {type:'button'}), tag`elf 328p`, end('button')
					tag('button', {type:'button'}), tag`elf 2560`, end('button')
				end('div')
			end('div')
		end(Collapse)
	end(Dialog)
	end('div')
});

const AppMenu = createElement(function(tag, end){
	const lineHeight = '2em';
	tag('nav', {style:{display:'flex',userSelect:'none',backgroundColor:'hsl(215, 100%, 65%)'}})
		tag(Menu, {mode:'horizontal',selectable:false,style:{lineHeight,flex:'auto'}})
			tag(SubMenu, {title:'文件'})
				tag(Menu.Item, {onClick:()=>console.log('new')}), tag`新建`, end(Menu.Item)
				tag(Menu.Item), tag`打开`, end(Menu.Item)
				tag(Menu.Item), tag`保存`, end(Menu.Item)
				tag(Menu.Item), tag`另存为`, end(Menu.Item)
			end(SubMenu)
			tag(SubMenu, {title:'编辑'})
				tag(Menu.Item), tag`撤销`, end(Menu.Item)
			end(SubMenu)
			tag(SubMenu, {title:'帮助'})
				tag(Menu.Item), tag`检查更新`, end(Menu.Item)
				tag(Menu.Item), tag`公司主页`, end(Menu.Item)
			end(SubMenu)
		end(Menu)
		tag(Menu, {mode:'horizontal',selectable:false,style:{lineHeight}})
			tag(Menu.Item)
				tag`代码模式 `, tag(antd.Switch, {checkedChildren:'打开', unCheckedChildren:'关闭'}, true)
			end(Menu.Item)
		end(Menu)
	end('nav')
})

/*
BlocklyPanel.prototype.render = createElement(function(tag, end){
	const {isCodeRun, onMaskClick} = this.props;
	tag('div', {ref:this.onInit})
		tag('div', {className:'blocklyMask', style:{visibility: isCodeRun?'visible':'hidden'}, onClick:onMaskClick})
			tag('img', {src:'icons/loading-bubbles.svg',width:'30%'}, true)
		end('div')
	end('div')
})
*/

const ExitDialog = createElement(function(tag, end, props){
	tag(Dialog, {maskClosable:true, title:'退出提示', style:{width:300,height:200}, buttonList:[
		{title:'直接退出', value:'quit', className:'ant-btn ant-btn-danger'},
		{title:'保存并退出', value:'save', className:'ant-btn ant-btn-primary'},
		{title:'取消', value:'',className:'ant-btn ant-btn-default'},
	], ...props})
		tag('div', {style:{display:'flex',justifyContent:'center',alignItems:'center',height:'100%'}})
			tag`文件有更改,退出前是否需要保存?`
		end('div')
	end(Dialog)
})


const BoardDialog = createElement(function(tag, end, {boardList, board, ...props}){
	tag(Dialog, {maskClosable:true,resetOnClose:true, title:'选择主板', style:{width:300,height:360}, buttonList:[
		{title:'选择', value:'ok', className:'ant-btn ant-btn-primary'},
		{title:'取消', value:'',className:'ant-btn ant-btn-default'},
	], ...props})
		const prefix = React.useId();
		tag('div', {className:'table', style:{padding:4,columnGap:4}})
		for(let {name} of boardList){
			const id = prefix + name;
			const isActive = board == name;
			tag('input', {type:'radio', id, name:'board', value:name, defaultChecked: isActive, disabled: isActive}, true)
			tag('label', {htmlFor:id}), tag`${name}`, end('label')
		}
		end('div')
	end(Dialog)
})

const PortDialog = createElement(function(tag, end, {port, ...props}){
	const [availablePortList, setAvailablePortList] = React.useState([]);
	const [tempPort, setTempPort] = React.useState(port);
	const prefix = React.useId();

	React.useEffect(() => {
		if(!props.isOpen)return;
		async function scanPortList(){
			//console.log('scanPortList', props.isOpen);
			//const portList = Serial.filter(await Serial.enum(), support_serial_ports);
			let portList = await Serial.enum();
			portList = portList.map(v => v.path).sort();
			setAvailablePortList(portList);
			if(portList.length <= 0)return;
			if(!tempPort || portList.every(path => tempPort != path)){
				setTempPort(portList[0]);
			}
		}
		const timer = setInterval(scanPortList, 200);
		return () => clearInterval(timer);
	});

	tag(Dialog, {maskClosable:true,resetOnClose:false,isOpen:true, title:'选择串口', style:{width:300,height:360}, buttonList:[
		availablePortList.length <= 0 ?
		{title:'安装', value:'install', className:'ant-btn ant-btn-primary'}:
		port && tempPort == port ?
		{title:'断开', value:'disconnect', className:'ant-btn ant-btn-danger'}:
		{title:'连接', value:'connect', className:'ant-btn ant-btn-primary'},
		{title:'取消', value:'cancel',className:'ant-btn ant-btn-default'},
	], ...props})
		if(availablePortList.length > 0){
			tag('div', {className:'table', style:{padding:4,columnGap:4}})
			for(let path of availablePortList){
				const id = prefix + path;
				tag('input', {type:'radio', id, name:'port', value:path, onChange(evt){
					setTempPort(evt.target.value)
				}, checked:tempPort == path}, true)
				tag('label', {htmlFor:id}), tag`${path}`, end('label')
			}
			end('div')
		}else{
			tag('div', {style:{display:'flex',justifyContent:'center',alignItems:'center',height:'100%'}})
				tag`未发现串口,安装驱动程序?`
			end('div')
		}
	end(Dialog)
});

const elf_mini_ports = [
	{vid:0x1A86,pid:0x7523},//elf
	{vid:0x1A86,pid:0x8040},//elf
];

const support_serial_ports = [
	
	{vid:0x2341,pid:0x0001},//uno
	{vid:0x2341,pid:0x0243},//uno
	{vid:0x2341,pid:0x0043},//uno
	{vid:0x2A03,pid:0x0043},//uno
];

function playVideo(evt, stream){
	const video = evt.target.parentElement.parentElement.nextElementSibling.firstElementChild;
	video.srcObject?.getTracks().forEach(v => v.stop());
	if(!stream){
		video.srcObject = null;
		return;
	}
	const track = stream.getVideoTracks()[0];
	console.log(track.getSettings(), stream.getTracks());
	video.srcObject = stream;
	video.play();
}

function handleExtLoad(blocks, toolbox, board){
	let list = toolbox.contents.map(v => v.contents).flat().filter(v => v && v.kind == 'block');
	for(let info of list){
		let b = blocks.find(v => v.type == info.type);
		let pin = b?.args0?.find(v => v.name == 'pin')
		if(!pin)continue;
		console.log(info.type, pin.check)
		if(!info.inputs){
			info.inputs = {};
		}
		let block;
		if(board == 'ELF MINI'){
			if(pin.check == 'EMPin'){
				info.disabled = 'true';
			}else if(pin.check == 'MPin'){
				block = {type:'elf_mini_mpin'};
			}else{
				block = {type:'elf_mini_port', fields:{value:'15'}};
				if(info.type == 'weeemake_single_line_follower'){
					block.fields.value = '19';
				}else if(info.type.startsWith('weeemake_ir_avoid')){
					block.fields.value = '18';
				}else if(info.type.startsWith('weeemake_led_matrix')){
					block.fields.value = '16';
				}
			}
		}else if(board == 'ELF 328P'){
			if(pin.check == 'EMPin'){
				block = {type:'elf_328p_empin'};
			}else if(pin.check == 'MPin'){
				block = {type:'elf_328p_mpin'};
			}else{
				block = {type:'elf_328p_port', fields:{value:'4'}};
				if(info.type.startsWith('weeemake_line_follower')){
					block.fields.value = '9';
				}else if(info.type.startsWith('weeemake_ultrasonic')){
					block.fields.value = '10';
				}else if(info.type.startsWith('weeemake_led_matrix')){
					block.fields.value = '12';
				}else if(info.type == 'weeemake_soil' || info.type == 'weeemake_single_line_follower'){
					block.fields.value = '18';
				}
			}
		}
		if(!block)continue;
		info.inputs.pin = {block};
	}
	
	toolbox.contents.push({"kind": "sep"})

	regExt(require('./extensions/canvas'), blocks, toolbox)

	toolbox.contents.push({"kind": "sep"})

	regExt(require('./extensions/pinIO'), blocks, toolbox)
	regExt(require('./extensions/sensor'), blocks, toolbox)
	regExt(require('./extensions/elf-mini'), blocks, toolbox, board != 'ELF MINI')
	regExt(require('./extensions/elf-328p'), blocks, toolbox, board != 'ELF 328P')
	toolbox.contents.push({"kind": "sep"})

	regExt(require('./extensions/tlink'), blocks, toolbox)
	regExt(require('./extensions/tinywebdb'), blocks, toolbox)
	regExt(require('./extensions/face++'), blocks, toolbox)
}

const MainFrame = createElement(function(tag, end){
	
	const [code, setCode] = React.useState('');
	const [blockXML, setBlockXML] = React.useState('');
	
	const blocklyPanel = React.useRef();
	const editorPanel = React.useRef();

	const [port, setPort] = React.useState('');
	const [isUploadMode, setUploadMode] = React.useState(true);//实时,上传
	
	const [isPortDialogOpen , setPortDialogOpen] = React.useState(false);
	const [isBoardDialogOpen, setBoardDialogOpen] = React.useState(false);
	const [isExitDialogOpen, setExitDialogOpen] = React.useState(false);
	const [board, setBoard] = React.useState('ELF MINI');
	const [isCodeRun, setCodeRun] = React.useState(false);

	function onPortDialogClose(btn, form){
		console.log(btn)
		setPortDialogOpen(false);
		if(btn == 'disconnect'){
			window.mainSerial.disconnect().then(() => setPort(''))
		}else if(btn == 'connect'){
			let v = form.get('port');
			window.mainSerial.connect(v).then(() => setPort(v))
		}else if(btn == 'install'){
			console.log('install driver')
		}
	}

	function onBoardDialogClose(btn, form){
		setBoardDialogOpen(false);
		if(btn == 'ok'){
			const board = form.get('board');
			if(!board)return;
			setBoard(board);
			//let toolbox = structuredClone(defaultToolbox);
		}
	}

	async function getWorkspaceDom(){
		let domText = await sendMsg(blocklyPanel.current, 'workspaceToDom');
		let parser = new DOMParser();
		let result = parser.parseFromString(domText, 'text/xml');
		const json = toJSON(result.documentElement);
		return json;
	}

	//disableOrphans
	function checkBlocks(block){
		if(!block)return;
		if(Array.isArray(block))return block.forEach(checkBlocks);
		let target = isUploadMode ? Blockly.Arduino.context : context;
		console.log(isUploadMode, target, block.type, block.type in target)
		if(block.type != 'when_start'){
			sendMsg(blocklyPanel.current, 'setBlockEnabled', {id:block.id, value:block.type in target});
		}
		checkBlocks(block.next?.block);
	}

	React.useEffect(() => {
		window.mainSerial.on('closed', () => {
			setPort('');
			message.warn('连接已断开');
		})
		console.log('reg once');
		nw.Window.get().on('close', () => setExitDialogOpen(true));
		//nw.Window.get().close(true);
	}, []);
	//setCommentText,setWarningText
	React.useEffect(() => {
		function onMessage(evt){
			const {type, data} = evt.data;
			if(type == 'change'){
				//getWorkspaceDom().then(({block}) => checkBlocks(block));
				getWorkspaceDom().then(workspaceDom => setCode(Blockly.Arduino.workspaceToCode(workspaceDom)));
			}
		}
		window.addEventListener('message', onMessage);
		return () => window.removeEventListener('message', onMessage)
	});
/*
	React.useEffect(() => {
		if(!blocklyPanel.current?.contentWindow)return;
		getWorkspaceDom().then(({block}) => checkBlocks(block));
	}, [isUploadMode])
*/	

	
	React.useEffect(() => void async function(){
		const blocks = await fetch('config/blocks.json').then(v => v.json())
		const toolbox = await fetch('config/toolbox.json').then(v => v.json())
		handleExtLoad(blocks, toolbox, board);
		const webview = blocklyPanel.current;
		await sendMsg(webview, 'updateToolbox', toolbox);
	}(), [board])

	React.useEffect(() => void async function(){
		const blocks = await fetch('config/blocks.json').then(v => v.json())
		const toolbox = await fetch('config/toolbox.json').then(v => v.json())
		const theme = await fetch('config/scratch_theme.json').then(v => v.json())

		handleExtLoad(blocks, toolbox, board);
	
		const webview = blocklyPanel.current;
		webview.addEventListener('newwindow', evt => {
			nw.Shell.openExternal(evt.targetUrl);
		});
		webview.addEventListener('dialog', async evt => {
			if(evt.messageType == 'prompt'){
				let v = prompt(evt.messageText)
				if(v != null){
					evt.dialog.ok(v);
				}else{
					evt.dialog.cancel();
				}
				return
			}
			evt.dialog.cancel();
			console.log(evt.messageType, evt.messageText);
			const workspaceDom = await getWorkspaceDom();
			setCode(Blockly.Arduino.workspaceToCode(workspaceDom));
/*
			function myCheck(block){
				let {type, next, id} = block;
				if(type in Blockly.Arduino.context){
					
				}
			}
			
			console.log(workspaceDom)
			checkBlocks(workspaceDom.block)
			*/
			//setUploadMode(isUploadMode)

		})
		await waitEvent(webview, 'contentload');
		//await waitEvent(webview.contentWindow, 'DOMContentLoaded');
		await sendMsg(webview, 'setTheme', theme);
		await sendMsg(webview, 'defineBlocks', blocks);
		await sendMsg(webview, 'updateToolbox', toolbox);
		await sendMsg(webview, 'textToWorkspace', defaultXml);
	}(), [blocklyPanel]);

	const boardList = [{name:'ELF MINI'},{name:'ELF 328P'}];
	/*navigator.serial.getPorts().then(v => {
		console.log('serial list', v);
		v.forEach(i=>console.log(i.getInfo()))
	})*/

	async function doUploadCode(code){
		message.info({key:'upload',duration:0,content:'正在编译'})
		let raw_hex = await compileCode(code);
		await window.mainSerial.upload(raw_hex, v => message.info({key:'upload',content:'正在上传:' + (100 * v).toFixed() + '%'}));
		message.info({key:'upload',content:'上传完成'})
	}

	tag('div', {className:'frame', style:{height:'100vh',backgroundColor:'aliceblue'}})
		tag('div'/*, {id:'menu'}*/)
			tag(MenuBar, {port:port || '未连接', board, mode:isUploadMode?'上传':'实时', async onClick(key){
				if(key == 'chooseMode'){
					setUploadMode(!isUploadMode);
				}else if(key == 'choosePort'){
					setPortDialogOpen(true);
				}else if(key == 'chooseBoard'){
					setBoardDialogOpen(true);
				}else if(key == 'online_firmware'){
					message.info({key:'upload',duration:0,content:'正在上传'})
					let raw_hex = await fetch('./hex/online_firmware_328p.hex.raw').then(v => v.arrayBuffer())
					await window.resetBLE(raw_hex, v => message.info({key:'upload',content:'正在上传:' + (100 * v).toFixed() + '%'}));
					message.info({key:'upload',content:'上传完成'})
				}
			}}, true)
			if(isPortDialogOpen){
				tag(PortDialog, {port, isOpen:isPortDialogOpen, onClose:onPortDialogClose}, true)
			}
			tag(BoardDialog, {board, boardList, isOpen:isBoardDialogOpen, onClose:onBoardDialogClose}, true)
			tag(ExitDialog, {isOpen:isExitDialogOpen, onClose(btn){
				setExitDialogOpen(false);
				if(btn == 'quit'){
					nw.Window.get().close(true);
				}else if(btn == 'save'){

				}
			}}, true)
		end('div')
		tag(TabPanel)
			tag('webview', {ref:blocklyPanel,title:'积木', src:'http://127.0.0.1/blockly/index.html', buttonList:[
				{title:isCodeRun?'停止':'运行', async onClick(){
					if(isCodeRun)return js_engine.stop();
					const json = await getWorkspaceDom();
					js_engine.exec(json.block, startBlockName, context).then(() => setCodeRun(false));
					setCodeRun(true);
				}},
				{title:'上传', onClick(){
					doUploadCode(code);
				}},
			]}, true)
			tag('webview', {ref:editorPanel, title:'代码', src:'http://127.0.0.1/monaco-editor/index.html', buttonList:[
				{title:'复制', async onClick(){
					let code = await sendMsg(editorPanel.current, 'getCode');
					await navigator.clipboard.writeText(code);
					message.info('复制成功')
				}},
				{title:'上传', async onClick(){
					let code = await sendMsg(editorPanel.current, 'getCode');
					doUploadCode(code)
				}},
			]}, true)
			tag('div', {key:'dialogPanel',title:'声音'})
				tag('div')
					tag('button'), tag`click`, end('button')
				end('div')
			end('div')
		end(TabPanel)
		tag(Collapse, {style:{width:480}})
			tag('canvas', {title:'舞台',open:true, width:480,height:320}, true)
			tag(CodeView, {title:'代码预览',open:true, children: code, buttonList:[
				{title:'上传', onClick(){console.log('upload')}},
				{title:'复制'},
			]}, true)
			tag(Video, {title:'捕获画面', open:false, style:{margin:4}, buttonList:[
				{title:'关闭', onClick(evt){
					playVideo(evt);
				}},
				{title:'显示器', onClick(evt){
					navigator.mediaDevices.getDisplayMedia().then(stream => {
						playVideo(evt, stream);
					}, error => {});
				}},
				{title:'摄像头', onClick(evt){
					navigator.mediaDevices.getUserMedia({video:true}).then(stream => {
						playVideo(evt, stream);
					}, error => {
						if(error.code == DOMException.NOT_FOUND_ERR){
							message.error('未找到摄像头!');
							return;
						}
					});
				}},
			]}, true)
			tag('div', {title:'输出日志', style:{height:'200px'}}, true)
			
		end(Collapse)
		tag('div')
		/*
			tag('span', {'data-title':'端口'})
				tag('span')
					tag`COM3`
				end('span')
			end('span')
			tag('span', {'data-title':'主板'})
				tag('span')
					tag`ELF MINI`
				end('span')
			end('span')
			*/
		end('div')
	end('div')
})

function setFontSize(target){
	const {style} = target.parentNode.parentNode.nextSibling;
	let fontSize = parseFloat(style.fontSize);
	if(isNaN(fontSize)){
		style.fontSize = '1.1em';
	}else{
		fontSize += 0.5;
		if(fontSize > 4){
			fontSize = 1;
		}
		style.fontSize = `${fontSize.toFixed(1)}em`;
	}
}


ReactInit(document.body, MainFrame)