'use strict';

function toJSON(xml){
	let json = Object.create(null);
	for(let attr of xml.attributes){
		json[attr.name] = attr.value;
	}
	for(let node of xml.childNodes){
		if(node.nodeType === 3){
			json[node.nodeName] = node.data;
			continue;
		}
		let nodeName = node.localName;
		let nodeData = toJSON(node);
		if(!(nodeName in json)){
			json[nodeName] = nodeData;
		}else if(Array.isArray(json[nodeName])){
			json[nodeName].push(nodeData);
		}else{
			json[nodeName] = [json[nodeName], nodeData];
		}
	}
	return json;
}

const js_engine = function(exports){
	'use strict';

const yieldFlag = Symbol();
const yieldOneTickFlag = Symbol();
const suspendFlag = Symbol();

const threadList = [];

requestAnimationFrame(function(){
	const finishThreads = [];
	const reviveThreads = [];
	return function loop(timestamp){
		requestAnimationFrame(loop);
		const timeEnd = timestamp + 10;
		let activeThreadCount = threadList.length;
		while(activeThreadCount > 0 && performance.now() < timeEnd){
			activeThreadCount = 0;
			for(const thread of threadList){
				while(!thread.suspendFlag){
					const {done, value} = thread.next(thread.returnValue);
					if(done){
						finishThreads.push(thread);
						break;
					}else if(value === yieldFlag){
						++activeThreadCount;
						break;
					}else if(value === yieldOneTickFlag){
						thread.suspendFlag = true;
						reviveThreads.push(thread);
					}else if(value === suspendFlag){
						thread.suspendFlag = true;
					}else if(value instanceof Promise){
						thread.suspendFlag = true;
						value.then(result => {
							thread.suspendFlag = false;
							thread.returnValue = result;
						});
					}else{
						thread.returnValue = value;
					}
				}
			}
			while(finishThreads.length > 0){
				let thread = finishThreads.shift();
				threadList.splice(threadList.indexOf(thread), 1);
				console.log('thread done!', thread.returnValue);
				if(threadList.length == 0){
					const {onfinish} = exports;
					if(onfinish)onfinish();
					return;
				}
			}
		}
		while(reviveThreads.length > 0){
			reviveThreads.pop().suspendFlag = false;
		}
	}
}());

const castBlockList = function(){
	const castToArray = v => v == null ? [] : Array.isArray(v) ? v : [v];
	const castToDict = v => castToArray(v).reduce((dict, v) => (dict[v.name] = v, dict), Object.create(null));
	const quote = (regExp => v => `'${v.replace(regExp, "\\'")}'`)(/'/g);
	const isVarName = (regExp => name => regExp.test(name))(/^[a-z_A-Z]\w*$/);
	const castVarName = v => '_' + v.replace(/\W/g, c => c.charCodeAt().toString(36));
	const insertYieldFlag = (tab, code='') => `{\n${tab+'\t'}yield yieldFlag\n${code}${tab}}`;
	function castArg({name, shadow, block}){
		return [name, castBlock(block || shadow)];
		let value;
		if(block){
			value = castBlock(block);
		}else{
			let {field, type} = shadow;
			value = field['#text'] || '';
			console.log(type, value)
			if(type.endsWith('_number') || type.endsWith('integer')){
				value = parseFloat(value);
			}else{
				value = quote(value);
			}
		}
		return [name, value];
	}
	function castArgList({field, value}){
		if(!(field || value)){
			return [];
		}
		if(field){
			if(!Array.isArray(field))
				field = [field];
			field = field.map(v => [v.name, quote(v['#text'])]);
		}
		if(value){
			if(!Array.isArray(value))
				value = [value];
			value = value.map(castArg);
		}
		return (field && value) ? field.concat(value) : (field || value);
	}
	function castBlock(block, offset=0){
		const tab = '\t'.repeat(offset);
		let opcode = block.type;
		if(opcode === 'math_number'){
			return Number(block.field['#text']);
		}
		if(opcode === 'text'){
			return quote(block.field['#text'] || '');
		}
		if(opcode === 'controls_flow_statements'){
			return tab + block.field['#text'].toLowerCase();
		}
		if(opcode === 'logic_boolean'){
			return block.field['#text'] === 'TRUE';
		}
		if(opcode === 'logic_negate'){
			return block.value ? `!(${castBlock(block.value.block)})` : true;
		}
		if(opcode === 'logic_null'){
			return null;
		}
		if(opcode === 'logic_ternary'){
			const {IF, THEN, ELSE} = castToDict(block.value);
			return `((${IF ? castArg(IF)[1] : 0}) ? (${THEN ? castArg(THEN)[1] : 0}) : (${ELSE ? castArg(ELSE)[1] : 0}))`;
		}
		if(opcode.startsWith('argument_reporter_')){
			return castVarName(block.field['#text']);
		}
		if(opcode == 'control_wait'){
			return tab + `for(const end=performance.now()+1000*(${
				castArg(block.value)[1]
			});performance.now()<end;)yield yieldOneTickFlag;`;
		}
		if(opcode === 'control_repeat'){
			if(!block.statement){
				return `${tab}void(${castArg(block.value)[1]})`;
			}
			let code = castBlockList(block.statement.block, offset+1);
			return tab + `for(let i=${castArg(block.value)[1]};i>0;--i)` + insertYieldFlag(tab, code);
		}
		if(opcode === 'control_if_else'){
			if(!block.statement){
				opcode = 'control_if';
			}else{
				let condition = block.value ? castArg(block.value)[1] : false;
				if(Array.isArray(block.statement)){
					let statement = block.statement.reduce((prev, {name, block}) => {
						prev[name] = block;
						return prev;
					},{});
					let code1 = castBlockList(statement['SUBSTACK'], offset+1);
					let code2 = castBlockList(statement['SUBSTACK2'], offset+1);
					return `${tab}if(${condition}){\n${code1}${tab}}else{\n${code2}${tab}}`;
				}
				let code = castBlockList(block.statement.block, offset+1);
				if(block.statement.name === 'SUBSTACK'){
					return `${tab}if(${condition}){\n${code}${tab}}`;
				}
				return `${tab}if(${condition}){\n${tab}}else{\n${code}${tab}}`;
			}
		}
		if(opcode === 'control_if'){
			if(!block.value){
				return tab + '//pass control_if';
			}
			let condition = castArg(block.value)[1];
			if(block.statement){
				return `${tab}if(${condition}){\n${castBlockList(block.statement.block, offset+1)}${tab}}`;
			}
			return `${tab}void(${condition})`;
		}
		if(opcode === 'controls_if'){//Blockly
			let elseifCount = 0;
			let elseCount = 0;
			let {mutation, value, statement} = block;
			if(mutation){
				elseifCount = Number(mutation['elseif']);
				elseCount = Number(mutation['else']);
			}
			value = castToDict(value);
			statement = castToDict(statement);
			let result = `${tab}if(${value.IF0 ? castArg(value.IF0)[1] : false}){\n${castBlockList(statement.DO0 && statement.DO0.block, offset+1)}${tab}}`;
			for(let i=1; i<=elseifCount; ++i){
				result += `else if(${value['IF'+i] ? castArg(value['IF'+i])[1] : false}){\n${castBlockList(statement['DO'+i] && statement['DO'+i].block, offset+1)}${tab}}`;
			}
			if(elseCount > 0){
				result += `else{\n${castBlockList(statement.ELSE && statement.ELSE.block, offset+1)}${tab}}`;
			}
			return result;
		}
		if(opcode === 'controls_repeat_ext'){//Blockly
			const {value, statement} = block;
			const count = value ? castArg(value)[1] : 0;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let i=${count};i>0;--i)` + insertYieldFlag(tab, code);
		}
		/*
		if(opcode === 'controls_for'){
			const {value, statement} = block;
			const name = block.field['#text'];
			const count = value ? castBlock(value.block) : 0;
			const code = castBlockList(statement && statement.block, offset+1);
			return tab + `for(let ${name}=0, n=${count};${name}<;${name}+=${step})` + insertYieldFlag(tab, code);
		}*/
		if(opcode === 'controls_forEach'){
			const {value, statement} = block;
			const name = block.field['#text'];
			const list = value ? castBlock(value.block) : '[]';
			let code = tab + `\tcontext.variables_set({VAR:${quote(name)},VALUE:${name}})\n`;
			if(statement)code += castBlockList(statement.block, offset+1);
			return tab + `for(let ${name} of ${list})` + insertYieldFlag(tab, code);
		}
		if(opcode === 'controls_whileUntil'){//Blockly
			if(block.field['#text'] === 'WHILE'){
				const {value, statement} = block;
				let condition = value ? castBlock(value.block) : false;
				let code = castBlockList(statement && statement.block, offset+1);
				return tab + `while(${condition})` + insertYieldFlag(tab, code);
			}
			opcode = 'control_repeat_until';
		}
		if(opcode === 'control_repeat_until'){
			if(!block.statement){
				opcode = 'control_wait_until';
			}else if(!block.value){
				opcode = 'control_forever';
			}else{
				let condition = castArg(block.value)[1];
				let code = castBlockList(block.statement.block, offset+1);
				return tab + `while(!(${condition}))` + insertYieldFlag(tab, code);
			}
		}
		if(opcode === 'control_wait_until'){
			if(!block.value){
				return tab + 'yield suspendFlag';
			}
			let condition = castArg(block.value)[1];
			return tab + `while(!(${condition}))` + insertYieldFlag(tab);
		}
		if(opcode === 'control_forever'){
			if(!block.statement){
				return tab + 'yield suspendFlag';
			}
			return tab + 'for(;;)' + insertYieldFlag(tab, castBlockList(block.statement.block, offset+1));
		}
		if(opcode === 'procedures_call'){
			let {proccode, argumentids} = block.mutation;
			let args = JSON.parse(argumentids).map(function(v){
				let result = this.find(([k]) => v == k);
				return result ? result[1] : 0;
			}, castArgList(block));
			return tab + `yield* ${castVarName(proccode)}(${args})`;
		}
		if(opcode === 'procedures_definition'){
			let {mutation} = block.statement.shadow;
			return `function* ${castVarName(mutation.proccode)}(${
				JSON.parse(mutation.argumentnames).map(castVarName)
			}){`;
		}
		opcode = isVarName(opcode) ? '.' + opcode : `['${opcode}']`;
		return tab + `yield context${opcode}({${
			castArgList(block).map(([k, v]) => (isVarName(k) ? k : quote(k)) + ':' + v)
		}})`;
	}
	return function(block, offset=1){
		let result = [];
		while(block){
			result.push(castBlock(block, offset));
			block = block.next && block.next.block;
		}
		return result.map(v => v + '\n').join('');
	}
}();

function genFunction(blocks, startBlockName){
	const fnDefBlocks = blocks.filter(v => v.type === 'procedures_definition');
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	let code = 'return context => {\n';
	code += fnDefBlocks.map(v => castBlockList(v) + '}\n').join('');
	code += 'return {';
	code += startBlocks.map(v => `*['${v.id}'](){\n${castBlockList(v.next && v.next.block)}}`);
	code += '}\n}';
	console.log(code);
	//return console.log;
	return Function('yieldFlag', 'yieldOneTickFlag', 'suspendFlag', code)(yieldFlag, yieldOneTickFlag, suspendFlag);
}

function exec(blocks, startBlockName, context){
	if(blocks == null)return;
	if(!Array.isArray(blocks))blocks = [blocks];
	const startBlocks = blocks.filter(v => v.type === startBlockName);
	if(startBlocks.length <= 0)return;
	const factory = genFunction(blocks, startBlockName)(context);
	threadList.push(...startBlocks.map(v => factory[v.id]()));
}

function stop(){
	threadList.length = 0;
}

exports.exec = exec;
exports.stop = stop;
exports.onfinish = null;
return exports;
}({});

Blockly.Blocks['device_port'] = {init:function(){
	this.appendDummyInput().appendField(
		new Blockly.FieldDropdown([
			["PORT A","A"],
			["PORT B","B"],
			["PORT C","C"],
			["PORT D","D"]
		]),
		"VALUE"
	);
	this.setOutput(true, "DEVICE_PORT");
	this.setColour(15);
}};

Blockly.Blocks['device_pin'] = {init:function(){
	this.appendDummyInput().appendField(
		new Blockly.FieldDropdown([
			["PIN 1","1"],
			["PIN 2","2"],
			["PIN 3","3"],
			["PIN 4","4"],
			["PIN 5","5"],
			["PIN 6","6"]
		]),
		"VALUE"
	);
	this.setOutput(true, "DEVICE_PIN");
	this.setColour(15);
}};

Blockly.Blocks['ir_code'] = {init:function(){
	this.appendDummyInput().appendField('红外码').appendField(
		new Blockly.FieldDropdown([
			["A", '69'],
			["B", '70'],
			["C", '71'],
			["D", '68'],
			["E", '67'],
			["F", '13'],
			["↑", '64'],
			["↓", '25'],
			["←", '7'],
			["→", '9'],
			["OK",'21'],
			["R0",'22'],
			["R1",'12'],
			["R2",'24'],
			["R3",'94'],
			["R4",'8'],
			["R5",'28'],
			["R6",'90'],
			["R7",'66'],
			["R8",'82'],
			["R9",'74']
		]),
		"VALUE"
	);
	this.setOutput(true, "Number");
	this.setColour(15);
}};

Blockly.Blocks['buzzer_note'] = {init:function(){
	this.appendDummyInput().appendField('音调').appendField(
		new Blockly.FieldDropdown([
			["B0", "31"],["C1", "33"],["D1", "37"],["E1", "41"],["F1", "44"],["G1", "49"],["A1", "55"],["B1", "62"],
			["C2", "65"],["D2", "73"],["E2", "82"],["F2", "87"],["G2", "98"],["A2", "110"],["B2", "123"],
			["C3", "131"],["D3", "147"],["E3", "165"],["F3", "175"],["G3", "196"],["A3", "220"],["B3", "247"],
			["C4", "262"],["D4", "294"],["E4", "330"],["F4", "349"],["G4", "392"],["A4", "440"],["B4", "494"],
			["C5", "523"],["D5", "587"],["E5", "659"],["F5", "698"],["G5", "784"],["A5", "880"],["B5", "988"],
			["C6", "1047"],["D6", "1175"],["E6", "1319"],["F6", "1397"],["G6", "1568"],["A6", "1760"],["B6", "1976"],
			["C7", "2093"],["D7", "2349"],["E7", "2637"],["F7", "2794"],["G7", "3136"],["A7", "3520"],["B7", "3951"],
			["C8", "4186"],["D8", "4699"]
		]),
		"VALUE"
	);
	this.setOutput(true, "Number");
	this.setColour(15);
}};

Blockly.Blocks['buzzer_beat'] = {init:function(){
	this.appendDummyInput().appendField(
		new Blockly.FieldDropdown([
			['二分之一',"500"],
			['四分之一',"250"],
			['百分之一',"125"],
			['一',"1000"],
			['两',"2000"]
		]),
		"VALUE"
	).appendField('拍');
	this.setOutput(true, "Number");
	this.setColour(15);
}};

Blockly.Blocks['weeebot_board_rgb'] = {init:function(){
	//this.appendDummyInput().appendField("设置板载RGB");
	//this.appendValueInput("NAME").setCheck("DEVICE_PORT").appendField("PORT");
	this.appendValueInput("COLOUR").setCheck("Colour").appendField("设置板载RGB");
	//this.setInputsInline(true);
	this.setPreviousStatement(true, null);
	this.setNextStatement(true, null);
	this.setColour(15);
}};

Blockly.Blocks['weeebot_button'] = {init:function(){
	this.appendDummyInput().appendField("板载按钮按下?");
	this.setOutput(true, "Boolean");
	this.setColour(15);
}};

Blockly.Blocks['weeebot_pin_light'] = {init:function(){
	this.appendValueInput("PIN").setCheck("DEVICE_PIN").appendField("板载光线传感器");
	this.setOutput(true, "Number");
	this.setColour(15);
}};

Blockly.Blocks['weeebot_pin_sound'] = {init:function(){
	this.appendValueInput("PIN").setCheck("DEVICE_PIN").appendField("板载声音传感器");
	this.setOutput(true, "Number");
	this.setColour(15);
}};

Blockly.Blocks['RJ11_light'] = {init:function(){
	this.appendValueInput("PORT").setCheck("DEVICE_PORT").appendField("外接光线传感器");
	this.setOutput(true, "Number");
	this.setColour(15);
}};

Blockly.Blocks['RJ11_sound'] = {init:function(){
	this.appendValueInput("PORT").setCheck("DEVICE_PORT").appendField("外接声音传感器");
	this.setOutput(true, "Number");
	this.setColour(15);
}};

Blockly.Blocks['single_led'] = {init:function(){
	this.appendValueInput("PORT").setCheck("DEVICE_PORT").appendField("设置单色LED");
	this.appendValueInput("VALUE").setCheck("Boolean").appendField("打开?");
	this.setPreviousStatement(true, null);
	this.setNextStatement(true, null);
	this.setInputsInline(true);
	this.setColour(15);
}};

Blockly.Blocks['weeebot_pin_ir'] = {init:function(){
	this.appendValueInput("PIN")
		.setCheck("DEVICE_PIN")
		.appendField("红外");
	this.appendValueInput("IR_CODE")
		.setCheck("Number")
		.appendField("接收到");
	this.setInputsInline(true);
	this.setOutput(true, "Boolean");
	this.setColour(15);
}};

Blockly.Blocks['buzzer'] = {init:function(){
	this.appendValueInput("NOTE").setCheck("Number").appendField("蜂鸣器响");
	this.appendValueInput("BEAT").setCheck("Number");
	this.setInputsInline(true);
	this.setPreviousStatement(true, null);
	this.setNextStatement(true, null);
	this.setColour(15);
}};

Blockly.Blocks['control_wait'] = {init:function(){
	this.appendValueInput("VALUE").setCheck("Number").appendField("等待");
	this.appendDummyInput().appendField("秒");
	this.setPreviousStatement(true, null);
	this.setNextStatement(true, null);
	this.setColour(15);
}};

const startBlockName = 'when_start';
const startBlockLabel = '当点击开始';
Blockly.Blocks[startBlockName] = {
	init: function() {
		this.appendDummyInput().appendField(startBlockLabel);
		this.setNextStatement(true, null);
		this.setColour(330);
		//this.setTooltip(Blockly.Msg['VARIABLES_SET_TOOLTIP']);
		//this.setHelpUrl(Blockly.Msg['VARIABLES_SET_HELPURL']);
	}
};
const defaultXml = `<xml xmlns="https://developers.google.com/blockly/xml"><block type="${startBlockName}" editable="false" deletable="false" movable="false"></block></xml>`;

Blockly.BlockSvg.START_HAT = true;
const workspace = Blockly.inject('blocklyDiv', {
	media: '../../media/',
	toolbox: document.getElementById('toolbox'),
	grid: {
		spacing: 20,
		length: 3,
		colour: '#ccc',
		snap: true
	}
});

Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(defaultXml), workspace);

workspace.addChangeListener(Blockly.Events.disableOrphans);
//workspace.addChangeListener(evt => console.log('changed'));

//const {toJSON} = require('G:/AladdinJS_git/AladdinJS/node_modules/fileformats/xml');
//const js_engine = require('G:/AladdinJS_git/AladdinJS/node_modules/blockly/js_engine');

const runBtn = document.getElementById('runBtn');
const mask = document.getElementById('mask');

const context = {
	buzzer({NOTE, BEAT}){
		return window.sendBLEData(`BZ ${NOTE} ${BEAT}`);
	},
	buzzer_note({VALUE}){
		return Number(VALUE);
	},
	buzzer_beat({VALUE}){
		return Number(VALUE);
	}
};

function onExecFinish(){
	js_engine.stop();
	mask.style.display = 'none';
}

mask.onclick = onExecFinish;
runBtn.onclick = async function(){
	await connectBLE();
	//let workspace = Blockly.getMainWorkspace();
	let json = toJSON(Blockly.Xml.workspaceToDom(workspace));
	console.log(json);
	js_engine.exec(json.block, startBlockName, context);
	js_engine.onfinish = onExecFinish;
	mask.style.display = 'block';
}


